"object" != typeof globalThis && (globalThis = window),
  (this.webpackJsonp = this.webpackJsonp || []).push([
    [21],
    {
      "+eUS": function (e, t, s) {
        "use strict";
        s.d(t, "a", function () {
          return h;
        });
        var i = s("jDHv"),
          n = s("+ExH"),
          a = s("ycTR"),
          r = s("YEoC"),
          o = s("kFM4"),
          d = s("teaq"),
          l = s("PhBv"),
          c = s("1UUk");
        function h(e) {
          Object(o.a)("RunMode", e),
            e !== r.e.Unknown &&
              (i.ModuleContainer.resolve(c.b).install(),
              e !== r.e.Background &&
                (setTimeout(() => {
                  const e = i.ModuleContainer.resolve(l.b);
                  e.install(n.a), e.start();
                }, 1),
                i.ModuleContainer.resolve(d.b).install(a.a)));
        }
      },
      "0rWR": function (e, t, s) {
        "use strict";
        var i,
          n = s("jDHv"),
          a = s("Mgpg"),
          r = s("YEoC"),
          o = s("PmZf"),
          d = s("x9oK"),
          l = s("UJ0r");
        let c =
          n.ModuleContainer.injectable()(
            (i =
              (function (e, t) {
                return n.ModuleContainer.inject(a.ZLoggerFactory)(e, void 0, 0);
              })(
                (i =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (i =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === a.ZLoggerFactory ? Object : a.ZLoggerFactory,
                      ])(
                        (i = class extends l.a {
                          constructor(e) {
                            super(),
                              (this.logger = void 0),
                              (this.dbSchema = null),
                              (this.logger = e.createZLogger("db", [
                                "adapter-manager",
                              ]));
                          }
                          registerListenersForAdapter(e) {
                            const t = (e) => {
                              this.dispatchEvent(e);
                            };
                            e.addEventListener(o.b.UnexpectedError, t),
                              e.addEventListener(o.b.TimeConsumingQuery, t),
                              e.addEventListener(o.b.SuccessOpenDB, t),
                              e.addEventListener(
                                o.b.ConnectionClosedAbnormally,
                                t,
                              );
                          }
                          async getDatabaseAdapter(e, t) {
                            const s = {
                              database: e,
                              version: t.version,
                              type: t.type,
                            };
                            this.logger.zsymb(0, 14389, 3e4, () => [
                              "creating",
                              s,
                            ]);
                            const i = this.getAdapterFactoryToken(t.type),
                              a = n.ModuleContainer.resolve(i),
                              r = await a.createAdapter(e, t);
                            return (
                              this.logger.zsymb(0, 14389, 30001, () => [
                                "create success",
                                s,
                              ]),
                              this.registerListenersForAdapter(r),
                              r
                            );
                          }
                          canUse(e) {
                            return e !== r.a.SQLite || this.canIUseSQLite();
                          }
                          canIUseSQLite() {
                            return !1;
                          }
                          getAdapterFactoryToken(e) {
                            return e === r.a.IDB ? d.b : d.c;
                          }
                          getExistedPartitionKeys(e, t) {
                            const s = this.getAdapterFactoryToken(t);
                            return n.ModuleContainer.resolve(
                              s,
                            ).getExistedPartitionKeys(e);
                          }
                        }),
                      ) || i),
                  ) || i),
              ) || i),
          ) || i;
        n.ModuleContainer.registerSingleton(l.b, c);
      },
      27: function (e, t) {},
      "5yGw": function (e, t, s) {
        "use strict";
        var i,
          n = s("jDHv"),
          a = s("Mgpg"),
          r = s("DI/x"),
          o = s("PmZf"),
          d = s("1UUk"),
          l = s("d/or"),
          c = s("teaq");
        let h =
          n.ModuleContainer.injectable()(
            (i =
              (function (e, t) {
                return n.ModuleContainer.inject(l.a)(e, void 0, 0);
              })(
                (i =
                  (function (e, t) {
                    return n.ModuleContainer.inject(a.ZLoggerFactory)(
                      e,
                      void 0,
                      1,
                    );
                  })(
                    (i =
                      Reflect.metadata(
                        "design:type",
                        Function,
                      )(
                        (i =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === l.a ? Object : l.a,
                            void 0 === a.ZLoggerFactory
                              ? Object
                              : a.ZLoggerFactory,
                          ])(
                            (i = class {
                              constructor(e, t) {
                                (this.settingsManager = e),
                                  (this.configFactory = void 0),
                                  (this.configCache = void 0),
                                  (this.logger = void 0),
                                  (this.logger = t.createZLogger("db", [
                                    "config",
                                  ])),
                                  (this.configCache = new Map());
                              }
                              install(e) {
                                this.configFactory = e;
                                n.ModuleContainer.resolve(d.b).addEventListener(
                                  o.b.SessionChange,
                                  () => {
                                    this.clearCache();
                                  },
                                );
                              }
                              getDatabaseConfigs(e) {
                                const t = this.configCache.get(e);
                                return t || this.createConfigCache(e);
                              }
                              clearCache() {
                                const e = this.configCache.values();
                                let t = e.next();
                                for (; !t.done; ) {
                                  t.value.forEach((e) => e.clearCache()),
                                    (t = e.next());
                                }
                                this.configCache.clear();
                              }
                              createConfigCache(e) {
                                const t = [],
                                  s = this.getCurrentConfig(e);
                                if (s) {
                                  t.push(s);
                                  const i = this.getConfigForMigrate(e, s.type);
                                  i && t.push(i);
                                }
                                return this.configCache.set(e, t), t;
                              }
                              getConfigForMigrate(e, t) {
                                const s = this.settingsManager;
                                let i,
                                  n = s.getPreferredAdapter(e);
                                if (n !== t) {
                                  if (
                                    (n && (i = this.configFactory(e, n)),
                                    !n || !i)
                                  ) {
                                    const t = s.preferAdapters;
                                    for (
                                      let s = 0;
                                      s < t.length &&
                                      ((n = t[s]),
                                      (i = this.configFactory(e, n)),
                                      !i);
                                      s++
                                    );
                                  }
                                  return i && t !== n ? i : void 0;
                                }
                              }
                              getCurrentConfig(e) {
                                const t =
                                  this.settingsManager.getCurrentAdapterType(e);
                                if ("number" != typeof t)
                                  throw new r.g(
                                    `${t} is not a valid AdapterType value!`,
                                  );
                                return this.configFactory(e, t);
                              }
                            }),
                          ) || i),
                      ) || i),
                  ) || i),
              ) || i),
          ) || i;
        n.ModuleContainer.registerSingleton(c.b, h);
      },
      BtX6: function (e, t, s) {
        s("E2g8").polyfill();
      },
      HPcM: function (e, t, s) {
        "use strict";
        s.d(t, "b", function () {
          return n;
        }),
          s.d(t, "a", function () {
            return a;
          });
        var i = s("jDHv");
        const n = Object(i.define)("zlog-sentry-bucket"),
          a = Object(i.define)("zlog-regular-bucket");
      },
      K8kB: function (e, t, s) {
        "use strict";
        s.d(t, "a", function () {
          return n;
        });
        var i = s("jDHv");
        const n = Object(i.define)("zlog-write-scheduler");
      },
      KRcn: function (e, t, s) {
        "use strict";
        s.d(t, "a", function () {
          return n;
        });
        var i = s("PLj1");
        function n() {
          let e;
          try {
            switch (__ZaBUNDLENAME__.toLocaleLowerCase()) {
              case "main":
                e = i.b.Main;
                break;
              case "web":
                e = i.b.Web;
                break;
              case "login":
                e = i.b.Login;
                break;
              case "photo":
                e = i.b.Photo;
                break;
              case "render":
                e = i.b.Render;
                break;
              case "shared-worker":
                e = i.b.SharedWorker;
                break;
              default:
                e = i.b.Unknown;
            }
          } catch {
            e = i.b.Unknown;
          }
          return e;
        }
      },
      KdAX: function (e, t, s) {
        "use strict";
        var i = s("jDHv"),
          n = s("W8fB"),
          a = s("UJDs"),
          r = s("7FSS"),
          o = (s("j6JD"), s("VTBJ"));
        const d = s("4JQ2"),
          l = {
            intro: (e) => l.eol(e),
            info: (e) => e,
            debug: (e) => e,
            warning: (e) => e,
            error: (e) => e,
            placeholder: (e) => e,
            tick: (e) => e,
            header: (e) => d.green(e),
            sourcemap: (e) => d.gray(e),
            level: (e) => e,
            bold: (e) => d.bold(e),
            eol: (e) => e + "\n\n",
          },
          c =
            (Object(o.a)(
              Object(o.a)({}, l),
              {},
              {
                intro: (e) => l.eol(d.bgWhite.black(e)),
                info: (e) => d.white(e),
                debug: (e) => d.blue(e),
                warning: (e) => d.yellow(e),
                error: (e) => d.red(e),
                tick: (e) => d.black.bgWhite.bold(` ${e} `),
                header: (e) => e,
              },
            ),
            l);
        s("CDcE");
        const h = { display: !0, style: "font-size: 11px; color: gray" },
          u = {
            display: !1,
            style: "font-size: 11px; color: gray; margin-bottom: 8px",
          };
        function g(e) {
          let { lineMeta: t, template: s, args: i } = e;
          if ("number" == typeof s)
            return (
              "Error: expected template as string. Got number?! [" +
              t.id1 +
              ":" +
              t.id2 +
              "]"
            );
          const n = [t.module, t.features.join("/")]
            .map((e) => e || "?")
            .join("|");
          let a = i.map((e) =>
            (function (e) {
              let t = e;
              if ("function" == typeof e)
                try {
                  t = e();
                } catch (s) {
                  r.a.error(
                    "ZLogSanitizer: failed to exec func. Please make sure your func executable" +
                      s,
                  ),
                    (t = e.toString());
                }
              return t;
            })(e),
          );
          1 === a.length &&
            1 === i.length &&
            "function" == typeof i[0] &&
            Array.isArray(a[0]) &&
            (a = a[0]);
          const o = (function (e, t) {
              if (null === e) return "";
              const s = "{}";
              let i = 0;
              for (; -1 !== e.search(s) && i < t.length; )
                switch (typeof t[i++]) {
                  case "number":
                    e = e.replace(s, "%d");
                    break;
                  case "string":
                  default:
                    e = e.replace(s, "%s");
                    break;
                  case "object":
                    e = e.replace(s, "%o");
                }
              return e;
            })(s, a).trim(),
            d =
              (t.id1.toString().substring(t.id1.toString().indexOf("src")),
              t.id2,
              ""),
            l = [];
          return (
            h.display && n.trim() && l.push(c.sourcemap(n.trim()) + "\n"),
            u.display && d.trim() && l.push(c.sourcemap(d) + "\n"),
            o.trim() && l.push(o.trim()),
            a.length > 0 ? (a.unshift(l.join(" ")), a) : [l.join(" ")]
          );
        }
        var m;
        let p =
          Object(i.injectable)()(
            (m = class {
              write(e) {
                const t = g(e);
                switch (e.lineMeta.level) {
                  case a.b.info:
                    r.a.log.apply(null, t);
                    break;
                  case a.b.warn:
                    r.a.warn.apply(null, t);
                    break;
                  case a.b.debug:
                    r.a.debug.apply(null, t);
                    break;
                  case a.b.error:
                    r.a.error.apply(null, t);
                    break;
                  default:
                    r.a.log.apply(null, t);
                }
              }
            }),
          ) || m;
        i.ModuleContainer.registerSingleton(n.a, p);
      },
      KhD4: function (e, t, s) {
        "use strict";
        s.d(t, "a", function () {
          return n;
        });
        var i = s("jDHv");
        const n = Object(i.define)("dal-db-path");
      },
      Lp8g: function (e, t) {
        globalThis.hasOwnProperty("$recoilDebugStates") &&
          (globalThis.$recoilDebugStates.push = function () {
            this.length >= 100 &&
              Array.prototype.splice.apply(this, [
                0,
                Math.round(this.length / 2),
              ]);
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
              t[s] = arguments[s];
            Array.prototype.push.apply(this, t);
          });
      },
      Lq8m: function (e, t, s) {
        "use strict";
        var i,
          n = s("jDHv"),
          a = s("Uzj0"),
          r = s("Mgpg"),
          o = s("zpw2"),
          d = s("Mk04"),
          l = s("pjo1");
        let c =
          n.ModuleContainer.injectable()(
            (i =
              (function (e, t) {
                return n.ModuleContainer.inject(r.ZLoggerFactory)(e, void 0, 0);
              })(
                (i =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (i =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === r.ZLoggerFactory ? Object : r.ZLoggerFactory,
                      ])(
                        (i = class {
                          constructor(e) {
                            (this.loggerFactory = e),
                              (this.logger = void 0),
                              (this.logger = this.loggerFactory.createZLogger(
                                "db",
                                ["client"],
                              ));
                          }
                          createQueryBuilder(e) {
                            const t = a.e.map(e, (e, t) =>
                                this.createBuilder(e, t),
                              ),
                              s = Object.keys(e),
                              i = this.logger;
                            return (
                              (t.deleteAllDatabases = Object(d.a)(async () => {
                                let e = [...s];
                                i.zsymb(
                                  0,
                                  14538,
                                  3e4,
                                  "Start deleting all dbs",
                                ),
                                  i.zsymb(
                                    3,
                                    14538,
                                    30001,
                                    "Wait for dbs to be deleted: {}",
                                    e,
                                  );
                                const n = s.map(async (s) => {
                                  await t[s].deleteThisDatabase(),
                                    (e = e.filter((e) => e !== s)),
                                    0 === e.length
                                      ? i.zsymb(
                                          0,
                                          14538,
                                          30002,
                                          "Done deleting all dbs",
                                        )
                                      : i.zsymb(
                                          3,
                                          14538,
                                          30003,
                                          "Wait for dbs to be deleted: {}",
                                          e,
                                        );
                                });
                                await Promise.all(n);
                              })),
                              (t.closeAllDatabases = Object(d.a)(async () => {
                                let e = [...s];
                                i.zsymb(
                                  0,
                                  14538,
                                  30004,
                                  "Start closing all dbs",
                                ),
                                  i.zsymb(
                                    3,
                                    14538,
                                    30005,
                                    "Wait for dbs to be closed: {}",
                                    e,
                                  );
                                const n = s.map(async (s) => {
                                  await t[s].closeThisDatabase(),
                                    (e = e.filter((e) => e !== s)),
                                    0 === e.length
                                      ? i.zsymb(
                                          0,
                                          14538,
                                          30006,
                                          "Done closing all dbs",
                                        )
                                      : i.zsymb(
                                          3,
                                          14538,
                                          30007,
                                          "Wait for dbs to be closed: {}",
                                          e,
                                        );
                                });
                                await Promise.all(n);
                              })),
                              t
                            );
                          }
                          createBuilder(e, t, s) {
                            return new o.a(e, t, s);
                          }
                        }),
                      ) || i),
                  ) || i),
              ) || i),
          ) || i;
        n.ModuleContainer.registerSingleton(l.a, c);
      },
      Mk04: function (e, t, s) {
        "use strict";
        function i(e) {
          let t = {};
          return async function () {
            for (var s = arguments.length, i = new Array(s), n = 0; n < s; n++)
              i[n] = arguments[n];
            const a = i.length ? i.join("-") : "";
            if (!t[a]) return (t[a] = !0), e(...i);
          };
        }
        s.d(t, "a", function () {
          return i;
        });
      },
      PLj1: function (e, t, s) {
        "use strict";
        s.d(t, "b", function () {
          return n;
        }),
          s.d(t, "c", function () {
            return a;
          }),
          s.d(t, "a", function () {
            return r;
          });
        var i = s("fsQs");
        let n;
        !(function (e) {
          (e.Main = "main"),
            (e.Render = "render"),
            (e.SharedWorker = "shared-worker"),
            (e.Unknown = "unknown"),
            (e.Photo = "photo"),
            (e.Web = "web"),
            (e.Embed = "embed"),
            (e.Login = "login");
        })(n || (n = {}));
        const a = {
            [n.Main]: i.e,
            [n.Render]: i.e,
            [n.SharedWorker]: i.e,
            [n.Unknown]: i.e,
            [n.Photo]: i.e,
            [n.Web]: i.g,
            [n.Embed]: -1,
            [n.Login]: i.f,
          },
          r = [n.Embed, n.Unknown];
      },
      SF1S: function (e, t) {},
      UJDs: function (e, t, s) {
        "use strict";
        let i;
        s.d(t, "b", function () {
          return i;
        }),
          s.d(t, "a", function () {
            return n;
          }),
          (function (e) {
            (e[(e.info = 0)] = "info"),
              (e[(e.error = 1)] = "error"),
              (e[(e.warn = 2)] = "warn"),
              (e[(e.debug = 3)] = "debug"),
              (e[(e.critical = 4)] = "critical");
          })(i || (i = {}));
        const n = {
          [i.info]: "info",
          [i.error]: "error",
          [i.warn]: "warn",
          [i.debug]: "debug",
          [i.critical]: "critical",
        };
      },
      W8fB: function (e, t, s) {
        "use strict";
        s.d(t, "b", function () {
          return n;
        }),
          s.d(t, "a", function () {
            return a;
          }),
          s.d(t, "c", function () {
            return r;
          });
        var i = s("jDHv");
        const n = Object(i.define)("sen-log-writer"),
          a = Object(i.define)("console-log-writer"),
          r = Object(i.define)("zlog-writer");
      },
      WOja: function (e, t) {},
      XuBa: function (e, t, s) {
        "use strict";
        s.d(t, "a", function () {
          return n;
        });
        const i = s("NFKh");
        class n {
          static encrypt(e) {
            return (
              i.AES.encrypt(e, "5dbe084b7eedNWjRref04e2rDxs01lwH", {
                iv: "7eb5dbe084b7eedeef04e2622d46ba00",
                mode: i.mode.ECB,
                padding: i.pad.Pkcs7,
              }) + ""
            );
          }
          static decrypt(e) {
            return i.AES.decrypt(e, "5dbe084b7eedNWjRref04e2rDxs01lwH", {
              keySize: 16,
              iv: "7eb5dbe084b7eedeef04e2622d46ba00",
              mode: i.mode.ECB,
              padding: i.pad.Pkcs7,
            }).toString(i.enc.Utf8);
          }
        }
      },
      Y41u: function (e, t, s) {
        "use strict";
        let i;
        s.d(t, "c", function () {
          return i;
        }),
          s.d(t, "b", function () {
            return n;
          }),
          s.d(t, "a", function () {
            return a;
          }),
          (function (e) {
            (e.RegLogBucketStatus = "RegLogBucketStatus"),
              (e.SentryLogBucketStatus = "SentryLogBucketStatus"),
              (e.WriteSchedulerRequestFlush = "WriteSchedulerRequestFlush"),
              (e.WriterStatus = "WriterStatus"),
              (e.LogBucketRequestFlush = "LogBucketRequestFlush");
          })(i || (i = {}));
        class n {
          constructor(e, t) {
            (this.type = e), (this.payload = t);
          }
        }
        class a {
          constructor(e) {
            this.type = e;
          }
        }
      },
      YpjI: function (e, t) {
        (globalThis.$zcommon = {}),
          (globalThis.$znode = {}),
          (globalThis.$zglobalThis = {}),
          (globalThis.$zresource = {
            onClipboardChange: () => {},
            onCheckIdleUpdaterBusy: () => {},
            getChildUrl: () => Promise.resolve(),
          }),
          (globalThis.$zlogger = {}),
          (globalThis.$zupdater = {}),
          (globalThis.$zapp = {
            onRequestShowPreference: () => {},
            onRequestShowAbout: () => {},
            beforeAppClose: () => {},
            beforeAppAutoRestart: () => {},
          }),
          (globalThis.$zdownload = {}),
          (globalThis.$zdb = {}),
          (globalThis.$zmulti = {}),
          (globalThis.$zcall = { sendDataToNative: () => {} }),
          (globalThis.$zsharedWorker = {}),
          (globalThis.$zelectron = {}),
          (globalThis.$zelectronNative = {}),
          (globalThis.$zuri = {
            onNewRequest: () => {},
            onRequestOpenConv: () => {},
            removeListenNewRequest: () => {},
            removeListenRequestOpenConv: () => {},
            onRequestOpenZavi: () => {},
          }),
          (globalThis.$zscreencap = { onEventOs: () => {} }),
          (globalThis.$zlogin = {}),
          (globalThis.$zperf = {}),
          (globalThis.$zconfig = {}),
          (globalThis.$zFileManager = { trustBlob: () => {} }),
          (globalThis.$zFeatures = {}),
          (globalThis.$zwindow = {
            closeWindow: () => {},
            expandMainWindow: () => {},
            focus: () => {},
            onHideWindowComplete: () => {},
            removeListenHideWindowComplete: () => {},
            removeListenVisibilityChange: () => {},
            onVisibilityChange: () => {},
          }),
          (globalThis.$zcloud = {}),
          (globalThis.$zsub = {
            $zapp: globalThis.$zapp,
            $zscreencap: globalThis.$zscreencap,
            $zuri: globalThis.$zuri,
            $zresource: globalThis.$zresource,
            $zlogger: globalThis.$zlogger,
            $zwindow: globalThis.$zwindow,
            $zFileManager: globalThis.$zFileManager,
            $zcall: globalThis.$zcall,
          }),
          (globalThis.$zInAppPayment = {
            openUrl: () => {},
            closeInAppPayment: () => {},
          });
      },
      cF85: function (e, t, s) {
        "use strict";
        var i = s("jDHv"),
          n = s("x9oK"),
          a = s("YEoC"),
          r = s("DI/x"),
          o = s("PmZf"),
          d = s("LzQZ"),
          l = s("rvru"),
          c = s("xpEm");
        function h(e) {
          return new Promise((t, s) => {
            (e.onerror = () => s(e.error)), (e.onsuccess = () => t(e.result));
          });
        }
        function u(e, t, s) {
          return `Invalid filter value for this method: '${e}' - Expected type: '${t}' - Actual type: '${s}'`;
        }
        function g(e, t) {
          const s = Object(c.m)(t, {
            operations: {
              AND: c.a,
              OR: c.k,
              NOT: c.j,
              gt: c.c,
              gte: c.d,
              lt: c.f,
              lte: c.g,
              in: c.e,
              notIn: c.i,
              eq: c.b,
              notEq: c.h,
              contains(e, t, s) {
                if ("string" != typeof e) {
                  const t = u("contains", "string", typeof e);
                  throw new r.n(t);
                }
                return Object(c.l)(
                  (t) => "string" == typeof t && t.includes(e),
                  t,
                  s,
                );
              },
              startsWith(e, t, s) {
                if ("string" != typeof e) {
                  const t = u("startsWith", "string", typeof e);
                  throw new r.n(t);
                }
                return Object(c.l)(
                  (t) => "string" == typeof t && t.startsWith(e),
                  t,
                  s,
                );
              },
              endsWith(e, t, s) {
                if ("string" != typeof e) {
                  const t = u("endsWith", "string", typeof e);
                  throw new r.n(t);
                }
                return Object(c.l)(
                  (t) => "string" == typeof t && t.endsWith(e),
                  t,
                  s,
                );
              },
            },
          });
          return s(e);
        }
        let m;
        var p;
        ((p = m || (m = {})).isVersionError = function (e) {
          return e instanceof DOMException && "VersionError" === e.name;
        }),
          (p.getCurrentVersionFromVersionError = function (e) {
            if (!m.isVersionError(e)) return NaN;
            const t = [...e.message.matchAll(/\(\d+\)/g)][1][0];
            return +t.slice(1, t.length - 1);
          }),
          (p.isInvalidStateError = function (e) {
            return (
              e instanceof DOMException &&
              ("InvalidStateError" === e.name || 11 === e.code)
            );
          });
        var f = s("AH6j"),
          v = s("Mgpg"),
          b = s("UK4g"),
          I = s("YZti");
        let y = null;
        const _ = () => {
          if (null === y) {
            const e = i.ModuleContainer.resolve(v.ZLoggerFactory);
            y = e.createZLogger("idb", ["connection"]);
          }
          return y;
        };
        class O extends f.b {
          constructor(e) {
            super(),
              (this.connectionFactory = e),
              (this.connection = null),
              (this.isManuallyClose = !1),
              (this.reOpenCountIn1Hour = 0),
              (this.firstTimeReOpenDttm = null),
              (this.onAbnormallyCloseListeners = []),
              (this.failedToOpenDBConnectionErrorMessage = "");
          }
          get hasActiveConnection() {
            return null !== this.connection;
          }
          async getName() {
            return (await this.getConnection()).name;
          }
          async getObjectStoreNames() {
            return (await this.getConnection()).objectStoreNames;
          }
          async getVersion() {
            return (await this.getConnection()).version;
          }
          canReOpenConnection() {
            return this.reOpenCountIn1Hour <= b.j;
          }
          updateReopenMetadata() {
            const e = Date.now();
            null === this.firstTimeReOpenDttm ||
            (() => Math.abs(e - this.firstTimeReOpenDttm) >= 36e5)()
              ? ((this.firstTimeReOpenDttm = e), (this.reOpenCountIn1Hour = 1))
              : (this.reOpenCountIn1Hour += 1);
          }
          async getConnection(e) {
            void 0 === e && (e = !1);
            const t = async () => {
              let e = null;
              try {
                (e = await this.connectionFactory()),
                  this.dispatchEvent(
                    new o.e({ fullname: e.name, adapterType: a.a.IDB }),
                  );
              } catch (t) {
                if (I.b.isFailedToOpenConnectionError(t)) {
                  return (
                    _().zsymb(18, 15322, 3e4, `${t}`),
                    (this.failedToOpenDBConnectionErrorMessage = t.message),
                    new Promise((e, t) => {
                      setTimeout(() => {
                        this.getConnection(!0).then(e).catch(t);
                      });
                    })
                  );
                }
                throw t;
              }
              return (
                (e.onclose = () => {
                  var t;
                  this.dispatchEvent(
                    new o.a(
                      (null === (t = e) || void 0 === t ? void 0 : t.name) ||
                        "",
                    ),
                  );
                }),
                e
              );
            };
            if (e) {
              if (this.isManuallyClose)
                throw new r.d(
                  "The database connection has manually been closed!",
                  ["idb"],
                );
              if ((this.updateReopenMetadata(), !this.canReOpenConnection())) {
                const e = this.failedToOpenDBConnectionErrorMessage;
                throw (
                  ((this.failedToOpenDBConnectionErrorMessage = ""), new r.l(e))
                );
              }
              const e = this.connection;
              e &&
                this.onAbnormallyCloseListeners.forEach((t) => {
                  e.removeEventListener("close", t);
                }),
                (this.connection = await t());
            } else this.connection || (this.connection = await t());
            return this.connection;
          }
          async getTransaction(e, t) {
            let s = await this.getConnection(),
              i = null;
            try {
              i = s.transaction(e, t);
            } catch (n) {
              if (!n || !m.isInvalidStateError(n)) throw n;
              (s = await this.getConnection(!0)), (i = s.transaction(e, t));
            }
            return i;
          }
          close() {
            this.connection &&
              !this.isManuallyClose &&
              (this.connection.close(),
              (this.connection = null),
              (this.isManuallyClose = !0));
          }
        }
        var C = s("bSii"),
          E = s("3wcW");
        class M extends E.a {
          constructor(e, t, s) {
            super(e, t, !1),
              (this._transaction = s),
              (this.allowMissingTable = !1);
          }
          async delete() {}
          async close() {
            this.instance && this.instance.close();
          }
          createMissingTable(e) {
            throw new r.x("IndexedDB doesn't support create missing tables");
          }
          async _getTables() {
            return Array.from(this.instance.objectStoreNames);
          }
          async _createTable(e) {
            const t = this.instance;
            let s = {};
            if (e.isNonFieldlikeEntity) s = { autoIncrement: !0 };
            else {
              const t = e.primaryIndex;
              s = {
                keyPath: Object(C.a)(t.getRealFields()),
                autoIncrement: t.autoIncrement,
              };
            }
            if (t.objectStoreNames.contains(e.tableName)) return;
            const i = t.createObjectStore(e.tableName, s);
            Object.values(e.indices).map((e) => {
              if ("primary" === e.name) return;
              const t = e.fields.map((e) =>
                "object" != typeof e
                  ? e
                  : "length" === e.type
                    ? `${e.field.toString()}.length`
                    : e.field,
              );
              i.createIndex(e.name, Object(C.a)(t), { unique: e.unique });
            });
          }
          async _createIndex(e, t) {
            const s = this._transaction;
            if (!s)
              throw new r.z(
                `Can't create '${t}' due to unavailable IDBTransaction transaction!`,
              );
            const i = s.objectStore(e.tableName),
              n = e.getIndex(t),
              a = n.fields.map((e) =>
                "object" != typeof e
                  ? e
                  : "length" === e.type
                    ? `${e.field.toString()}.length`
                    : e.field,
              );
            var o;
            i.indexNames.contains(t) ||
              i.createIndex(t, 1 === (o = a).length ? o[0] : o, {
                unique: n.unique,
              });
          }
          _addColumns(e, t) {
            return Promise.resolve();
          }
        }
        var S = s("VTBJ"),
          T = s("X2RP");
        class w extends T.a {
          constructor(e, t) {
            super(), (this.instance = e), (this.transactionManager = t);
          }
          getExecutorName() {
            return "idb";
          }
          async clear(e) {
            let { transaction: t, meta: s, deferrer: i } = e;
            const n = s.tableConfig;
            return h(
              (await this.getStore(t, n, a.f.READWRITE, i.reject)).clear(),
            );
          }
          async get(e) {
            let { transaction: t, meta: s, params: i, deferrer: n } = e;
            const a = i.index,
              r = i.key,
              o = s.tableConfig,
              d = await this.getStoreOrIndex(t, o, a, n.reject),
              l = this.validateKey(o, a, r),
              c = d.get(l);
            return this.getResult(o, c);
          }
          async getMulti(e) {
            let { transaction: t, meta: s, params: i, deferrer: n } = e;
            const { index: a, keys: r, onValue: o } = i,
              d = s.tableConfig,
              l = await this.getStoreOrIndex(t, d, a, n.reject),
              c = r.map(async (e) => {
                const t = this.validateKey(d, a, e),
                  s = l.get(t),
                  i = await this.getResult(d, s);
                return o && o(i), i;
              });
            return Promise.all(c);
          }
          getAll(e) {
            return e.params.direction === a.b.PREV ||
              e.params.direction === a.b.PREV_UNIQUE ||
              e.params.filter ||
              e.params.predicate ||
              e.params.aborted ||
              e.params.onProgress ||
              e.params.onValue
              ? this.getAllByCursor(e)
              : this.getAllWithoutFilter(e);
          }
          async getAllKeyByCursor(e) {
            let { meta: t, params: s, transaction: i, deferrer: n } = e;
            const a = t.tableConfig,
              r = s.range && this.toIDBKeyRange(s.range),
              o = (
                await this.getStoreOrIndex(i, a, s.index, n.reject)
              ).openKeyCursor(r, s.direction);
            return null === o
              ? []
              : new Promise((e, t) => {
                  const i = [];
                  (o.onsuccess = () => {
                    const t = o.result;
                    if (null === t || null === t.primaryKey) return void e(i);
                    const n = t.primaryKey;
                    i.push(n);
                    i.length >= s.limit ? e(i) : t.continue();
                  }),
                    (o.onerror = () => {
                      t(o.error);
                    });
                });
          }
          async getAllKey(e) {
            if (
              e.params.direction === a.b.PREV ||
              e.params.direction === a.b.PREV_UNIQUE
            )
              return this.getAllKeyByCursor(e);
            {
              const { meta: t, params: s, transaction: i } = e,
                n = t.tableConfig,
                a = s.range && this.toIDBKeyRange(s.range);
              return h(
                (
                  await this.getStoreOrIndex(i, n, s.index, e.deferrer.reject)
                ).getAllKeys(a, s.limit),
              );
            }
          }
          async getAndUpdate(e) {
            const { transaction: t, params: s, meta: i } = e,
              n = s.index,
              o = s.updater,
              d = s.key,
              l = i.tableConfig,
              c = await this.getStoreOrIndex(t, l, n, e.deferrer.reject),
              u = this.validateKey(l, n, d),
              g = c.get(u),
              m = await this.getResult(l, g);
            if (void 0 === m) return;
            const p = await this.getStore(
                t,
                l,
                a.f.READWRITE,
                e.deferrer.reject,
              ),
              f = await o(m || {});
            if (!f && !1 !== s.ignoreNotFound)
              throw new r.f("Update undefined document");
            const v = this.toDB(l, f),
              b = p.put(v);
            return await h(b), f;
          }
          insert(e) {
            return e.params.replace
              ? this._insertOrReplace(e)
              : this._insertIfNotExist(e);
          }
          insertMulti(e) {
            return e.params.replace
              ? this.insertOrReplaceMulti(e)
              : this.insertIfNotExistMulti(e);
          }
          async update(e) {
            const { transaction: t, meta: s, params: i, deferrer: n } = e,
              r = s.tableConfig,
              o = await this.getStore(t, r, a.f.READWRITE, n.reject);
            return this._update(
              o,
              this.validateKey(r, "primary", i.key),
              i.attributes,
              this.toDB(r, i.value, !1),
              i.ignoreNotFound,
            ).then((t) => (t ? this.fromDB(e.meta.tableConfig, t) : t));
          }
          async updateMulti(e) {
            const { transaction: t, meta: s, params: i } = e,
              n = s.tableConfig,
              r = await this.getStore(t, n, a.f.READWRITE, e.deferrer.reject),
              o = [],
              d = [],
              l = i.patches.map((t) =>
                this._update(
                  r,
                  this.validateKey(n, "primary", t.key),
                  t.attributes,
                  this.toDB(n, t.value, !1),
                  i.ignoreNotFound,
                )
                  .then((t) => (t ? this.fromDB(e.meta.tableConfig, t) : t))
                  .then((e) => {
                    e ? o.push(e) : d.push(e);
                  }),
              );
            return Promise.all(l).then(() => ({ success: o, fail: d }));
          }
          async delete(e) {
            let { transaction: t, meta: s, params: i, deferrer: n } = e;
            const r = s.tableConfig,
              o = (await this.getStore(t, r, a.f.READWRITE, n.reject)).delete(
                this.validateKey(r, "primary", i.key),
              );
            return this.checkReqSuccessOrFail(o);
          }
          async deleteMulti(e) {
            let { transaction: t, meta: s, params: i, deferrer: n } = e;
            const r = s.tableConfig,
              o = await this.getStore(t, r, a.f.READWRITE, n.reject),
              d = { success: [], fail: [] },
              l = i.keys.map((e) =>
                this.checkReqSuccessOrFail(o.delete(e)).then((t) => {
                  t ? d.success.push(e) : d.fail.push(e);
                }),
              );
            return await Promise.all(l), d;
          }
          async count(e) {
            let { transaction: t, meta: s, params: i, deferrer: n } = e;
            const a = s.tableConfig,
              r = this.toIDBKeyRange(i.range);
            return h(
              (await this.getStoreOrIndex(t, a, i.index, n.reject)).count(r),
            );
          }
          async findAndDelete(e) {
            let { transaction: t, meta: s, params: i, deferrer: n } = e;
            const r = s.tableConfig,
              { filter: o } = i,
              d = o ? (e) => g(e, o) : null,
              l = this.toIDBKeyRange(i.range),
              c = (
                await this.getStore(t, r, a.f.READWRITE, n.reject)
              ).openCursor(l);
            return null === c
              ? 0
              : new Promise((e, t) => {
                  let s = 0,
                    i = !1;
                  (c.onsuccess = () => {
                    if (i) return;
                    const t = c.result;
                    if (null === t || null === t.value)
                      return (i = !0), void e(s);
                    const n = this.fromDB(r, t.value);
                    (d && !d(n)) || (t.delete(), (s += 1), !i)
                      ? t.continue()
                      : e(s);
                  }),
                    (c.onerror = () => {
                      t(c.error);
                    });
                });
          }
          async getAllByCursor(e) {
            let { transaction: t, meta: s, params: i, deferrer: n } = e;
            const a = s.tableConfig,
              {
                onProgress: o,
                advance: d,
                stepCount: l,
                onValue: c,
                predicate: h,
                filter: u,
              } = i;
            if (h && u) {
              const e = new r.n(
                "Query using both 'filter' and 'predicate' is not allowed!",
              );
              return void (null == n || n.reject(e));
            }
            let m = null;
            (h || u) && (m = h || ((e) => g(e, u)));
            const p = await this.getStoreOrIndex(t, a, i.index, n.reject),
              f = this.toIDBKeyRange(i.range),
              v = p.openCursor(f, i.direction);
            return null === v
              ? []
              : new Promise((e, t) => {
                  const s = [];
                  let n = !1,
                    r = !!d;
                  (v.onsuccess = () => {
                    if (n) return;
                    const t = v.result;
                    if (null === t || null === t.value)
                      return (n = !0), void e(s);
                    if (r && d) return (r = !1), void t.advance(d);
                    const h = this.fromDB(a, t.value);
                    c && c(h),
                      (m && !m(h)) ||
                      (s.push(h),
                      o && o(s, h),
                      (n = s.length >= i.limit),
                      n || (n = !!i.aborted && i.aborted(s, h)),
                      !n)
                        ? (l && t.advance(l), t.continue())
                        : e(s);
                  }),
                    (v.onerror = () => {
                      t(v.error);
                    });
                });
          }
          async getAllWithoutFilter(e) {
            let { transaction: t, meta: s, params: i, deferrer: n } = e;
            const a = s.tableConfig,
              r = this.toIDBKeyRange(i.range),
              o = (await this.getStoreOrIndex(t, a, i.index, n.reject)).getAll(
                r,
                i.limit,
              );
            return this.getResult(a, o);
          }
          async getStoreOrIndex(e, t, s, i) {
            const n = await this.getStore(e, t, a.f.READONLY, i);
            if ("primary" === s) return n;
            const o = t.getIndex(s);
            if (!o) throw new r.s(s);
            return n.index(o.name);
          }
          async _insertIfNotExist(e) {
            const { transaction: t, meta: s, params: i } = e,
              n = s.tableConfig,
              r = await this.getTransaction(
                t,
                n,
                a.f.READWRITE,
                e.deferrer.reject,
              ),
              o = r.objectStore(n.tableName);
            let d = null;
            if (!n.isNonFieldlikeEntity) {
              const e = n.primaryIndex;
              if (!e.autoIncrement) {
                const t = Object(C.a)(e.createKey(i.value)),
                  s = o.get(t);
                d = await new Promise((e) => {
                  (s.onsuccess = () => {
                    const t = this.fromDB(n, s.result);
                    e(t);
                  }),
                    (s.onerror = () => {
                      e(null);
                    });
                });
              }
            }
            if (d) return Promise.resolve(d);
            {
              const e = o.add(this.toDB(n, i.value));
              return t
                ? h(e).then(() => i.value)
                : new Promise((t, s) => {
                    (r.oncomplete = () => {
                      t(i.value);
                    }),
                      (r.onerror = () => {
                        var n;
                        0 ===
                        (null === (n = e.error) || void 0 === n
                          ? void 0
                          : n.code)
                          ? t(i.value)
                          : s(e.error);
                      });
                  });
            }
          }
          async _insertOrReplace(e) {
            const { transaction: t, meta: s, params: i } = e,
              n = s.tableConfig,
              r = await this.getTransaction(
                t,
                n,
                a.f.READWRITE,
                e.deferrer.reject,
              ),
              o = r.objectStore(n.tableName).put(this.toDB(n, i.value));
            return t
              ? h(o).then(() => i.value)
              : new Promise((e, t) => {
                  (r.oncomplete = () => {
                    e(i.value);
                  }),
                    (r.onerror = () => {
                      t(o.error);
                    });
                });
          }
          async insertIfNotExistMulti(e) {
            const { transaction: t, meta: s, params: i } = e,
              n = s.tableConfig,
              r = await this.getTransaction(
                t,
                n,
                a.f.READWRITE,
                e.deferrer.reject,
              ),
              o = r.objectStore(n.tableName),
              d = [],
              l = [],
              c = i.values.map(async (e) => {
                let t = !1;
                if (!n.isNonFieldlikeEntity) {
                  const s = n.primaryIndex;
                  if (!s.autoIncrement) {
                    const i = Object(C.a)(s.createKey(e)),
                      a = o.get(i);
                    t = await new Promise((e) => {
                      (a.onsuccess = () => {
                        const t = this.fromDB(n, a.result);
                        let s = !1;
                        void 0 !== t && (d.push(t), (s = !0)), e(s);
                      }),
                        (a.onerror = () => {
                          e(!1);
                        });
                    });
                  }
                }
                if (t) return;
                const s = o.add(this.toDB(n, e));
                return this.checkReqSuccessOrFail(s)
                  .then((t) => {
                    if (t) {
                      let t = e;
                      if (!n.isNonFieldlikeEntity) {
                        const { primaryIndex: e } = n,
                          i = e.fields[0].field;
                        Object.prototype.hasOwnProperty.call(t, i) ||
                          (t[i] = s.result);
                      }
                      d.push(t);
                    } else l.push(e);
                  })
                  .catch(() => {
                    l.push(e);
                  });
              });
            return t
              ? Promise.all(c).then(() => ({ success: d, fail: l }))
              : new Promise((e) => {
                  (r.oncomplete = () => {
                    e({ success: d, fail: l });
                  }),
                    (r.onerror = () => {
                      e({ success: d, fail: l });
                    });
                });
          }
          async insertOrReplaceMulti(e) {
            const { transaction: t, meta: s, params: i } = e,
              n = s.tableConfig,
              r = await this.getTransaction(
                t,
                n,
                a.f.READWRITE,
                e.deferrer.reject,
              ),
              o = r.objectStore(n.tableName),
              d = [],
              l = [],
              c = i.values.map((e) => {
                const t = o.put(this.toDB(n, e));
                return this.checkReqSuccessOrFail(t)
                  .then(() => {
                    let s = e;
                    if (!n.isNonFieldlikeEntity) {
                      const { primaryIndex: e } = n,
                        i = e.fields[0].field;
                      Object.prototype.hasOwnProperty.call(s, i) ||
                        (s[i] = t.result);
                    }
                    d.push(s);
                  })
                  .catch(() => {
                    l.push(e);
                  });
              });
            return t
              ? Promise.all(c).then(() => ({ success: d, fail: l }))
              : new Promise((e) => {
                  (r.oncomplete = () => e({ success: d, fail: l })),
                    (r.onerror = () => e({ success: d, fail: l }));
                });
          }
          async _update(e, t, s, i, n) {
            const a = await h(e.get(t));
            if (!a) {
              if (n) return;
              throw new r.f("Update undefined document!");
            }
            return await h(e.put(s.reduce((e, t) => ((e[t] = i[t]), e), a))), a;
          }
          checkReqSuccessOrFail(e) {
            return h(e)
              .then(() => !0)
              .catch(() => !1);
          }
          async getTransaction(e, t, s, i) {
            const n = t.tableName;
            if (e > 0) {
              const t = this.transactionManager.get(e);
              return Promise.resolve(t.instance);
            }
            const a = await this.instance.getTransaction([n], s);
            return (
              a.addEventListener("error", () => i(a.error)),
              a.addEventListener("abort", () => i(a.error)),
              a
            );
          }
          async getStore(e, t, s, i) {
            return (await this.getTransaction(e, t, s, i)).objectStore(
              t.tableName,
            );
          }
          toIDBKeyRange(e) {
            if (e) {
              if (e.from && e.to)
                try {
                  return IDBKeyRange.bound(
                    e.from,
                    e.to,
                    e.excludeFrom,
                    e.excludeTo,
                  );
                } catch (t) {
                  throw t;
                }
              return e.from
                ? IDBKeyRange.lowerBound(e.from, e.excludeFrom)
                : e.to
                  ? IDBKeyRange.upperBound(e.to, e.excludeTo)
                  : void 0;
            }
          }
          getResult(e, t) {
            return h(t).then((t) => this.fromDB(e, t));
          }
          toDB(e, t, s) {
            void 0 === s && (s = !0);
            try {
              e.validate(t, s);
            } catch (r) {
              this.logger.zsymb(
                21,
                12349,
                3e4,
                "{}: {} (database={}, table={})",
                r.name,
                r.message,
                e.dbName,
                e.name,
              );
            }
            const { isNonFieldlikeEntity: i } = e,
              n = e.getTransformConfigs(a.a.IDB);
            return (function (e) {
              if (0 === n.length) return e;
              const t = (e) => {
                if (i) return n.reduce((e, t) => t.toDB(e), e);
                {
                  const t = Object(S.a)({}, e);
                  return (
                    n.forEach((e) => {
                      e.toDB(t);
                    }),
                    t
                  );
                }
              };
              return Array.isArray(e) ? e.map(t) : t(e);
            })((t = e.prepareValue(t, s, i)));
          }
          fromDB(e, t) {
            const s = e.getTransformConfigs(a.a.IDB);
            if (0 === s.length) return t;
            const i = (e) => (
              s.forEach((t) => {
                t.fromDB(e);
              }),
              e
            );
            return Array.isArray(t) ? t.map(i) : i(t);
          }
          validateKey(e, t, s) {
            if (!e.getIndex(t).validateKey(s))
              throw new r.n("The query key is invalid!");
            return s;
          }
        }
        class R {
          constructor(e, t) {
            (this.partition = e), (this.instance = t);
          }
          async beginTransaction(e) {
            try {
              const t = e.params.tables.map(
                  (e) => this.partition.getTableConfig(e).tableName,
                ),
                s = e.params.mode,
                i = await this.instance.getTransaction(t, s),
                n = e.transaction;
              e.deferrer.resolve(new L(n, i));
            } catch (t) {
              e.deferrer.reject(t);
            }
          }
        }
        class L {
          constructor(e, t) {
            (this.id = e),
              (this.instance = t),
              (this.error = null),
              (this.closed = void 0),
              (this.onCloseListeners = []),
              (this.closed = !1);
            const s = (e) => {
              (this.closed = !0),
                (this.error = e),
                this.onCloseListeners.forEach((t) => t(e));
            };
            t.addEventListener("complete", () => s(t.error)),
              t.addEventListener("abort", () => s(t.error)),
              t.addEventListener("error", () => s(t.error));
          }
          execute(e) {
            return e().catch((e) => {
              throw (this.instance.abort(), e);
            });
          }
          onClose(e) {
            this.onCloseListeners.push(e), this.closed && e(this.error);
          }
        }
        class D extends n.a {
          constructor(e, t, s, i, n, a) {
            super(e, t, s, i, n, a, {}), this.registerEvents();
          }
          registerEvents() {
            const e = (e) => {
              this.dispatchEvent(e);
            };
            this.instance.addEventListener(o.b.UnexpectedError, e),
              this.instance.addEventListener(o.b.SuccessOpenDB, e),
              this.instance.addEventListener(
                o.b.ConnectionClosedAbnormally,
                (t) => {
                  this.logger.zsymb(
                    6,
                    14541,
                    3e4,
                    "The database connection has abnormally closed!",
                  ),
                    e(t);
                },
              );
          }
          async doesDatabaseExist(e) {
            try {
              return (
                (
                  await (function (e) {
                    const t = globalThis.indexedDB.open(e);
                    return new Promise((s, i) => {
                      (t.onupgradeneeded = function () {
                        var s;
                        null === (s = t.transaction) ||
                          void 0 === s ||
                          s.abort(),
                          i(new A(`No database whose name is ${e} exists`));
                      }),
                        (t.onsuccess = function () {
                          s(t.result);
                        }),
                        (t.onerror = function () {
                          i(t.error);
                        });
                    });
                  })(e)
                ).close(),
                !0
              );
            } catch (t) {
              if (t.name === F) return !1;
              throw t;
            }
          }
          async deleteThisDatabase() {
            if (!(await this.doesDatabaseExist(this.fullName)))
              return void this.logger.zsymb(
                6,
                14541,
                30001,
                `Skip db deletion due to non-existence: '${this.fullName}'`,
              );
            this.instance.close();
            const e = indexedDB.deleteDatabase(this.fullName),
              t = this.instance,
              s = this.fullName,
              i = this.logger;
            return (
              i.zsymb(
                6,
                14541,
                30002,
                `The database connection is manually closed due to database deletion: '${s}'`,
              ),
              new Promise((n, a) => {
                (e.onsuccess = function () {
                  i.zsymb(
                    0,
                    14541,
                    30003,
                    `Delete database sucessfully: '${s}'`,
                  ),
                    n();
                }),
                  (e.onblocked = function () {
                    t.close();
                  }),
                  (e.onerror = function () {
                    const t = e.error;
                    i.zsymb(
                      0,
                      14541,
                      30004,
                      `Failed to delete database: '${s}' - Error: ${t}`,
                    ),
                      a(t);
                  });
              })
            );
          }
          closeThisDatabase() {
            return this.instance.hasActiveConnection
              ? (this.instance.close(),
                this.logger.zsymb(
                  6,
                  14541,
                  30005,
                  `The database connection is manually closed due to manual database closing: '${this.fullName}'`,
                ),
                new Promise((e) => {
                  setTimeout(() => {
                    e();
                  }, 1e4);
                }))
              : Promise.resolve();
          }
          static async factory(e, t) {
            const s = new O(async function () {
                const s = Date.now(),
                  n = i.ModuleContainer.resolve(l.a),
                  a = setTimeout(() => {
                    n.sendLongOpenRequestQos(e);
                  }, 2e4),
                  o = await new Promise((s, i) => {
                    const n = indexedDB.open(e, t.version);
                    let a = null;
                    const o = (e, s) => (null === a && (a = new M(t, e, s)), a);
                    (n.onupgradeneeded = async (e) => {
                      if (null !== e.newVersion)
                        try {
                          const t = o(n.result, n.transaction);
                          await t.upgrade(e.oldVersion, e.newVersion);
                        } catch (t) {
                          n.transaction.abort(), i(t);
                        }
                    }),
                      (n.onsuccess = async () => {
                        try {
                          const e = n.result,
                            t = o(e, n.transaction);
                          await t.validate(), s(e);
                        } catch (e) {
                          i(e);
                        }
                      }),
                      (n.onerror = () => {
                        let s = n.error;
                        (s = m.isVersionError(s)
                          ? new r.o({
                              fullname: e,
                              currentVersion:
                                m.getCurrentVersionFromVersionError(s),
                              requestedVersion: t.version,
                            })
                          : new r.l(s.message)),
                          i(s);
                      }),
                      (n.onblocked = () => {
                        var e;
                        const t = new r.l(
                          (null === (e = n.error) || void 0 === e
                            ? void 0
                            : e.message) || "",
                        );
                        i(t);
                      });
                  }).catch((e) => {
                    throw (clearTimeout(a), e);
                  }),
                  d = Date.now();
                clearTimeout(a);
                const c = d - s;
                return (
                  n.sendSuccessOpenDBDurationQos(e, s, c),
                  (o.onversionchange = function (e) {
                    if (null === e.newVersion) {
                      e.target.close();
                    }
                  }),
                  o
                );
              }),
              n = i.ModuleContainer.resolve(d.a),
              o = new R(t, s),
              c = new w(s, n);
            return (
              t.tables.forEach((e) =>
                e
                  .getTransformConfigs(a.a.IDB)
                  .forEach((e) => e.init(t.cipherKey)),
              ),
              new D(t, e, n, s, c, o)
            );
          }
        }
        const F = "NonExistedDBError";
        class A extends Error {
          constructor(e) {
            super(e), (this.name = F);
          }
        }
        var j;
        let P =
          i.ModuleContainer.injectable()(
            (j = class {
              async createAdapter(e, t) {
                return D.factory(e, t);
              }
              async getExistedPartitionKeys(e) {
                return [];
              }
            }),
          ) || j;
        i.ModuleContainer.registerSingleton(n.b, P);
      },
      d951: function (e, t, s) {
        "use strict";
        s.d(t, "a", function () {
          return i;
        });
        class i {
          constructor(e) {
            (this.executor = e),
              (this.resolve = () => {}),
              (this.reject = () => {});
          }
          execute() {
            this.executor().then(this.resolve).catch(this.reject);
          }
          getResult() {
            return new Promise((e, t) => {
              (this.resolve = e), (this.reject = t);
            });
          }
        }
      },
      ebA4: function (e, t, s) {
        "use strict";
        s.d(t, "c", function () {
          return l;
        }),
          s.d(t, "b", function () {
            return c;
          }),
          s.d(t, "a", function () {
            return h;
          });
        var i = s("UJDs"),
          n = s("j6JD"),
          a = s("CDcE"),
          r = s("fsQs"),
          o = s("XuBa");
        const d = new TextEncoder();
        function l(e) {
          let t = e;
          if (Object(a.c)(t)) return (t.asset = o.a.encrypt(t.asset)), t;
          if (Object(a.b)(t)) return t.args;
          if ("function" == typeof t)
            try {
              t = e();
            } catch (s) {
              t = t.toString();
            }
          return (
            "object" == typeof t && (t = JSON.stringify(t, Object(a.a)())),
            "string" == typeof t &&
              (t = t.replace(/\r\n|\n|\t|\r/g, "").toString()),
            t
          );
        }
        function c(e, t) {
          let { lineMeta: s, template: o, args: c } = e;
          if ("number" == typeof o)
            throw new Error(
              "Error: expected template as string. Got number?! [" +
                s.id1 +
                ":" +
                s.id2 +
                "]",
            );
          const h = Object(n.a)(s.tick),
            u = [s.module, s.features.join("/")].filter((e) => e).join("|"),
            g = (function (e, t) {
              let s = [],
                i = -1;
              if (
                (t.forEach((e, t) => {
                  (Object(a.b)(e) || Object(a.c)(e)) && (i = t), s.push(l(e));
                }),
                1 === s.length &&
                  1 === t.length &&
                  "function" == typeof t[0] &&
                  Array.isArray(s[0]) &&
                  (s = [...s[0]]),
                !e)
              )
                return s.join(" ");
              const n = "{}";
              let r = e;
              const o = [];
              for (
                s.forEach((e) => {
                  -1 !== r.search(n) ? (r = r.replace(n, e)) : o.push(e);
                });
                -1 !== r.search(n);

              )
                r = r.replace(n, "");
              return r.concat(" ").concat(o.join(" "));
            })(o, c),
            m = "[" + [s.id1, s.id2].join(":") + "]",
            p = i.a[s.level].toUpperCase(),
            f = [`${h}__${t ? `${t.ss}.${t.ss_ln}` : "?.?"}`, p, u, g, m].join(
              "\t",
            ),
            v = d.encode(f.concat("\n"));
          return v.byteLength > r.k.file_lim ? v.slice(0, r.k.file_lim) : v;
        }
        function h(e) {
          const t = new ArrayBuffer(8),
            s = new DataView(t),
            i = 4294967295,
            n = ~~(e / i),
            a = (e % i) - n;
          return s.setUint32(0, n), s.setUint32(4, a), t;
        }
      },
      ez9R: function (e, t, s) {
        "use strict";
        s.d(t, "a", function () {
          return n;
        });
        var i = s("jDHv");
        const n = Object(i.define)("zlog-bin-encoder");
      },
      ezdo: function (e, t, s) {
        "use strict";
        var i,
          n = s("jDHv"),
          a = s("HPcM"),
          r = s("Y58e"),
          o = s("AH6j"),
          d = s("fsQs"),
          l = s("Y41u"),
          c = s("UJDs"),
          h = s("jGDt"),
          u = s("7FSS");
        const g =
          null === globalThis || void 0 === globalThis
            ? void 0
            : globalThis.performance;
        let m =
          Object(n.injectable)()(
            (i =
              (function (e, t) {
                return Object(n.inject)(h.a)(e, void 0, 0);
              })(
                (i =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (i =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === h.a ? Object : h.a,
                      ])(
                        (i = class extends o.b {
                          constructor(e) {
                            super(),
                              (this._session = e),
                              (this._data = []),
                              (this._lastPing = 0),
                              (this._isSessionLineReady = !1),
                              (this.add = (e) => {
                                this._data.push(e),
                                  g.now() - this._lastPing >= d.l &&
                                    ((this._lastPing = g.now()),
                                    this._broadcastEvent(
                                      l.c.LogBucketRequestFlush,
                                    )),
                                  this._data.length > 5e4 &&
                                    u.a.error(
                                      `[ZLL]: bucket size high: ${this._data.length}`,
                                    );
                              }),
                              (this.getElectronApi = () => {
                                let e = null;
                                try {
                                  e = $zelectron;
                                } catch (t) {}
                                return e;
                              }),
                              (this._broadcastEvent = (e, t) => {
                                switch (e) {
                                  case l.c.LogBucketRequestFlush:
                                  case l.c.RegLogBucketStatus:
                                    this.dispatchEvent(new l.b(e, t));
                                }
                              }),
                              this.recordSession();
                          }
                          get(e) {
                            return (
                              void 0 === e && (e = d.i),
                              this._isSessionLineReady ||
                                u.a.error(
                                  "[ZLL]: session line not ready. get() returns 0 untils it is ready",
                                ),
                              this._isSessionLineReady
                                ? this._data.slice(0, e)
                                : []
                            );
                          }
                          removeFirst(e) {
                            void 0 === e && (e = 1), this._data.splice(0, e);
                          }
                          getAll() {
                            return this._isSessionLineReady ? this._data : [];
                          }
                          size() {
                            return this._data.length;
                          }
                          async recordSession() {
                            const e = this._session.getSession();
                            const t = `zlgvers:${e.zlgv} ps:${e.process} build:${e.env}-${e.buildType} pversion:${e.pversion} avers: bhash:${e.build}`,
                              s = {
                                lineMeta: {
                                  type: "info",
                                  module: "Session".toUpperCase(),
                                  features: [""],
                                  level: c.b.info,
                                  id1: 0,
                                  id2: 0,
                                  tick: this._session.getProcessStartTime(),
                                },
                                template: "",
                                args: [t],
                              };
                            this._data.unshift(s),
                              (this._isSessionLineReady = !0);
                          }
                        }),
                      ) || i),
                  ) || i),
              ) || i),
          ) || i;
        var p;
        n.ModuleContainer.registerSingleton(a.a, m);
        let f =
          Object(n.injectable)()(
            (p = class extends o.b {
              constructor() {
                super(...arguments), (this._data = []);
              }
              removeFirst(e) {
                void 0 === e && (e = 1), this._data.splice(0, e);
              }
              add(e) {
                this._data.push(e),
                  this._broadcastEvent(l.c.LogBucketRequestFlush);
              }
              get(e) {
                const t = this._data.slice(0, e);
                return (this._data = this._data.slice(e)), t;
              }
              getAll() {
                return this._data;
              }
              size() {
                return this._data.length;
              }
              _broadcastEvent(e, t) {
                switch (e) {
                  case l.c.LogBucketRequestFlush:
                  case l.c.SentryLogBucketStatus:
                    this.dispatchEvent(new l.b(e, t));
                }
              }
            }),
          ) || p;
        n.ModuleContainer.registerSingleton(a.b, f);
        const v = Object(n.define)("zlogger-validator");
        var b,
          I = s("PLj1");
        let y =
          Object(n.injectable)()(
            (b =
              (function (e, t) {
                return Object(n.inject)(r.a)(e, void 0, 0);
              })(
                (b =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (b =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === r.a ? Object : r.a,
                      ])(
                        (b = class {
                          constructor(e) {
                            (this.config = e),
                              (this.DevOrStagingLevelConfig = {
                                [c.b.info]: !0,
                                [c.b.error]: !0,
                                [c.b.warn]: !0,
                                [c.b.debug]: !0,
                                [c.b.critical]: !0,
                              }),
                              (this.ProdLevelConfig = {
                                [c.b.info]: !0,
                                [c.b.error]: !0,
                                [c.b.warn]: !0,
                                [c.b.debug]: !1,
                                [c.b.critical]: !0,
                              }),
                              (this.DevOrStagingTransConfig = {
                                [c.b.info]: { toFile: !0, toConsole: !0 },
                                [c.b.error]: { toFile: !0, toConsole: !0 },
                                [c.b.warn]: { toFile: !0, toConsole: !0 },
                                [c.b.debug]: { toFile: !0, toConsole: !0 },
                                [c.b.critical]: { toFile: !0, toConsole: !0 },
                              }),
                              (this.ProdTransConfig = {
                                [c.b.info]: { toFile: !0, toConsole: !0 },
                                [c.b.error]: { toFile: !0, toConsole: !0 },
                                [c.b.warn]: { toFile: !1, toConsole: !1 },
                                [c.b.debug]: { toFile: !1, toConsole: !1 },
                                [c.b.critical]: { toFile: !0, toConsole: !0 },
                              }),
                              (this._ProcessBlacklist = []),
                              d.n && u.a.log("zlogger validator init");
                          }
                          validateLog(e, t, s, i) {
                            if (this._isBlackedlisted(e)) return !1;
                            switch (e) {
                              case I.b.Main:
                                return this._validateNoConfig(t, s, i);
                              case I.b.Web:
                              case I.b.Login:
                              case I.b.Photo:
                              case I.b.SharedWorker:
                              case I.b.Render:
                                return this._validateUsingConfig(t, s, i);
                              default:
                                return this._validateNoConfig(t, s, i);
                            }
                          }
                          _validateUsingConfig(e, t, s) {
                            const i =
                                !!this.config &&
                                this.config.get("stagingAccount"),
                              n = !!this.config && this.config.get("adminMode");
                            return (
                              (!0 !== (null == s ? void 0 : s.stagingOnly) ||
                                !1 !== i ||
                                !1 != !n) &&
                              (n || i
                                ? this.DevOrStagingLevelConfig[e] &&
                                  this.DevOrStagingTransConfig[e][t]
                                : this.ProdLevelConfig[e] &&
                                  this.ProdTransConfig[e][t])
                            );
                          }
                          _validateNoConfig(e, t, s) {
                            return (
                              this.ProdLevelConfig[e] &&
                              this.ProdTransConfig[e][t]
                            );
                          }
                          _isBlackedlisted(e) {
                            var t;
                            return !!(
                              e === I.b.Embed ||
                              (this.config &&
                                !0 ===
                                  (null === (t = this.config) || void 0 === t
                                    ? void 0
                                    : t.get("adminConfig.offLog"))) ||
                              this._ProcessBlacklist.includes(e)
                            );
                          }
                        }),
                      ) || b),
                  ) || b),
              ) || b),
          ) || b;
        n.ModuleContainer.register(v, y);
        const _ = Object(n.define)("zsentry-log-trans"),
          O = Object(n.define)("zfile-log-trans"),
          C = Object(n.define)("zconsole-log-trans");
        var E,
          M,
          S,
          T = s("KRcn"),
          w = s("W8fB");
        let R =
            Object(n.injectable)()(
              (E =
                (function (e, t) {
                  return Object(n.inject)(a.b)(e, void 0, 0);
                })(
                  (E =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (E =
                        Reflect.metadata("design:paramtypes", [
                          void 0 === a.b ? Object : a.b,
                        ])(
                          (E = class {
                            constructor(e) {
                              this.sentryBucket = e;
                            }
                            transport(e) {
                              throw new Error("Method not implemented.");
                            }
                          }),
                        ) || E),
                    ) || E),
                ) || E),
            ) || E,
          L =
            Object(n.injectable)()(
              (M =
                (function (e, t) {
                  return Object(n.inject)(a.a)(e, void 0, 0);
                })(
                  (M =
                    (function (e, t) {
                      return Object(n.inject)(v)(e, void 0, 1);
                    })(
                      (M =
                        Reflect.metadata(
                          "design:type",
                          Function,
                        )(
                          (M =
                            Reflect.metadata("design:paramtypes", [
                              void 0 === a.a ? Object : a.a,
                              void 0 === v ? Object : v,
                            ])(
                              (M = class {
                                constructor(e, t) {
                                  (this.regularBucket = e),
                                    (this.validator = t),
                                    (this._currentProcess = void 0),
                                    (this._currentProcess = Object(T.a)());
                                }
                                transport(e) {
                                  this.validator.validateLog(
                                    this._currentProcess,
                                    e.lineMeta.level,
                                    "toFile",
                                    e.extras,
                                  ) && this.regularBucket.add(e);
                                }
                              }),
                            ) || M),
                        ) || M),
                    ) || M),
                ) || M),
            ) || M,
          D =
            Object(n.injectable)()(
              (S =
                (function (e, t) {
                  return Object(n.inject)(v)(e, void 0, 0);
                })(
                  (S =
                    (function (e, t) {
                      return Object(n.inject)(w.a)(e, void 0, 1);
                    })(
                      (S =
                        Reflect.metadata(
                          "design:type",
                          Function,
                        )(
                          (S =
                            Reflect.metadata("design:paramtypes", [
                              void 0 === v ? Object : v,
                              void 0 === w.a ? Object : w.a,
                            ])(
                              (S = class {
                                constructor(e, t) {
                                  (this.validator = e),
                                    (this.consoleWriter = t),
                                    (this._currentProcess = void 0),
                                    (this._currentProcess = Object(T.a)());
                                }
                                transport(e) {
                                  this.validator.validateLog(
                                    this._currentProcess,
                                    e.lineMeta.level,
                                    "toConsole",
                                    e.extras,
                                  ) && this.consoleWriter.write(e);
                                }
                              }),
                            ) || S),
                        ) || S),
                    ) || S),
                ) || S),
            ) || S;
        n.ModuleContainer.registerSingleton(O, L),
          n.ModuleContainer.registerSingleton(_, R),
          n.ModuleContainer.registerSingleton(C, D);
        var F = s("XB6V");
        const A = ["info", "warn", "debug", "error", "critical"],
          j = ["", "F", "C", "T", "FT", "CT"];
        function P() {
          let e = 0;
          const t = {},
            s = {};
          return (
            A.forEach((i) => {
              j.forEach((n) => {
                "" === n
                  ? ((t[e] = `z${i}A`), (s[`z${i}A`] = e), (e += 1))
                  : "T" === n
                    ? ((t[e] = `z${i}AT`), (s[`z${i}AT`] = e), (e += 1))
                    : ((t[e] = `z${i}${n}`), (s[`z${i}${n}`] = e), (e += 1));
              });
            }),
            { EnumeratedLevels: t, ReversedEnumeratedLevels: s }
          );
        }
        Object.freeze(j), Object.freeze(A);
        const N = P().EnumeratedLevels,
          U = P().ReversedEnumeratedLevels;
        Object.freeze(N), Object.freeze(U);
        var k,
          B = s("h0S/");
        let G =
          Object(n.injectable)()(
            (k =
              (function (e, t) {
                return Object(n.inject)(O)(e, void 0, 0);
              })(
                (k =
                  (function (e, t) {
                    return Object(n.inject)(_)(e, void 0, 1);
                  })(
                    (k =
                      (function (e, t) {
                        return Object(n.inject)(C)(e, void 0, 2);
                      })(
                        (k =
                          Reflect.metadata(
                            "design:type",
                            Function,
                          )(
                            (k =
                              Reflect.metadata("design:paramtypes", [
                                void 0 === O ? Object : O,
                                void 0 === _ ? Object : _,
                                void 0 === C ? Object : C,
                              ])(
                                (k = class extends class {} {
                                  constructor(e, t, s) {
                                    super(),
                                      (this.fileTransporter = e),
                                      (this.sentryTransporter = t),
                                      (this.consoleTransporter = s),
                                      (this._instanceMap = new Map());
                                  }
                                  createZLogger(e, t, s) {
                                    void 0 === t && (t = []);
                                    const i = `${e}:${t.join(":")}`,
                                      a = this._instanceMap.get(i);
                                    var r, o, d, l, g, m, p, f, v, b, I;
                                    if (
                                      a &&
                                      (null == s ? void 0 : s.trans) ===
                                        (null === (r = a.config) || void 0 === r
                                          ? void 0
                                          : r.trans) &&
                                      (null == s ||
                                      null === (o = s.trans) ||
                                      void 0 === o
                                        ? void 0
                                        : o.file) ===
                                        (null === (d = a.config) ||
                                        void 0 === d ||
                                        null === (l = d.trans) ||
                                        void 0 === l
                                          ? void 0
                                          : l.file) &&
                                      (null == s ||
                                      null === (g = s.trans) ||
                                      void 0 === g
                                        ? void 0
                                        : g.console) ===
                                        (null === (m = a.config) ||
                                        void 0 === m ||
                                        null === (p = m.trans) ||
                                        void 0 === p
                                          ? void 0
                                          : p.console) &&
                                      (null == s ||
                                      null === (f = s.trans) ||
                                      void 0 === f
                                        ? void 0
                                        : f.sentry) ===
                                        (null === (v = a.config) ||
                                        void 0 === v ||
                                        null === (b = v.trans) ||
                                        void 0 === b
                                          ? void 0
                                          : b.sentry) &&
                                      (null == s ? void 0 : s.stagingOnly) ===
                                        (null === (I = a.config) || void 0 === I
                                          ? void 0
                                          : I.stagingOnly)
                                    )
                                      return a.logger;
                                    let y, _, O;
                                    (void 0 ===
                                      (null == s ? void 0 : s.trans) ||
                                      (null != s && s.trans.file)) &&
                                      (y = this.fileTransporter),
                                      (void 0 ===
                                        (null == s ? void 0 : s.trans) ||
                                        (null != s && s.trans.console)) &&
                                        (_ = this.consoleTransporter),
                                      (void 0 ===
                                        (null == s ? void 0 : s.trans) ||
                                        (null != s && s.trans.sentry)) &&
                                        (O = this.sentryTransporter);
                                    const C = class {
                                      constructor(e, t, s) {
                                        var i = this;
                                        (this.module = e),
                                          (this.features = t),
                                          (this.config = s),
                                          (this.enabled = !0),
                                          (this.Sentry = null),
                                          (this.tempOffConfig = {
                                            toConsole: !1,
                                            toFile: !1,
                                            toSentry: !1,
                                          }),
                                          (this.zsentry = function () {
                                            if (i.Sentry) {
                                              for (
                                                var e = arguments.length,
                                                  t = new Array(e),
                                                  s = 0;
                                                s < e;
                                                s++
                                              )
                                                t[s] = arguments[s];
                                              i.Sentry.captureException(
                                                new Error(t.join(" ")),
                                              );
                                            }
                                          }),
                                          (this.zfatal = function () {}),
                                          (this.zsymb = function (e, t, s) {
                                            if (!1 === i.enabled) return;
                                            const n = N[e];
                                            for (
                                              var a = arguments.length,
                                                r = new Array(
                                                  a > 3 ? a - 3 : 0,
                                                ),
                                                o = 3;
                                              o < a;
                                              o++
                                            )
                                              r[o - 3] = arguments[o];
                                            if (n.includes("zcritical"))
                                              return void (
                                                i.Sentry &&
                                                i.Sentry.captureException(
                                                  new Error(r.join(" ")),
                                                )
                                              );
                                            const d = i._getLevel(n);
                                            if (n.endsWith("A"))
                                              i._transport({
                                                tick: Date.now(),
                                                level: d,
                                                id1: t,
                                                id2: s,
                                                templ: null,
                                                args: r,
                                                target: "ConsoleFile",
                                              });
                                            else if (n.endsWith("AT")) {
                                              const [e, ...n] = r;
                                              i._transport({
                                                tick: Date.now(),
                                                level: d,
                                                id1: t,
                                                id2: s,
                                                templ: e,
                                                args: n,
                                                target: "ConsoleFile",
                                              });
                                            } else if (
                                              n.endsWith("C") ||
                                              n.endsWith("F")
                                            )
                                              i._transport({
                                                tick: Date.now(),
                                                level: d,
                                                id1: t,
                                                id2: s,
                                                templ: null,
                                                args: r,
                                                target: n.endsWith("C")
                                                  ? "toConsole"
                                                  : "toFile",
                                              });
                                            else if (
                                              n.endsWith("CT") ||
                                              n.endsWith("FT")
                                            ) {
                                              const [e, ...a] = r;
                                              i._transport({
                                                tick: Date.now(),
                                                level: d,
                                                id1: t,
                                                id2: s,
                                                templ: e,
                                                args: a,
                                                target: n.endsWith("CT")
                                                  ? "toConsole"
                                                  : "toFile",
                                              });
                                            }
                                          }),
                                          (this._transport = (e) => {
                                            let {
                                              tick: t,
                                              level: s,
                                              id1: i,
                                              id2: a,
                                              templ: r,
                                              args: o,
                                              target: d,
                                            } = e;
                                            const l = () => ({
                                                lineMeta: {
                                                  type: "normal",
                                                  module: this.module,
                                                  features: this.features,
                                                  id1: i,
                                                  id2: a,
                                                  level: s,
                                                  tick: t,
                                                },
                                                template: r,
                                                args: o,
                                                extras: {
                                                  stagingOnly:
                                                    this.config.stagingOnly,
                                                },
                                              }),
                                              c = n.ModuleContainer.resolve(
                                                h.a,
                                              );
                                            var u, g;
                                            if ("ConsoleFile" === d)
                                              !1 ===
                                                this.tempOffConfig.toConsole &&
                                                c.isEnabledConsole() &&
                                                (null ===
                                                  (u = this.config.toConsole) ||
                                                  void 0 === u ||
                                                  u.transport(l())),
                                                !1 ===
                                                  this.tempOffConfig.toFile &&
                                                  (null ===
                                                    (g = this.config.toFile) ||
                                                    void 0 === g ||
                                                    g.transport(l()));
                                            else if (
                                              !1 === this.tempOffConfig[d]
                                            ) {
                                              var m;
                                              if (
                                                "toConsole" === d &&
                                                !c.isEnabledConsole()
                                              )
                                                return;
                                              null === (m = this.config[d]) ||
                                                void 0 === m ||
                                                m.transport(l());
                                            }
                                          }),
                                          (this._getLevel = (e) => {
                                            let t = e;
                                            e.endsWith("A")
                                              ? (t = e.replace("A", ""))
                                              : e.endsWith("AT")
                                                ? (t = e.replace("AT", ""))
                                                : e.endsWith("C")
                                                  ? (t = e.replace("C", ""))
                                                  : e.endsWith("CT")
                                                    ? (t = e.replace("CT", ""))
                                                    : e.endsWith("F")
                                                      ? (t = e.replace("F", ""))
                                                      : e.endsWith("FT") &&
                                                        (t = e.replace(
                                                          "FT",
                                                          "",
                                                        ));
                                            let s = c.b.info;
                                            switch (t) {
                                              case "zinfo":
                                                s = c.b.info;
                                                break;
                                              case "zwarn":
                                                s = c.b.warn;
                                                break;
                                              case "zerror":
                                                s = c.b.error;
                                                break;
                                              case "zdebug":
                                                s = c.b.debug;
                                            }
                                            return s;
                                          }),
                                          (this.zinfo = function () {
                                            throw new Error(
                                              "babel-plugin-transform-zlog failed: zlog malfunction",
                                            );
                                          }),
                                          (this.zinfoC = function () {
                                            throw new Error(
                                              "babel-plugin-transform-zlog failed: zlog malfunction",
                                            );
                                          }),
                                          (this.zinfoF = function () {
                                            throw new Error(
                                              "babel-plugin-transform-zlog failed: zlog malfunction",
                                            );
                                          }),
                                          (this.zwarn = function () {
                                            throw new Error(
                                              "babel-plugin-transform-zlog failed: zlog malfunction",
                                            );
                                          }),
                                          (this.zwarnC = function () {
                                            throw new Error(
                                              "babel-plugin-transform-zlog failed: zlog malfunction",
                                            );
                                          }),
                                          (this.zwarnF = function () {
                                            throw new Error(
                                              "babel-plugin-transform-zlog failed: zlog malfunction",
                                            );
                                          }),
                                          (this.zerror = function () {
                                            throw new Error(
                                              "babel-plugin-transform-zlog failed: zlog malfunction",
                                            );
                                          }),
                                          (this.zerrorC = function () {
                                            throw new Error(
                                              "babel-plugin-transform-zlog failed: zlog malfunction",
                                            );
                                          }),
                                          (this.zerrorF = function () {
                                            throw new Error(
                                              "babel-plugin-transform-zlog failed: zlog malfunction",
                                            );
                                          }),
                                          (this.zdebug = function () {
                                            throw new Error(
                                              "babel-plugin-transform-zlog failed: zlog malfunction",
                                            );
                                          }),
                                          (this.zdebugC = function () {
                                            throw new Error(
                                              "babel-plugin-transform-zlog failed: zlog malfunction",
                                            );
                                          }),
                                          (this.zdebugF = function () {
                                            throw new Error(
                                              "babel-plugin-transform-zlog failed: zlog malfunction",
                                            );
                                          }),
                                          (this.enabled =
                                            !0 ===
                                            (function (e, t, s) {
                                              if (
                                                (void 0 === s && (s = !1),
                                                !B.ZLogNametagsWhitelist.includes(
                                                  e,
                                                ) &&
                                                  !1 ===
                                                    B.ZLoggerNametagsMap[e])
                                              )
                                                return (
                                                  u.a.error(
                                                    "LogModeController:",
                                                    [e, t],
                                                    `module ${e} is not whitelisted`,
                                                  ),
                                                  !1
                                                );
                                              let i = !1;
                                              for (const n of t) {
                                                const a =
                                                  B.ZLogNametagsWhitelist.includes(
                                                    n,
                                                  ) ||
                                                  !(
                                                    !1 ===
                                                    B.ZLoggerNametagsMap[e]
                                                  );
                                                if ((s && !a) || (!a && !i))
                                                  return !1;
                                                if (a) {
                                                  if (((i = !0), !s)) return !0;
                                                } else if (!i)
                                                  return (
                                                    u.a.error(
                                                      "LogModeController:",
                                                      [e, t],
                                                      `feat ${n} is not whitelisted and requireAllFeatOn:${s}`,
                                                    ),
                                                    !1
                                                  );
                                              }
                                              return !0;
                                            })(this.module, this.features));
                                      }
                                      disableFile() {
                                        this.tempOffConfig.toFile = !0;
                                      }
                                      enableFile() {
                                        this.tempOffConfig.toFile = !1;
                                      }
                                      disableConsole() {
                                        this.tempOffConfig.toConsole = !0;
                                      }
                                      enableConsole() {
                                        this.tempOffConfig.toConsole = !1;
                                      }
                                      static create(e, t, s) {
                                        return new this(e, t, s);
                                      }
                                      pause() {
                                        this.enabled = !0;
                                      }
                                      resume() {
                                        this.enabled = !1;
                                      }
                                      specialTransport(e) {
                                        this._transport(e);
                                      }
                                    }.create(e, t, {
                                      toFile: y,
                                      toConsole: _,
                                      toSentry: O,
                                      stagingOnly:
                                        null == s ? void 0 : s.stagingOnly,
                                    });
                                    return (
                                      this._instanceMap.set(i, {
                                        logger: C,
                                        config: s,
                                      }),
                                      C
                                    );
                                  }
                                  createZLoggerStaging(e, t, s) {
                                    return (
                                      t.push(B.ZLoggerNametags.staging),
                                      this.createZLogger(e, t, {
                                        trans: s,
                                        stagingOnly: !0,
                                      })
                                    );
                                  }
                                }),
                              ) || k),
                          ) || k),
                      ) || k),
                  ) || k),
              ) || k),
          ) || k;
        n.ModuleContainer.register(F.a, G);
        var x = s("yBqK"),
          z = s("ebA4");
        var V,
          H = s("CDcE");
        let $ =
          Object(n.injectable)()(
            (V =
              Reflect.metadata(
                "design:type",
                Function,
              )(
                (V =
                  Reflect.metadata(
                    "design:paramtypes",
                    [],
                  )(
                    (V = class extends (
                      class {
                        constructor() {
                          this._TextEncoder = new TextEncoder();
                        }
                        encodeUi8(e, t, s) {
                          return e.setUint8(t, s), t + d.b.ui8;
                        }
                        encodeUi16(e, t, s) {
                          return e.setUint16(t, s), t + d.b.ui16;
                        }
                        encodeUi32(e, t, s) {
                          return e.setUint32(t, s), t + d.b.ui32;
                        }
                        encodeFloat32(e, t, s) {
                          return e.setFloat32(t, s), t + d.b.float32;
                        }
                        encodeFloat64(e, t, s) {
                          return e.setFloat64(t, s), t + d.b.float64;
                        }
                        encodeBigInt64(e, t, s) {
                          const i = Object(z.a)(s),
                            n = new Uint8Array(i);
                          for (let a = 0; a < n.byteLength; a++)
                            t = this.encodeUi8(e, t, n[a]);
                          return t;
                        }
                        encodeTotalSize(e, t, s) {
                          return this.encodeUi16(e, t, s);
                        }
                        encodeTotalSizeEnd(e, t) {
                          return this.encodeUi16(e, t, t + d.b.ui16);
                        }
                        encodeTick(e, t, s) {
                          const i = Object(z.a)(s),
                            n = new Uint8Array(i);
                          return this.copyCache(e, t, n);
                        }
                        encodeVers(e, t, s) {
                          if (s > 32767)
                            throw new Error(
                              "[BinEncoder] error: encoding verion is TOO BIG!",
                            );
                          return this.encodeUi16(e, t, s);
                        }
                        encodeEncoderVers(e, t, s) {
                          if (s > 255)
                            throw new Error(
                              "[BinEncoder] error: encoding level is TOO BIG!",
                            );
                          return this.encodeUi8(e, t, s);
                        }
                        encodeLevel(e, t, s) {
                          if (s > 255)
                            throw new Error(
                              "[BinEncoder] error: encoding level is TOO BIG!",
                            );
                          return this.encodeUi8(e, t, s);
                        }
                        encodeHeaderNum(e, t, s) {
                          if (s > 255)
                            throw new Error(
                              "[BinEncoder] error: encoding numOfHeader is TOO BIG!",
                            );
                          return this.encodeUi8(e, t, s);
                        }
                        encodeStringOnly(e, t, s) {
                          const i = this._TextEncoder.encode(s),
                            n = i.byteLength;
                          return (
                            (t = this.encodeUi8(e, t, n)),
                            this.copyCache(e, t, i)
                          );
                        }
                        copyCache(e, t, s) {
                          for (let i = 0; i < s.byteLength; i++)
                            t = this.encodeUi8(e, t, s[i]);
                          return t;
                        }
                      }
                    ) {
                      constructor() {
                        super(),
                          (this.MemoryLogBatch = void 0),
                          (this.dv = void 0),
                          (this._lastOffset = 0),
                          (this._lastTs = 0),
                          (this.MemoryLogBatch = new ArrayBuffer(
                            d.d.mem_batch_lim,
                          )),
                          (this.dv = new DataView(this.MemoryLogBatch));
                      }
                      getLastBuffer() {
                        return this.MemoryLogBatch.slice(0, this._lastOffset);
                      }
                      encode(e, t, s) {
                        try {
                          const { lineMeta: i, args: n } = e;
                          let a = 0;
                          a += d.b.ui16;
                          let r = i.tick;
                          r <= this._lastTs && (r = this._lastTs + 1),
                            (this._lastTs = r),
                            (a = this.encodeTick(this.dv, a, r)),
                            (a = this.encodeEncoderVers(this.dv, a, d.o)),
                            (a = this.encodeLevel(this.dv, a, i.level)),
                            (a = this.encodeUi16(this.dv, a, s.ss)),
                            (a = this.encodeUi32(this.dv, a, s.ss_ln)),
                            (a = this.encodeStringOnly(this.dv, a, "HsN7f2nB")),
                            (a = this.encodeUi32(this.dv, a, t)),
                            (a = this.encodeUi16(this.dv, a, i.id1)),
                            (a = this.encodeUi16(this.dv, a, i.id2)),
                            (a = this._encodeArgs(a, this.dv, n));
                          const o = a + d.b.ui16;
                          return (
                            this.encodeTotalSize(this.dv, 0, o),
                            (a = this.encodeTotalSize(this.dv, a, o)),
                            (this._lastOffset = a),
                            this.MemoryLogBatch.slice(0, o)
                          );
                        } catch (i) {
                          throw (
                            (u.a.error("BinEncoderImpl.encode error:", i),
                            new Error("BinEncoderImpl.encode error"))
                          );
                        }
                      }
                      _allowTruncate() {
                        const e = n.ModuleContainer.resolve(r.a),
                          t = (null == e ? void 0 : e.get("adminMode")) || !1,
                          s = e.get("stagingAccount") || !1;
                        return !(t || s);
                      }
                      _encodeArgs(e, t, s) {
                        let i = !1;
                        const n = [];
                        if (s.length)
                          for (let r of s)
                            "object" == typeof r &&
                              (i = Object(H.b)(r) || Object(H.c)(r)),
                              n.push(Object(z.c)(r));
                        let a;
                        if (
                          ((a =
                            1 === n.length &&
                            1 === s.length &&
                            Array.isArray(n[0]) &&
                            "function" == typeof s[0]
                              ? x.encode([...n[0]])
                              : x.encode(n)),
                          a.byteLength > d.d.line_hard_lim)
                        ) {
                          const e = JSON.stringify(n, Object(H.a)()).slice(
                            0,
                            d.d.line_hard_lim,
                          );
                          a = x.encode(e);
                        } else if (
                          !i &&
                          a.byteLength > d.d.line_soft_lim &&
                          this._allowTruncate()
                        ) {
                          const e = JSON.stringify(n, Object(H.a)()).slice(
                            0,
                            d.d.line_soft_lim,
                          );
                          a = x.encode(e);
                        }
                        for (let r = 0; r < a.byteLength; r++)
                          e = this.encodeUi8(t, e, a[r]);
                        return e;
                      }
                    }),
                  ) || V),
              ) || V),
          ) || V;
        var W = s("ez9R");
        n.ModuleContainer.registerSingleton(W.a, $);
        var K = s("K8kB");
        var q,
          Z = class {
            constructor(e, t) {
              void 0 === e && (e = []),
                void 0 === t && (t = !0),
                (this.tasks = e),
                (this.alive = t);
            }
            do() {
              return this.add(...arguments);
            }
            add() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              return (this.tasks = this.tasks.concat(t)), this;
            }
            once(e) {
              return (
                void 0 === e && (e = !1),
                (this.alive = !1),
                (e && (async (e) => this.async())()) || this.sync(),
                this
              );
            }
            every(e) {
              return (
                this.add(() => new Promise((t) => setTimeout(t, e))),
                this.forever(!0)
              );
            }
            forever(e) {
              return (
                void 0 === e && (e = !1),
                (this.alive = !0),
                (e && (async (e) => this.async())()) || this.sync(),
                this
              );
            }
            cancel() {
              return (this.alive = !1), this;
            }
            async async() {
              for (let e of this.tasks) await e();
              this.alive && this.async();
            }
            sync() {
              for (let e of this.tasks) e();
              this.alive && this.sync();
            }
          };
        let J =
          Object(n.injectable)()(
            (q =
              (function (e, t) {
                return Object(n.inject)(a.a)(e, void 0, 0);
              })(
                (q =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (q =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === a.a ? Object : a.a,
                      ])(
                        (q = class extends o.b {
                          constructor(e) {
                            super(),
                              (this.bucket = e),
                              (this.task = void 0),
                              (this.start = () => {
                                var e;
                                if (
                                  null !== (e = this.task) &&
                                  void 0 !== e &&
                                  e.alive
                                )
                                  return;
                                this.task || (this.task = new Z());
                                const t = I.c[Object(T.a)()] || d.e;
                                this.task
                                  .add(() =>
                                    this._broadcastEvent(
                                      l.c.WriteSchedulerRequestFlush,
                                    ),
                                  )
                                  .every(t),
                                  this._listenEvents();
                              }),
                              (this.stop = () => {
                                this.task && this.task.cancel(),
                                  (this.task = void 0);
                              }),
                              (this._listenEvents = () => {
                                this.bucket.addEventListener(
                                  l.c.LogBucketRequestFlush,
                                  this._handleFlushRequestFromBucket,
                                );
                              }),
                              (this._handleFlushRequestFromBucket = () => {
                                var e;
                                (this.task && this.task.alive) ||
                                  (d.n &&
                                    u.a.log(
                                      "Oopsie! Scheduler is somehow not running. Restarting...",
                                    ),
                                  null === (e = this.task) ||
                                    void 0 === e ||
                                    e.cancel(),
                                  (this.task = void 0),
                                  this.start());
                              });
                          }
                          _broadcastEvent(e) {
                            if (e === l.c.WriteSchedulerRequestFlush)
                              this.dispatchEvent(new l.a(e));
                          }
                        }),
                      ) || q),
                  ) || q),
              ) || q),
          ) || q;
        n.ModuleContainer.registerSingleton(K.a, J);
      },
      gpNb: function (e, t, s) {
        "use strict";
        var i,
          n = s("jDHv"),
          a = s("UK4g"),
          r = s("YEoC"),
          o = s("PmZf"),
          d = s("rvru"),
          l = s("PhBv"),
          c = s("tHMN");
        let h =
          n.ModuleContainer.injectable()(
            (i =
              (function (e, t) {
                return n.ModuleContainer.inject(l.b)(e, void 0, 0);
              })(
                (i =
                  (function (e, t) {
                    return n.ModuleContainer.inject(d.a)(e, void 0, 1);
                  })(
                    (i =
                      Reflect.metadata(
                        "design:type",
                        Function,
                      )(
                        (i =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === l.a ? Object : l.a,
                            void 0 === d.a ? Object : d.a,
                          ])(
                            (i = class extends c.a {
                              constructor(e, t) {
                                super(),
                                  (this.queryPlanner = e),
                                  (this.dbQos = t),
                                  this.registerListeners();
                              }
                              registerListeners() {
                                const e = (e) => this.dispatchEvent(e);
                                this.queryPlanner.addEventListener(
                                  o.b.QueryError,
                                  (t) => {
                                    e(t), this.dbQos.sendDBErrorQos(t.error);
                                  },
                                ),
                                  this.queryPlanner.addEventListener(
                                    o.b.UnexpectedError,
                                    (t) => {
                                      e(t), this.dbQos.sendDBErrorQos(t.error);
                                    },
                                  ),
                                  this.queryPlanner.addEventListener(
                                    o.b.TimeConsumingQuery,
                                    (e) => {
                                      this.dbQos.sendTimeConsumingQueryQos(
                                        e.logInfo,
                                        e.totalTime,
                                      );
                                    },
                                  ),
                                  this.queryPlanner.addEventListener(
                                    o.b.SuccessOpenDB,
                                    e,
                                  ),
                                  this.queryPlanner.addEventListener(
                                    o.b.ConnectionClosedAbnormally,
                                    e,
                                  );
                              }
                              do(e) {
                                return this.queryPlanner.do(e);
                              }
                              doImmediately(e) {
                                return (
                                  "Qos" === e.database && e.trace(),
                                  this.queryPlanner.doImmediately(e)
                                );
                              }
                              deleteDatabase(e) {
                                return this.doImmediately({
                                  trace: function () {},
                                  type: r.d.DeleteDB,
                                  database: e,
                                  table: "",
                                  transaction: 0,
                                  priority: r.c.BLOCKING,
                                  retry: a.i,
                                  timing: {},
                                  meta: {
                                    error: new Error(),
                                    dead: !1,
                                    step: -1,
                                  },
                                });
                              }
                              deleteAllDatabases() {
                                return this.doImmediately({
                                  trace: function () {},
                                  type: r.d.DeleteAllDBs,
                                  database: "",
                                  table: "",
                                  transaction: 0,
                                  priority: r.c.BLOCKING,
                                  retry: a.i,
                                  timing: {},
                                  meta: {
                                    error: new Error(),
                                    dead: !1,
                                    step: -1,
                                  },
                                });
                              }
                              closeDatabase(e) {
                                return this.doImmediately({
                                  trace: function () {},
                                  type: r.d.CloseDB,
                                  database: e,
                                  table: "",
                                  transaction: 0,
                                  priority: r.c.BLOCKING,
                                  retry: a.i,
                                  timing: {},
                                  meta: {
                                    error: new Error(),
                                    dead: !1,
                                    step: -1,
                                  },
                                });
                              }
                              closeAllDatabases() {
                                return this.doImmediately({
                                  trace: function () {},
                                  type: r.d.CloseAllDBs,
                                  database: "",
                                  table: "",
                                  transaction: 0,
                                  priority: r.c.BLOCKING,
                                  retry: a.i,
                                  timing: {},
                                  meta: {
                                    error: new Error(),
                                    dead: !1,
                                    step: -1,
                                  },
                                });
                              }
                            }),
                          ) || i),
                      ) || i),
                  ) || i),
              ) || i),
          ) || i;
        n.ModuleContainer.registerSingleton(c.b, h);
      },
      hRcX: function (e, t, s) {
        "use strict";
        var i = s("VTBJ"),
          n = s("jDHv"),
          a = s("Uzj0");
        const r = () => {},
          o = (() => {
            let e = 0;
            return () => ++e;
          })(),
          d = { id: 0, retry: 0, success: r, error: r, execute: r };
        function l(e, t) {
          const s = e.length;
          e.push(t),
            (function (e, t, s) {
              let i = s;
              for (;;) {
                const s = (i - 1) >>> 1,
                  n = e[s];
                if (!(void 0 !== n && h(n, t) > 0)) return;
                (e[s] = t), (e[i] = n), (i = s);
              }
            })(e, t, s);
        }
        function c(e) {
          const t = e[0];
          if (void 0 !== t) {
            const s = e.pop();
            return (
              s !== t &&
                ((e[0] = s),
                (function (e, t, s) {
                  let i = s;
                  const n = e.length;
                  for (; i < n; ) {
                    const s = 2 * (i + 1) - 1,
                      n = e[s],
                      a = s + 1,
                      r = e[a];
                    if (void 0 !== n && h(n, t) < 0)
                      void 0 !== r && h(r, n) < 0
                        ? ((e[i] = r), (e[a] = t), (i = a))
                        : ((e[i] = n), (e[s] = t), (i = s));
                    else {
                      if (!(void 0 !== r && h(r, t) < 0)) return;
                      (e[i] = r), (e[a] = t), (i = a);
                    }
                  }
                })(e, s, 0)),
              t
            );
          }
          return null;
        }
        function h(e, t) {
          const s = e.sortIndex - t.sortIndex;
          return 0 !== s ? s : e.id - t.id;
        }
        let u;
        !(function (e) {
          (e[(e.BLOCKING = 50)] = "BLOCKING"),
            (e[(e.NON_BLOCKING = 250)] = "NON_BLOCKING"),
            (e[(e.IDLE = 500)] = "IDLE"),
            (e[(e.NEVER_TIMEOUT = 1e3)] = "NEVER_TIMEOUT");
        })(u || (u = {}));
        const g = new (class {
            push(e, t) {
              const s = Object(i.a)(
                Object(i.a)(Object(i.a)({}, d), t),
                {},
                { id: o() },
              );
              e.push(s);
            }
            getCandidate(e) {
              return e.shift();
            }
          })(),
          m = new (class {
            push(e, t) {
              l(
                e,
                Object(i.a)(
                  Object(i.a)(Object(i.a)({}, d), t),
                  {},
                  {
                    sortIndex: Date.now() + (t.deadline || u.NON_BLOCKING),
                    id: o(),
                  },
                ),
              );
            }
            getCandidate(e) {
              return c(e);
            }
          })();
        class p {
          constructor(e, t) {
            void 0 === e && (e = g),
              void 0 === t && (t = !0),
              (this._queue = void 0),
              (this._strategy = void 0),
              (this._stopped = void 0),
              (this._inactive = void 0),
              (this._queue = []),
              (this._strategy = e),
              (this._stopped = !t),
              (this._inactive = !0);
          }
          run(e) {
            this._strategy.push(this._queue, e), this._inactive && this._run();
          }
          start() {
            (this._stopped = !1),
              setTimeout(() => {
                this._run();
              });
          }
          stop() {
            (this._stopped = !0), (this._inactive = !0);
          }
          async _run() {
            if (this._stopped) return void (this._inactive = !0);
            const e = this._strategy.getCandidate(this._queue);
            if (e)
              try {
                const s = await e.execute();
                try {
                  null == e || e.success(s);
                } catch (t) {}
                setTimeout(() => {
                  this._run();
                });
              } catch (t) {
                e.retry > 0
                  ? (e.retry--, this.run(e))
                  : null == e || e.error(t),
                  setTimeout(() => {
                    this._run();
                  });
              }
            else this._inactive = !0;
          }
        }
        new p(m);
        var f = s("Mgpg"),
          v = s("YEoC"),
          b = s("DI/x"),
          I = s("PmZf"),
          y = s("YZti"),
          _ = s("1UUk"),
          O = s("MRjZ"),
          C = s("UJ0r"),
          E = s("teaq"),
          M = s("Abbu"),
          S = s("PhBv"),
          T = s("rkiK"),
          w = s("wH4e");
        const R = new Set(["Qos"]);
        var L;
        let D =
          n.ModuleContainer.injectable()(
            (L =
              (function (e, t) {
                return n.ModuleContainer.inject(C.b)(e, void 0, 0);
              })(
                (L =
                  (function (e, t) {
                    return n.ModuleContainer.inject(E.b)(e, void 0, 1);
                  })(
                    (L =
                      (function (e, t) {
                        return n.ModuleContainer.inject(f.ZLoggerFactory)(
                          e,
                          void 0,
                          2,
                        );
                      })(
                        (L =
                          Reflect.metadata(
                            "design:type",
                            Function,
                          )(
                            (L =
                              Reflect.metadata("design:paramtypes", [
                                void 0 === C.a ? Object : C.a,
                                void 0 === E.b ? Object : E.b,
                                void 0 === f.ZLoggerFactory
                                  ? Object
                                  : f.ZLoggerFactory,
                              ])(
                                (L = class extends S.a {
                                  constructor(e, t, s) {
                                    super(),
                                      (this.adapterManager = e),
                                      (this.configManager = t),
                                      (this.scheduler = void 0),
                                      (this.pendingQueries = []),
                                      (this.session = void 0),
                                      (this.logger = void 0),
                                      (this.adapterContainers = new Map()),
                                      (this.idCounter = 0),
                                      (this.dbSchema = void 0),
                                      (this.scheduler = new p(g, !1)),
                                      (this.logger = s.createZLogger("db", [
                                        "host",
                                        "planner",
                                      ])),
                                      this.registerListeners();
                                  }
                                  registerListeners() {
                                    const e = (e) => this.dispatchEvent(e);
                                    this.adapterManager.addEventListener(
                                      I.b.UnexpectedError,
                                      e,
                                    ),
                                      this.adapterManager.addEventListener(
                                        I.b.TimeConsumingQuery,
                                        e,
                                      ),
                                      this.adapterManager.addEventListener(
                                        I.b.SuccessOpenDB,
                                        e,
                                      ),
                                      this.adapterManager.addEventListener(
                                        I.b.ConnectionClosedAbnormally,
                                        e,
                                      );
                                  }
                                  install(e) {
                                    this.dbSchema = e;
                                  }
                                  start() {
                                    this.scheduler.start();
                                    const e = n.ModuleContainer.resolve(_.b),
                                      t = (e) => {
                                        this.session = e;
                                        const t = this.pendingQueries;
                                        (this.pendingQueries = []),
                                          t.forEach((e) => {
                                            this.enqueue(e, {
                                              immediately: !1,
                                            });
                                          });
                                      };
                                    e.session && t(e.session),
                                      e.addEventListener(
                                        I.b.SessionChange,
                                        (e) => {
                                          t(e.session),
                                            this.adapterContainers.clear();
                                        },
                                      );
                                  }
                                  stop() {
                                    this.scheduler.stop(),
                                      this.logger.zsymb(6, 14463, 3e4, "Stop!");
                                  }
                                  do(e) {
                                    const t = (function (e) {
                                      if (R.has(e.database)) return;
                                      const t = T.default.start(
                                          T.MetricName.query_resolution_time,
                                        ),
                                        s = {
                                          method: w.QueryUtils.getTypeName(
                                            e.type,
                                          ),
                                          database: e.database,
                                          table: e.table,
                                          transaction: e.transaction,
                                        };
                                      return t.pushInfo(s), t;
                                    })(e);
                                    return new Promise((t, s) => {
                                      this.enqueue(
                                        Object(i.a)(
                                          Object(i.a)({}, e),
                                          {},
                                          {
                                            deferrer: { resolve: t, reject: s },
                                          },
                                        ),
                                        { immediately: M.a.isInTransaction(e) },
                                      );
                                    }).finally(() => {
                                      null == t || t.end();
                                    });
                                  }
                                  doImmediately(e) {
                                    return new Promise((t, s) => {
                                      this.enqueue(
                                        Object(i.a)(
                                          Object(i.a)({}, e),
                                          {},
                                          {
                                            deferrer: { resolve: t, reject: s },
                                          },
                                        ),
                                        { immediately: !0 },
                                      );
                                    });
                                  }
                                  enqueue(e, t) {
                                    (e.meta.step = 0),
                                      (e.meta.id = this.idCounter++),
                                      this.scheduler.run({
                                        immediately: t.immediately,
                                        execute: () => {
                                          try {
                                            return this.execute(e);
                                          } catch (t) {
                                            if (0 !== e.retry)
                                              throw ((e.retry -= 1), t);
                                            {
                                              const s =
                                                this.createErrorForQuery(e, t);
                                              this.logger.zsymb(
                                                18,
                                                14463,
                                                30001,
                                                () => [s],
                                              ),
                                                this.dispatchEvent(
                                                  new I.g(new b.i(s.message)),
                                                );
                                            }
                                          }
                                        },
                                        retry: e.retry,
                                      });
                                  }
                                  trapQueryError(e) {
                                    let t = null,
                                      s = () => {};
                                    this.shouldTrapTimeoutQuery(e) &&
                                      ((t = setTimeout(() => {
                                        var t, s;
                                        const i =
                                            (null === (t = e.params) ||
                                            void 0 === t ||
                                            null === (s = t.values) ||
                                            void 0 === s
                                              ? void 0
                                              : s.length) || void 0,
                                          n = void 0 !== i ? [i] : [];
                                        e.deferrer.reject(new b.y(n));
                                      }, e.meta.timeout)),
                                      (e.meta.timer = t),
                                      (s = () => {
                                        clearTimeout(t);
                                      }));
                                    const i = e.deferrer;
                                    e.deferrer = {
                                      resolve: (e) => {
                                        s(), i.resolve(e);
                                      },
                                      reject: (t) => {
                                        s();
                                        const n = this.createErrorForQuery(
                                          e,
                                          t,
                                        );
                                        this.dispatchEvent(new I.c(n)),
                                          i.reject(n);
                                      },
                                    };
                                  }
                                  createErrorForQuery(e, t) {
                                    const s = {
                                        method: y.c.getTypeName(e.type),
                                        database: e.database,
                                        table: e.table,
                                        step: e.meta.step,
                                        partition: e.meta.partitionKey,
                                        trans: e.transaction,
                                        deadline: e.meta.timeout,
                                      },
                                      i = Object(O.a)(s);
                                    let n = null;
                                    const a = ((e) => {
                                      const t = e.stack;
                                      if (!t) return "";
                                      const s =
                                        `${e.name}` +
                                        (e.message ? `: ${e.message}` : "") +
                                        "\n";
                                      return t.startsWith(s)
                                        ? t.slice(s.length)
                                        : t;
                                    })(e.meta.error);
                                    if (t)
                                      if (t instanceof Error) {
                                        const s = t.message + ` (${i})`;
                                        t instanceof DOMException
                                          ? ((n = new b.c(s, t.name, t.code)),
                                            n.setStack(a))
                                          : t instanceof b.e
                                            ? ((n = t),
                                              (n.message = s),
                                              n.setStack(a))
                                            : ((n = e.meta.error),
                                              (n.message = s),
                                              (n.name = t.name),
                                              (n.stack = `${n.name}: ${n.message} ${a}`));
                                      } else {
                                        let e = t ? `${t}` : "Unknown reason";
                                        (e += ` (${i})`),
                                          (n = new b.i(e)),
                                          n.setStack(a);
                                      }
                                    else {
                                      let e = `Unknown reason (${i})`;
                                      (n = new b.i(e)), n.setStack(a);
                                    }
                                    return n;
                                  }
                                  shouldTrapTimeoutQuery(e) {
                                    return !1;
                                  }
                                  execute(e) {
                                    (e.meta.step = 1),
                                      (e.meta.dead = !1),
                                      (e.meta.step = 2),
                                      (!e.meta.databaseConfig &&
                                        (this.computeDatabaseConfig(e),
                                        e.meta.dead)) ||
                                        ((e.meta.step = 3),
                                        this.isReadyForExecute(e) &&
                                          (e.meta.shouldNotTrapQuery ||
                                            this.trapQueryError(e),
                                          (e.meta.step = 4),
                                          (!e.meta.databaseName &&
                                            (this.computeDatabaseName(e),
                                            e.meta.dead)) ||
                                            ((e.meta.step = 5),
                                            (e.meta.step = 6),
                                            (!e.meta.partitionConfig &&
                                              (this.computePartitionConfig(e),
                                              e.meta.dead)) ||
                                              ((e.meta.step = 7),
                                              (!e.meta.tableConfig &&
                                                (this.computeTableConfig(e),
                                                e.meta.dead)) ||
                                                ((e.meta.step = 8),
                                                ("string" !=
                                                  typeof e.meta.partitionKey &&
                                                  (this.computePartitionKey(e),
                                                  e.meta.dead)) ||
                                                  ((e.meta.step = 9),
                                                  (!e.meta.executor &&
                                                    (this.computeDatabaseAdapter(
                                                      e,
                                                    ),
                                                    e.meta.dead)) ||
                                                    ((e.meta.step = 10),
                                                    e.meta.executor())))))));
                                  }
                                  computeDatabaseAdapter(e) {
                                    const {
                                      databaseName: t,
                                      partitionConfig: s,
                                      partitionKey: i,
                                      databaseConfig: n,
                                      tableConfig: r,
                                    } = e.meta;
                                    let o = t;
                                    if (
                                      !M.a.isPartitionlessQuery(e) &&
                                      n.supportPartitionByField &&
                                      r.doesHavePartitionByField(s.type)
                                    ) {
                                      if ("" === i)
                                        return void this.rejectQuery(
                                          e,
                                          new b.u(),
                                        );
                                      o = `${t}/${i}`;
                                    }
                                    const d = `${o}_${s.type}`;
                                    let l = this.adapterContainers.get(d);
                                    l ||
                                      ((l = new a.b.Container()),
                                      this.adapterContainers.set(d, l),
                                      this.adapterManager
                                        .getDatabaseAdapter(o, s)
                                        .then(l.resolve)
                                        .catch(l.reject)),
                                      l.value ||
                                        l.promise
                                          .then(
                                            () => (
                                              (e.meta.shouldNotTrapQuery = !0),
                                              this.execute(e)
                                            ),
                                          )
                                          .catch((e) => {
                                            const t = new b.b(d, e.message);
                                            this.logger.zsymb(
                                              18,
                                              14463,
                                              30003,
                                              () => [t],
                                            ),
                                              this.dispatchEvent(new I.g(t));
                                          });
                                    const c = l.value;
                                    c
                                      ? ((e.meta.adapterName =
                                          c.type === v.a.IDB
                                            ? "idb"
                                            : "sqlite"),
                                        (e.meta.executor = () => {
                                          (e.meta.databaseName = o),
                                            c.execute(e);
                                        }))
                                      : (e.meta.dead = !0);
                                  }
                                  replicate(e, t) {
                                    this.do(
                                      Object(i.a)(
                                        Object(i.a)({}, e),
                                        {},
                                        {
                                          transaction: 0,
                                          meta: Object(i.a)(
                                            Object(i.a)({}, e.meta),
                                            {},
                                            {
                                              databaseConfig: t,
                                              error: new Error(),
                                            },
                                          ),
                                          deferrer: void 0,
                                        },
                                      ),
                                    );
                                  }
                                  isReadyForExecute(e) {
                                    return (
                                      !(
                                        e.meta.databaseConfig.session &&
                                        !this.session
                                      ) || (this.pendingQueries.push(e), !1)
                                    );
                                  }
                                  computeDatabaseConfig(e) {
                                    if (
                                      "" === e.database &&
                                      (M.a.isCloseAllDBsQuery(e) ||
                                        M.a.isDeleteAllDBsQuery(e))
                                    ) {
                                      e.meta.dead = !0;
                                      const t = this.getAllDBNames().map((t) =>
                                        this.doImmediately(
                                          Object(i.a)(
                                            Object(i.a)({}, e),
                                            {},
                                            {
                                              type: M.a.isCloseAllDBsQuery(e)
                                                ? v.d.CloseDB
                                                : v.d.DeleteDB,
                                              database: t,
                                              meta: Object(i.a)(
                                                Object(i.a)({}, e.meta),
                                                {},
                                                { error: new Error() },
                                              ),
                                              deferrer: void 0,
                                            },
                                          ),
                                        ),
                                      );
                                      return void Promise.all(t)
                                        .then(() => e.deferrer.resolve())
                                        .catch(e.deferrer.reject);
                                    }
                                    const t =
                                      this.configManager.getDatabaseConfigs(
                                        e.database,
                                      );
                                    if (0 !== t.length) {
                                      if (
                                        t.length > 1 &&
                                        this.shouldReplicate(e)
                                      )
                                        for (let s = 1; s < t.length; s++)
                                          this.replicate(e, t[s]);
                                      e.meta.databaseConfig = t[0];
                                    } else
                                      this.rejectQuery(e, new b.q(e.database));
                                  }
                                  getAllDBNames() {
                                    return Object.keys(this.dbSchema);
                                  }
                                  getTablesNameOfDB(e) {
                                    const t = this.dbSchema[e];
                                    if (!t) throw new b.r(e);
                                    return Object.values(t).map((e) => e.name);
                                  }
                                  computeDatabaseName(e) {
                                    var t, s;
                                    const {
                                      meta: n,
                                      table: a,
                                      database: r,
                                    } = e;
                                    if (
                                      "" === a &&
                                      (M.a.isCloseDBQuery(e) ||
                                        M.a.isCloseAllDBsQuery(e) ||
                                        M.a.isDeleteDBQuery(e) ||
                                        M.a.isDeleteAllDBsQuery(e))
                                    ) {
                                      e.meta.dead = !0;
                                      const t = this.getTablesNameOfDB(r).map(
                                        (t) =>
                                          this.doImmediately(
                                            Object(i.a)(
                                              Object(i.a)({}, e),
                                              {},
                                              {
                                                table: t,
                                                meta: Object(i.a)(
                                                  Object(i.a)({}, e.meta),
                                                  {},
                                                  { error: new Error() },
                                                ),
                                                deferrer: void 0,
                                              },
                                            ),
                                          ),
                                      );
                                      return void Promise.all(t)
                                        .then(() => e.deferrer.resolve())
                                        .catch(e.deferrer.reject);
                                    }
                                    const o =
                                        null !==
                                          (t =
                                            null === (s = this.session) ||
                                            void 0 === s
                                              ? void 0
                                              : s.userId) && void 0 !== t
                                          ? t
                                          : "",
                                      d = n.databaseConfig.computeDatabaseName(
                                        o,
                                        a,
                                      );
                                    n.databaseName = d;
                                  }
                                  computePartitionConfig(e) {
                                    const t =
                                      e.meta.databaseConfig.getPartition(
                                        e.table,
                                        this.session,
                                      );
                                    t
                                      ? (e.meta.partitionConfig = t)
                                      : this.rejectQuery(
                                          e,
                                          new b.t(e.table, this.session),
                                        );
                                  }
                                  computeTableConfig(e) {
                                    const t =
                                      e.meta.partitionConfig.getTableConfig(
                                        e.table,
                                      );
                                    t
                                      ? ((t.dbName = e.database),
                                        (e.meta.tableConfig = t))
                                      : this.rejectQuery(e, new b.v(e.table));
                                  }
                                  computePartitionKey(e) {
                                    const {
                                      databaseConfig: t,
                                      tableConfig: s,
                                      partitionConfig: i,
                                    } = e.meta;
                                    if (
                                      t.supportPartitionByField &&
                                      s.doesHavePartitionByField(i.type)
                                    )
                                      switch (e.type) {
                                        case v.d.BeginTransaction:
                                          return void (e.meta.partitionKey =
                                            "");
                                        case v.d.Clear:
                                          return;
                                        case v.d.Insert:
                                          return void this.computePartitionForInsertQuery(
                                            e,
                                          );
                                        case v.d.InsertMulti:
                                          return void this.computePartitionForInsertMultiQuery(
                                            e,
                                          );
                                        case v.d.Get:
                                        case v.d.GetAndUpdate:
                                        case v.d.Update:
                                        case v.d.Delete:
                                          return void this.computePartitionForIndexedQuery(
                                            e,
                                          );
                                        case v.d.FindAndDelete:
                                        case v.d.GetAllKey:
                                        case v.d.GetAll:
                                        case v.d.Count:
                                          return void this.computePartitionForRangedQuery(
                                            e,
                                          );
                                        case v.d.DeleteMulti:
                                        case v.d.GetMulti:
                                          return void this.computePartitionForGetMultiAndDeleteMultiQuery(
                                            e,
                                          );
                                        case v.d.UpdateMulti:
                                          return void this.computePartitionForUpdateMultiQuery(
                                            e,
                                          );
                                        case v.d.CloseDB:
                                        case v.d.DeleteDB:
                                          return void this.computePartitionForCloseDBAndDeleteDBQuery(
                                            e,
                                          );
                                      }
                                    else e.meta.partitionKey = "";
                                  }
                                  computePartitionForInsertQuery(e) {
                                    const t =
                                      this.computePartitionKeyFromEntityValue(
                                        e.meta.tableConfig,
                                        e.params.value,
                                      );
                                    void 0 !== t
                                      ? (e.meta.partitionKey = `${t}`)
                                      : this.rejectQuery(e, new b.u());
                                  }
                                  computePartitionForInsertMultiQuery(e) {
                                    const t = { groupByPartitions: {} };
                                    for (const i of e.params.values) {
                                      const s =
                                        this.computePartitionKeyFromEntityValue(
                                          e.meta.tableConfig,
                                          i,
                                        );
                                      if (void 0 === s)
                                        return void this.rejectQuery(
                                          e,
                                          new b.u(),
                                        );
                                      t.groupByPartitions[s] ||
                                        (t.groupByPartitions[s] = []),
                                        t.groupByPartitions[s].push(i);
                                    }
                                    let s;
                                    const n = Object.entries(
                                      t.groupByPartitions,
                                    );
                                    if (1 === n.length)
                                      (s = n[0][0]),
                                        void 0 !== s
                                          ? (e.meta.partitionKey = s)
                                          : this.rejectQuery(e, new b.u());
                                    else {
                                      e.meta.dead = !0;
                                      const t = n.map((t) => {
                                        let [s, n] = t;
                                        const a = s;
                                        return this.doImmediately(
                                          Object(i.a)(
                                            Object(i.a)({}, e),
                                            {},
                                            {
                                              meta: Object(i.a)(
                                                Object(i.a)({}, e.meta),
                                                {},
                                                {
                                                  partitionKey: a,
                                                  error: new Error(),
                                                },
                                              ),
                                              params: Object(i.a)(
                                                Object(i.a)({}, e.params),
                                                {},
                                                { values: n },
                                              ),
                                              deferrer: void 0,
                                            },
                                          ),
                                        );
                                      });
                                      Promise.all(t)
                                        .then((t) =>
                                          e.deferrer.resolve(t.flat()),
                                        )
                                        .catch(e.deferrer.reject);
                                    }
                                  }
                                  computePartitionForIndexedQuery(e) {
                                    const t =
                                      this.computePartitionKeyFromEntityKey(
                                        e.meta.tableConfig,
                                        e.params.key,
                                        e.params.index,
                                      );
                                    void 0 !== t
                                      ? (e.meta.partitionKey = `${t}`)
                                      : this.rejectQuery(e, new b.u());
                                  }
                                  computePartitionForRangedQuery(e) {
                                    var t, s;
                                    if (!e.params.range) {
                                      const t = new b.x(
                                        "Get all data in partitioned table",
                                      );
                                      return void this.rejectQuery(e, t);
                                    }
                                    let i = "";
                                    i =
                                      e.type === v.d.FindAndDelete ||
                                      e.type === v.d.Count
                                        ? "primary"
                                        : e.params.index;
                                    const {
                                      partitionConfig: n,
                                      tableConfig: a,
                                    } = e.meta;
                                    if (
                                      -1 === a.getIndexPartitionField(n.type, i)
                                    ) {
                                      if (a.usePartitionTable) {
                                        const t = new b.x(
                                          "Lookup partition from query range",
                                        );
                                        this.rejectQuery(e, t);
                                      } else {
                                        const t = new b.x(
                                          "Get all data by index in partitioned table",
                                        );
                                        this.rejectQuery(e, t);
                                      }
                                      return;
                                    }
                                    if (
                                      null === (t = e.params.range) ||
                                      void 0 === t ||
                                      !t.from ||
                                      null === (s = e.params.range) ||
                                      void 0 === s ||
                                      !s.to
                                    ) {
                                      const t = new b.x(
                                        "Get data with open boundary in partition table",
                                      );
                                      return void this.rejectQuery(e, t);
                                    }
                                    const r = e.params.range.from,
                                      o = e.params.range.to,
                                      d = this.computePartitionKeyFromEntityKey(
                                        e.meta.tableConfig,
                                        r,
                                        i,
                                      );
                                    if (
                                      d !==
                                      this.computePartitionKeyFromEntityKey(
                                        e.meta.tableConfig,
                                        o,
                                        i,
                                      )
                                    ) {
                                      const t = new b.x(
                                        "Get data from multiple partition",
                                      );
                                      return void this.rejectQuery(e, t);
                                    }
                                    let l = d;
                                    void 0 !== l
                                      ? (e.meta.partitionKey = `${l}`)
                                      : this.rejectQuery(e, new b.u());
                                  }
                                  computePartitionForGetMultiAndDeleteMultiQuery(
                                    e,
                                  ) {
                                    let t = "";
                                    t =
                                      e.type === v.d.DeleteMulti
                                        ? "primary"
                                        : e.params.index;
                                    const s = {};
                                    for (const i of e.params.keys) {
                                      const n =
                                        this.computePartitionKeyFromEntityKey(
                                          e.meta.tableConfig,
                                          i,
                                          t,
                                        );
                                      if (void 0 === n)
                                        return void this.rejectQuery(
                                          e,
                                          new b.u(),
                                        );
                                      s[n] || (s[n] = []), s[n].push(i);
                                    }
                                    const n = Object.entries(s);
                                    let a;
                                    if (1 === n.length)
                                      (a = n[0][0]),
                                        void 0 !== a
                                          ? (e.meta.partitionKey = `${a}`)
                                          : this.rejectQuery(e, new b.u());
                                    else {
                                      e.meta.dead = !0;
                                      const t = n.map((t) => {
                                        let [s, n] = t;
                                        const a = s;
                                        return this.doImmediately(
                                          Object(i.a)(
                                            Object(i.a)({}, e),
                                            {},
                                            {
                                              meta: Object(i.a)(
                                                Object(i.a)({}, e.meta),
                                                {},
                                                {
                                                  partitionKey: a,
                                                  error: new Error(),
                                                },
                                              ),
                                              params: Object(i.a)(
                                                Object(i.a)({}, e.params),
                                                {},
                                                { keys: n },
                                              ),
                                              deferrer: void 0,
                                            },
                                          ),
                                        );
                                      });
                                      Promise.all(t)
                                        .then((t) =>
                                          e.deferrer.resolve(t.flat()),
                                        )
                                        .catch(e.deferrer.reject);
                                    }
                                  }
                                  computePartitionForUpdateMultiQuery(e) {
                                    const { patches: t } = e.params,
                                      s = {};
                                    for (const i of t) {
                                      const { key: t } = i,
                                        n =
                                          this.computePartitionKeyFromEntityKey(
                                            e.meta.tableConfig,
                                            t,
                                          );
                                      if (void 0 === n)
                                        return void this.rejectQuery(
                                          e,
                                          new b.u(),
                                        );
                                      s[n] || (s[n] = []), s[n].push(i);
                                    }
                                    let n;
                                    const a = Object.entries(s);
                                    if (1 === a.length)
                                      (n = a[0][0]),
                                        void 0 !== n
                                          ? (e.meta.partitionKey = n)
                                          : this.rejectQuery(e, new b.u());
                                    else {
                                      const t = a.map((t) => {
                                        let [s, n] = t;
                                        const a = s;
                                        return this.doImmediately(
                                          Object(i.a)(
                                            Object(i.a)({}, e),
                                            {},
                                            {
                                              meta: Object(i.a)(
                                                Object(i.a)({}, e.meta),
                                                {},
                                                {
                                                  partitionKey: a,
                                                  error: new Error(),
                                                },
                                              ),
                                              params: Object(i.a)(
                                                Object(i.a)({}, e.params),
                                                {},
                                                { patches: n },
                                              ),
                                              deferrer: void 0,
                                            },
                                          ),
                                        );
                                      });
                                      Promise.all(t)
                                        .then((t) =>
                                          e.deferrer.resolve(t.flat()),
                                        )
                                        .catch(e.deferrer.reject);
                                    }
                                  }
                                  async computePartitionForCloseDBAndDeleteDBQuery(
                                    e,
                                  ) {
                                    e.meta.dead = !0;
                                    const { meta: t } = e,
                                      s = (
                                        await this.adapterManager.getExistedPartitionKeys(
                                          t.databaseName,
                                          t.databaseConfig.type,
                                        )
                                      ).map((t) =>
                                        this.doImmediately(
                                          Object(i.a)(
                                            Object(i.a)({}, e),
                                            {},
                                            {
                                              meta: Object(i.a)(
                                                Object(i.a)({}, e.meta),
                                                {},
                                                {
                                                  partitionKey: t,
                                                  error: new Error(),
                                                },
                                              ),
                                              deferrer: void 0,
                                            },
                                          ),
                                        ),
                                      );
                                    Promise.all(s)
                                      .then(() => e.deferrer.resolve())
                                      .catch(e.deferrer.reject);
                                  }
                                  computePartitionKeyFromEntityValue(e, t) {
                                    const s = e.partitionField;
                                    if (void 0 !== s) return t[s];
                                  }
                                  computePartitionKeyFromEntityKey(e, t, s) {
                                    void 0 === s && (s = "primary");
                                    const i = e.partitionField;
                                    if (void 0 !== i)
                                      return e.getIndex(s).getValue(t, i);
                                  }
                                  shouldReplicate(e) {
                                    switch (e.type) {
                                      case v.d.Clear:
                                      case v.d.Delete:
                                      case v.d.DeleteMulti:
                                      case v.d.FindAndDelete:
                                      case v.d.Insert:
                                      case v.d.InsertMulti:
                                      case v.d.Update:
                                      case v.d.UpdateMulti:
                                      case v.d.GetAndUpdate:
                                      case v.d.CloseDB:
                                      case v.d.CloseAllDBs:
                                      case v.d.DeleteDB:
                                      case v.d.DeleteAllDBs:
                                        return !0;
                                      default:
                                        return !1;
                                    }
                                  }
                                  logQueryInfo(e) {
                                    M.a.isBeginTransaction(e)
                                      ? this.logger.zsymb(
                                          12,
                                          14463,
                                          30004,
                                          () => [
                                            y.c.getTypeName(e.type),
                                            {
                                              database: e.meta.databaseName,
                                              table: e.params.tables.join(","),
                                              transaction: e.transaction,
                                              adapter:
                                                e.meta.databaseConfig.typeName,
                                            },
                                          ],
                                        )
                                      : this.logger.zsymb(
                                          12,
                                          14463,
                                          30005,
                                          () => [
                                            y.c.getTypeName(e.type),
                                            {
                                              database: e.meta.databaseName,
                                              table: e.table,
                                              transaction: e.transaction,
                                              adapter:
                                                e.meta.databaseConfig.typeName,
                                            },
                                          ],
                                        );
                                  }
                                  rejectQuery(e, t) {
                                    (e.meta.dead = !0), e.deferrer.reject(t);
                                  }
                                }),
                              ) || L),
                          ) || L),
                      ) || L),
                  ) || L),
              ) || L),
          ) || L;
        n.ModuleContainer.registerSingleton(S.b, D);
      },
      i15Q: function (e, t, s) {
        "use strict";
        s.d(t, "a", function () {
          return n;
        });
        var i = s("KRcn");
        class n {
          constructor() {
            (this._session = null),
              (this._processStart = void 0),
              (this._enableConsole = void 0),
              (this.isReady = () => !!this._session),
              (this.getSession = () => {
                if (!this._session) throw new Error("session is not ready");
                return this._session;
              }),
              (this.getProcessStartTime = () => this._processStart),
              (this.setSession = (e) => {
                this._session = e;
              }),
              (this._processStart = Date.now()),
              (this._session = {
                build: "aa8694a28bb82018c06e553ffd0e62e62e0a99fe",
                zlgv: "HsN7f2nB",
                env: "prod",
                buildType: "release",
                pversion: s("kiQV").version,
                process: Object(i.a)(),
              }),
              (this._enableConsole = !1);
          }
          enableConsole() {}
          disableConsole() {}
          isEnabledConsole() {
            return this._enableConsole;
          }
        }
      },
      j6JD: function (e, t, s) {
        "use strict";
        function i(e, t) {
          "string" == typeof e && (e = parseInt(e));
          const s = new Date(e),
            i = s.getDate(),
            a = s.getMonth() + 1,
            r = (s.getFullYear(), s.getHours()),
            o = s.getMinutes(),
            d = s.getSeconds();
          return null != t && t.dayOnly
            ? `${i}.${a}`
            : null != t && t.timeOnly
              ? `${n(r, 2)}:${n(o, 2)}:${n(d, 2)}`
              : `${i}.${a} ${n(r, 2)}:${n(o, 2)}:${n(d, 2)}`;
        }
        function n(e, t) {
          const s = e.toString();
          return s.length < t ? "0".repeat(t - s.length) + s : s;
        }
        s.d(t, "a", function () {
          return i;
        });
      },
      jw3m: function (e, t, s) {},
      kiQV: function (e) {
        e.exports = JSON.parse(
          '{"name":"Zalo","homepage":"https://zalo.me/","version":"24.4.1","description":"Zalo - Nhn gi yu thng","engines":{"npm":">=3"},"lint-staged":{"*.{js}":["node ./tools/prettier-include/index.js","eslint --quiet"],"*.{jsx,tsx,ts,scss,md,json,html,yml}":["node ./tools/prettier-include/index.js"]},"pre-commit":"check","main":"bootstrap.js","scripts":{"check":"lint-staged","preinstall":"node tools/nodeVersionCheck.js && git submodule init && git submodule update","postinstall":"npm run update-bundle-files-list && git config core.hooksPath .githooks","setup":"node tools/setup/setupMessage.js && npm install && node tools/setup/setup.js","remove-demo":"babel-node tools/removeDemo.js","start":"npm run init-zlog-vers && cross-env NODE_OPTIONS=\'--max-old-space-size=8192\' zpc-cli run dev:web","start-zaloapp":"npm run init-zlog-vers && cross-env NODE_OPTIONS=\'--max-old-space-size=8192\' WEB_DOMAIN=zaloapp zpc-cli run dev:web","open:src":"cross-env NODE_OPTIONS=\'--max-old-space-size=8192\' zpc-cli run dev:web","open:dist":"cross-env BABEL_ENV=web babel-node tools/distServer.js","update-about":"babel-node tools/updateAbout.js","distwname":"babel-node tools/dist-with-name.js","send-zlog":"node ./tools/zlog/collect-zlog-templates.js","send-zlog-web":"node ./tools/zlog/collect-zlog-templates-web.js","init-zlog-vers":"node ./tools/init-zlog-vers.js","prep":"rimraf ./node_modules/.cache ./zlog-dist && npm run sass && npm run lang","update-call-hash":"babel-node tools/update-call-hash.js","update-zavi-hash":"babel-node tools/update-zavi-hash.js","lint":"esw src --color --parser babel-eslint","lint-strict":"eslint main/*.js","m-lint":"eslint src/utils/meta-info-msg/*.js src/database/base-db.js","lint:watch":"npm run lint -- --watch","clean-dist":"npm run remove-dist && mkdir dist","remove-dist":"rimraf ./dist","prebuild":"npm run clean-dist && npm run sass && npm run lang","prebuild-pc":"npm run lint-strict && rimraf ./pc-dist && mkdir pc-dist && npm run sass && npm run lang","build-dev":"cross-env WEB_ENV=dev npm run build","build-prod":"cross-env WEB_ENV=prod npm run build","build-zaloapp-prod":"cross-env WEB_ENV=prod WEB_DOMAIN=zaloapp npm run build","build-zalome-prod":"cross-env WEB_ENV=prod WEB_DOMAIN=zalome npm run build","build:local":"npm run init-zlog-vers && npm run cross-env NODE_OPTIONS=\'--max-old-space-size=8192\' BUILD_TYPE=release zpc-cli run compile:web","build":"npm run init-zlog-vers && cross-env NODE_OPTIONS=\'--max-old-space-size=8192\' BUILD_TYPE=release node ./tools/zpc-cli.js run compile:web","compile:main":"npm run init-zlog-vers && cross-env NODE_OPTIONS=\'--max-old-space-size=8192\' zpc-cli run compile:main","build-pc":"npm run init-zlog-vers && cross-env NODE_OPTIONS=\'--max-old-space-size=8192\' zpc-cli run compile:renderer","build-pc-appX":"npm run init-zlog-vers && cross-env NODE_OPTIONS=\'--max-old-space-size=8192\' zpc-cli run compile:renderer:appx","test:cover":"babel-node node_modules/isparta/bin/isparta cover --root src --report html node_modules/mocha/bin/_mocha -- --require ./tools/testSetup.js \\"src/**/*.spec.js\\" --reporter progress","test:cover:travis":"babel-node node_modules/isparta/bin/isparta cover --root src --report lcovonly _mocha -- --require ./tools/testSetup.js \\"src/**/*.spec.js\\" && cat ./coverage/lcov.info | node_modules/coveralls/bin/coveralls.js","test:watch":"npm run test -- --watch","open:cover":"npm run test:cover && open coverage/index.html","test:electron":"electron ./test/main/download.js","test":"for f in $(find src -name *.spec.js); do NODE_PATH=./src mocha tools/testSetup.js \\"$f\\" --reporter progress; done;","wintest":"for %f in (src/utils/*.spec.js) do mocha tools/testSetup.js \\"src/utils/%f\\" done;","jest:test":"cross-env NODE_PATH=./src __PLATFORM__=WEB NODE_ENV=development jest --forceExit","jest:emoji":"cross-env NODE_PATH=./src __PLATFORM__=WEB jest test/core/parse-emoji.test.js --forceExit","jest:conversation":"cross-env NODE_PATH=./src __PLATFORM__=WEB jest --watch --testPathPattern=src/logic/conversation --forceExit","jest:log:test":"cross-env NODE_PATH=./src jest --runInBand --forceExit","jest:update":"cross-env NODE_PATH=./src jest -u","test:single":"cross-env NODE_PATH=./src mocha tools/testSetup.js src/utils/message.spec.js","test:file":"node ./test/file/test.js","test:ibparser":"cross-env NODE_PATH=./src mocha tools/testSetup.js  src/utils/inputbox-parser.spec.js","test:compare":"cross-env NODE_PATH=./src mocha tools/testSetup.js  src/utils/third-party/compare.spec.js","test:zstructures":"cross-env NODE_PATH=./src mocha tools/testSetup.js  src/utils/third-party/zstructures.spec.js","test:common":"cross-env NODE_PATH=./src mocha tools/testSetup.js src/utils/common.spec.js","test:schema":"cross-env NODE_PATH=./src jest --config= database/zdb/row-items/schema/data-validator.test.js --forceExit --detectOpenHandles","presass":"mkdirp src/static/css && mkdirp pc/static/fonts/zalo && ncp src/static/fonts/zalo/ pc/static/fonts/zalo/ && mkdirp pc/static/fonts/main  && ncp src/static/fonts/main/ pc/static/fonts/main/ ","sass":"sass src/static/scss/layout.scss src/static/css/layout.css && sass pc/static/scss/login.scss pc/static/css/login.css && sass src/static/scss/base/color-v1.scss src/static/css/color-v1.css && sass src/static/scss/base/darkmode.scss src/static/css/darkmode.css && sass src/static/scss/base/color-vtest.scss src/static/css/color-vtest.css","preelectron-start-dev":"npm run init-zlog-vers && cross-env NODE_OPTIONS=\'--max-old-space-size=8192\' zpc-cli run dev:main","electron-start-dev":"npm run init-zlog-vers && cross-env PC=1 BABEL_ENV=pc NODE_ENV=development electron .","predebug-main":"npm run init-zlog-vers && npm run init-zlog-vers && cross-env NODE_OPTIONS=\'--max-old-space-size=8192\' zpc-cli run dev:main","debug-main":"npm run init-zlog-vers && cross-env PC=1 BABEL_ENV=pc NODE_ENV=development electron . --inspect=9230","pc-compile":"cross-env FORCE_COLOR=1 PC=1 BABEL_ENV=pc NODE_ENV=development npm run electron-start-dev","pc-compile-2":"cross-env PC=1 BABEL_ENV=pc CLONE=1 NODE_ENV=development npm run electron-start-dev","v1-start-dev":"npm run init-zlog-vers && cross-env NODE_OPTIONS=\'--max-old-space-size=8192\' zpc-cli run dev:renderer","pc-start-dev":"npm run init-zlog-vers && cross-env NODE_OPTIONS=\'--max-old-space-size=8192\' zpc-cli run dev:renderer","start-pc":"npm run init-zlog-vers && npm-run-all -p pc-compile pc-start-dev","prepack":"npm run build-pc && npm run compile:main","prepack:win32":"npm run build-pc && npm run compile:main","prepack:winstaller":"npm run build-pc && npm run signtool && npm run compile:main","prewinstaller":"git submodule init && git submodule update","pack":"electron-builder --dir --config electron-builder.config.js","pack:win32":"cross-env BUILD_TYPE=release npm run pack:winstaller && node ./tools/afterpack.js ia32 && babel-node tools/genPartialUpdate.js ia32 -- ","pack:winstaller:no-build":"cross-env BUILD_TYPE=release ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES=true electron-builder --dir --ia32 --config electron-builder.config.js","pack:winstaller":"electron-builder --dir --ia32 --config electron-builder.config.js","pack:winstaller64":"electron-builder --dir --x64 --config electron-builder.config.js","postpack":"babel-node tools/genPartialUpdate.js","postpack:win32":"babel-node tools/genPartialUpdate.js ia32","predodist":"npm run build-pc && npm run signtool && npm run compile:main","predodist:win64":"npm run predodist","predodist:win32":"npm run predodist","predodist:mac":"node ./tools/predodistmac.js && npm run predodist","dodist":"electron-builder --config electron-builder.config.js","predodist:dir":"npm run build-pc && npm run signtool && npm run compile:main","dodist:mac":"electron-builder --mac --config electron-builder.config.js","dodist:dir":"electron-builder --dir --mac --config electron-builder.config.js","dodist:win":"electron-builder --win --config electron-builder.config.js","dodist:win32":"electron-builder --ia32 --config electron-builder.config.js","dodist:win64":"electron-builder --arch x64 --config electron-builder.config.js","pack:installer":"node ./tools/prebuild.js && npm run pack:winstaller && node ./tools/afterpack.js ia32 && electron-builder --prepackaged ./dist/win-ia32-unpacked/ --ia32 --config electron-builder.config.js && babel-node tools/genPartialUpdate.js ia32 -- ","pack:installer64":"node ./tools/prebuild.js && npm run pack:winstaller && node ./tools/afterpack.js x64 && electron-builder --prepackaged ./dist/win-unpacked/ --arch x64 --config electron-builder.config.js && babel-node tools/genPartialUpdate.js x64 -- ","pack:full":"node ./tools/prebuild.js && npm run pack:winstaller && node ./tools/afterpack.js ia32 && electron-builder --prepackaged ./dist/win-ia32-unpacked/ --ia32 --config electron-builder.config.js && babel-node tools/diffModule.js","dist:win32":"cross-env ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES=true NODE_OPTIONS=\'--max-old-space-size=4096\' BUILD_ENV=test npm run pack:installer","dist:win64":"cross-env ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES=true NODE_OPTIONS=\'--max-old-space-size=4096\' BUILD_ENV=test npm run pack:installer64","dist:win32release":"cross-env ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES=true NODE_OPTIONS=\'--max-old-space-size=4096\' BUILD_TYPE=release BUILD_ENV=test NEED_SIGN=1 npm run pack:installer","dist:win32fullpack":"cross-env ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES=true NODE_OPTIONS=\'--max-old-space-size=8096\' BUILD_TYPE=release BUILD_ENV=production NEED_SIGN=1 npm run pack:full","postpack:full":"","uploadsourcemapwin":"cross-env ZLOG_TYPE=PC sentry-cli releases files Zalo%npm_package_version% upload-sourcemaps pc-dist/ --url-prefix app:///pc-dist/ && sentry-cli releases files Zalo%npm_package_version% upload-sourcemaps main-dist/ --url-prefix app:///main-dist/ && npm run send-zlog","uploadsourcemapmac":"cross-env ZLOG_TYPE=PC sentry-cli releases files Zalo$npm_package_version upload-sourcemaps pc-dist/ --url-prefix app:///pc-dist/ && sentry-cli releases files Zalo$npm_package_version upload-sourcemaps main-dist/ --url-prefix app:///main-dist/ && npm run send-zlog","uploadsourcemapweb":"cross-env ZLOG_TYPE=WEB sentry-cli releases files Zalo$npm_package_version upload-sourcemaps dist/ --url-prefix ~/ && rm -r ./dist/sourcemaps && npm run send-zlog-web","dist:win32nobuild":"electron-builder --prepackaged ./dist/win-ia32-unpacked/ --ia32 --config electron-builder.config.js&& babel-node tools/genPartialUpdate.js ia32 -- ","dist:win":"cross-env ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES=true npm run dodist:win","dist:appX":"(npm run dodist:appX || true) && babel-node tools/rename-appx-64.js &&  npm run dodist:appX32","dist:mac":"cross-env ARCH=x64 ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES=true BUILD_ENV=test npm run dodist:mac","dist:macrelease":"cross-env ARCH=x64 NODE_OPTIONS=\'--max-old-space-size=4096\' ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES=true BUILD_TYPE=release NEED_SIGN=1 npm run dodist:mac","dist:mac:m1":"cross-env ARCH=arm64 ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES=true BUILD_ENV=test npm run dodist:mac","dist:macrelease:m1":"cross-env ARCH=arm64 NODE_OPTIONS=\'--max-old-space-size=4096\' ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES=true BUILD_TYPE=release NEED_SIGN=1 npm run dodist:mac","dist:macnobuild":"cross-env ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES=true electron-builder --mac --config electron-builder.config.js","dist":"cross-env NODE_OPTIONS=\'--max-old-space-size=2048\' ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES=true npm run dodist","predist:appX":"npm run build-pc-appX && npm run signtool && npm run compile:main","dodist:appX":"cross-env ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES=true electron-builder --win AppX --config electron-builder.config.js","dodist:appX32":"cross-env ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES=true electron-builder --win AppX --ia32  --config electron-builder.config.js","zip-pc":"babel-node tools/zipResource.js","db:clear":"babel-node tools/clearDb.js","icon:gen":"gulp icon","icon:check":"babel-node icon/checkIconsCli.js","icon":"babel-node icon/buildIcons.js && babel-node icon/createSVGFont.js && npm run sass","icon:full":"npm run icon:check && npm run icon && npm run sass ","lang":"mkdirp src/static/lang &&  cd ./InitLang && node ./run.js","signtool":"cross-env BABEL_ENV=node babel-node tools/sign-tool-win.js","install-native":"electron-builder install-app-deps","install-native-32":"electron-builder install-app-deps --arch=ia32","pack-module":"babel-node tools/genPartialUpdate.js ia32 -- ","update-bundle-files-list":"node ./tools/get-node-modules-glob.js","upload-native-symbol":"sentry-cli upload-dif -o vng -p zalopc --wait ./.symbols"},"author":{"name":"VNG Corp.","email":"feddback@zalo.me","url":"https://zalo.me/"},"license":"MIT","dependencies":{"@babel/plugin-transform-runtime":"7.11.0","@babel/preset-react":"7.10.4","@babel/runtime-corejs3":"7.11.2","@google-cloud/secret-manager":"4.0.0","@google-cloud/storage":"6.1.0","@reduxjs/toolkit":"1.5.1","@sentry/electron":"4.8.0","@sentry/react":"6.2.4","@tensorflow/tfjs":"0.15.3","@types/generic-pool":"3.1.9","adm-zip":"0.4.13","ajv":"5.2.2","archiver":"^5.3.1","auto-launch":"^5.0.1","babel-plugin-module-resolver":"4.0.0","babel-plugin-transform-zlog":"1.17.1","big-integer":"1.6.23","bloom-filters":"1.3.8","broadcast-channel":"~4.10.0","cborg":"1.9.5","change-case":"4.1.2","chart.js":"2.7.2","check-disk-space":"2.1.0","cheerio":"1.0.0-rc.12","clsx":"1.0.4","codemirror":"^5.59.0","core-js":"3.6.5","cron":"2.1.0","crypto-js":"3.1.8","decompress":"4.2.0","dompurify":"2.3.6","dropbox":"2.5.9","electron-log":"4.2.2","electron-store":"8.1.0","electron-updater":"4.0.0","es6-promise":"3.2.1","fast-memoize":"^2.5.2","file-saver":"1.3.3","file-type":"16.5.4","flatted":"3.2.5","fs-extra":"6.0.1","generic-pool":"3.7.2","glob":"7.1.2","immer":"7.0.5","jpeg-js":"0.4.1","js-yaml":"^3.8.4","jszip":"3.10.1","libphonenumber-js":"^1.10.28","lodash.debounce":"4.0.8","lodash.toarray":"4.4.0","lottie-web":"^5.1.7","lowdb":"2.1.0","lz-string":"1.4.4","mediatr-ts":"0.3.0","microm":"0.2.4","mkdirp":"^0.5.1","moment":"^2.29.1","nanoid":"3.3.3","network":"0.5.0","node-fetch":"2.6.0","node-stream-zip":"^1.15.0","node-wifi":"2.0.13","p-defer":"4.0.0","p-queue":"6.6.2","p-tap":"4.0.0","pako":"2.0.3","pdfjs-dist":"2.5.207","percentile":"1.6.0","progress-stream":"1.2.0","prop-types":"15.5.10","protobufjs":"6.11.2","quick-lru":"6.0.2","react":"16.14.0","react-codemirror2":"^7.2.1","react-custom-scrollbars":"^4.2.1","react-datetime":"file:native/zdate-time-picker","react-dom":"16.14.0","react-draggable":"^4.4.3","react-error-overlay":"6.0.7","react-input-range":"^1.3.0","react-intersection-observer":"8.25.2","react-measure":"2.0.2","react-motion":"0.5.2","react-redux":"7.2.4","react-refresh":"0.8.3","react-resizable":"^1.11.0","react-router-redux":"^4.0.8","react-simple-timefield":"3.2.5","react-transition-group":"4.4.1","react-virtualized":"9.9.0","recoil":"0.7.1","recompose":"0.30.0","redux":"4.0.5","redux-batched-subscribe":"0.1.6","redux-thunk":"2.3.0","reflect-metadata":"0.1.13","request":"2.88.0","reselect":"4.0.0","resize-observer-polyfill":"1.5.1","sax":"1.2.4","sift":"16.0.0","source-map-support":"0.5.19","spark-md5":"3.0.0","stackblur-canvas":"1.4.0","systeminformation":"5.6.12","tar-fs":"2.0.0","tmp":"0.0.31","tough-cookie":"^2.3.2","tsyringe":"4.6.0","unload":"git+https://zalogit2.zing.vn/zalo-pc/unload.git","unused-filename":"0.1.0","uuid":"3.1.0","web-vitals":"3.5.0","workerpool":"6.1.0","xstate":"4.23.1"},"devDependencies":{"@babel/cli":"^7.0.0","@babel/core":"7.19.6","@babel/eslint-parser":"7.12.1","@babel/node":"^7.0.0","@babel/plugin-proposal-class-properties":"7.12.1","@babel/preset-env":"7.11.0","@babel/preset-typescript":"7.18.6","@babel/register":"^7.0.0","@electron/fuses":"1.6.1","@electron/notarize":"2.1.0","@sentry/cli":"1.51.1","@types/async":"3.2.3","@types/codemirror":"0.0.98","@types/core-js":"2.5.4","@types/dompurify":"2.3.3","@types/gulp":"4.0.6","@types/jest":"26.0.23","@types/lodash.debounce":"4.0.6","@types/lodash.toarray":"4.4.6","@types/node":"17.0.35","@types/react":"^16.8.25","@types/react-custom-scrollbars":"4.0.8","@types/react-dom":"17.0.9","@types/react-resizable":"1.7.3","@types/react-transition-group":"4.4.0","@types/react-virtualized":"9.21.12","@types/rimraf":"3.0.2","@types/sqlite3":"3.1.8","@types/workerpool":"6.1.0","@types/spark-md5":"3.0.2","@typescript-eslint/parser":"4.22.0","@types/sax":"1.2.4","babel-core":"^7.0.0-bridge.0","babel-eslint":"^9.0.0","babel-jest":"27.5.1","babel-plugin-encrypt-src":"^1.0.3","capitalize":"2.0.4","chai":"3.5.0","chalk":"1.1.3","connect":"3.6.6","combined-stream":"^1.0.8","consola":"2.15.0","coveralls":"2.11.12","cross-env":"^2.0.0-beta","debug":"4.1.1","devtron":"1.4.0","electron":"22.3.9","electron-builder":"20.44.4","electron-devtools-installer":"3.1.1","electron-download":"4.1.1","electron-notarize":"0.2.1","electron-publish":"19.53.3","enzyme":"3.3.0","eslint":"5.4.0","eslint-import-resolver-babel-module":"5.1.0","eslint-import-resolver-webpack":"0.6.0","eslint-plugin-babel":"3.3.0","eslint-plugin-import":"2.16.0","eslint-plugin-jest":"21.22.0","eslint-plugin-jsx-a11y":"2.1.0","eslint-plugin-react":"7.11.1","eslint-plugin-react-hooks":"2.4.0","eslint-watch":"2.1.14","fake-indexeddb":"4.0.0","faker":"5.5.3","globby":"11.0.1","gulp":"4.0.2","gulp-consolidate":"0.2.0","gulp-iconfont":"11.0.0","isparta":"4.0.0","jest":"27.5.1","jsftp":"1.5.5","lint-staged":"10.5.4","md5":"2.2.1","md5-file":"4.0.0","micromatch":"4.0.2","mocha":"4.1.0","ncp":"^2.0.0","node-abi":"^2.0.2","node-pre-gyp":"^0.6.37","nodemon":"1.11.0","npm":"6.14.2","npm-run-all":"2.3.0","open":"0.0.5","pre-commit":"1.2.2","prettier":"2.4.1","prompt":"1.0.0","react-hook-form":"7.31.3","react-hook-form-auto":"1.3.13","react-test-renderer":"16.5.1","recoilize":"2.0.1","redux-logger":"3.0.6","redux-perf-middleware":"1.1.0","regenerator-runtime":"0.13.7","replace":"0.3.0","rimraf":"2.5.4","serve-static":"1.13.2","shelving-mock-indexeddb":"1.0.8","sinon":"1.17.5","sinon-chai":"2.8.0","terser-webpack-plugin-legacy":"1.2.3","ts-jest":"27.1.5","ts-node":"8.10.2","typescript":"3.9.6","uglify-es":"3.3.7","uglifyjs-webpack-plugin":"1.1.6","utility-types":"3.10.0","walkdir":"0.0.12","webpack":"3.10.0","webpack-chain":"6.5.1","webpack-dev-middleware":"^2.0.4","webpack-hot-middleware":"^2.21.0","webpack-md5-hash":"0.0.5","webpack-strip":"0.1.0","webpack-virtual-modules":"0.4.3","yargs":"15.4.1"},"externals":[]}',
        );
      },
      nUpV: function (e, t, s) {
        "use strict";
        var i = s("jDHv"),
          n = s("YEoC"),
          a = (s("bSii"), s("UJ0r")),
          r = s("teaq");
        const o = n.a.IDB;
        var d,
          l = s("d/or");
        let c =
          i.ModuleContainer.injectable()(
            (d =
              Reflect.metadata(
                "design:type",
                Function,
              )(
                (d =
                  Reflect.metadata(
                    "design:paramtypes",
                    [],
                  )(
                    (d = class e {
                      constructor() {
                        (this._preferAdapters = void 0),
                          (this._settings = void 0),
                          (this._preferAdapters = []),
                          (this._settings = new Map());
                      }
                      get preferAdapters() {
                        return this._preferAdapters;
                      }
                      set preferAdapters(e) {
                        (this._preferAdapters = e),
                          this._settings.clear(),
                          this.save();
                        i.ModuleContainer.resolve(r.b).clearCache();
                      }
                      async load() {
                        i.ModuleContainer.resolve(a.b);
                        throw new Error(
                          "'zdb_setting' localStorage key is no longer in-use! Please remove it usage!",
                        );
                      }
                      async save() {
                        e.deserializePreferAdapter(this._preferAdapters),
                          e.deserializeDatabaseSettings(this._settings);
                        throw new Error(
                          "'zdb_setting' localStorage key is no longer in-use! Please remove it usage!",
                        );
                      }
                      getPreferredAdapter(e) {
                        var t;
                        return null === (t = this._settings.get(e)) ||
                          void 0 === t
                          ? void 0
                          : t.preferAdapter;
                      }
                      setPreferAdapter(e, t) {
                        let s = this._settings.get(e);
                        s
                          ? (s.preferAdapter = t)
                          : (s = { currentAdapter: t, preferAdapter: t }),
                          this._settings.set(e, s),
                          this.save();
                      }
                      getCurrentAdapterType(e) {
                        let t = this._settings.get(e);
                        return (
                          t ||
                            ((t = { currentAdapter: o }),
                            this._settings.set(e, t)),
                          t.currentAdapter
                        );
                      }
                      setCurrentAdapter(e, t) {
                        let s = this._settings.get(e);
                        s
                          ? (s.currentAdapter = t)
                          : (s = { currentAdapter: t, preferAdapter: t }),
                          this._settings.set(e, s);
                      }
                      getDatabaseState(e) {
                        return this._settings.get(e);
                      }
                      static deserializePreferAdapter(e) {
                        return e.map((e) => (e === n.a.IDB ? "IDB" : "SQLite"));
                      }
                      static serializePreferAdapter(e) {
                        return e.adapter.map((e) =>
                          "IDB" === e ? n.a.IDB : n.a.SQLite,
                        );
                      }
                      static deserializeDatabaseSettings(e) {
                        return Array.from(e.entries());
                      }
                      static serializeDatabaseSettings(e) {
                        return new Map(e.databases);
                      }
                    }),
                  ) || d),
              ) || d),
          ) || d;
        i.ModuleContainer.registerSingleton(l.a, c);
      },
      o0oJ: function (e, t, s) {
        (function (e) {
          const t = {};
          function s(e) {
            return t[e] || (t[e] = 0), (t[e] += 1), 100 * e + t[e];
          }
          if (!e.perf) {
            let t = () => Date.now();
            const i = {
              STARTUP: s(1),
              MIGRATION_DONE: s(2),
              MAIN_SCRIPT: s(2),
              LOADED_MAIN_SCRIPT: s(3),
              MAIN_APP_READY: s(3),
              LOADED_STARTUP_SCRIPT: s(2),
              STARTUP_BEFORE_HEAVY: s(3),
              CREATE_MAIN_WINDOW: s(3),
              SHOW_MAIN_WINDOW: s(3),
              MAIN_WINDOW_LOADING: s(3),
              MAIN_WINDOW_LOADED: s(3),
              APP_STARTUP: s(2),
              LOAD_APP_SCRIPT: s(3),
              APP_DID_MOUNT: s(3),
              CHATBOX_DID_MOUNT: s(3),
              SELECT_CONVERSATION: s(1),
              SELECTED_CONVERSATION: s(2),
            };
            e.perf = {
              ...i,
              perfRecords: [],
              record: (s) => {
                s || (s = 0);
                const i = [s, t()];
                e.perf.perfRecords.push(i);
              },
            };
          }
        }).call(this, s("kjmW"));
      },
      oSk7: function (e, t, s) {
        "use strict";
        class i {
          constructor(e) {
            (this.stream = void 0), (this.stream = e);
          }
          pipe(e) {
            return (this.stream = i.transformStream(this.stream, e)), this;
          }
          getStream() {
            return this.stream;
          }
          static transformStream(e, t, s) {
            try {
              return e.pipeThrough(new TransformStream(t));
            } catch (i) {
              const s = e.getReader();
              return new ReadableStream({
                start(e) {
                  var s;
                  const i = {
                    desiredSize: null,
                    enqueue(t) {
                      e.enqueue(t);
                    },
                    error(e) {},
                    terminate() {},
                  };
                  return null === (s = t.start) || void 0 === s
                    ? void 0
                    : s.call(t, i);
                },
                async pull(e) {
                  let i = !1;
                  const n = {
                    desiredSize: null,
                    enqueue(t) {
                      (i = !0), t && e.enqueue(t);
                    },
                    error(e) {},
                    terminate() {},
                  };
                  for (; !i; ) {
                    var a;
                    const i = await s.read();
                    var r;
                    if (i.done)
                      return (
                        await (null === (r = t.flush) || void 0 === r
                          ? void 0
                          : r.call(t, n)),
                        e.close()
                      );
                    await (null === (a = t.transform) || void 0 === a
                      ? void 0
                      : a.call(t, i.value, n));
                  }
                },
              });
            }
          }
          static createReadbleStreamFromArrayBuffer(e, t) {
            void 0 === t && (t = 2 ** 20);
            const s = Math.ceil(e.byteLength / t);
            return new ReadableStream({
              start(i) {
                for (let n = 0; n <= s; n++)
                  i.enqueue(new Uint8Array(e, n * t, t));
                i.close();
              },
            });
          }
        }
        t.a = i;
      },
      qLCR: function (e, t, s) {
        "use strict";
        s.r(t);
        s("cOPa"), s("mNvP"), s("BtX6"), s("YpjI");
        var i = s("jDHv"),
          n = s("7wvk");
        i.ModuleContainer.registerSingleton(
          n.TFactoryMainless,
          class {
            constructor() {
              (this.map = new Map()), (this.mainless = new Map());
            }
            registerMainless(e, t) {
              if (this.mainless.has(t)) throw Error("mainless registered");
              this.mainless.set(t, e);
            }
            registerMethod(e, t) {
              if (this.map.has(e)) throw Error("method registered");
              this.map.set(e, t);
            }
            getMethodTarget(e) {
              return this.map.get(e);
            }
            getMainless(e) {
              const t = this.map.get(e);
              return this.mainless.get(t);
            }
          },
        );
        var a = s("wq09");
        const r = i.ModuleContainer.resolve(n.TFactoryMainless),
          o = {
            zip: a.b.node,
            unzip: a.b.node,
            md5: a.b.node,
            fileEexc: a.b.node,
            getDirSize: a.b.node,
            genThumbMacOfficeBuffer: a.b.node,
            genThumbWinOfficeBuffer: a.b.node,
            parseLink: a.b.node,
            parseBank: a.b.node,
          },
          d = {
            fileType: a.b.render,
            sha256: a.b.render,
            rmd5: a.b.render,
            genThumbPicBuffer: a.b.render,
            genPreviewThumb: a.b.render,
            resizeImage: a.b.render,
          },
          l = {
            sha256: a.b.web,
            genPreviewThumb: a.b.web,
            resizeImage: a.b.web,
            fileType: a.b.web,
            wmd5: a.b.web,
            parseBank: a.b.web,
          };
        for (let dC in l) r.registerMethod(dC, l[dC]);
        if ("render" == __ZaBUNDLENAME__) {
          for (let e in d) r.registerMethod(e, d[e]);
          for (let e in o) r.registerMethod(e, o[e]);
        }
        var c = s("9jPG");
        class h {
          get instance() {
            return this._instance || (this._instance = new h()), this._instance;
          }
          constructor() {
            (this._instance = void 0),
              (this._do_not_use_me_pool = void 0),
              (this._do_not_use_me_pool = Object(c.pool)(
                __SRC_MAINLESS_WORKER__,
                { workerType: "web", maxWorkers: 1, minWorkers: 1 },
              ));
          }
          get pool() {
            return this.instance._do_not_use_me_pool;
          }
          get proxy() {
            return this.pool.proxy();
          }
          exec(e, t, s) {
            return Promise.resolve(this.execRaw(e, t, s));
          }
          execRaw(e, t, s) {
            return this.pool.exec(e, t, s);
          }
        }
        const u = i.ModuleContainer.resolve(n.TFactoryMainless);
        {
          const e = new h();
          u.registerMainless(e, a.b.web),
            i.ModuleContainer.registerValue(n.TWebMainless, e);
        }
        var g = s("hzFW");
        class m {}
        class p {
          constructor() {
            this.instance = void 0;
          }
          createAppPathManager() {
            return this.instance || (this.instance = new m()), this.instance;
          }
        }
        "function" == typeof importScripts ||
          i.ModuleContainer.registerSingleton(g.a, p);
        var f = s("VTBJ"),
          v = s("mwIZ"),
          b = s.n(v),
          I = s("D1y2"),
          y = s.n(I),
          _ = s("Y58e");
        i.ModuleContainer.registerSingleton(
          _.a,
          class {
            get(e) {
              const t = s("NDmK").default;
              return b()(t, e);
            }
            set(e, t) {
              const i = s("NDmK").default,
                n = Object(f.a)(Object(f.a)({}, b()(i, e)), t);
              return y()(i, e, n);
            }
          },
        );
        var O,
          C = s("jGDt"),
          E = s("igA5"),
          M = s("PLj1"),
          S = s("KRcn"),
          T = s("7FSS"),
          w = s("i15Q"),
          R = s("1pet");
        let L =
          Object(i.injectable)()(
            (O =
              Reflect.metadata(
                "design:type",
                Function,
              )(
                (O =
                  Reflect.metadata(
                    "design:paramtypes",
                    [],
                  )(
                    (O = class extends w.a {
                      constructor() {
                        super();
                        const e = Object(S.a)();
                        if (M.a.includes(e)) this._enableConsole = !1;
                        else {
                          var t;
                          const e =
                            null === (t = E.default.getInstance()) ||
                            void 0 === t
                              ? void 0
                              : t.getItem(
                                  R.ZLoggerLocalStorageKeys
                                    .RENDERER_CONSOLE_MODE,
                                );
                          this._enableConsole = "true" === e || !1;
                        }
                        T.a.log(
                          "[ZLL]: Console logging",
                          this._enableConsole ? "enabled" : "disabled",
                        );
                      }
                      enableConsole() {
                        T.a.log("[ZLL]: Console logging enabled"),
                          (this._enableConsole = !0);
                        const e = Object(S.a)();
                        var t;
                        M.a.includes(e) ||
                          null === (t = E.default.getInstance()) ||
                          void 0 === t ||
                          t.setItem(
                            R.ZLoggerLocalStorageKeys.RENDERER_CONSOLE_MODE,
                            "true",
                          );
                      }
                      disableConsole() {
                        T.a.log("[ZLL]: Console logging disabled"),
                          (this._enableConsole = !1);
                        const e = Object(S.a)();
                        var t;
                        M.a.includes(e) ||
                          null === (t = E.default.getInstance()) ||
                          void 0 === t ||
                          t.setItem(
                            R.ZLoggerLocalStorageKeys.RENDERER_CONSOLE_MODE,
                            "false",
                          );
                      }
                    }),
                  ) || O),
              ) || O),
          ) || O;
        i.ModuleContainer.registerSingleton(C.a, L);
        s("ezdo"), s("KdAX");
        var D = s("W8Xk");
        const F = Object(i.define)("kv-cache"),
          A = Object(i.define)("kv-cache-in-mem");
        var j;
        class P {
          constructor(e) {
            (this._prefix = void 0), (this._prefix = `${e}-kv-db`);
          }
          _buildKey(e) {
            return `${this._prefix}-${e}`;
          }
          async setItem(e, t) {
            const s = this._buildKey(e),
              i = E.default.getInstance();
            return await i.setItemAsync(s, D.b(t)), t;
          }
          async getItem(e) {
            const t = this._buildKey(e),
              s = E.default.getInstance(),
              i = await s.getItemAsync(t);
            return Promise.resolve(i ? D.a(i) : void 0);
          }
          async removeItem(e) {
            const t = this._buildKey(e),
              s = E.default.getInstance();
            return await s.removeItemAsync(t), this;
          }
        }
        Object(i.singleton)(F)(
          (j = class {
            createCache(e) {
              return new P(`${e}`);
            }
          }),
        );
        var N,
          U = s("ndDP");
        class k {
          constructor(e, t) {
            (this._unused_name = e),
              (this._lru = void 0),
              (this._lru = new U.default(t));
          }
          setItem(e, t) {
            return this._lru.set(e, t), Promise.resolve(t);
          }
          getItem(e) {
            return Promise.resolve(this._lru.get(e));
          }
          removeItem(e) {
            return this._lru.delete(e), Promise.resolve(this);
          }
        }
        Object(i.singleton)(A)(
          (N = class {
            constructor() {
              this._registry = {};
            }
            createCache(e, t) {
              return (
                this._registry[e] || (this._registry[e] = new k(e, t)),
                this._registry[e]
              );
            }
          }),
        );
        s("0rWR"),
          s("Lq8m"),
          s("nUpV"),
          s("5yGw"),
          s("hRcX"),
          s("gpNb"),
          s("rhBN"),
          s("cF85");
        var B = s("4prX"),
          G = s("12Ui");
        i.ModuleContainer.registerSingleton(
          G.a,
          class {
            increaseSuccess(e, t, s, i, n) {
              B.default.increaseSuccess(e, t, s, i, n);
            }
            increaseFailed(e, t, s, i, n, a, r) {
              B.default.increaseFailed(e, t, s, i, n, a, r);
            }
          },
        );
        var x = s("KhD4");
        i.ModuleContainer.registerSingleton(
          x.a,
          class {
            getAppDataPath() {
              throw new Error("Method not implemented.");
            }
          },
        );
        var z,
          V = s("8/YW"),
          H = s("PmZf"),
          $ = s("tHMN"),
          W = s("jIg3"),
          K = s("fsN4"),
          q = s("Mgpg");
        let Z =
          i.ModuleContainer.injectable()(
            (z =
              (function (e, t) {
                return i.ModuleContainer.inject($.b)(e, void 0, 0);
              })(
                (z =
                  (function (e, t) {
                    return i.ModuleContainer.inject(q.ZLoggerFactory)(
                      e,
                      void 0,
                      1,
                    );
                  })(
                    (z =
                      Reflect.metadata(
                        "design:type",
                        Function,
                      )(
                        (z =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === $.a ? Object : $.a,
                            void 0 === q.ZLoggerFactory
                              ? Object
                              : q.ZLoggerFactory,
                          ])(
                            (z = class extends W.a {
                              constructor(e, t) {
                                super(),
                                  (this.engine = e),
                                  (this.logger = void 0),
                                  (this.logger = t.createZLogger("db", [
                                    "browser",
                                  ])),
                                  this.registerListeners();
                              }
                              registerListeners() {
                                const e = (e) => this.dispatchEvent(e);
                                this.engine.addEventListener(
                                  H.b.UnexpectedError,
                                  e,
                                ),
                                  this.engine.addEventListener(
                                    H.b.QueryError,
                                    e,
                                  ),
                                  this.engine.addEventListener(
                                    H.b.SuccessOpenDB,
                                    e,
                                  ),
                                  this.engine.addEventListener(
                                    H.b.ConnectionClosedAbnormally,
                                    e,
                                  );
                              }
                              install() {
                                const e = i.ModuleContainer.resolve(V.a);
                                e.addEventListener(V.b.Authenticated, (e) => {
                                  this.authenticate(e.getSession());
                                }),
                                  e.currentSession &&
                                    this.authenticate(e.currentSession),
                                  this.logger.zsymb(3, 14461, 3e4, "installed");
                              }
                              areYouOk() {
                                return !0;
                              }
                              authenticate(e) {
                                e &&
                                  ((this.session = e),
                                  this.dispatchEvent(new H.d(e)),
                                  this.logger.zsymb(0, 14461, 30001, () => [
                                    "authenticated",
                                    `id: ${e.userId}`,
                                  ]));
                              }
                              async closeDBs(e) {
                                const t = K.default.getInstance();
                                let s = [];
                                e
                                  ? e.length &&
                                    (s = e.map((e) => t[e].closeThisDatabase()))
                                  : (s = [t.closeAllDatabases()]),
                                  await Promise.all(s);
                              }
                            }),
                          ) || z),
                      ) || z),
                  ) || z),
              ) || z),
          ) || z;
        i.ModuleContainer.registerSingleton(W.b, Z);
        const J = Object(i.define)("qos");
        var Q = s("PoHQ");
        i.ModuleContainer.registerSingleton(
          J,
          class {
            log(e) {
              Q.p.triggerEvent(Q.h, [
                {
                  commandId: e.commandId,
                  success: !0 === e.success,
                  subCommandId: e.subCommandId || 0,
                  duration: e.duration || 0,
                  errorCode: e.errorCode || 0,
                  startTime: e.startTime || Date.now(),
                  params: e.params,
                },
              ]);
            }
          },
        );
        var Y,
          X = s("W8fB");
        let ee = Object(i.injectable)()((Y = class {})) || Y;
        i.ModuleContainer.registerSingleton(X.b, ee);
        var te = s("AH6j"),
          se = s("fsQs"),
          ie = s("HPcM");
        let ne;
        !(function (e) {
          (e.Binary = "zlog"), (e.Text = "log");
        })(ne || (ne = {}));
        ne.Binary, ne.Text;
        let ae, re;
        !(function (e) {
          (e.PhysicalTextWriter = "PhysicalTextWriter"),
            (e.PhysicalBinaryWriter = "PhysicalBinaryWriter"),
            (e.PhysicalMeta = "PhysicalMeta");
        })(ae || (ae = {})),
          (function (e) {
            (e.Init = "Init"),
              (e.Idle = "Idle"),
              (e.Busy = "Busy"),
              (e.Paused = "Paused"),
              (e.Disabled = "Disabled");
          })(re || (re = {}));
        const oe = Object(i.define)("virtual-file-writer");
        var de;
        let le =
          Object(i.injectable)()(
            (de =
              (function (e, t) {
                return Object(i.inject)(ie.a)(e, void 0, 0);
              })(
                (de =
                  (function (e, t) {
                    return Object(i.inject)(oe)(e, void 0, 1);
                  })(
                    (de =
                      Reflect.metadata(
                        "design:type",
                        Function,
                      )(
                        (de =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === ie.a ? Object : ie.a,
                            void 0 === oe ? Object : oe,
                          ])(
                            (de = class extends te.b {
                              constructor(e, t) {
                                super(),
                                  (this.bucket = e),
                                  (this.logWriter = t),
                                  (this._mode = void 0),
                                  (this.status = re.Init),
                                  (this._mode = ne.Binary);
                              }
                              async init() {
                                se.n && T.a.log("DBLogWriterImpl.init()");
                                try {
                                  await this.logWriter.loadMeta(),
                                    this._mode === ne.Binary &&
                                      (await this.logWriter.loadModule());
                                } catch (e) {
                                  T.a.debug(
                                    "[ZLL]: DBLogWriterImpl.init() failed",
                                    e,
                                  );
                                }
                                (this.status = re.Idle),
                                  se.n &&
                                    T.a.log(
                                      "[ZLL]: DBLogWriterImpl init() DONE",
                                      re[this.status],
                                    );
                              }
                              async flush() {
                                if (this.status !== re.Idle) return;
                                let e = Date.now();
                                if (0 === this.bucket.size()) return;
                                se.n &&
                                  T.a.log(
                                    `FLUSHING: ${this.bucket.size()} logs => DB`,
                                  ),
                                  (this.status = re.Busy);
                                const t = this.bucket.get(se.j),
                                  s = t.length;
                                (await this.logWriter.write(t))
                                  ? (await this.logWriter.flushMetas(),
                                    this.bucket.removeFirst(s - t.length))
                                  : t.length > 0 &&
                                    T.a.error(
                                      `[ZLL]: flush failed: ${s - t.length}/${s}. failed:${t.length}/${s}`,
                                    ),
                                  this._mode === ne.Binary &&
                                    (await this.logWriter.flushModules()),
                                  (this.status = re.Idle),
                                  se.n &&
                                    T.a.log(
                                      `FLUSHED: ${s - t.length}/${s} logs => DB. TOOK: ${Date.now() - e}ms`,
                                    );
                              }
                            }),
                          ) || de),
                      ) || de),
                  ) || de),
              ) || de),
          ) || de;
        var ce,
          he = s("ebA4"),
          ue = s("ez9R"),
          ge = s("XuBa"),
          me = s("j6JD");
        const pe = {
          id: 0,
          current: 0,
          currentPage: 0,
          startups: [],
          ss: -1,
          ss_ln: -1,
        };
        let fe =
          Object(i.injectable)()(
            (ce =
              Reflect.metadata(
                "design:type",
                Function,
              )(
                (ce =
                  Reflect.metadata(
                    "design:paramtypes",
                    [],
                  )(
                    (ce = class {
                      constructor() {
                        (this._status = void 0),
                          (this.BinEncoder = null),
                          (this.DB = void 0),
                          (this.currentPage = void 0),
                          (this.module = new Map()),
                          (this.metas = { data: pe, updateRequired: !1 }),
                          (this._status = re.Idle),
                          (this.DB = K.default.getInstance().ZLog);
                      }
                      get status() {
                        return this._status;
                      }
                      async write(e) {
                        try {
                          return (
                            (this._status = re.Busy),
                            await this.encodeFit(e, this.metas),
                            (this._status = re.Idle),
                            !0
                          );
                        } catch (t) {
                          return (
                            T.a.error(
                              `[ZLL]: VirtualFileWriterImpl.write err ${t}`,
                            ),
                            (this._status = re.Idle),
                            !1
                          );
                        }
                      }
                      async collectAllLogs() {
                        try {
                          const e = (await this.DB.Pages.getAll()).map((e) =>
                              e.data.slice(0, e.curoffs),
                            ),
                            t = new Blob(e);
                          return await t.arrayBuffer();
                        } catch (e) {
                          return (
                            T.a.error(
                              `[ZLL]:VirtualFileWriterImpl.getAllPagesCombine err ${e}`,
                            ),
                            new ArrayBuffer(0)
                          );
                        }
                      }
                      async read(e) {
                        try {
                          return await this.DB.Pages.get(e);
                        } catch (t) {
                          return void T.a.error(
                            `[ZLL]: VirtualFileWriterImpl.reading ${e} err ${t}`,
                          );
                        }
                      }
                      async delete(e) {
                        try {
                          return await this.DB.Pages.delete(e), !0;
                        } catch (t) {
                          return (
                            T.a.error(
                              `[ZLL]:VirtualFileWriterImpl.deleting ${e} err ${t}`,
                            ),
                            !1
                          );
                        }
                      }
                      async encodeFit(e, t) {
                        var s;
                        if (0 === e.length) return;
                        const i = [],
                          n = se.d.page_limit;
                        (this.currentPage &&
                          this.currentPage.id === t.data.currentPage) ||
                          ((this.currentPage = await this.DB.Pages.get(
                            t.data.currentPage,
                          )),
                          this.currentPage && (this.currentPage.curoffs = 0));
                        let a = 0;
                        const r =
                          n -
                          ((null === (s = this.currentPage) || void 0 === s
                            ? void 0
                            : s.curoffs) || 0);
                        let o = se.c.OK;
                        for (; e.length; ) {
                          const t = await this.encodeBinary(e[0]);
                          if (a + t.byteLength > r) {
                            o = se.c.OVERSIZE_NEXTPAGE;
                            break;
                          }
                          i.push(new Uint8Array(t)),
                            (a += t.byteLength),
                            e.shift();
                        }
                        if (0 === i.length && o === se.c.OVERSIZE_NEXTPAGE) {
                          if (
                            this.currentPage &&
                            this.currentPage.curoffs <
                              this.currentPage.data.size
                          ) {
                            const e = this.currentPage.data.slice(
                              0,
                              this.currentPage.curoffs,
                            );
                            (this.currentPage.data = e),
                              await this.DB.Pages.insert(this.currentPage, {
                                replace: !0,
                              });
                          }
                          return (
                            this.nextPage(t),
                            void (await this.DB.Metas.insert(t.data, {
                              replace: !0,
                            }))
                          );
                        }
                        if (!i.length) return;
                        const d = this.combineArrayBuffers(i);
                        if (this.currentPage) {
                          if (d.byteLength) {
                            const e = this.currentPage.data.slice(
                                0,
                                this.currentPage.curoffs,
                              ),
                              t = new Blob([e, d]);
                            (this.currentPage.data = t),
                              (this.currentPage.curoffs += d.byteLength),
                              (this.currentPage.max = se.d.page_limit),
                              (this.currentPage.mtime = Date.now());
                          }
                          o === se.c.OVERSIZE_NEXTPAGE
                            ? this.nextPage(t)
                            : (t.data.current = this.currentPage.curoffs),
                            d.byteLength &&
                              (await this.DB.Pages.insert(this.currentPage, {
                                replace: !0,
                              }));
                          try {
                            await this.DB.Metas.insert(t.data, { replace: !0 });
                          } catch (l) {
                            T.a.error(
                              "[ZLL]: VirtualFileWriterImpl.encodeFit err2",
                              l,
                            );
                          }
                        } else {
                          (this.currentPage = {
                            id: t.data.currentPage,
                            data: new Blob([d]),
                            curoffs: d.byteLength,
                            max: se.d.page_limit,
                            mtime: Date.now(),
                          }),
                            (t.data.current = d.byteLength);
                          try {
                            await this.DB.Pages.insert(this.currentPage, {
                              replace: !0,
                            }),
                              await this.DB.Metas.insert(t.data, {
                                replace: !0,
                              });
                          } catch (l) {
                            T.a.error(
                              "[ZLL]:VirtualFileWriterImpl.encodeFit err",
                              l,
                            );
                          }
                        }
                      }
                      combineArrayBuffers(e) {
                        const t = e.reduce((e, t) => e + t.byteLength, 0),
                          s = new Uint8Array(t);
                        let i = 0;
                        for (const n of e)
                          s.set(new Uint8Array(n), i), (i += n.byteLength);
                        return s.buffer;
                      }
                      getSessionLineId() {
                        let e = this.metas.data.ss;
                        const t =
                          (this.metas.data.ss_ln + 1) % se.m.SESSION_LINE_MAX;
                        return (
                          0 === t && (e = (e + 1) % se.m.SESSION_MAX),
                          (this.metas.data.ss = e),
                          (this.metas.data.ss_ln = t),
                          { ss: e, ss_ln: t }
                        );
                      }
                      encodeText(e) {
                        const t = this.getSessionLineId();
                        return Object(he.b)(e, t).buffer;
                      }
                      async encodeBinary(e) {
                        this.BinEncoder ||
                          (this.BinEncoder = i.ModuleContainer.resolve(ue.a));
                        const t = await this._getModule([
                            e.lineMeta.module,
                            e.lineMeta.features,
                          ]),
                          s = this.getSessionLineId();
                        return this.BinEncoder.encode(e, t.data.id, s);
                      }
                      nextPage(e) {
                        const t = se.d.page_limit,
                          s = se.d.file_lim,
                          i = Math.floor(s / t),
                          n = (e.data.currentPage + 1) % i;
                        return (
                          (e.updateRequired = !0),
                          (e.data.currentPage = n),
                          (e.data.current = 0),
                          e
                        );
                      }
                      async loadMeta() {
                        try {
                          let e = await this.DB.Metas.get(0);
                          e || (e = pe),
                            e.startups.length > se.a &&
                              (e.startups = e.startups.slice(0, se.a)),
                            e.startups.unshift(Object(me.a)(Date.now())),
                            (e.ss = void 0 !== e.ss ? e.ss : -1),
                            (e.ss_ln = -1),
                            (this.metas.data = e),
                            (this.metas.updateRequired = !1);
                        } catch (e) {
                          T.a.error(
                            `[ZLL]: VirtualFileWriterImpl.loadMeta err ${e}`,
                          );
                        }
                        return await this._loadCurrentPage(), this.metas;
                      }
                      async flushMetas() {
                        this.metas.updateRequired &&
                          (await this.DB.Metas.insert(this.metas.data, {
                            replace: !0,
                            retry: 1,
                          }));
                      }
                      async loadModule() {
                        try {
                          const e = await this.DB.Modules.getAll();
                          if (e) {
                            const t = e.map((e) => [
                              ge.a.decrypt(e.hash),
                              { data: e, updateRequired: !1 },
                            ]);
                            this.module = new Map(t);
                          }
                        } catch (e) {
                          T.a.error(
                            `[ZLL]: VirtualFileWriterImpl.loadModule err ${e}`,
                          );
                        }
                        return this.module;
                      }
                      async flushModules() {
                        const e = Array.from(this.module.values());
                        for (const t of e)
                          t.updateRequired &&
                            (await this.DB.Modules.insert(t.data, { retry: 1 }),
                            (t.updateRequired = !1));
                      }
                      async _loadCurrentPage() {
                        this.metas || (await this.loadMeta());
                        const e = await this.DB.Pages.get(
                          this.metas.data.currentPage,
                        );
                        return (this.currentPage = e), e;
                      }
                      async _getModule(e) {
                        const t = JSON.stringify(e),
                          s = this.module.get(t);
                        if (s) return s;
                        const i = ge.a.encrypt(t),
                          n = {
                            data: { id: this.module.size, hash: i },
                            updateRequired: !0,
                          };
                        return this.module.set(t, n), n;
                      }
                    }),
                  ) || ce),
              ) || ce),
          ) || ce;
        i.ModuleContainer.registerSingleton(oe, fe),
          i.ModuleContainer.registerSingleton(X.c, le);
        const ve = Object(i.define)("zlog-writer-manager");
        var be,
          Ie = s("Y41u"),
          ye = s("K8kB");
        let _e =
          Object(i.injectable)()(
            (be =
              (function (e, t) {
                return Object(i.inject)(ye.a)(e, void 0, 0);
              })(
                (be =
                  (function (e, t) {
                    return Object(i.inject)(X.c)(e, void 0, 1);
                  })(
                    (be =
                      (function (e, t) {
                        return Object(i.inject)(X.b)(e, void 0, 2);
                      })(
                        (be =
                          Reflect.metadata(
                            "design:type",
                            Function,
                          )(
                            (be =
                              Reflect.metadata("design:paramtypes", [
                                void 0 === ye.a ? Object : ye.a,
                                void 0 === X.c ? Object : X.c,
                                void 0 === X.b ? Object : X.b,
                              ])(
                                (be = class {
                                  constructor(e, t, s) {
                                    (this._writeScheduler = e),
                                      (this.zlogWriter = t),
                                      (this.senWriter = s),
                                      (this._handleFlushRequest = () => {
                                        this.zlogWriter.flush();
                                      }),
                                      (this._handleWriterStatus = (e) => {});
                                  }
                                  setupWriters() {
                                    this.zlogWriter.init(),
                                      this._writeScheduler.start(),
                                      this._listenEvents();
                                  }
                                  _listenEvents() {
                                    this._writeScheduler.addEventListener(
                                      Ie.c.WriteSchedulerRequestFlush,
                                      this._handleFlushRequest,
                                    ),
                                      this.zlogWriter.addEventListener(
                                        Ie.c.WriterStatus,
                                        this._handleWriterStatus,
                                      );
                                  }
                                }),
                              ) || be),
                          ) || be),
                      ) || be),
                  ) || be),
              ) || be),
          ) || be;
        i.ModuleContainer.registerSingleton(ve, _e);
        var Oe,
          Ce = s("OMsT"),
          Ee = s("XS0u");
        let Me =
          Object(i.injectable)()(
            (Oe = class {
              clientDeviceInfo() {
                return navigator.userAgent;
              }
              prepareLogBlob(e) {
                return new Promise((t, i) => {
                  let n = e.viewerKey;
                  if (!n) {
                    n = Ee.default.getLastViewKey() || "";
                    try {
                      var a;
                      n =
                        null === (a = n) || void 0 === a
                          ? void 0
                          : a.split(".")[0];
                    } catch {}
                  }
                  const r = new (s("xOOu"))(),
                    o = [
                      this.collectLDBLogs(),
                      this.collectLDBMetas(),
                      this.collectLDBModules(),
                    ];
                  Promise.all(o).then((s) => {
                    const [a, o, d] = s;
                    {
                      const e = `${Object(S.a)()}.zlog`;
                      r.file(e, a);
                    }
                    {
                      const e = `${Object(S.a)()}.meta`;
                      r.file(e, o);
                    }
                    {
                      const e = `${Object(S.a)()}.module`;
                      r.file(e, d);
                    }
                    {
                      const e = "device.zinfo",
                        t = new TextEncoder();
                      r.file(e, t.encode(this.clientDeviceInfo()).buffer);
                    }
                    r.generateAsync({
                      type: "arraybuffer",
                      compression: "DEFLATE",
                    })
                      .then((s) => {
                        if (e.bareContent)
                          t({
                            name: `zlog_${n}_${Date.now()}.zip`,
                            data: new Uint8Array(s),
                          });
                        else {
                          const e = new Blob([new Uint8Array(s)]);
                          (e.name = `zlog_${n}_${Date.now()}.zip`), t(e);
                        }
                      })
                      .catch((e) => {
                        i(e);
                      });
                  });
                });
              }
              async collectLDBLogs() {
                try {
                  const e = K.default.getInstance().ZLog,
                    t = (await e.Pages.getAll()).map((e) => e.data),
                    s = new Blob(t);
                  return await s.arrayBuffer();
                } catch (e) {
                  return (
                    T.a.error(
                      `VirtualFileWriterImpl.getAllPagesCombine err ${e}`,
                    ),
                    new ArrayBuffer(0)
                  );
                }
              }
              async collectLDBMetas() {
                try {
                  const e = K.default.getInstance().ZLog,
                    t = await e.Metas.get(0);
                  if (t) {
                    const e = new Blob([
                      JSON.stringify({
                        current: t.current,
                        currentPage: t.currentPage,
                        startups: t.startups,
                      }),
                    ]);
                    return await e.arrayBuffer();
                  }
                  return new ArrayBuffer(0);
                } catch (e) {
                  return (
                    T.a.error(
                      `VirtualFileWriterImpl.getAllPagesCombine err ${e}`,
                    ),
                    new ArrayBuffer(0)
                  );
                }
              }
              async collectLDBModules() {
                try {
                  const e = K.default.getInstance().ZLog,
                    t = await e.Modules.getAll();
                  if (t) {
                    const e = { size: 0 };
                    t.forEach((t) => {
                      (e[t.hash] = t.id), e.size++;
                    });
                    const s = new Blob([JSON.stringify(e)]);
                    return await s.arrayBuffer();
                  }
                  return new ArrayBuffer(0);
                } catch (e) {
                  return (
                    T.a.error(
                      `VirtualFileWriterImpl.getAllPagesCombine err ${e}`,
                    ),
                    new ArrayBuffer(0)
                  );
                }
              }
            }),
          ) || Oe;
        i.ModuleContainer.registerSingleton(Ce.a, Me);
        s("jw3m");
        var Se = s("q1tI"),
          Te = s.n(Se),
          we = s("i8i4"),
          Re = s.n(we),
          Le = s("Jcee");
        class De extends Le.b {
          constructor(e, t, s, i) {
            super(e, t, s),
              (this.container = void 0),
              (this.component = void 0),
              (this.container = i.container),
              (this.component = i.component);
          }
          async start() {
            await super.start(), this.render();
          }
          render() {
            Re.a.render(Te.a.createElement(this.component), this.container);
          }
        }
        let Fe, Ae;
        !(function (e) {
          (e.Idle = "Idle"), (e.Active = "Active");
        })(Fe || (Fe = {})),
          (function (e) {
            (e[(e.idle = 0)] = "idle"), (e[(e.active = 1)] = "active");
          })(Ae || (Ae = {}));
        class je extends te.b {
          constructor(e) {
            super(),
              (this.status = Ae.active),
              (this.window = void 0),
              (this.idleDelay = void 0),
              (this.minimumIdlePeriod = void 0),
              (this.lastIdleTime = void 0),
              (this.focusStateChangeDebounceTimer = void 0),
              (this.handleDocumentBlur = () => {
                this.resetFocusStateChangeDebounceTimer(),
                  (this.focusStateChangeDebounceTimer = setTimeout(() => {
                    this.setStateToIdle();
                  }, this.idleDelay));
              }),
              (this.handleDocumentFocus = () => {
                this.resetFocusStateChangeDebounceTimer(),
                  this.setStateToActive();
              }),
              (this.idleDelay = e.idleDelay),
              (this.minimumIdlePeriod = e.minimumIdlePeriod),
              (this.window = e.window || window),
              (this.lastIdleTime = 0),
              (this.focusStateChangeDebounceTimer = null);
          }
          start() {
            this.window.addEventListener("blur", this.handleDocumentBlur),
              this.window.addEventListener("focus", this.handleDocumentFocus);
          }
          stop() {
            this.window.removeEventListener("blur", this.handleDocumentBlur),
              this.window.removeEventListener(
                "focus",
                this.handleDocumentFocus,
              );
          }
          onIdle(e) {
            return this.addEventListener(Fe.Idle, e);
          }
          setStateToActive() {
            this.status !== Ae.idle ||
              ((this.status = Ae.active),
              this.dispatchEvent(new Event(Fe.Active)));
          }
          setStateToIdle() {
            if (this.status !== Ae.active) return;
            this.isThrottlingIdleState() ||
              ((this.lastIdleTime = Date.now()),
              (this.status = Ae.idle),
              this.dispatchEvent(new Event(Fe.Idle)));
          }
          isThrottlingIdleState() {
            return Date.now() - this.lastIdleTime < this.minimumIdlePeriod;
          }
          resetFocusStateChangeDebounceTimer() {
            this.focusStateChangeDebounceTimer &&
              (clearTimeout(this.focusStateChangeDebounceTimer),
              (this.focusStateChangeDebounceTimer = null));
          }
        }
        var Pe = s("wx14"),
          Ne = s("/MKj"),
          Ue = s("FK2X"),
          ke = s("emRR"),
          Be = s("xrk1"),
          Ge = s("ZBGy"),
          xe = s("T1Xd"),
          ze = s("uzdi");
        const Ve = Object(ze.a)();
        function He() {
          const e = Ve.useRecoilSnapshot();
          return Ve.setSnapShot(e), null;
        }
        var $e = s("QVmZ"),
          We = s("72hn"),
          Ke = s("ZlRg"),
          qe = s("VaDh"),
          Ze = s("CzFt"),
          Je = s("h0sc"),
          Qe = s("L+5E"),
          Ye = s("UiPd"),
          Xe = s("Yi2m"),
          et = s("6uTC"),
          tt = s("c51z"),
          st = s("sqm0"),
          it = s("NTw/");
        var nt = s("hI9i");
        const at = () => {
            const e = Object(Ne.f)(),
              t = Object(Ge.d)(e),
              s = Object(Ge.c)(),
              i = Object(Ne.g)((e) => ({
                user: e.user,
                popup: e.popup,
                status: e.status,
                profile: e.profile,
                zaviState: e.zaviState,
                chatview: e.chatview,
              }));
            return (
              ((e) => {
                const t = Object(Se.useCallback)(() => {
                    Je.ModalManagerV2.openModal({
                      windowId: "1",
                      name: R.ModalIdentitiesDefine.SETTINGS,
                      params: !0,
                      forceCloseAll: !0,
                    });
                  }, []),
                  s = Object(Se.useCallback)(() => {
                    Je.ModalManagerV2.openModal({
                      windowId: "1",
                      name: R.ModalIdentitiesDefine.APP_INFO,
                      params: !0,
                    });
                  }, []),
                  i = Object(Se.useCallback)((e, t) => {
                    Qe.a.doOpenZaviURL(t, "1");
                  }, []),
                  n = Object(Se.useCallback)((e, t) => {
                    var s;
                    st.a.setFlagCopyFromCapture(!!t && !!t.isCopyFromCap),
                      st.a.setTimeClipboardChanged(performance.now()),
                      null === (s = Object(it.b)()) ||
                        void 0 === s ||
                        s.setTimeClipboardChanged(performance.now());
                  }, []),
                  a = (t, s) => {
                    const i = Ye.default.getFriendsSync();
                    Qe.a.doActionWithUri(s, e, i);
                  },
                  r = (t, s) => {
                    let { term: i, data: n } = s;
                    switch (i) {
                      case "id":
                        Qe.a.autoOpenConversationById(n, e),
                          n.startsWith(R.GROUPID_PREFIX)
                            ? Xe.e.logAction(2220801)
                            : n.startsWith(R.OA_ID_PREFIX)
                              ? Xe.e.logAction(2220803)
                              : Xe.e.logAction(2220802);
                        break;
                      case "phone":
                        Xe.e.logAction(2220804),
                          Qe.a.autoOpenConversationByPhone(n, e);
                        break;
                      case "username":
                        Xe.e.logAction(2220805),
                          Qe.a.autoOpenConversationByUsername(n, e);
                        break;
                      default:
                        et.a.createError(tt.default.str("STR_GROUP_NO_EXIST"));
                    }
                  };
                Object(Se.useEffect)(
                  () => (
                    $zsub.$zuri.onNewRequest(a),
                    $zsub.$zuri.onRequestOpenConv(r),
                    () => {
                      $zsub.$zuri.removeListenNewRequest(a),
                        $zsub.$zuri.removeListenRequestOpenConv(r);
                    }
                  ),
                  [e],
                ),
                  Object(Se.useEffect)(() => {
                    $zsub.$zapp.onRequestShowPreference(t),
                      $zsub.$zapp.onRequestShowAbout(s),
                      $zsub.$zuri.onRequestOpenZavi(i),
                      $zsub.$zresource.onClipboardChange(n);
                  }, []);
              })(t),
              Te.a.createElement(
                Ue.c,
                Object(Pe.a)({ emitter: s, dispatch: t }, i),
              )
            );
          },
          rt = (function () {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
              t[s] = arguments[s];
            return (e) => {
              let { children: s } = e;
              return t.reduceRight((e, t) => {
                let [s, i = {}] = t;
                return Te.a.createElement(s, i, e);
              }, s);
            };
          })(
            [Ne.a, { store: ke.default }],
            [Ne.a, { store: Ze.a, context: Ze.b }],
            [Ne.a, { store: $e.a, context: We.a }],
            [Ne.a, { store: Ke.a, context: qe.a }],
            [Ne.a, { store: nt.b, context: nt.a }],
            [Ge.b],
            [Be.d],
            [xe.a],
          ),
          ot = () =>
            Te.a.createElement(
              rt,
              null,
              Te.a.createElement(He, null),
              Te.a.createElement(at, null),
            );
        var dt;
        let lt =
          Object(i.injectable)()(
            (dt =
              (function (e, t) {
                return Object(i.inject)(_.a)(e, void 0, 0);
              })(
                (dt =
                  (function (e, t) {
                    return Object(i.inject)(q.ZLoggerFactory)(e, void 0, 1);
                  })(
                    (dt =
                      Reflect.metadata(
                        "design:type",
                        Function,
                      )(
                        (dt =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === _.a ? Object : _.a,
                            void 0 === q.ZLoggerFactory
                              ? Object
                              : q.ZLoggerFactory,
                          ])(
                            (dt = class extends De {
                              constructor(e, t) {
                                super("zalo", e, t, {
                                  component: ot,
                                  container: document.getElementById("app"),
                                });
                              }
                              async start() {
                                this.setupIdleDetector(), await super.start();
                              }
                              setupIdleDetector() {
                                const e = this.config.get("idle_detector"),
                                  t = new je(e);
                                t.addEventListener(Fe.Idle, () => {
                                  this.setStateToIdle();
                                }),
                                  t.addEventListener(Fe.Active, () =>
                                    this.setStateToActive(),
                                  ),
                                  t.start(),
                                  this.disposables.add(() => t.stop()),
                                  document.hasFocus()
                                    ? this.setStateToActive()
                                    : this.setStateToIdle();
                              }
                            }),
                          ) || dt),
                      ) || dt),
                  ) || dt),
              ) || dt),
          ) || dt;
        i.ModuleContainer.registerSingleton(V.a, lt);
        var ct = s("sxU/"),
          ht = s("SZ0g");
        i.ModuleContainer.registerValue(
          ht.a,
          new (class {
            constructor() {
              (this._emitter = void 0), (this._emitter = ct.a.instance);
            }
            emit(e) {
              return this._emitter.emit(e.topic, e), Promise.resolve();
            }
            on(e, t) {
              return this._emitter.on(e, t), this;
            }
            off(e, t) {
              return this._emitter.off(e, t), this;
            }
          })(),
        );
        var ut = s("ahRi");
        var gt = s("ptxg"),
          mt = s("pUq9");
        let pt;
        (pt = class {
          getOverrideDomain(e) {}
          getDomainConfig() {
            return {};
          }
          setDomainConfig(e) {
            return this;
          }
          subscribe(e) {
            return () => {};
          }
        }),
          Object(i.injectable)()(pt),
          Object(i.singleton)(gt.a)(pt);
        var ft,
          vt,
          bt = s("NDmK"),
          It = s("qLo6");
        Object(V.e)()(
          (ft = class {
            onAuthenticated(e) {
              bt.default.e2ee.enable_wasm &&
                It.AesGcmWasmFactory.instance
                  .installAndTestWasm()
                  .then(() => {})
                  .catch((e) => {});
            }
          }),
        ),
          Object(V.e)()(
            (vt = class {
              onAuthenticated(e) {
                try {
                  WebAssembly.validate(
                    new Uint8Array([
                      0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2,
                      1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11,
                    ]),
                  )
                    ? B.default.increaseSuccess(97135, 0, 0)
                    : B.default.increaseFailed(97135, 0, 0, 0, 0);
                } catch {
                  B.default.increaseFailed(97135, 0, 0, 1, 0);
                }
              }
            }),
          );
        const yt = Object(i.define)("system-time");
        var _t = s("bUXd");
        i.ModuleContainer.registerSingleton(
          yt,
          class {
            getHourNow() {
              return new Date(_t.default.getTimeNow()).getHours();
            }
            getTimeNow() {
              return _t.default.getTimeNow();
            }
            getSystemTimeNow() {
              return _t.default.getSystemTimeNow();
            }
          },
        );
        s("o0oJ");
        var Ot = s("dThN"),
          Ct = s("z0WU"),
          Et = s("vSga");
        perf.record(perf.LOAD_APP_SCRIPT),
          (function () {
            window.__loadTimer && clearTimeout(window.__loadTimer);
            window.__startTime &&
              $zlogger.loadShellQos(Date.now() - window.__startTime);
          })();
        s("FcQj");
        var Mt = s("Ydol"),
          St = s("97kL"),
          Tt = s("eSGF");
        let wt;
        function Rt() {
          return (
            wt ||
              (wt = i.ModuleContainer.resolve(q.ZLoggerFactory).createZLogger(
                "utils",
                ["event-bus-effects"],
              )),
            wt
          );
        }
        const Lt = {
          [St.FetchActions.DELETE_EVERYONE]: (e, t) => {
            Dt(e.toUid, e.msgId);
          },
          [St.FetchActions.UNDO_MULTI]: (e, t) => {
            var s;
            null == e ||
              null === (s = e.forEach) ||
              void 0 === s ||
              s.call(e, (e) => Dt(e.toUid || e.userId, e.msgId));
          },
          [St.FetchActions.UNDO]: (e, t) => {
            Dt(e.toUid || e.userId, e.msgId);
          },
          [St.FetchActions.REMOVE_MEDIA]: (e, t) => {
            for (let s of e.items)
              Dt(
                null == e ? void 0 : e.conversationId,
                null == s ? void 0 : s.msgId,
              );
          },
          [St.ChatBoxActions.REMOVE_EXPIRED_MEDIA]: (e, t) => {
            Dt(
              null == e ? void 0 : e.conversationId,
              (null == e ? void 0 : e.msgIds) || (null == e ? void 0 : e.msgId),
            );
          },
          [St.ChatBoxActions.DELETE_MESSAGE]: (e, t) => {
            const s =
              e.toUid || e.userId || (e.conversation && e.conversation.userId);
            s !== bt.default.sendToMeId && Dt(s, e.msgId);
          },
        };
        function Dt(e, t) {
          if (!e) return;
          if (!t) return;
          let s = Object(Tt.a)(t);
          ct.a.instance.emit("media-removed", { convId: e, msgIds: s });
        }
        Mt.default.subscribe(function (e, t) {
          let s = Lt[e];
          if (s)
            try {
              s(t, e);
            } catch (i) {
              Rt().zsymb(
                18,
                10277,
                3e4,
                "Failed to run side effect for event:" + e,
              ),
                Rt().zsymb(18, 10277, 30001, [i]);
            }
        });
        var Ft = s("2ua2");
        s.p;
        Ft.a.init(), Ct.default.checkSupport(), Ct.default.showWarningMsg();
        var At,
          jt = s("Kvb3"),
          Pt = s("QPNp"),
          Nt = s("Y4eg"),
          Ut = s("+2cI");
        Object(i.singleton)(jt.a)(
          (At =
            Object(V.e)()(
              (At =
                Reflect.metadata(
                  "design:type",
                  Function,
                )(
                  (At =
                    Reflect.metadata(
                      "design:paramtypes",
                      [],
                    )(
                      (At = class {
                        constructor() {
                          (this._isConnectSignalChangeInfo = void 0),
                            (this._dispatch = void 0),
                            (this._authEvent = void 0),
                            (this._isConnectSignalChangeInfo = !1),
                            (this.signalInfoChange =
                              this.signalInfoChange.bind(this));
                        }
                        isWeb() {
                          return !0;
                        }
                        bindDispatch(e) {
                          this._dispatch = e;
                        }
                        getDispatch() {
                          return this._dispatch;
                        }
                        async preFormatPayload(e) {
                          let t = Object(f.a)({}, e);
                          if (t.conversation) {
                            var s, i;
                            if (
                              null === (s = t.conversation.userId) ||
                              void 0 === s ||
                              null === (i = s.startsWith) ||
                              void 0 === i
                                ? void 0
                                : i.call(s, R.GROUPID_PREFIX)
                            ) {
                              const e = t.conversation.userId,
                                s = await Pt.a.GroupManager.get(e);
                              if (
                                (s &&
                                  ((t.conversation.topMember = s.topMembers),
                                  (t.conversation.displayName = s.displayName)),
                                t.conversation.topMember)
                              )
                                for (const i of t.conversation.topMember) {
                                  const e = Ye.default.getMiniInfo(i.id);
                                  e &&
                                    ((i.dName = e.dName),
                                    (i.avatar = e.avatar));
                                }
                            } else {
                              const e = Ye.default.getMiniInfo(
                                t.conversation.userId,
                              );
                              e &&
                                ((t.conversation.displayName = e.dName),
                                (t.conversation.avatar = e.avatar));
                            }
                          }
                          return t;
                        }
                        signalInfoChange(e) {
                          this.isWeb();
                        }
                        connectSignalToFriendWorker() {
                          this._isConnectSignalChangeInfo ||
                            ((this._isConnectSignalChangeInfo = !0),
                            Ye.default.connectSignalChangeDNameAndAvatar(
                              this.signalInfoChange,
                            ));
                        }
                        onAuthenticated(e) {
                          this._authEvent = e;
                        }
                        _addSession(e) {
                          var t;
                          return (
                            ((e = Object(f.a)({}, e)).session =
                              null === (t = this._authEvent) || void 0 === t
                                ? void 0
                                : t.getSession()),
                            e
                          );
                        }
                        async openPhotoViewer(e) {
                          let t = await this.preFormatPayload(e);
                          (t = this._addSession(t)),
                            this.connectSignalToFriendWorker();
                          const s = this.getDispatch();
                          s &&
                            s({
                              type: St.ChatBoxActions.SHOW_FULL_IMAGE,
                              payload: t,
                            }),
                            Nt.a.initLog(),
                            Ut.a.startSession();
                        }
                        async openImageCaptionEditor(e) {
                          let t = await this.preFormatPayload(e);
                          (t = this._addSession(t)),
                            this.connectSignalToFriendWorker();
                          const s = this.getDispatch();
                          s &&
                            s({
                              type: St.ChatBoxActions.SHOW_MEDIA_CAPTION_EDITOR,
                              payload: t,
                            });
                        }
                      }),
                    ) || At),
                ) || At),
            ) || At),
        );
        var kt,
          Bt = s("vQ8b"),
          Gt = s("smi1"),
          xt = s("gEkt"),
          zt = s("yzMR");
        let Vt =
          Object(i.injectable)()(
            (kt =
              (function (e, t) {
                return i.ModuleContainer.inject(zt.j)(e, void 0, 0);
              })(
                (kt =
                  (function (e, t) {
                    return i.ModuleContainer.inject(zt.i)(e, void 0, 1);
                  })(
                    (kt =
                      Reflect.metadata(
                        "design:type",
                        Function,
                      )(
                        (kt =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === zt.j ? Object : zt.j,
                            void 0 === zt.i ? Object : zt.i,
                          ])(
                            (kt = class {
                              constructor(e, t) {
                                (this.unreadDataManager = e),
                                  (this.previewManager = t),
                                  (this.menuRef = void 0),
                                  (this.menuRef = {});
                              }
                              deleteConversation(e, t) {
                                void 0 === t && (t = !0),
                                  e != R.CONV_FILTER.STRANGER &&
                                    (Ct.default.logCoreError(
                                      `[user call del conv] ${e}`,
                                    ),
                                    Gt.default
                                      .deleteConversation(e, t)
                                      .then((e) => {
                                        e &&
                                          e.delConversationId &&
                                          Object(Ge.f)({
                                            type: St.ConversationListActions
                                              .TAG_CONV,
                                            payload: {
                                              data: [
                                                {
                                                  userId: e.delConversationId,
                                                  label: null,
                                                },
                                              ],
                                            },
                                          });
                                      })
                                      .catch((e) => {
                                        Ct.default.logCoreError(
                                          "Delete conversation fail - " +
                                            JSON.stringify(e),
                                        );
                                      }));
                              }
                              bindUIMenu(e, t) {
                                this.menuRef[e] = t;
                              }
                              cleanUpUIMenu(e) {
                                this.menuRef[e] = null;
                              }
                              showMenu(e, t, s) {
                                if (this.menuRef[e] && e === xt.b)
                                  this.showConvActionMenu(t, s);
                              }
                              hideMenu(e) {
                                this.menuRef[e] && this.menuRef[e].close();
                              }
                              showConvActionMenu(e, t) {
                                if (t && t.friendItem) return;
                                const s = Object(f.a)({}, t),
                                  i = s.userId;
                                if (s && !Ct.default.isFakeId(i)) {
                                  const e =
                                      this.previewManager.getPreviewByIDSync(i),
                                    t =
                                      Ye.default.getProfileFriendByIdSync(i) ||
                                      {},
                                    n =
                                      this.unreadDataManager.getUnreadByConvIdSync(
                                        i,
                                      );
                                  (s.lastMessage =
                                    null == e ? void 0 : e.message),
                                    (s.isFr = t.isFr),
                                    (s.type = t.type),
                                    (s.unreadMark =
                                      null == n ? void 0 : n.unreadMark),
                                    (s.smsUnreadCount =
                                      null == n ? void 0 : n.smsUnreadCount);
                                }
                                this.menuRef[xt.b].updateTargetInfo(s),
                                  this.menuRef[xt.b].showAction(
                                    Object(f.a)({}, e),
                                  );
                              }
                            }),
                          ) || kt),
                      ) || kt),
                  ) || kt),
              ) || kt),
          ) || kt;
        var Ht,
          $t = s("rCQs"),
          Wt = s("iZzu"),
          Kt = s("6Vk1"),
          qt = s("RojW"),
          Zt = s("rXIX"),
          Jt = s("EFQ6"),
          Qt = s("3xbP"),
          Yt = s("l+Gc"),
          Xt = s("VTLO"),
          es = s("LJTV"),
          ts = s("Enw1"),
          ss = s("M7kw"),
          is = s("Ws4b"),
          ns = s("Ja3U"),
          as = s("SdS7"),
          rs = s("WQAo"),
          os = s("TeAh"),
          ds = s("Gm1y"),
          ls = s("P6UB"),
          cs = s("FEfs"),
          hs = s("h0S/");
        const us = {
            typeFilter: Wt.FilterType.ALL,
            labelFilters: [],
            loaded: !1,
            isEnableArchivedChat: !!cs.a.isEnableArchivedChat(),
            hasUnreadArchivedChat: !1,
            typeFilterSrc: Wt.FilterSrcType.ALL,
          },
          gs = "z_sendtome_bubbledot";
        Object($t.b)(Wt.ConvListController)(
          (Ht =
            (function (e, t) {
              return i.ModuleContainer.inject(zt.b)(e, void 0, 0);
            })(
              (Ht =
                (function (e, t) {
                  return i.ModuleContainer.inject(Kt.b)(e, void 0, 1);
                })(
                  (Ht =
                    (function (e, t) {
                      return i.ModuleContainer.inject(zt.j)(e, void 0, 2);
                    })(
                      (Ht =
                        (function (e, t) {
                          return i.ModuleContainer.inject(zt.g)(e, void 0, 3);
                        })(
                          (Ht =
                            (function (e, t) {
                              return i.ModuleContainer.inject(zt.h)(
                                e,
                                void 0,
                                4,
                              );
                            })(
                              (Ht =
                                (function (e, t) {
                                  return i.ModuleContainer.inject(zt.a)(
                                    e,
                                    void 0,
                                    5,
                                  );
                                })(
                                  (Ht =
                                    Reflect.metadata(
                                      "design:type",
                                      Function,
                                    )(
                                      (Ht =
                                        Reflect.metadata("design:paramtypes", [
                                          void 0 === zt.b ? Object : zt.b,
                                          void 0 === Kt.b ? Object : Kt.b,
                                          void 0 === zt.j ? Object : zt.j,
                                          void 0 === zt.g ? Object : zt.g,
                                          void 0 === zt.h ? Object : zt.h,
                                          void 0 === zt.a ? Object : zt.a,
                                        ])(
                                          (Ht = class extends te.b {
                                            constructor(e, t, s, i, n, a) {
                                              var r;
                                              super(),
                                                (r = this),
                                                (this.convDataManager = e),
                                                (this.labelDataManager = t),
                                                (this.unreadDataManager = s),
                                                (this.muteDataManager = i),
                                                (this.pinDataManager = n),
                                                (this.archivedChatManager = a),
                                                (this.typeFilter = void 0),
                                                (this.labelFilters = void 0),
                                                (this.listRawAll = void 0),
                                                (this.listVisible = void 0),
                                                (this.listStrangers = void 0),
                                                (this.listHiddens = void 0),
                                                (this.listFiltered = void 0),
                                                (this.newestStrangerId =
                                                  void 0),
                                                (this.menuRef = void 0),
                                                (this.convUIListContainer =
                                                  void 0),
                                                (this.showedOnboarding =
                                                  void 0),
                                                (this.loaded = void 0),
                                                (this.isEnableArchivedChat =
                                                  void 0),
                                                (this.typeFilterSrc = void 0),
                                                (this.hasUnreadArchivedChat =
                                                  void 0),
                                                (this._logger = void 0),
                                                (this._pm = null),
                                                (this._sbc = null),
                                                (this.handleMuteChange = (
                                                  e,
                                                ) => {
                                                  const t = e.convId,
                                                    s = e.payload,
                                                    i =
                                                      this.listFiltered.includes(
                                                        t,
                                                      );
                                                  this.logger.zsymb(
                                                    0,
                                                    16624,
                                                    30002,
                                                    "handleMuteChange",
                                                    t,
                                                    i,
                                                    this.typeFilter,
                                                    s,
                                                  ),
                                                    i &&
                                                      (this.typeFilter ===
                                                        Wt.FilterType.UNREAD ||
                                                        (this
                                                          .isEnableArchivedChat &&
                                                          this.typeFilterSrc ===
                                                            Wt.FilterSrcType
                                                              .UNREAD)) &&
                                                      this.addConvToUnreadFilterV2(
                                                        t,
                                                      );
                                                }),
                                                (this.deleteConversation =
                                                  function (e, t) {
                                                    void 0 === t && (t = !0),
                                                      e !=
                                                        R.CONV_FILTER
                                                          .STRANGER &&
                                                        (r.logger.zsymb(
                                                          18,
                                                          16624,
                                                          30006,
                                                          `[user call del conv] ${e}`,
                                                        ),
                                                        Gt.default
                                                          .deleteConversation(
                                                            e,
                                                            t,
                                                          )
                                                          .then((e) => {
                                                            e &&
                                                              e.delConversationId &&
                                                              Object(Ge.f)({
                                                                type: St
                                                                  .ConversationListActions
                                                                  .TAG_CONV,
                                                                payload: {
                                                                  data: [
                                                                    {
                                                                      userId:
                                                                        e.delConversationId,
                                                                      label:
                                                                        null,
                                                                    },
                                                                  ],
                                                                },
                                                              });
                                                          })
                                                          .catch((e) => {
                                                            r.logger.zsymb(
                                                              18,
                                                              16624,
                                                              30007,
                                                              "Delete conversation fail - " +
                                                                JSON.stringify(
                                                                  e,
                                                                ),
                                                            );
                                                          }));
                                                  }),
                                                (this.name =
                                                  Wt.CONV_LIST_CONTROLLER),
                                                (this.data = new Map()),
                                                (this.key = "windowId"),
                                                (this.isEnableArchivedChat =
                                                  !1),
                                                (this.typeFilter =
                                                  Wt.FilterType.ALL),
                                                (this.labelFilters = []),
                                                (this.typeFilterSrc =
                                                  Wt.FilterSrcType.ALL),
                                                (this.listRawAll = new Set()),
                                                (this.listVisible = []),
                                                (this.listStrangers = []),
                                                (this.listHiddens = []),
                                                (this.listFiltered = []),
                                                (this.newestStrangerId = ""),
                                                (this.menuRef = {}),
                                                (this.showedOnboarding = !1),
                                                (this.loaded = !1),
                                                (this.hasUnreadArchivedChat =
                                                  !1),
                                                (this.getRecentContactWithId =
                                                  this.getRecentContactWithId.bind(
                                                    this,
                                                  )),
                                                (this.selectConversation =
                                                  this.selectConversation.bind(
                                                    this,
                                                  )),
                                                (this.showBroadCastMsgModal =
                                                  this.showBroadCastMsgModal.bind(
                                                    this,
                                                  )),
                                                (this.markAsRead =
                                                  this.markAsRead.bind(this)),
                                                this.addListener();
                                            }
                                            get logger() {
                                              return (
                                                this._logger ||
                                                  (this._logger =
                                                    i.ModuleContainer.resolve(
                                                      q.ZLoggerFactory,
                                                    ).createZLogger(
                                                      hs.ZLoggerNametags
                                                        .conversation,
                                                      [
                                                        hs.ZLoggerNametags
                                                          .convList,
                                                      ],
                                                    )),
                                                this._logger
                                              );
                                            }
                                            get previewManager() {
                                              return (
                                                this._pm ||
                                                  (this._pm =
                                                    i.ModuleContainer.resolve(
                                                      zt.i,
                                                    )),
                                                this._pm
                                              );
                                            }
                                            get sidebarController() {
                                              return (
                                                this._sbc ||
                                                  (this._sbc =
                                                    i.ModuleContainer.resolve(
                                                      Wt.SidebarController,
                                                    )),
                                                this._sbc
                                              );
                                            }
                                            get currUser() {
                                              return Object(is.c)();
                                            }
                                            onTypeFilterChange(e, t) {
                                              if (e === Wt.FilterType.UNREAD) {
                                                const e =
                                                  this.labelFilters.length > 0
                                                    ? 1453215
                                                    : 1453214;
                                                Xe.e.logAction(e),
                                                  setTimeout(() => {
                                                    this.scrollToTop(!1);
                                                  });
                                              } else
                                                (e !== Wt.FilterType.ARCHIVED &&
                                                  e !==
                                                    Wt.FilterType.FOCUSED) ||
                                                  this.typeFilter === e ||
                                                  setTimeout(() => {
                                                    this.scrollToTop(!1);
                                                  });
                                              e == Wt.FilterType.ARCHIVED &&
                                                this.hasUnreadArchivedChat &&
                                                (this.hasUnreadArchivedChat =
                                                  !1),
                                                this.applyTypeFilter(e, t);
                                            }
                                            onLabelFilterChange(e) {
                                              this.typeFilter ===
                                                Wt.FilterType.UNREAD &&
                                                setTimeout(() => {
                                                  this.scrollToTop(!1);
                                                }),
                                                this.applyLabelFilter(e);
                                            }
                                            rerenderList() {
                                              this.signalRenderList();
                                            }
                                            async onPreviewChange(e, t) {
                                              if (!e || !t) return;
                                              const s = e.convId;
                                              if (
                                                (this.listRawAll.add(s),
                                                Jt.a.isThreadHidden(s))
                                              )
                                                return void (
                                                  this.listHiddens.includes(
                                                    s,
                                                  ) || this.listHiddens.push(s)
                                                );
                                              let i = s,
                                                n = !1,
                                                a = !1,
                                                r = !1;
                                              if (await qt.a.isOATypeAsync(s)) {
                                                const e =
                                                  this.convDataManager.getConvByIdSync(
                                                    s,
                                                  );
                                                if (!e || !qt.a.popoutOA(e))
                                                  return;
                                              } else if (
                                                qt.a.isStrangerV2(s) &&
                                                ((n = !0),
                                                this.listStrangers.includes(
                                                  s,
                                                ) ||
                                                  (this.logger.zsymb(
                                                    0,
                                                    16624,
                                                    30001,
                                                    `first new stranger msg ${s}`,
                                                  ),
                                                  this.listStrangers.push(s)),
                                                !this.isUnboxStrangerAccount())
                                              ) {
                                                const t =
                                                    "0" == e.fromUid ||
                                                    this.convDataManager.isRespondedByMeSync(
                                                      s,
                                                    ),
                                                  n =
                                                    this.listVisible.includes(
                                                      s,
                                                    );
                                                t ||
                                                  (n &&
                                                    ((r = !0),
                                                    (this.listVisible =
                                                      this.listVisible.filter(
                                                        (e) => e !== s,
                                                      ))),
                                                  this.updateNewestStrangerId(
                                                    this.listStrangers,
                                                  ),
                                                  (i = R.CONV_FILTER.STRANGER)),
                                                  t &&
                                                    !n &&
                                                    ((a = !0),
                                                    this.listVisible.unshift(s),
                                                    this.newestStrangerId ===
                                                      s &&
                                                      this.updateNewestStrangerId(
                                                        this.listStrangers,
                                                      ));
                                              }
                                              const [o, d] =
                                                qt.a.insertToProperPosition(
                                                  this.listVisible,
                                                  i,
                                                  this.getAlterId(),
                                                );
                                              (this.listVisible = o),
                                                e.msgId !==
                                                  R.FAKE_DRAFT_MSG_ID ||
                                                  e.draft ||
                                                  ((this.listVisible =
                                                    this.listVisible.filter(
                                                      (e) => e !== s,
                                                    )),
                                                  (r = !0));
                                              const l =
                                                  Yt.b.getLabelObjByConversaionId(
                                                    s,
                                                  ),
                                                c =
                                                  l &&
                                                  l.id &&
                                                  this.labelFilters.includes(
                                                    "" + l.id,
                                                  ),
                                                h =
                                                  n &&
                                                  this.labelFilters.includes(
                                                    xt.g,
                                                  ),
                                                u = c || h,
                                                g = d || a || r;
                                              if (
                                                this.typeFilter ===
                                                Wt.FilterType.ALL
                                              )
                                                this.addTabAllFiltered(s, u, g);
                                              else if (
                                                this.typeFilter ===
                                                Wt.FilterType.UNREAD
                                              )
                                                this.addTabUnreadFiltered(
                                                  s,
                                                  u,
                                                  n,
                                                );
                                              else if (
                                                this.typeFilter ===
                                                Wt.FilterType.STRANGER
                                              ) {
                                                const e =
                                                    c ||
                                                    !this.labelFilters.length,
                                                  t = n && e;
                                                this.addTabStrangerFiltered(
                                                  s,
                                                  t,
                                                );
                                              } else
                                                this.isEnableArchivedChat &&
                                                  ((this.listFiltered =
                                                    this.genListArchivedChat(
                                                      this.listVisible,
                                                      this.typeFilter ===
                                                        Wt.FilterType.ARCHIVED,
                                                      this.labelFilters,
                                                    )),
                                                  this.signalRenderList());
                                            }
                                            addTabAllFiltered(e, t, s) {
                                              if (t) {
                                                const [t, s] =
                                                  qt.a.insertToProperPosition(
                                                    this.listFiltered,
                                                    e,
                                                    this.getAlterId(),
                                                  );
                                                s &&
                                                  ((this.listFiltered = t),
                                                  this.signalRenderList());
                                              } else
                                                s && this.signalRenderList();
                                            }
                                            addTabUnreadFiltered(e, t, s) {
                                              if (
                                                this.listFiltered.includes(e) ||
                                                !ls.b.isMyMessage(
                                                  this.previewManager.getPreviewByIDSync(
                                                    e,
                                                  ),
                                                )
                                              )
                                                if (t)
                                                  this.addConvToUnreadFilterV2(
                                                    e,
                                                  );
                                                else {
                                                  if (this.labelFilters.length)
                                                    return;
                                                  this.isUnboxStrangerAccount() ||
                                                  !s
                                                    ? this.addConvToUnreadFilterV2(
                                                        e,
                                                      )
                                                    : this.addConvToUnreadFilterV2(
                                                        R.CONV_FILTER.STRANGER,
                                                      );
                                                }
                                            }
                                            addTabStrangerFiltered(e, t) {
                                              if (!t) return;
                                              const [s, i] =
                                                qt.a.insertToProperPosition(
                                                  this.listFiltered,
                                                  e,
                                                  this.getAlterId(),
                                                );
                                              i &&
                                                ((this.listFiltered = s),
                                                this.signalRenderList());
                                            }
                                            addConvToUnreadFilterV2(e) {
                                              if (
                                                this.muteDataManager.isMuted(
                                                  e,
                                                ) &&
                                                !qt.a.getPinFromConvId(e)
                                              )
                                                (this.listFiltered =
                                                  this.safeSortConvList(
                                                    this.listFiltered,
                                                    !1,
                                                  )),
                                                  this.signalRenderList();
                                              else {
                                                const [t, s] =
                                                  qt.a.insertToProperPosition(
                                                    this.listFiltered,
                                                    e,
                                                    this.getAlterId(),
                                                  );
                                                s &&
                                                  ((this.listFiltered = t),
                                                  this.signalRenderList());
                                              }
                                            }
                                            onPinChange(e) {
                                              let t = !1;
                                              for (
                                                let s = 0;
                                                s < e.length;
                                                s++
                                              ) {
                                                const i = e[s].priority,
                                                  n = e[s].id;
                                                i
                                                  ? (this.onPreviewChange(
                                                      { convId: n },
                                                      [],
                                                    ),
                                                    (t = !1))
                                                  : ((t = !0),
                                                    (!this.previewManager.getPreviewByIDSync(
                                                      n,
                                                    ) ||
                                                      (!this.convDataManager.isRespondedByMeSync(
                                                        n,
                                                      ) &&
                                                        qt.a.isStrangerV2(
                                                          n,
                                                        ))) &&
                                                      (this.listVisible =
                                                        this.listVisible.filter(
                                                          (e) => e !== n,
                                                        )));
                                              }
                                              t &&
                                                ((this.listVisible =
                                                  this.safeSortConvList(
                                                    this.listVisible,
                                                    !1,
                                                  )),
                                                (this.typeFilter !==
                                                  Wt.FilterType.ALL ||
                                                  this.labelFilters.length) &&
                                                  (this.listFiltered =
                                                    qt.a.sortConvId(
                                                      this.listFiltered,
                                                      !1,
                                                      !0,
                                                    ))),
                                                this.signalRenderList();
                                            }
                                            onHiddenChat(e, t) {
                                              const s =
                                                this.convDataManager.getConvByIdSync(
                                                  e,
                                                );
                                              if (
                                                (this.logger.zsymb(
                                                  0,
                                                  16624,
                                                  30003,
                                                  "onHiddenChat ",
                                                  e,
                                                  t,
                                                  !!s,
                                                ),
                                                t)
                                              )
                                                this.listHiddens.push(e),
                                                  (this.listVisible =
                                                    this.listVisible.filter(
                                                      (t) => t !== e,
                                                    )),
                                                  (this.listFiltered =
                                                    this.listFiltered.filter(
                                                      (t) => t !== e,
                                                    )),
                                                  this.signalRenderList();
                                              else {
                                                if (
                                                  !s &&
                                                  !Pt.a.PinDataManager.isPinned(
                                                    e,
                                                  )
                                                )
                                                  return;
                                                if (
                                                  ((this.listHiddens =
                                                    this.listHiddens.filter(
                                                      (t) => t !== e,
                                                    )),
                                                  this.isUnboxStrangerAccount() ||
                                                    !qt.a.isStrangerV2(e) ||
                                                    this.listStrangers.includes(
                                                      e,
                                                    ))
                                                ) {
                                                  const [t, s] =
                                                    qt.a.insertToProperPosition(
                                                      this.listVisible,
                                                      e,
                                                      this.getAlterId(),
                                                    );
                                                  this.listVisible = t;
                                                } else
                                                  this.listStrangers.push(e);
                                                if (this.listFiltered) {
                                                  const [t, s] =
                                                    qt.a.insertToProperPosition(
                                                      this.listFiltered,
                                                      e,
                                                      this.getAlterId(),
                                                    );
                                                  (this.listFiltered = t),
                                                    this.isEnableArchivedChat &&
                                                      (this.listFiltered =
                                                        this.genListArchivedChat(
                                                          this.listVisible,
                                                          this.typeFilter ===
                                                            Wt.FilterType
                                                              .ARCHIVED,
                                                          this.labelFilters,
                                                        ));
                                                }
                                              }
                                              this.signalRenderList();
                                            }
                                            getCurrentFilter() {
                                              return {
                                                type: this.typeFilter,
                                                labels: this.labelFilters,
                                              };
                                            }
                                            getRecentContacts() {
                                              const e = [];
                                              return (
                                                this.listRawAll.forEach((t) => {
                                                  const s =
                                                    this.convDataManager.getConvByIdSync(
                                                      t,
                                                    );
                                                  s && e.push(s);
                                                }),
                                                e
                                              );
                                            }
                                            getRecentContactWithId(e) {
                                              if (this.listRawAll.has(e)) {
                                                return (
                                                  this.convDataManager.getConvByIdSync(
                                                    e,
                                                  ) || null
                                                );
                                              }
                                              return null;
                                            }
                                            addConvToLabel(e, t) {
                                              let s = Yt.b.getItem(t);
                                              Je.ModalManagerV2.openModal({
                                                windowId: Qt.c,
                                                name: R.ModalIdentitiesDefine
                                                  .MANAGE_LABEL,
                                                params: {
                                                  view: Xt.b.ADD_CONVERSATION,
                                                  info: s,
                                                },
                                              }),
                                                e &&
                                                  (e.preventDefault(),
                                                  e.stopPropagation()),
                                                Xe.e.logAction(14521);
                                            }
                                            selectConversation(e) {
                                              if (
                                                (es.b.startPerf(es.a),
                                                e.userId ===
                                                  R.CONV_FILTER.MEDIA)
                                              )
                                                return void this.logger.zsymb(
                                                  18,
                                                  16624,
                                                  30004,
                                                  "No handler for mediabox. This feat disable!!!",
                                                );
                                              if (
                                                e.userId ===
                                                R.CONV_FILTER.STRANGER
                                              )
                                                return void (2 ==
                                                Number(
                                                  Ee.default.getConvUXVersion(),
                                                )
                                                  ? this.applyTypeFilter(
                                                      Wt.FilterType.STRANGER,
                                                    )
                                                  : this.labelDataManager.onSelectLabel(
                                                      xt.g,
                                                    ));
                                              const t =
                                                this.sidebarController.getState(
                                                  Qt.c,
                                                ).selectedId;
                                              e.userId === t &&
                                              e.userId !==
                                                R.FAKE_CONVERSATION_ID
                                                  .FRIEND_CENTER
                                                ? Object(Ge.f)({
                                                    type: St
                                                      .ConversationListActions
                                                      .SELECT_CONV_MINOR,
                                                    payload: e,
                                                  })
                                                : (this.convUIListContainer &&
                                                    this.convUIListContainer.focus(),
                                                  e.userId ===
                                                    bt.default.sendToMeId &&
                                                    (ts.g.getFlagForCurrentUser(
                                                      this.currUser.userId,
                                                      gs,
                                                    ) ||
                                                      (Q.p.getHasShownSendToMeTip()
                                                        ? ts.g.setFlagForCurrentUser(
                                                            this.currUser
                                                              .userId,
                                                            gs,
                                                            1,
                                                          )
                                                        : setTimeout(() => {
                                                            Mt.default.send(
                                                              St
                                                                .ConversationListActions
                                                                .SHOW_BUBBLE_DOT,
                                                            ),
                                                              Q.p.setHasShownSendToMeTip(
                                                                !0,
                                                              );
                                                          }, 144e5)),
                                                    ss.b.getCurrentStepKey() !==
                                                      ss.a.UPLOAD_IMAGES ||
                                                      this.showedOnboarding ||
                                                      (ss.b.show(),
                                                      (this.showedOnboarding =
                                                        !0)),
                                                    Xe.e.logAction(13901)),
                                                  e.userId ===
                                                  R.FAKE_CONVERSATION_ID
                                                    .FRIEND_CENTER
                                                    ? Object(Ge.f)({
                                                        type: St.SideBarActions
                                                          .SELECT_FRIEND_CENTER,
                                                        payload: Object(f.a)(
                                                          {},
                                                          e,
                                                        ),
                                                      })
                                                    : i.ModuleContainer.resolve(
                                                        rs.b,
                                                      ).openConversation(
                                                        e.userId,
                                                        rs.c.fromConvItem(e),
                                                      )),
                                                this.logActionSelectConv(
                                                  e.userId,
                                                );
                                            }
                                            showBroadCastMsgModal() {
                                              var e;
                                              if (
                                                !Ee.default.checkBroadcastTime()
                                              )
                                                return void et.a.createError(
                                                  tt.default.str(
                                                    "STR_BROADCAST_OVER_LIMIT_TIP",
                                                  ),
                                                );
                                              let t = !0;
                                              1 === this.labelFilters.length &&
                                                (t =
                                                  Yt.b.getItem(
                                                    this.labelFilters[0],
                                                  ) || !0),
                                                null !==
                                                  (e =
                                                    bt.default
                                                      .broadcast_resend_config) &&
                                                void 0 !== e &&
                                                e.enable
                                                  ? Je.ModalManagerV2.openModal(
                                                      {
                                                        windowId: Qt.c,
                                                        name: R
                                                          .ModalIdentitiesDefine
                                                          .BROADCAST_RESEND,
                                                        params: t,
                                                      },
                                                    )
                                                  : Je.ModalManagerV2.openModal(
                                                      {
                                                        windowId: Qt.c,
                                                        name: R
                                                          .ModalIdentitiesDefine
                                                          .BROADCAST_COMPSE,
                                                        params: { label: t },
                                                      },
                                                    ),
                                                Xe.e.logAction(1453102);
                                            }
                                            markAsRead(e, t) {
                                              void 0 === t && (t = null),
                                                e &&
                                                  (e.preventDefault(),
                                                  e.stopPropagation()),
                                                Xe.e.logAction(164),
                                                Ee.default.isShowMarkAsReadAgain()
                                                  ? ns.ConfirmManagerV2.openConfirm(
                                                      {
                                                        windowId: Qt.c,
                                                        name: R.MODAL_CONFIRM
                                                          .confirmIdentities,
                                                        params: {
                                                          message:
                                                            tt.default.str(
                                                              "STR_MARK_READ_CONFIRM_TEXT",
                                                            ),
                                                          okText:
                                                            tt.default.str(
                                                              "STR_CONFIRM",
                                                            ),
                                                          okType: "primary",
                                                          cancelText:
                                                            tt.default.str(
                                                              "STR_LOGOUT_NO",
                                                            ),
                                                          onOk: (e) => {
                                                            Ee.default.setShowMarkAsReadAgain(
                                                              !(
                                                                e &&
                                                                e.dont_show_mark_as_read
                                                              ),
                                                            ),
                                                              this.markConvsAsRead(
                                                                t,
                                                              );
                                                          },
                                                          options: [
                                                            {
                                                              default_val: !1,
                                                              key: "dont_show_mark_as_read",
                                                              title:
                                                                "STR_DONT_SHOW_AGAIN",
                                                            },
                                                          ],
                                                        },
                                                      },
                                                    )
                                                  : this.markConvsAsRead(t);
                                            }
                                            scrollToTop(e) {
                                              const t = as.b
                                                .instance()
                                                .getConvList();
                                              t && t.scrollToTop(e);
                                            }
                                            scrollToConv(e) {
                                              const t = as.b
                                                .instance()
                                                .getConvList();
                                              t && t.scrollToConversation(e);
                                            }
                                            openInNewWindow(e, t) {
                                              if (!e || !e.userId) return;
                                              const s = this.menuRef[xt.b];
                                              s &&
                                                s.openInNewWindow &&
                                                (s.updateTargetInfo(e),
                                                s.openInNewWindow(t));
                                            }
                                            getStrangerInfo() {
                                              let e = "";
                                              if (this.newestStrangerId) {
                                                const t =
                                                  this.previewManager.getPreviewByIDSync(
                                                    this.newestStrangerId,
                                                  );
                                                e = t ? t.messageTime : "";
                                              }
                                              return (
                                                this.logger.zsymb(
                                                  0,
                                                  16624,
                                                  30005,
                                                  "getStrangerInfo ",
                                                  this.newestStrangerId,
                                                  e,
                                                ),
                                                { messageTime: e }
                                              );
                                            }
                                            getTopMostConv() {
                                              return this.typeFilter !==
                                                Wt.FilterType.ALL ||
                                                this.labelFilters.length
                                                ? this.listFiltered[0]
                                                : this.listVisible[0];
                                            }
                                            isPreviewLoaded() {
                                              return this.loaded;
                                            }
                                            addListener() {
                                              setTimeout(() => {
                                                this.labelDataManager.addEventListener(
                                                  Kt.d.SelectedLabelChange,
                                                  (e) => {
                                                    this.onLabelFilterChange(
                                                      e.payload,
                                                    );
                                                  },
                                                ),
                                                  this.labelDataManager.addEventListener(
                                                    Kt.d.LabelAddConvs,
                                                    (e) => {
                                                      this.onLabelChangeConvs(
                                                        e.payload.labelId,
                                                        e.payload.convIds,
                                                        "add",
                                                      );
                                                    },
                                                  ),
                                                  this.labelDataManager.addEventListener(
                                                    Kt.d.LabelRemoveConvs,
                                                    (e) => {
                                                      this.onLabelChangeConvs(
                                                        e.payload.labelId,
                                                        e.payload.convIds,
                                                        "remove",
                                                      );
                                                    },
                                                  );
                                                const e =
                                                  i.ModuleContainer.resolve(
                                                    zt.i,
                                                  );
                                                e.addEventListener(
                                                  Zt.b.DoneLoadPreview,
                                                  (e) => {
                                                    this.onLoadPreview(
                                                      e.payload,
                                                    );
                                                  },
                                                ),
                                                  e.addEventListener(
                                                    Zt.b.DoneMigratePreview,
                                                    () => {
                                                      this.onMigratedPreview();
                                                    },
                                                  ),
                                                  e.addEventListener(
                                                    Zt.b.PreviewChanged,
                                                    (e) => {
                                                      const {
                                                        changedItem: t,
                                                        all: s,
                                                      } = e.payload;
                                                      this.onPreviewChange(
                                                        t,
                                                        s,
                                                      );
                                                    },
                                                  ),
                                                  e.addEventListener(
                                                    Zt.b.DraftChanged,
                                                    (e) => {},
                                                  ),
                                                  this.convDataManager.addEventListener(
                                                    Zt.b.DeleteConv,
                                                    (e) => {
                                                      this.moveConvOutConvList(
                                                        e.convId,
                                                      );
                                                    },
                                                  ),
                                                  this.convDataManager.addEventListener(
                                                    Zt.b.EmptyConv,
                                                    (e) => {
                                                      this.moveConvOutConvList(
                                                        e.convId,
                                                      );
                                                    },
                                                  ),
                                                  this.convDataManager.addEventListener(
                                                    Zt.b.LeaveGroup,
                                                    (e) => {
                                                      this.moveConvOutConvList(
                                                        e.convId,
                                                      );
                                                    },
                                                  ),
                                                  this.pinDataManager.addEventListener(
                                                    Zt.b.ChangePinConv,
                                                    (e) => {
                                                      this.onPinChange(
                                                        e.payload,
                                                      );
                                                    },
                                                  ),
                                                  this.archivedChatManager.addEventListener(
                                                    Zt.b.UpdateListArchivedChat,
                                                    (e) => {
                                                      this.updateListArchivedChat();
                                                    },
                                                  ),
                                                  this.archivedChatManager.addEventListener(
                                                    Zt.b.OnOffArchivedChat,
                                                    (e) => {
                                                      this.onOffArchivedChat(
                                                        e.payload.status,
                                                      );
                                                    },
                                                  ),
                                                  this.unreadDataManager.addEventListener(
                                                    Zt.b
                                                      .ChangeUnreadArchiveChat,
                                                    (e) => {
                                                      this.updateUnreadArchivedChat(
                                                        e.payload
                                                          .hasUnreadArchivedChat,
                                                      );
                                                    },
                                                  ),
                                                  this.muteDataManager.addEventListener(
                                                    Zt.b.MuteChanged,
                                                    this.handleMuteChange,
                                                  ),
                                                  Ye.default.subscribeEventFriend(
                                                    R.EventFriend.ADD_FRIEND,
                                                    (e) => {
                                                      let { userId: t } = e,
                                                        s = 0;
                                                      this.listStrangers.includes(
                                                        t,
                                                      ) &&
                                                        (s++,
                                                        (this.listStrangers =
                                                          this.listStrangers.filter(
                                                            (e) => e !== t,
                                                          )),
                                                        t ==
                                                          this
                                                            .newestStrangerId &&
                                                          (s++,
                                                          this.updateNewestStrangerId(
                                                            this.listStrangers,
                                                          ))),
                                                        this.onPreviewChange(
                                                          { convId: t },
                                                          [],
                                                        );
                                                      const i =
                                                        Ye.default.isFriend(t);
                                                      this.logger.zsymb(
                                                        0,
                                                        16624,
                                                        30008,
                                                        `on add friend ${t} ${s} ${i}`,
                                                      );
                                                    },
                                                  ),
                                                  Ye.default.subscribeEventFriend(
                                                    R.EventFriend.REMOVE_FRIEND,
                                                    (e) => {
                                                      let { userId: t } = e,
                                                        s = 0;
                                                      !this.listStrangers.includes(
                                                        t,
                                                      ) &&
                                                        this.listVisible.some(
                                                          (e) => e === t,
                                                        ) &&
                                                        (s++,
                                                        this.listStrangers.push(
                                                          t,
                                                        )),
                                                        this.logger.zsymb(
                                                          0,
                                                          16624,
                                                          30009,
                                                          `on remove friend ${t} ${s}`,
                                                        );
                                                    },
                                                  ),
                                                  Ye.default.subscribeEventFriend(
                                                    R.EventFriend
                                                      .DOWNGRADE_BIZ_PROFILE,
                                                    () => {
                                                      this.handleUserPackageChange();
                                                    },
                                                  ),
                                                  Ye.default.subscribeEventFriend(
                                                    R.EventFriend
                                                      .UPGRADE_BIZ_PROFILE,
                                                    () => {
                                                      this.handleUserPackageChange();
                                                    },
                                                  );
                                              }, 0);
                                            }
                                            addToListFiltered(e, t) {
                                              void 0 === t && (t = !1),
                                                e.forEach((e) => {
                                                  if (t) {
                                                    const t =
                                                      this.unreadDataManager.getUnreadByConvIdSync(
                                                        e,
                                                      );
                                                    if (
                                                      !t ||
                                                      (!t.smsUnreadCount &&
                                                        !t.unreadMark)
                                                    )
                                                      return;
                                                  }
                                                  const [s] =
                                                    qt.a.insertToProperPosition(
                                                      this.listFiltered,
                                                      e,
                                                    );
                                                  this.listFiltered = s;
                                                });
                                            }
                                            applyTypeFilter(e, t) {
                                              if (
                                                (void 0 === t && (t = !1),
                                                this.typeFilter === e && !t)
                                              )
                                                return;
                                              this.logger.zsymb(
                                                0,
                                                16624,
                                                30010,
                                                "applyTypeFilter ",
                                                e,
                                                t,
                                              );
                                              const s = this.typeFilter;
                                              switch (
                                                ((this.typeFilter = e), e)
                                              ) {
                                                case Wt.FilterType.ALL:
                                                  if (
                                                    0 !==
                                                    this.labelFilters.length
                                                  ) {
                                                    if (
                                                      ((this.listFiltered =
                                                        qt.a.filterByLabel(
                                                          this.listVisible,
                                                          this.labelFilters,
                                                        )),
                                                      this.labelFilters.includes(
                                                        xt.g,
                                                      ))
                                                    ) {
                                                      let e =
                                                        this.listStrangers;
                                                      this.showStrangerNROnly() &&
                                                        (e =
                                                          qt.a.filterByResponsed(
                                                            e,
                                                            !1,
                                                          )),
                                                        this.addToListFiltered(
                                                          e,
                                                        );
                                                    } else
                                                      this.doAddStrangerHasLabel(
                                                        this.listFiltered,
                                                        this.labelFilters,
                                                      );
                                                    this.addLikeConvToFilterListV2(
                                                      this.listFiltered,
                                                      this.labelFilters,
                                                    );
                                                  }
                                                  break;
                                                case Wt.FilterType.UNREAD:
                                                  if (
                                                    0 !==
                                                    this.labelFilters.length
                                                  ) {
                                                    const e =
                                                      s == Wt.FilterType.ALL
                                                        ? this.listFiltered
                                                        : this.listVisible;
                                                    (this.listFiltered =
                                                      qt.a.filterByLabel(
                                                        e,
                                                        this.labelFilters,
                                                      )),
                                                      this.labelFilters.includes(
                                                        xt.g,
                                                      )
                                                        ? this.addToListFiltered(
                                                            this.listStrangers,
                                                          )
                                                        : this.doAddStrangerHasLabel(
                                                            this.listFiltered,
                                                            this.labelFilters,
                                                          ),
                                                      (this.listFiltered =
                                                        qt.a.filterByUnread(
                                                          this.listFiltered,
                                                        )),
                                                      (this.listFiltered =
                                                        qt.a.sortConvId(
                                                          this.listFiltered,
                                                          !1,
                                                          !0,
                                                        ));
                                                  } else
                                                    (this.listFiltered =
                                                      qt.a.filterByUnread(
                                                        this.listVisible,
                                                      )),
                                                      (this.listFiltered =
                                                        this.safeSortConvList(
                                                          this.listFiltered,
                                                          !1,
                                                        ));
                                                  break;
                                                case Wt.FilterType.STRANGER:
                                                  (this.listFiltered =
                                                    qt.a.filterByLabel(
                                                      this.listStrangers,
                                                      this.labelFilters,
                                                    )),
                                                    (this.listFiltered =
                                                      qt.a.sortConvId(
                                                        this.listFiltered,
                                                        !1,
                                                        !0,
                                                      )),
                                                    this.showStrangerNROnly() &&
                                                      (this.listFiltered =
                                                        qt.a.filterByResponsed(
                                                          this.listFiltered,
                                                          !1,
                                                        ));
                                                  break;
                                                case Wt.FilterType.FOCUSED:
                                                  this.listFiltered =
                                                    this.genListArchivedChat(
                                                      this.listVisible,
                                                      !1,
                                                      this.labelFilters,
                                                    );
                                                  break;
                                                case Wt.FilterType.ARCHIVED:
                                                  this.listFiltered =
                                                    this.genListArchivedChat(
                                                      this.listVisible,
                                                      !0,
                                                      this.labelFilters,
                                                    );
                                              }
                                              this.signalRenderState(),
                                                this.signalRenderList();
                                            }
                                            applyLabelFilter(e) {
                                              if (this.labelFilters !== e) {
                                                switch (
                                                  (this.logger.zsymb(
                                                    0,
                                                    16624,
                                                    30011,
                                                    "applyLabelFilter ",
                                                    e.join("-"),
                                                  ),
                                                  (this.labelFilters = e.map(
                                                    (e) => "" + e,
                                                  )),
                                                  this.typeFilter)
                                                ) {
                                                  case Wt.FilterType.ALL:
                                                    if (
                                                      ((this.listFiltered =
                                                        qt.a.filterByLabel(
                                                          this.listVisible,
                                                          this.labelFilters,
                                                        )),
                                                      this.doAddStrangerHasLabel(
                                                        this.listFiltered,
                                                        this.labelFilters,
                                                      ),
                                                      this.addLikeConvToFilterListV2(
                                                        this.listFiltered,
                                                        e,
                                                      ),
                                                      this.labelFilters.some(
                                                        (e) => e == xt.g,
                                                      ))
                                                    ) {
                                                      let e =
                                                        this.listStrangers;
                                                      this.showStrangerNROnly() &&
                                                        (e =
                                                          qt.a.filterByResponsed(
                                                            e,
                                                            !1,
                                                          )),
                                                        this.addToListFiltered(
                                                          e,
                                                        );
                                                    }
                                                    break;
                                                  case Wt.FilterType.UNREAD:
                                                    if (
                                                      ((this.listFiltered =
                                                        qt.a.filterByLabel(
                                                          this.listVisible,
                                                          e,
                                                        )),
                                                      this.doAddStrangerHasLabel(
                                                        this.listFiltered,
                                                        this.labelFilters,
                                                      ),
                                                      this.labelFilters.some(
                                                        (e) => e == xt.g,
                                                      ))
                                                    ) {
                                                      let e =
                                                        this.listStrangers;
                                                      this.showStrangerNROnly() &&
                                                        (e =
                                                          qt.a.filterByResponsed(
                                                            e,
                                                            !1,
                                                          )),
                                                        this.addToListFiltered(
                                                          e,
                                                        );
                                                    }
                                                    (this.listFiltered =
                                                      qt.a.filterByUnread(
                                                        this.listFiltered,
                                                      )),
                                                      (this.listFiltered =
                                                        this.safeSortConvList(
                                                          this.listFiltered,
                                                          !1,
                                                        ));
                                                    break;
                                                  case Wt.FilterType.STRANGER:
                                                    (this.listFiltered =
                                                      qt.a.filterByLabel(
                                                        this.listStrangers,
                                                        this.labelFilters,
                                                      )),
                                                      (this.listFiltered =
                                                        qt.a.sortConvId(
                                                          this.listFiltered,
                                                          !1,
                                                          !0,
                                                        )),
                                                      this.showStrangerNROnly() &&
                                                        (this.listFiltered =
                                                          qt.a.filterByResponsed(
                                                            this.listFiltered,
                                                            !1,
                                                          ));
                                                    break;
                                                  case Wt.FilterType.FOCUSED:
                                                    this.listFiltered =
                                                      this.genListArchivedChat(
                                                        this.listVisible,
                                                        !1,
                                                        e,
                                                      );
                                                    break;
                                                  case Wt.FilterType.ARCHIVED:
                                                    this.listFiltered =
                                                      this.genListArchivedChat(
                                                        this.listVisible,
                                                        !0,
                                                        e,
                                                      );
                                                }
                                                this.signalRenderState(),
                                                  this.signalRenderList();
                                              }
                                            }
                                            showStrangerNROnly() {
                                              return !this.isUnboxStrangerAccount();
                                            }
                                            isUnboxStrangerAccount() {
                                              const e = os.c.isUnboxStranger();
                                              return (
                                                this.logger.zsymb(
                                                  0,
                                                  16624,
                                                  30012,
                                                  "isUnboxStrangerAccount ",
                                                  e,
                                                ),
                                                e
                                              );
                                            }
                                            doAddStrangerHasLabel(e, t) {
                                              if (t.length) {
                                                const s = qt.a.filterByLabel(
                                                  this.listStrangers,
                                                  t,
                                                );
                                                if (s.length) {
                                                  const t = new Set(s);
                                                  for (
                                                    let s = 0;
                                                    s < e.length;
                                                    s++
                                                  )
                                                    t.has(e[s]) &&
                                                      t.delete(e[s]);
                                                  this.addToListFiltered(t);
                                                }
                                              }
                                              return e;
                                            }
                                            isConvExists(e) {
                                              const t =
                                                this.convDataManager.getConvByIdSync(
                                                  e,
                                                );
                                              return !!(
                                                (null != t &&
                                                  t.firstSmsLocalId) ||
                                                (null != t && t.lastSmsLocalId)
                                              );
                                            }
                                            safeSortConvList(e, t) {
                                              void 0 === t && (t = !0);
                                              const s = e.indexOf(
                                                R.CONV_FILTER.STRANGER,
                                              );
                                              if (-1 !== s) {
                                                e[s] = this.newestStrangerId;
                                                const i = (e = qt.a.sortConvId(
                                                  e,
                                                  t,
                                                  !0,
                                                )).indexOf(
                                                  this.newestStrangerId,
                                                );
                                                e[i] = R.CONV_FILTER.STRANGER;
                                              } else
                                                e = qt.a.sortConvId(e, t, !0);
                                              return e;
                                            }
                                            isValidFakeConv(e, t, s) {
                                              if (
                                                e.some((e) => e == s) ||
                                                Jt.a.isThreadHidden(s)
                                              )
                                                return !1;
                                              const i =
                                                Yt.b.getLabelObjByConversaionId(
                                                  s,
                                                );
                                              return !(
                                                !i || !t.some((e) => e == i.id)
                                              );
                                            }
                                            isValidFakeConvV2(e, t) {
                                              if (
                                                !t ||
                                                e.some((e) => e == t) ||
                                                Jt.a.isThreadHidden(t)
                                              )
                                                return !1;
                                              return (
                                                !(
                                                  t &&
                                                  t.startsWith(R.GROUPID_PREFIX)
                                                ) ||
                                                !!ds.default.getGroupByIdSync(t)
                                              );
                                            }
                                            addLikeConvToFilterListV2(e, t) {
                                              if (
                                                t.length &&
                                                this.typeFilter !==
                                                  Wt.FilterType.UNREAD
                                              ) {
                                                this.logger.zsymb(
                                                  0,
                                                  16624,
                                                  30013,
                                                  "addLikeConvToFilterListV2 ",
                                                  t,
                                                );
                                                for (const s of t) {
                                                  const t =
                                                    this.labelDataManager.getLabelById(
                                                      s,
                                                    );
                                                  if (t && t.conversations)
                                                    for (const s of t.conversations)
                                                      this.isValidFakeConvV2(
                                                        e,
                                                        s,
                                                      ) && e.push(s);
                                                }
                                              }
                                            }
                                            markConvsAsRead(e) {
                                              const t = [],
                                                s =
                                                  0 ===
                                                  this.labelFilters.length;
                                              this.logger.zsymb(
                                                0,
                                                16624,
                                                30014,
                                                `markConvsAsRead #1  ${null == e ? void 0 : e.join("-")}`,
                                              ),
                                                this.listRawAll.forEach((i) => {
                                                  const n =
                                                    this.unreadDataManager.getUnreadByConvIdSync(
                                                      i,
                                                    );
                                                  if (
                                                    n &&
                                                    (n.smsUnreadCount > 0 ||
                                                      n.unreadMark)
                                                  ) {
                                                    if (
                                                      (this.logger.zsymb(
                                                        0,
                                                        16624,
                                                        30015,
                                                        `markConvsAsRead #2, ${i}, ${n.smsUnreadCount}`,
                                                      ),
                                                      (e &&
                                                        !e.hasOwnProperty(i)) ||
                                                        i ===
                                                          R.FAKE_CONVERSATION_ID
                                                            .FRIEND_CENTER)
                                                    )
                                                      return;
                                                    const a =
                                                        Yt.b.getLabelObjByConversaionId(
                                                          i,
                                                        ) || {},
                                                      r =
                                                        this.convDataManager.getConvByIdSync(
                                                          i,
                                                        ) || { userId: i };
                                                    (s ||
                                                      this.labelFilters.some(
                                                        (e) => e == a.id,
                                                      ) ||
                                                      (qt.a.isInStrangerBoxV2(
                                                        i,
                                                      ) &&
                                                        this.typeFilter ===
                                                          Wt.FilterType
                                                            .STRANGER)) &&
                                                      t.push(r);
                                                  }
                                                }),
                                                this.logger.zsymb(
                                                  0,
                                                  16624,
                                                  30016,
                                                  `markConvsAsRead #3 ${t.length} ${t.map((e) => e.userId).join("-")}`,
                                                ),
                                                t.length > 0 &&
                                                  (Mt.default.send(
                                                    St.SideBarActions
                                                      .MARK_AS_READ,
                                                    { conversations: t },
                                                  ),
                                                  Xe.e.logAction(1453304));
                                            }
                                            onLoadPreview(e) {
                                              this.logger.zsymb(
                                                0,
                                                16624,
                                                30017,
                                                `onload Preview 1: ${this.listRawAll.size}`,
                                              );
                                              let t = e.map((e) => e.convId);
                                              const s =
                                                Ee.default.getConvUXVersion();
                                              (this.isEnableArchivedChat =
                                                !!cs.a.isEnableArchivedChat() &&
                                                "3" == s),
                                                (this.typeFilter = this
                                                  .isEnableArchivedChat
                                                  ? Wt.FilterType.FOCUSED
                                                  : Wt.FilterType.ALL),
                                                this.listRawAll.size &&
                                                  this.listRawAll.forEach(
                                                    (e) => {
                                                      t.some((t) => t === e) ||
                                                        t.push(e);
                                                    },
                                                  ),
                                                (this.listRawAll = new Set(t));
                                              const i = bt.default.sendToMeId;
                                              this.listRawAll.has(i) ||
                                                (t.push(i),
                                                this.listRawAll.add(i)),
                                                this.logger.zsymb(
                                                  0,
                                                  16624,
                                                  30018,
                                                  `onload Preview 2: ${t.length}`,
                                                ),
                                                qt.a
                                                  .groupConversaion(t)
                                                  .then((e) => {
                                                    if (
                                                      (this.logger.zsymb(
                                                        0,
                                                        16624,
                                                        30019,
                                                        `grouped list #1: \n\t\t\t\t${e.hidden.length}\n\t\t\t\t- ${e.stranger.length}\n\t\t\t\t- ${e.outdate.length}\n\t\t\t\t- ${e.visible.length}\n\t\t\t`,
                                                      ),
                                                      bt.default.stagingAccount)
                                                    )
                                                      for (const i in e)
                                                        this.logger.zsymb(
                                                          0,
                                                          16624,
                                                          30020,
                                                          `${i}: ${e[i]}`,
                                                        );
                                                    (this.listStrangers =
                                                      e.stranger),
                                                      (this.listHiddens =
                                                        e.hidden);
                                                    const t =
                                                      this.addStrangersToVisible(
                                                        e.visible,
                                                        this.listStrangers,
                                                      );
                                                    let s = t;
                                                    if (
                                                      this.listVisible.length
                                                    ) {
                                                      this.logger.zsymb(
                                                        0,
                                                        16624,
                                                        30021,
                                                        `preview changed while group csc #1: ${this.listVisible}`,
                                                      ),
                                                        (s = this.listVisible);
                                                      const e = new Set(
                                                        this.listVisible,
                                                      );
                                                      t.forEach((t) => {
                                                        e.has(t) || s.push(t);
                                                      });
                                                    }
                                                    (this.listVisible =
                                                      this.safeSortConvList(
                                                        s,
                                                        !1,
                                                      )),
                                                      this.initMyCloud(),
                                                      this
                                                        .isEnableArchivedChat &&
                                                        (this.listFiltered =
                                                          this.genListArchivedChat(
                                                            this.listVisible,
                                                            this.typeFilter ===
                                                              Wt.FilterType
                                                                .ARCHIVED,
                                                            this.labelFilters,
                                                          )),
                                                      this.logger.zsymb(
                                                        0,
                                                        16624,
                                                        30022,
                                                        `visible sorted #1: ${this.listVisible}`,
                                                      ),
                                                      (this.loaded = !0),
                                                      this.signalRenderList(),
                                                      this.signalRenderState(),
                                                      this.dispatchEvent(
                                                        new Zt.a(
                                                          Zt.c.LoadPreviewDone,
                                                          "",
                                                          this.listVisible.slice(),
                                                        ),
                                                      );
                                                  });
                                            }
                                            onMigratedPreview() {
                                              this.logger.zsymb(
                                                0,
                                                16624,
                                                30023,
                                                `onMigratedPreview #1: ${this.listVisible}`,
                                              );
                                              const e =
                                                Ee.default.getConvUXVersion();
                                              (this.isEnableArchivedChat =
                                                !!cs.a.isEnableArchivedChat() &&
                                                "3" == e),
                                                (this.typeFilter = this
                                                  .isEnableArchivedChat
                                                  ? Wt.FilterType.FOCUSED
                                                  : Wt.FilterType.ALL);
                                              const t = bt.default.sendToMeId;
                                              this.listRawAll.has(t) ||
                                                this.initMyCloud(),
                                                this.convDataManager.getConvByIdSync(
                                                  t,
                                                ) &&
                                                  !this.listVisible.includes(
                                                    t,
                                                  ) &&
                                                  (this.logger.zsymb(
                                                    0,
                                                    16624,
                                                    30024,
                                                    "onMigratedPreview #2",
                                                  ),
                                                  this.onPreviewChange(
                                                    { convId: t },
                                                    [],
                                                  )),
                                                (this.loaded = !0),
                                                this.signalRenderList(),
                                                this.signalRenderState();
                                            }
                                            initMyCloud() {
                                              const e =
                                                  ts.g.getFlagForCurrentUser(
                                                    null,
                                                    "z_sendtome",
                                                  ),
                                                t = bt.default.sendToMeId,
                                                s = !(
                                                  bt.default.isOffSendToMe ||
                                                  (e && 1 !== e)
                                                );
                                              if (
                                                (this.logger.zsymb(
                                                  0,
                                                  16624,
                                                  30025,
                                                  "initMyCloud",
                                                  e,
                                                  bt.default.isOffSendToMe,
                                                ),
                                                this.listVisible.some(
                                                  (e) => e === t,
                                                ))
                                              ) {
                                                const e =
                                                  this.convDataManager.getConvByIdSync(
                                                    t,
                                                  );
                                                e && e.pinned
                                                  ? Xe.e.logAction(1390703)
                                                  : (ts.g.setFlagForCurrentUser(
                                                      null,
                                                      "z_sendtome",
                                                      Date.now(),
                                                    ),
                                                    Xe.e.logAction(1390702));
                                              } else if (s) {
                                                const e =
                                                    Pt.a.PinDataManager.getTotalPinnedConversation() >=
                                                    bt.default
                                                      .limit_pin_messages,
                                                  s =
                                                    bt.default
                                                      .auto_pin_send2me &&
                                                    !ts.g.getFlagForCurrentUser(
                                                      null,
                                                      "z_sendtome_pinned",
                                                    ) &&
                                                    !e;
                                                this.convDataManager.createEmptyConvForUser(
                                                  t,
                                                  s ? 1 : 0,
                                                  R.CONV_OT_STATE.none,
                                                  {},
                                                ),
                                                  s &&
                                                    (Pt.a.PinDataManager.pin([
                                                      t,
                                                    ]),
                                                    ts.g.setFlagForCurrentUser(
                                                      null,
                                                      "z_sendtome_pinned",
                                                      1,
                                                    )),
                                                  ts.g.setFlagForCurrentUser(
                                                    null,
                                                    "z_sendtome",
                                                    Date.now(),
                                                  ),
                                                  this.onPreviewChange(
                                                    { convId: t },
                                                    [],
                                                  );
                                              }
                                            }
                                            addStrangersToVisible(e, t) {
                                              if (!t || !t.length) return e;
                                              if (this.isUnboxStrangerAccount())
                                                return e.concat(t);
                                              {
                                                const s =
                                                  qt.a.filterByResponsed(t, !1);
                                                if (s.length) {
                                                  this.newestStrangerId =
                                                    qt.a.getNewestConvFromIds(
                                                      s,
                                                    );
                                                  e.includes(
                                                    R.CONV_FILTER.STRANGER,
                                                  ) ||
                                                    e.push(
                                                      R.CONV_FILTER.STRANGER,
                                                    );
                                                }
                                                return (
                                                  t.forEach((t) => {
                                                    this.convDataManager.isRespondedByMeSync(
                                                      t,
                                                    ) && e.push(t);
                                                  }),
                                                  e
                                                );
                                              }
                                            }
                                            onLabelChangeConvs(e, t, s) {
                                              if (
                                                (this.logger.zsymb(
                                                  0,
                                                  16624,
                                                  30026,
                                                  "onLabelChangeConvs",
                                                  t.length,
                                                  e,
                                                ),
                                                t.length &&
                                                  this.labelFilters.includes(e))
                                              )
                                                if ("add" == s) {
                                                  const e = t.filter(
                                                    (e) =>
                                                      !this.listFiltered.includes(
                                                        e,
                                                      ) &&
                                                      !this.listHiddens.includes(
                                                        e,
                                                      ),
                                                  );
                                                  if (!e.length) return;
                                                  (this.listFiltered = [
                                                    ...this.listFiltered,
                                                    ...e,
                                                  ]),
                                                    (this.listFiltered =
                                                      qt.a.sortConvId(
                                                        this.listFiltered,
                                                        !1,
                                                        !1,
                                                      )),
                                                    this.signalRenderList();
                                                } else {
                                                  let e = !1;
                                                  t.forEach((t) => {
                                                    const s =
                                                        Yt.b.getLabelObjByConversaionId(
                                                          t,
                                                        ),
                                                      i = s ? s.id : null;
                                                    this.labelFilters.includes(
                                                      "" + i,
                                                    ) ||
                                                      ((this.listFiltered =
                                                        this.listFiltered.filter(
                                                          (e) => e !== t,
                                                        )),
                                                      (e = !0));
                                                  }),
                                                    e &&
                                                      this.signalRenderList();
                                                }
                                            }
                                            moveConvOutConvList(e) {
                                              this.logger.zsymb(
                                                0,
                                                16624,
                                                30027,
                                                "moveConvOutConvList",
                                                e,
                                              ),
                                                (this.listVisible =
                                                  this.listVisible.filter(
                                                    (t) => t !== e,
                                                  )),
                                                (this.listFiltered =
                                                  this.listFiltered.filter(
                                                    (t) => t !== e,
                                                  )),
                                                (this.listStrangers =
                                                  this.listStrangers.filter(
                                                    (t) => t !== e,
                                                  )),
                                                e !== this.newestStrangerId ||
                                                  this.isUnboxStrangerAccount() ||
                                                  this.updateNewestStrangerId(
                                                    this.listStrangers,
                                                  ),
                                                this.signalRenderList();
                                            }
                                            getAlterId() {
                                              return new Map([
                                                [
                                                  R.CONV_FILTER.STRANGER,
                                                  this.newestStrangerId,
                                                ],
                                              ]);
                                            }
                                            updateNewestStrangerId(e) {
                                              if (this.isUnboxStrangerAccount())
                                                return;
                                              const t = qt.a.filterByResponsed(
                                                  e,
                                                  !1,
                                                ),
                                                s = this.newestStrangerId;
                                              if (
                                                ((this.newestStrangerId =
                                                  qt.a.getNewestConvFromIds(t)),
                                                this.newestStrangerId ||
                                                  ((this.listVisible =
                                                    this.listVisible.filter(
                                                      (e) =>
                                                        e !==
                                                        R.CONV_FILTER.STRANGER,
                                                    )),
                                                  this.signalRenderList()),
                                                this.previewManager.updateStrangerBox(
                                                  this.newestStrangerId,
                                                ),
                                                s !== this.newestStrangerId &&
                                                  this.newestStrangerId)
                                              ) {
                                                const [e, t] =
                                                  qt.a.insertToProperPosition(
                                                    this.listVisible,
                                                    R.CONV_FILTER.STRANGER,
                                                    this.getAlterId(),
                                                  );
                                                (this.listVisible = e),
                                                  this.signalRenderList();
                                              }
                                            }
                                            rebuildList() {
                                              this.logger.zsymb(
                                                0,
                                                16624,
                                                30028,
                                                `rebuildList 1: ${this.listRawAll.size} ${this.listVisible.length} ${this.listStrangers.length}`,
                                              ),
                                                (this.listStrangers = []),
                                                (this.listVisible = []),
                                                (this.listHiddens = []),
                                                (this.listFiltered = []),
                                                (this.newestStrangerId = "");
                                              const e = Array.from(
                                                  this.listRawAll,
                                                ),
                                                t =
                                                  qt.a.groupConversaionSync(e);
                                              if (
                                                (this.logger.zsymb(
                                                  0,
                                                  16624,
                                                  30029,
                                                  `grouped list #2: \n\t\t\t${t.hidden.length}\n\t\t\t- ${t.stranger.length}\n\t\t\t- ${t.outdate.length}\n\t\t\t- ${t.visible.length}\n\t\t`,
                                                ),
                                                bt.default.stagingAccount)
                                              )
                                                for (const n in t)
                                                  this.logger.zsymb(
                                                    0,
                                                    16624,
                                                    30030,
                                                    `${n}:, ${t[n]}`,
                                                  );
                                              (this.listStrangers = t.stranger),
                                                (this.listHiddens = t.hidden);
                                              const s =
                                                  this.addStrangersToVisible(
                                                    t.visible,
                                                    this.listStrangers,
                                                  ),
                                                i = this.safeSortConvList(
                                                  s,
                                                  !1,
                                                );
                                              (this.listVisible = i),
                                                this.logger.zsymb(
                                                  0,
                                                  16624,
                                                  30031,
                                                  `visible sorted #2: ${this.listVisible}`,
                                                ),
                                                this.labelFilters.length &&
                                                  this.applyLabelFilter(
                                                    this.labelFilters,
                                                  ),
                                                this.typeFilter !==
                                                  Wt.FilterType.ALL &&
                                                  this.applyTypeFilter(
                                                    this.typeFilter,
                                                    bt.default
                                                      .should_force_genlist_conv,
                                                  ),
                                                this.signalRenderList(),
                                                this.signalRenderState();
                                            }
                                            handleUserPackageChange() {
                                              this.logger.zsymb(
                                                0,
                                                16624,
                                                30032,
                                                `handleUserPackageChange: ${Ye.default.isMeBAAccount()}}`,
                                              ),
                                                this.rebuildList();
                                            }
                                            signalRenderList(e) {
                                              void 0 === e && (e = "all"),
                                                Object(nt.i)(this.name, e);
                                            }
                                            signalRenderState() {
                                              Object(nt.g)(this.name, Qt.c);
                                            }
                                            logActionSelectConv(e) {
                                              const t =
                                                this.labelFilters.length > 0;
                                              if (
                                                (this.typeFilter ===
                                                Wt.FilterType.UNREAD
                                                  ? (Xe.e.logAction(1453103),
                                                    t ||
                                                      Xe.e.logAction(1453107))
                                                  : this.typeFilter ===
                                                      Wt.FilterType.ALL
                                                    ? (Xe.e.logAction(1453104),
                                                      t &&
                                                        Xe.e.logAction(1453108))
                                                    : this.typeFilter ===
                                                        Wt.FilterType.FOCUSED
                                                      ? Xe.e.logAction(1453501)
                                                      : this.typeFilter ===
                                                          Wt.FilterType
                                                            .ARCHIVED &&
                                                        Xe.e.logAction(1453502),
                                                t)
                                              )
                                                Xe.e.logAction(1453105);
                                              else {
                                                Xe.e.logAction(1453106);
                                                for (
                                                  let e = 0;
                                                  e < this.labelFilters.length;
                                                  e++
                                                ) {
                                                  if (
                                                    parseInt(
                                                      this.labelFilters[e],
                                                    ) > 0
                                                  ) {
                                                    Xe.e.logAction(1453109);
                                                    break;
                                                  }
                                                }
                                              }
                                              this.typeFilter ==
                                                Wt.FilterType.ARCHIVED &&
                                                cs.a.sendTrackSrc(e, 4, !1);
                                            }
                                            init() {}
                                            getItem(e) {
                                              return e.key === Qt.c
                                                ? {
                                                    labelFilters:
                                                      this.labelFilters,
                                                    typeFilter: this.typeFilter,
                                                    loaded: this.loaded,
                                                    isEnableArchivedChat:
                                                      this.isEnableArchivedChat,
                                                    hasUnreadArchivedChat:
                                                      this
                                                        .hasUnreadArchivedChat,
                                                    typeFilterSrc:
                                                      this.typeFilterSrc,
                                                  }
                                                : us;
                                            }
                                            getList(e) {
                                              return e.key === Qt.c ||
                                                (this.typeFilter ==
                                                  Wt.FilterType.ALL &&
                                                  0 ===
                                                    this.labelFilters.length)
                                                ? this.listVisible
                                                : this.listFiltered;
                                            }
                                            onGetItemFailure(e) {}
                                            onGetListFailure(e) {}
                                            bindUIMenu(e, t) {
                                              this.menuRef[e] = t;
                                            }
                                            cleanUpUIMenu(e) {
                                              this.menuRef[e] = null;
                                            }
                                            showMenu(e, t, s) {
                                              if (this.menuRef[e] && e === xt.b)
                                                this.showConvActionMenu(t, s);
                                            }
                                            hideMenu(e) {
                                              this.menuRef[e];
                                            }
                                            showConvActionMenu(e, t) {
                                              if (t && t.friendItem) return;
                                              if (
                                                t.userId ===
                                                  R.CONV_FILTER.STRANGER ||
                                                t.userId === R.CONV_FILTER.MEDIA
                                              )
                                                return;
                                              const s = Object(f.a)({}, t),
                                                i = s.userId;
                                              if (
                                                s &&
                                                !Ct.default.isFakeId(i)
                                              ) {
                                                const e =
                                                    this.previewManager.getPreviewByIDSync(
                                                      i,
                                                    ),
                                                  t =
                                                    Ye.default.getProfileFriendByIdSync(
                                                      i,
                                                    ) || {},
                                                  n =
                                                    this.unreadDataManager.getUnreadByConvIdSync(
                                                      i,
                                                    );
                                                (s.lastMessage =
                                                  null == e
                                                    ? void 0
                                                    : e.message),
                                                  (s.isFr = t.isFr),
                                                  (s.unreadMark =
                                                    null == n
                                                      ? void 0
                                                      : n.unreadMark),
                                                  (s.smsUnreadCount =
                                                    null == n
                                                      ? void 0
                                                      : n.smsUnreadCount);
                                              }
                                              this.menuRef[
                                                xt.b
                                              ].updateTargetInfo(s),
                                                this.menuRef[xt.b].showAction(
                                                  Object(f.a)({}, e),
                                                );
                                            }
                                            bindUIContainer(e) {
                                              this.convUIListContainer = e;
                                            }
                                            cleanUpUIContainer() {
                                              this.convUIListContainer = null;
                                            }
                                            getEnableArchivedChat() {
                                              return this.isEnableArchivedChat;
                                            }
                                            getListFilterSrc(e) {
                                              return this.typeFilterSrc ===
                                                Wt.FilterSrcType.UNREAD
                                                ? qt.a.filterByUnread(e)
                                                : e;
                                            }
                                            setTypeFilterSrc(e) {
                                              if (
                                                this.typeFilterSrc !== e &&
                                                ((this.typeFilterSrc = e),
                                                this.applyTypeFilter(e, !0),
                                                e === Wt.FilterSrcType.UNREAD)
                                              ) {
                                                const e =
                                                  this.labelFilters.length > 0
                                                    ? 1453215
                                                    : 1453214;
                                                Xe.e.logAction(e);
                                              }
                                            }
                                            genListArchivedChat(e, t, s, i, n) {
                                              void 0 === i && (i = !0),
                                                void 0 === n && (n = !0);
                                              let a = [];
                                              (a = qt.a.filterByLabel(
                                                this.getListFilterSrc(e),
                                                s,
                                              )),
                                                s.length &&
                                                  n &&
                                                  this.typeFilterSrc !==
                                                    Wt.FilterSrcType.UNREAD &&
                                                  this.addLikeConvToFilterListV2(
                                                    a,
                                                    s,
                                                  );
                                              let r = this.getListFilterSrc(
                                                this.listStrangers,
                                              ).filter(
                                                (e) =>
                                                  ((cs.a.isArchivedChat(e) &&
                                                    t) ||
                                                    (!cs.a.isArchivedChat(e) &&
                                                      !t)) &&
                                                  !Jt.a.isThreadHidden(e),
                                              );
                                              return (
                                                s.includes(xt.g) &&
                                                1 == s.length
                                                  ? this.isUnboxStrangerAccount() ||
                                                    (r = qt.a.filterByResponsed(
                                                      r,
                                                      !1,
                                                    ))
                                                  : s.includes(xt.g) ||
                                                    (r = qt.a.filterByLabel(
                                                      r,
                                                      s,
                                                    )),
                                                (a = a.filter(
                                                  (e) =>
                                                    !(
                                                      this.typeFilter ===
                                                        Wt.FilterType
                                                          .ARCHIVED ||
                                                      !r.length ||
                                                      e !=
                                                        R.CONV_FILTER.STRANGER
                                                    ) ||
                                                    (((cs.a.isArchivedChat(e) &&
                                                      t) ||
                                                      (!cs.a.isArchivedChat(
                                                        e,
                                                      ) &&
                                                        !t)) &&
                                                      e !==
                                                        R.CONV_FILTER
                                                          .STRANGER &&
                                                      !qt.a.isStrangerV2(e) &&
                                                      !Jt.a.isThreadHidden(e)),
                                                )),
                                                i &&
                                                  (this.typeFilter ===
                                                  Wt.FilterType.ARCHIVED
                                                    ? (a = a.concat(r))
                                                    : this.isUnboxStrangerAccount() ||
                                                        s.length
                                                      ? ((this.isUnboxStrangerAccount() &&
                                                          (null == s ||
                                                            !s.length)) ||
                                                          (null != s &&
                                                            s.length)) &&
                                                        (a = a.concat(r))
                                                      : (a =
                                                          this.addStrangersToVisible(
                                                            a,
                                                            r,
                                                          ))),
                                                (a = a.filter(
                                                  (e, t) => a.indexOf(e) == t,
                                                )),
                                                this.safeSortConvList(a, !1)
                                              );
                                            }
                                            updateListArchivedChat() {
                                              this.typeFilter ==
                                              Wt.FilterType.FOCUSED
                                                ? this.onTypeFilterChange(
                                                    Wt.FilterType.FOCUSED,
                                                    !0,
                                                  )
                                                : this.typeFilter ==
                                                    Wt.FilterType.ARCHIVED &&
                                                  this.onTypeFilterChange(
                                                    Wt.FilterType.ARCHIVED,
                                                    !0,
                                                  );
                                            }
                                            onOffArchivedChat(e) {
                                              if (
                                                !bt.default.enable_archived_chat
                                              )
                                                return;
                                              const t =
                                                Ee.default.getConvUXVersion();
                                              this.isEnableArchivedChat &&
                                                e &&
                                                "2" == t &&
                                                ((this.isEnableArchivedChat =
                                                  !1),
                                                this.signalRenderState()),
                                                this.isEnableArchivedChat !=
                                                  e &&
                                                  (e ||
                                                  (this.typeFilter !==
                                                    Wt.FilterType.ARCHIVED &&
                                                    this.typeFilter !==
                                                      Wt.FilterType.FOCUSED)
                                                    ? e &&
                                                      this.onTypeFilterChange(
                                                        Wt.FilterType.FOCUSED,
                                                        !0,
                                                      )
                                                    : this.onTypeFilterChange(
                                                        Wt.FilterType.ALL,
                                                        !0,
                                                      ),
                                                  this.labelDataManager.onClearFilter(),
                                                  this.setTypeFilterSrc(
                                                    Wt.FilterSrcType.ALL,
                                                  ),
                                                  (this.isEnableArchivedChat =
                                                    e && "3" == t),
                                                  this.signalRenderState());
                                            }
                                            isShowUnreadArchivedChat() {
                                              return this.hasUnreadArchivedChat;
                                            }
                                            updateUnreadArchivedChat(e) {
                                              this.typeFilter !=
                                                Wt.FilterType.ARCHIVED &&
                                                (this.hasUnreadArchivedChat =
                                                  e),
                                                this.signalRenderState();
                                            }
                                          }),
                                        ) || Ht),
                                    ) || Ht),
                                ) || Ht),
                            ) || Ht),
                        ) || Ht),
                    ) || Ht),
                ) || Ht),
            ) || Ht),
        );
        var ms,
          ps = s("EYv5"),
          fs = s("BR4E"),
          vs = s("AtyM"),
          bs = s("R5gT"),
          Is = s("Xzw3"),
          ys = s("d+hT"),
          _s = s("uEOi"),
          Os = s("rQsU"),
          Cs = s("kTC5"),
          Es = s("4wTQ"),
          Ms = s("ES/k"),
          Ss = s("uAQs"),
          Ts = s("WBqA"),
          ws = s("qa8q");
        const Rs = {
            isFocusSearchBox: !1,
            isFocusOnRecentSearch: !1,
            searchText: "",
            searchResult: {},
            searching: !1,
            conversation: null,
            highlightId: "",
            filter: { timeFrom: 0, timeTo: Date.now() },
          },
          Ls = new Ct.LocalId();
        var Ds;
        !(function (e) {
          (e[(e.STEP_CONTACT = 0)] = "STEP_CONTACT"),
            (e[(e.STEP_MESSAGES = 1)] = "STEP_MESSAGES"),
            (e[(e.STEP_FILES = 2)] = "STEP_FILES"),
            (e[(e.STEP_DIRECTORY = 3)] = "STEP_DIRECTORY");
        })(Ds || (Ds = {}));
        Object($t.b)(Wt.SearchController)(
          (ms =
            (function (e, t) {
              return i.ModuleContainer.inject(Os.b)(e, void 0, 0);
            })(
              (ms =
                (function (e, t) {
                  return i.ModuleContainer.inject(zt.b)(e, void 0, 1);
                })(
                  (ms =
                    (function (e, t) {
                      return i.ModuleContainer.inject(zt.i)(e, void 0, 2);
                    })(
                      (ms =
                        Reflect.metadata(
                          "design:type",
                          Function,
                        )(
                          (ms =
                            Reflect.metadata("design:paramtypes", [
                              void 0 === Os.b ? Object : Os.b,
                              void 0 === zt.b ? Object : zt.b,
                              void 0 === zt.i ? Object : zt.i,
                            ])(
                              (ms = class {
                                constructor(e, t, s) {
                                  (this.convListController = e),
                                    (this.convDataManager = t),
                                    (this.previewDataManager = s),
                                    (this.state = void 0),
                                    (this.pageLoad = void 0),
                                    (this.curQuery = void 0),
                                    (this.cacheResSearch = void 0),
                                    (this.countQuery = void 0),
                                    (this.countTimeUseGlobalSearch = void 0),
                                    (this.countSelectTopRes = void 0),
                                    (this.cacheSearch = void 0),
                                    (this.trackSearch = void 0),
                                    (this.trackSearchVietnamese = void 0),
                                    (this.lastTextSearch = void 0),
                                    (this.lastTextSearchTs = void 0),
                                    (this.isShowRecentSearch = void 0),
                                    (this.isFirstLoadSuccess = void 0),
                                    (this.isSearchingMsg = void 0),
                                    (this.searchDelay = void 0),
                                    (this.closeBySendingMsg = void 0),
                                    (this.clearAdminMode = void 0),
                                    (this.timeouResetDataMsg = void 0),
                                    (this.searchResultList = void 0),
                                    (this.recentSearchList = void 0),
                                    (this.searchInput = void 0),
                                    (this.loadingMore = void 0),
                                    (this.loadingMoreFiles = void 0),
                                    (this.oldestTime = void 0),
                                    (this.functionSearchByName = void 0),
                                    (this.timeoutLog = void 0),
                                    (this._timeDebounceSearch = null),
                                    (this.dataLoaded = void 0),
                                    (this._sbc = null),
                                    (this._removeSearchResult = (e, t) => {
                                      const s = this.getSearchState();
                                      if (
                                        s &&
                                        !s.conversation &&
                                        s.searchResult
                                      )
                                        if (t) {
                                          if (!s.searchResult.groups) return;
                                          const t = [...s.searchResult.groups];
                                          for (let i = 0; i < t.length; i++)
                                            if (t[i].userId == e) {
                                              t.splice(i, 1),
                                                this.updateState(
                                                  Object(f.a)(
                                                    Object(f.a)({}, s),
                                                    {},
                                                    {
                                                      searchResult: Object(f.a)(
                                                        Object(f.a)(
                                                          {},
                                                          s.searchResult,
                                                        ),
                                                        {},
                                                        { groups: t },
                                                      ),
                                                    },
                                                  ),
                                                );
                                              break;
                                            }
                                        } else {
                                          if (!s.searchResult.friends) return;
                                          const t = [...s.searchResult.friends];
                                          for (let i = 0; i < t.length; i++)
                                            if (t[i].userId == e) {
                                              t.splice(i, 1),
                                                this.updateState(
                                                  Object(f.a)(
                                                    Object(f.a)({}, s),
                                                    {},
                                                    {
                                                      searchResult: Object(f.a)(
                                                        Object(f.a)(
                                                          {},
                                                          s.searchResult,
                                                        ),
                                                        {},
                                                        { friends: t },
                                                      ),
                                                    },
                                                  ),
                                                );
                                              break;
                                            }
                                        }
                                    }),
                                    (this.name = Wt.SEARCH_CONTROLLER),
                                    (this.key = "windowId"),
                                    (this.state = Rs),
                                    (this.pageLoad = 0),
                                    (this.curQuery = ""),
                                    (this.countQuery = 0),
                                    (this.countTimeUseGlobalSearch = 0),
                                    (this.countSelectTopRes = 0),
                                    (this.cacheSearch = {
                                      items: [],
                                      keywords: null,
                                    }),
                                    (this.trackSearch = !1),
                                    (this.trackSearchVietnamese = !1),
                                    (this.lastTextSearch = ""),
                                    (this.lastTextSearchTs = 0),
                                    (this.isShowRecentSearch = !1),
                                    (this.searchDelay =
                                      this._getSearchDelaySetting()),
                                    (this.closeBySendingMsg = !1),
                                    (this.loadingMore = !1),
                                    (this.loadingMoreFiles = !1),
                                    (this.oldestTime = 0),
                                    (this.timeoutLog = null),
                                    (this.isFirstLoadSuccess = !1),
                                    (this.isSearchingMsg = !1),
                                    (this.dataLoaded = null),
                                    (this._innerSearchFunc =
                                      this._innerSearchFunc.bind(this)),
                                    (this.functionSearchByName =
                                      Ct.default.throttle(
                                        this._innerSearchFunc,
                                        this.searchDelay,
                                      )),
                                    (this.onKeywordChange =
                                      this.onKeywordChange.bind(this)),
                                    (this.loadMoreMessagesV2 =
                                      this.loadMoreMessagesV2.bind(this)),
                                    (this.loadMessagesV2 =
                                      this.loadMessagesV2.bind(this)),
                                    (this.loadMoreFiles =
                                      this.loadMoreFiles.bind(this)),
                                    (this.onKeyPressInput =
                                      this.onKeyPressInput.bind(this)),
                                    (this.onFocusInput =
                                      this.onFocusInput.bind(this)),
                                    (this.onBlurInput =
                                      this.onBlurInput.bind(this)),
                                    (this.onclickCloseSearchButton =
                                      this.onclickCloseSearchButton.bind(this)),
                                    (this.onClickClearSearch =
                                      this.onClickClearSearch.bind(this)),
                                    (this.onSearchKeyword =
                                      this.onSearchKeyword.bind(this)),
                                    (this.setRecentSearchFocusState =
                                      this.setRecentSearchFocusState.bind(
                                        this,
                                      )),
                                    (this.focusSearchBox =
                                      this.focusSearchBox.bind(this)),
                                    (this.selectResult =
                                      this.selectResult.bind(this)),
                                    (this.onFileSelect =
                                      this.onFileSelect.bind(this)),
                                    (this.selectTopRes =
                                      this.selectTopRes.bind(this)),
                                    this.listenEvents();
                                }
                                get sidebarController() {
                                  return (
                                    this._sbc ||
                                      (this._sbc = i.ModuleContainer.resolve(
                                        Wt.SidebarController,
                                      )),
                                    this._sbc
                                  );
                                }
                                listenEvents() {
                                  Mt.default.subscribe((e, t) => {
                                    switch (e) {
                                      case St.SideBarActions.FOCUS_SEARCH_INPUT:
                                        this.focusSearchBox();
                                        break;
                                      case St.FetchActions.FRIENDS_REMOVED:
                                        this._removeSearchResult(t, !1);
                                        break;
                                      case St.FetchActions.GROUP_LEAVE:
                                        this._removeSearchResult(t, !0);
                                        break;
                                      case St.SideBarActions.SEARCH_FILE_DONE:
                                        this.updateState(
                                          Object(f.a)(
                                            Object(f.a)({}, this.state),
                                            {},
                                            { searching: !1 },
                                          ),
                                        );
                                        break;
                                      case St.SideBarActions.CLEAR_SEARCH:
                                        this.clearSearch();
                                        break;
                                      case St.ConversationListActions
                                        .SELECT_CONVERSATION:
                                        setTimeout(() => {
                                          this.state.highlightId !== t.userId &&
                                            this.setRecentSearchFocusState(
                                              !1,
                                              !1,
                                              !0,
                                            ),
                                            t.callPoint !== rs.a.JumpMessage &&
                                              this.updateStateOf(
                                                "highlightId",
                                                null == t ? void 0 : t.userId,
                                              );
                                        }, 0);
                                    }
                                  });
                                }
                                logSearch(e) {
                                  Q.p.getDebugSearch().showLogSearchFlow;
                                }
                                updateState(e, t) {
                                  void 0 === t && (t = !0),
                                    (this.state = e),
                                    t && Object(nt.g)(this.name, Qt.c);
                                }
                                isTextKey(e) {
                                  return e.match(
                                    /^[a-zA-Z0-9!@#$%^&*)(+=._-|\\\[\]{}~`"\';:?/<>,-\s\n]$/,
                                  );
                                }
                                isMultipleKeyPressed(e) {
                                  return e.ctrlKey || e.metaKey || e.altKey;
                                }
                                isKeywordStale(e) {
                                  return (
                                    Ms.a.formatTextSearch(e) !==
                                    Ms.a.formatTextSearch(this.state.searchText)
                                  );
                                }
                                bindUIList(e, t) {
                                  this._updateListRef(e, t);
                                }
                                cleanUpUIList(e) {
                                  this._updateListRef(e, null);
                                }
                                bindUISearchInput(e) {
                                  this.searchInput = e;
                                }
                                cleanUpUISearchInput() {
                                  this.searchInput = null;
                                }
                                _updateListRef(e, t) {
                                  switch (e) {
                                    case Cs.c.SEARCH_RESULT:
                                      this.searchResultList = t;
                                      break;
                                    case Cs.c.RECENT_SEARCH:
                                      this.recentSearchList = t;
                                  }
                                }
                                resetState() {
                                  (this.searchInput.value = ""),
                                    this.updateState(Object(f.a)({}, Rs));
                                }
                                updateStateOf(e, t) {
                                  this.state.hasOwnProperty(e) &&
                                    this.state[e] !== t &&
                                    ("searchText" === e &&
                                      (this.searchInput.value = t),
                                    this.updateState(
                                      Object(f.a)(
                                        Object(f.a)({}, this.state),
                                        {},
                                        { [e]: t },
                                      ),
                                    ));
                                }
                                onKeyPressInput(e) {
                                  if (
                                    (this._isSelectAllSearchText() &&
                                      this.searchResultList &&
                                      this.isTextKey(e.key) &&
                                      !this.isMultipleKeyPressed(e) &&
                                      (this.searchResultList.openTabAll(),
                                      this.searchResultList.resetContactList()),
                                    e.which == R.K_BACK_SPACE
                                      ? this.state &&
                                        this.state.searchText &&
                                        "" !== this.state.searchText &&
                                        Xe.e.logAction(12307)
                                      : "" === this.state.searchText &&
                                        !this.timeoutLog &&
                                        this.isTextKey(e.key) &&
                                        (this.timeoutLog = setTimeout(() => {
                                          (this.timeoutLog = null),
                                            Xe.e.logAction(1232002);
                                        }, 3e3)),
                                    e.which == R.K_ESC)
                                  )
                                    !0 === this.isShowRecentSearch &&
                                      (this.updateState(
                                        Object(f.a)(
                                          Object(f.a)({}, this.state),
                                          {},
                                          {
                                            isFocusOnRecentSearch: !1,
                                            isFocusSearchBox: !1,
                                          },
                                        ),
                                      ),
                                      this.searchInput &&
                                        this.searchInput.blur(),
                                      this.onCloseSearch()),
                                      "" != this.searchInput.value
                                        ? this.clearSearch(!1)
                                        : this.clearSearch(!0);
                                  else if (e.which == R.K_ENTER) {
                                    let e =
                                      this.searchResultList ||
                                      this.recentSearchList;
                                    if (e && this.state.searchText) {
                                      let t = e.selectFocusedConversation(!0);
                                      setTimeout(() => {
                                        this.state.conversation
                                          ? this.focusSearchBox()
                                          : Jt.a.isThreadHidden(t) ||
                                            Mt.default.send(
                                              St.ChatBoxActions.FOCUS_INPUT,
                                              { userId: t, windowId: Qt.c },
                                            );
                                      }, 0);
                                    }
                                  } else if (
                                    e.which == R.K_UP ||
                                    e.which == R.K_DOWN
                                  ) {
                                    this.searchResultList &&
                                      Xe.e.logAction(12317);
                                    let t =
                                      this.searchResultList ||
                                      this.recentSearchList;
                                    t &&
                                      (e.stopPropagation(),
                                      e.preventDefault(),
                                      e.which == R.K_UP
                                        ? t.moveUp()
                                        : t.moveDown());
                                  }
                                }
                                onAbortSearch() {
                                  bs.a.abortSearch();
                                }
                                onKeywordChange(e, t) {
                                  let s = "";
                                  if (
                                    ((s = !e && t ? t : e.target.value),
                                    s &&
                                      (s = Ct.default.ZSafeFunction(
                                        () => s.normalize(),
                                        s,
                                      )),
                                    this.countTimeUseGlobalSearch ||
                                      ((this.countTimeUseGlobalSearch =
                                        vs.a.now()),
                                      (this.countSelectTopRes = 0)),
                                    s)
                                  ) {
                                    const e = Ms.a.formatTextSearch(
                                        this.lastTextSearch,
                                      ),
                                      t = Ms.a.formatTextSearch(s);
                                    Ct.default.log("searching: true"),
                                      bt.default.stagingAccount &&
                                        this._checkOnAdminMode(s),
                                      this.trackSearch ||
                                        ((this.trackSearch = !0),
                                        Xe.e.logAction(12318)),
                                      this.updateState(
                                        Object(f.a)(
                                          Object(f.a)({}, this.state),
                                          {},
                                          { searchText: s },
                                        ),
                                      ),
                                      (this.countQuery = Ls.next()),
                                      this.functionSearchByName(
                                        s,
                                        this.countQuery,
                                        e !== t,
                                      );
                                  } else
                                    this._resetCacheResultSearch(),
                                      bs.a.abortSearch(),
                                      this.clearSearch(!1);
                                }
                                onFocusInput() {
                                  Ts.a.onNewSession(Qt.c),
                                    this.searchInput &&
                                      "" !== this.searchInput.value &&
                                      this.searchInput.select(),
                                    this.updateState(
                                      Object(f.a)(
                                        Object(f.a)({}, this.state),
                                        {},
                                        { isFocusSearchBox: !0 },
                                      ),
                                    ),
                                    Xe.e.logAction(1232001);
                                }
                                onBlurInput() {
                                  setTimeout(() => {
                                    this.updateState(
                                      Object(f.a)(
                                        Object(f.a)({}, this.state),
                                        {},
                                        { isFocusSearchBox: !1 },
                                      ),
                                    ),
                                      this.searchInput &&
                                        "" == this.searchInput.value &&
                                        this.qosLogSearch();
                                  }, 20);
                                }
                                onclickCloseSearchButton(e) {
                                  this.setRecentSearchFocusState(!1),
                                    this.onCloseSearch(),
                                    this._resetCacheResultSearch(),
                                    this.clearSearch(!this.state.conversation),
                                    Xe.e.logAction(1232003),
                                    e &&
                                      (e.stopPropagation(), e.preventDefault());
                                }
                                onClickClearSearch() {
                                  Q.p.resetGlobalSearchMode(),
                                    this.state.conversation &&
                                      Xe.e.logAction(12314),
                                    this._resetCacheResultSearch(),
                                    this.clearSearch(!this.state.conversation),
                                    this.focusSearchBox(),
                                    Xe.e.logAction(1232006);
                                }
                                onSearchKeyword(e) {
                                  "string" == typeof e &&
                                    this.searchInput &&
                                    ((this.searchInput.value = e),
                                    this.onKeywordChange(null, e),
                                    _s.a.addCacheKeyword(e));
                                }
                                onRemoveKeyword(e) {
                                  "string" == typeof e &&
                                    _s.a.removeCacheKeyword(e);
                                }
                                onFileSelect(e) {
                                  null != e &&
                                    e.msgId &&
                                    (this.updateStateOf("highlightId", e.msgId),
                                    this.state.searchText &&
                                      _s.a.addCacheKeyword(
                                        this.state.searchText,
                                      ));
                                }
                                setRecentSearchFocusState(e, t, s) {
                                  if (
                                    (void 0 === t && (t = !1),
                                    void 0 === s && (s = !1),
                                    !s)
                                  ) {
                                    const t =
                                      this.sidebarController.getSelectedId();
                                    if (
                                      this.state.isFocusOnRecentSearch === e ||
                                      (t && this.state.highlightId === t && !e)
                                    )
                                      return;
                                  }
                                  (this.state.isFocusOnRecentSearch = e),
                                    e && (this.closeBySendingMsg = !1),
                                    Object(nt.g)(this.name, Qt.c);
                                }
                                onCloseSearch() {
                                  var e, t;
                                  Xe.e.logAction(1232004),
                                    0 ==
                                      (null === (e = this.state.searchResult) ||
                                      void 0 === e ||
                                      null === (t = e.messages) ||
                                      void 0 === t
                                        ? void 0
                                        : t.length) && Xe.e.logAction(1232202),
                                    this.qosLogSearch();
                                }
                                focusSearchBox(e) {
                                  void 0 === e && (e = !1),
                                    this.searchInput &&
                                      (this.searchInput.focus(),
                                      e &&
                                        setTimeout(() => {
                                          this.searchInput.select();
                                        }, 0));
                                }
                                openRecentSearch() {
                                  this.searchInput
                                    ? this.searchInput.focus()
                                    : this.setRecentSearchFocusState(!0);
                                }
                                loadCachedMessages(e, t, s) {
                                  var i, n;
                                  if (!this.dataLoaded)
                                    return void (s && s(null, -1));
                                  let a = "";
                                  if (!this.state.searchText) return;
                                  a = this.state.searchText;
                                  const r = () =>
                                      !(
                                        !this.state.searchText ||
                                        !this.isKeywordStale(a)
                                      ),
                                    o = !(
                                      !e ||
                                      (!e.timeFrom &&
                                        !e.timeTo &&
                                        "string" != typeof e.sender)
                                    ),
                                    d = [],
                                    l = t ? this.dataLoaded.indexCurrent : 0,
                                    c = Math.min(
                                      l + 20,
                                      this.dataLoaded.allMsgIds.length,
                                    );
                                  if (
                                    (t || delete this.dataLoaded.oldestIndex,
                                    e &&
                                      e.timeFrom &&
                                      this.dataLoaded.oldestIndex &&
                                      c >= this.dataLoaded.oldestIndex)
                                  )
                                    return void (s && s(null, -1));
                                  if (c <= l)
                                    return void (s && s(null, -1, !1));
                                  this.updateState(
                                    Object(f.a)(
                                      Object(f.a)({}, this.state),
                                      {},
                                      { searching: !0 },
                                    ),
                                  );
                                  let h = this.dataLoaded.allMsgIds.slice(l, c);
                                  this.dataLoaded.indexCurrent = c;
                                  const u = (i) => {
                                    let n = [];
                                    if (
                                      ((this.loadingMore = !1),
                                      (this.isSearchingMsg = !1),
                                      r())
                                    )
                                      s && s(null, -1);
                                    else if (i && i.listConv && i.arr) {
                                      if (
                                        (this.convListController
                                          .getRecentContacts()
                                          .forEach((e) => {
                                            let t = i.listConv.indexOf(
                                              e.userId,
                                            );
                                            if (
                                              t >= 0 &&
                                              !Jt.a.isThreadHidden(e.userId)
                                            )
                                              for (
                                                let s = t;
                                                s < i.listConv.length;
                                                ++s
                                              )
                                                i.listConv[s] == e.userId &&
                                                  (i.arr[s].conversation = e);
                                          }),
                                        i.arr.forEach((t) => {
                                          if (o) {
                                            if (!t.message) return;
                                            if (
                                              e &&
                                              "string" == typeof e.sender &&
                                              e.sender !== t.message.fromUid
                                            )
                                              return;
                                            if (
                                              e &&
                                              e.timeFrom &&
                                              e.timeFrom > t.message.sendDttm
                                            )
                                              return void (this.dataLoaded.oldestIndex =
                                                this.dataLoaded.indexCurrent);
                                            if (
                                              e &&
                                              e.timeTo &&
                                              e.timeTo < t.message.sendDttm
                                            )
                                              return;
                                          }
                                          Object.keys(t.conversation).length >
                                            1 && n.push(t);
                                        }),
                                        Array.prototype.push.apply(d, n),
                                        !r() && this.isFirstLoadSuccess)
                                      ) {
                                        if (
                                          t &&
                                          this.state.searchResult.messages
                                        ) {
                                          var a;
                                          const e =
                                            null ===
                                              (a =
                                                this.state.searchResult
                                                  .messages[
                                                  this.state.searchResult
                                                    .messages.length - 1
                                                ]) || void 0 === a
                                              ? void 0
                                              : a.message;
                                          e && e.sendDttm < i.maxTime
                                            ? ((n =
                                                this.state.searchResult.messages.concat(
                                                  n,
                                                )),
                                              (n = n.sort(
                                                (e, t) =>
                                                  t.message.sendDttm -
                                                  e.message.sendDttm,
                                              )))
                                            : (n =
                                                this.state.searchResult.messages.concat(
                                                  n,
                                                ));
                                        }
                                        this.updateState(
                                          Object(f.a)(
                                            Object(f.a)({}, this.state),
                                            {},
                                            {
                                              searchResult: Object(f.a)(
                                                Object(f.a)(
                                                  {},
                                                  this.state.searchResult,
                                                ),
                                                {},
                                                {
                                                  isMoreMsg:
                                                    c <
                                                    this.dataLoaded.allMsgIds
                                                      .length,
                                                  messages: n,
                                                },
                                              ),
                                              searching: !1,
                                            },
                                          ),
                                        );
                                        const r = !(
                                          o &&
                                          e.timeFrom &&
                                          c >= this.dataLoaded.allMsgIds.length
                                        );
                                        s && s(d, this.pageLoad, r);
                                      }
                                    }
                                  };
                                  fs.a.logTrace(
                                    `load more msg with key ${a} - msgID length: ${h.length} - ${c}/${null === (i = this.dataLoaded) || void 0 === i || null === (n = i.allMsgIds) || void 0 === n ? void 0 : n.length}`,
                                  ),
                                    (this.isSearchingMsg = !0),
                                    bs.a
                                      .getMessages(h, r)
                                      .then((e) => {
                                        u(e);
                                      })
                                      .catch((e) => {
                                        s && s(null, -1);
                                      })
                                      .finally(() => {
                                        (this.isSearchingMsg = !1),
                                          this.updateState(
                                            Object(f.a)(
                                              Object(f.a)({}, this.state),
                                              {},
                                              { searching: !1 },
                                            ),
                                          );
                                      });
                                }
                                loadMessagesV2(e, t, s) {
                                  return (
                                    void 0 === t && (t = !1),
                                    this.loadCachedMessages(e, t, s)
                                  );
                                }
                                loadMoreMessagesWithMsgIdsLoaded(e, t, s) {
                                  return (
                                    void 0 === t && (t = !1),
                                    this.loadCachedMessages(e, t, s)
                                  );
                                }
                                isCanLoadMoreWithMsgIdsLoaded() {
                                  return (
                                    !!(
                                      this.dataLoaded &&
                                      Ct.default.valueValid(
                                        this.dataLoaded.indexCurrent,
                                      ) &&
                                      Ct.default.valueValid(
                                        this.dataLoaded.allMsgIds,
                                      )
                                    ) &&
                                    !(
                                      this.dataLoaded.allMsgIds.length <=
                                      this.dataLoaded.indexCurrent
                                    )
                                  );
                                }
                                loadMoreMessagesWithRange(e, t, s, i) {
                                  var n, a, r;
                                  let o = this.state.searchText;
                                  if (!o) return;
                                  let d =
                                    null === (n = this.searchResultList) ||
                                    void 0 === n
                                      ? void 0
                                      : n.getRange(!t);
                                  const l = !(
                                      !i ||
                                      (!i.timeFrom &&
                                        !i.timeTo &&
                                        "string" != typeof i.sender)
                                    ),
                                    c = () =>
                                      !(
                                        !this.state.searchText ||
                                        !this.isKeywordStale(o)
                                      );
                                  this.updateState(
                                    Object(f.a)(
                                      Object(f.a)({}, this.state),
                                      {},
                                      {
                                        searchResult: Object(f.a)(
                                          Object(f.a)(
                                            {},
                                            this.state.searchResult,
                                          ),
                                          {},
                                          {
                                            messages: t
                                              ? null ===
                                                  (a =
                                                    this.state.searchResult) ||
                                                void 0 === a
                                                ? void 0
                                                : a.messages
                                              : null,
                                            isMoreMsg:
                                              !!t &&
                                              (null ===
                                                (r = this.state.searchResult) ||
                                              void 0 === r
                                                ? void 0
                                                : r.isMoreMsg),
                                          },
                                        ),
                                        searching: !0,
                                      },
                                    ),
                                  );
                                  const h = (e) => {
                                    this.isSearchingMsg = !1;
                                    let n = [],
                                      a = [];
                                    if (c())
                                      return (
                                        this.pageLoad++, void (s && s(null, -1))
                                      );
                                    if (!e || !e.listConv || !e.arr)
                                      return void (s && s(null, -1));
                                    this.convListController
                                      .getRecentContacts()
                                      .forEach((t) => {
                                        let s = e.listConv.indexOf(t.userId);
                                        if (
                                          s >= 0 &&
                                          !Jt.a.isThreadHidden(t.userId)
                                        )
                                          for (
                                            let i = s;
                                            i < e.listConv.length;
                                            ++i
                                          )
                                            e.listConv[i] == t.userId &&
                                              (e.arr[i].conversation = t);
                                      }),
                                      e.arr.forEach((e) => {
                                        (l &&
                                          i &&
                                          "string" == typeof i.sender &&
                                          i.sender !== e.message.fromUid) ||
                                          (Object.keys(e.conversation).length >
                                            1 &&
                                            a.push(e));
                                      }),
                                      Array.prototype.push.apply(n, a),
                                      t &&
                                        (a =
                                          this.state.searchResult.messages.concat(
                                            a,
                                          )),
                                      this.dataLoaded
                                        ? (e.dataLoaded.allMsgIds &&
                                            (this.dataLoaded.allMsgIds =
                                              this.dataLoaded.allMsgIds.concat(
                                                e.dataLoaded.allMsgIds,
                                              )),
                                          e.dataLoaded.indexCurrent &&
                                            (this.dataLoaded.indexCurrent +=
                                              e.dataLoaded.indexCurrent))
                                        : (this.dataLoaded = e.dataLoaded);
                                    const r = !(
                                      l &&
                                      i.timeFrom &&
                                      a.length <
                                        this.dataLoaded.allMsgIds.length
                                    );
                                    this.updateState(
                                      Object(f.a)(
                                        Object(f.a)({}, this.state),
                                        {},
                                        {
                                          searchResult: Object(f.a)(
                                            Object(f.a)(
                                              {},
                                              this.state.searchResult,
                                            ),
                                            {},
                                            {
                                              messages: a,
                                              isMoreMsg:
                                                !(
                                                  !a.length &&
                                                  !this.dataLoaded.allMsgIds
                                                    .length
                                                ) &&
                                                a.length <
                                                  this.dataLoaded.allMsgIds
                                                    .length,
                                            },
                                          ),
                                          searching: !1,
                                        },
                                      ),
                                    ),
                                      s && s(n, this.pageLoad, r);
                                  };
                                  let u = { totalItemReq: 4 };
                                  fs.a.logTrace(
                                    `load more msg with range: ${d.timeFrom} - ${d.timeTo}`,
                                  ),
                                    (this.isSearchingMsg = !0),
                                    bs.a
                                      .searchGlobalMessagesV3(
                                        o,
                                        c,
                                        void 0,
                                        null,
                                        bt.default.limit_result_msg_search + 1,
                                        d,
                                        u,
                                      )
                                      .then((e) => h(e))
                                      .catch((e) => {
                                        (this.loadingMore = !1),
                                          s && s(null, -1),
                                          Ct.default.logCoreError(
                                            "searchGlobalMsg v2 " + e,
                                          );
                                      })
                                      .finally(() => {
                                        (this.isSearchingMsg = !1),
                                          this.updateState(
                                            Object(f.a)(
                                              Object(f.a)({}, this.state),
                                              {},
                                              { searching: !1 },
                                            ),
                                          );
                                      });
                                }
                                loadMoreMessagesV2(e, t, s, i) {
                                  if (
                                    (void 0 === t && (t = !1),
                                    this.isFirstLoadSuccess &&
                                      !this.isSearchingMsg)
                                  )
                                    return bt.default.enable_optimize_search &&
                                      !Ss.a.isSearchOnSqlite3()
                                      ? this.loadCachedMessages(i, t, s)
                                      : t &&
                                          this.isCanLoadMoreWithMsgIdsLoaded()
                                        ? this.loadMoreMessagesWithMsgIdsLoaded(
                                            i,
                                            t,
                                            s,
                                          )
                                        : (t || (this.dataLoaded = null),
                                          this.loadMoreMessagesWithRange(
                                            e,
                                            t,
                                            s,
                                            i,
                                          ));
                                  s && s(null, -1);
                                }
                                loadMoreMessages() {
                                  let e = this.state.searchResult;
                                  if (
                                    Ss.a.isSearchOnSqlite3() &&
                                    e &&
                                    e.rawSearchResult &&
                                    e.messageList &&
                                    e.rawSearchResult.length > e.lastOffset &&
                                    !this.loadingMore
                                  ) {
                                    this.loadingMore = !0;
                                    const t = this.state.conversation.userId;
                                    bs.a
                                      .getMessageOfConversation(
                                        e.rawSearchResult,
                                        this.state.conversation.userId,
                                        20,
                                        e.lastOffset,
                                      )
                                      .then((s) => {
                                        let i = s.list;
                                        if (
                                          this.state.conversation &&
                                          t == this.state.conversation.userId
                                        ) {
                                          let t = Ct.default.ZSafeFunction(
                                            () =>
                                              Math.max(
                                                0,
                                                e.rawSearchResult.length -
                                                  e.lastOffset -
                                                  20,
                                              ) +
                                              e.messageList.length +
                                              i.length,
                                            s.len,
                                          );
                                          i.length > 0
                                            ? this.updateState(
                                                Object(f.a)(
                                                  Object(f.a)({}, this.state),
                                                  {},
                                                  {
                                                    searchResult: Object(f.a)(
                                                      Object(f.a)(
                                                        {},
                                                        this.state.searchResult,
                                                      ),
                                                      {},
                                                      {
                                                        messageList:
                                                          this.state.searchResult.messageList.concat(
                                                            i.map((e) => ({
                                                              message: e,
                                                              conversation:
                                                                this.state
                                                                  .conversation,
                                                            })),
                                                          ),
                                                        realLen: t,
                                                        lastOffset:
                                                          this.state
                                                            .searchResult
                                                            .lastOffset + 20,
                                                      },
                                                    ),
                                                  },
                                                ),
                                              )
                                            : this.state &&
                                              this.state.searchResult &&
                                              (this.state.searchResult
                                                .realLen !== t
                                                ? this.updateState(
                                                    Object(f.a)(
                                                      Object(f.a)(
                                                        {},
                                                        this.state,
                                                      ),
                                                      {},
                                                      {
                                                        searchResult: Object(
                                                          f.a,
                                                        )(
                                                          Object(f.a)(
                                                            {},
                                                            this.state
                                                              .searchResult,
                                                          ),
                                                          {},
                                                          {
                                                            realLen: t,
                                                            lastOffset:
                                                              e.lastOffset + 20,
                                                          },
                                                        ),
                                                      },
                                                    ),
                                                  )
                                                : (this.state.searchResult.lastOffset += 20));
                                        }
                                        this.loadingMore = !1;
                                      });
                                  }
                                }
                                loadMoreFiles() {
                                  let e = this.state.searchResult,
                                    t = this.state.searchText;
                                  var s;
                                  e &&
                                    e.rawFileResult &&
                                    e.files &&
                                    e.rawFileResult.length > e.lastFileOffset &&
                                    !this.loadingMoreFiles &&
                                    ((this.loadingMoreFiles = !0),
                                    null ===
                                      (s = i.ModuleContainer.resolve(ps.a)) ||
                                      void 0 === s ||
                                      s
                                        .getMultiMedias(
                                          "file",
                                          e.rawFileResult.slice(
                                            e.lastFileOffset,
                                            e.lastFileOffset + 20,
                                          ),
                                        )
                                        .then((s) => {
                                          if (
                                            ((this.loadingMoreFiles = !1),
                                            this.isKeywordStale(t))
                                          )
                                            return;
                                          e = this.state.searchResult;
                                          const i = s.filter(Boolean);
                                          let n = Ct.default.ZSafeFunction(
                                              () =>
                                                Math.max(
                                                  0,
                                                  e.rawFileResult.length -
                                                    e.lastFileOffset -
                                                    20,
                                                ) +
                                                e.files.length +
                                                i.length,
                                              e.realFileLen,
                                            ),
                                            a =
                                              this.state.searchResult.files.concat(
                                                i,
                                              );
                                          a.sort(
                                            (e, t) =>
                                              parseInt(t.sendDttm) -
                                              parseInt(e.sendDttm),
                                          ),
                                            this.updateState(
                                              Object(f.a)(
                                                Object(f.a)({}, this.state),
                                                {},
                                                {
                                                  searchResult: Object(f.a)(
                                                    Object(f.a)(
                                                      {},
                                                      this.state.searchResult,
                                                    ),
                                                    {},
                                                    {
                                                      files: a,
                                                      realFileLen: n,
                                                      lastFileOffset:
                                                        e.lastFileOffset + 20,
                                                    },
                                                  ),
                                                },
                                              ),
                                            );
                                        })
                                        .catch((e) => {
                                          (this.loadingMoreFiles = !1),
                                            Ct.default.logCoreError(
                                              "_loadMoreFiles ",
                                              e,
                                            );
                                        }));
                                }
                                qosLogSearch() {
                                  this.countTimeUseGlobalSearch &&
                                    (B.default.increaseSuccess(
                                      97111,
                                      0,
                                      vs.a.now() -
                                        this.countTimeUseGlobalSearch,
                                    ),
                                    (this.countTimeUseGlobalSearch = 0)),
                                    this.countSelectTopRes >= 0 &&
                                      (B.default.increaseSuccess(
                                        97112,
                                        0,
                                        this.countSelectTopRes,
                                      ),
                                      (this.countSelectTopRes = -1));
                                }
                                selectTopRes() {
                                  this.countSelectTopRes >= 0 &&
                                    this.countSelectTopRes++;
                                }
                                selectResult(e, t, s, i) {
                                  var n;
                                  void 0 === t && (t = !1),
                                    void 0 === s && (s = !1),
                                    void 0 === i && (i = !1);
                                  const a = this.state.searchText;
                                  let r = !!this.state.conversation;
                                  Es.a
                                    .jumpToMessage(
                                      e.message,
                                      null === (n = e.conversation) ||
                                        void 0 === n
                                        ? void 0
                                        : n.userId,
                                      Ge.f,
                                    )
                                    .then((t) => {
                                      const { groupMsgs: s = [] } = t;
                                      let i = null;
                                      Ct.default.ZSafeFunction(() => {
                                        if (s)
                                          for (let t = 0; t < s.length; t++)
                                            if (s[t].msgId == e.message.msgId)
                                              return (
                                                (i = Object(f.a)({}, s[t])),
                                                void (i.searchKeyWord = a)
                                              );
                                      }, null),
                                        this.state.searchText &&
                                          _s.a.addCacheKeyword(
                                            this.state.searchText,
                                          ),
                                        Mt.default.send(
                                          St.ChatBoxActions
                                            .OPEN_CONV_JUMP_TO_MESSAGE_SEARCH,
                                          {
                                            messages: s,
                                            focusId: ["" + e.message.msgId],
                                            conversation: e.conversation,
                                          },
                                        ),
                                        i &&
                                          Object(Ge.f)({
                                            type: St.ChatBoxActions
                                              .UPDATE_MESSAGE_ATTRIBUTES,
                                            payload: i,
                                          });
                                    })
                                    .catch((t) => {
                                      Ct.default.logCoreError(t),
                                        et.a.createWarning(
                                          tt.default.str(
                                            "STR_MESSAGE_NOT_FOUND",
                                          ),
                                        ),
                                        i ||
                                          Mt.default.send(
                                            St.ChatBoxActions
                                              .OPEN_CONV_JUMP_TO_MESSAGE_SEARCH,
                                            {
                                              messages: [],
                                              focusId: [],
                                              conversation: e.conversation,
                                            },
                                          );
                                    }),
                                    r
                                      ? (s && this.focusSearchBox(),
                                        this.updateState(
                                          Object(f.a)(
                                            Object(f.a)({}, this.state),
                                            {},
                                            { highlightId: e.message.msgId },
                                          ),
                                        ))
                                      : t ||
                                        this.updateState(
                                          Object(f.a)(
                                            Object(f.a)({}, this.state),
                                            {},
                                            { highlightId: e.message.msgId },
                                          ),
                                        );
                                }
                                getRecentSearchItems() {
                                  if (0 === bt.default.recent_search.is_enable)
                                    return [];
                                  let e = _s.a.getLocalRecentSearchList();
                                  if (!e) return [];
                                  let t = ds.default.getGroupsListSync(),
                                    s = t || [];
                                  return (
                                    (e = e.filter((e) => {
                                      if (
                                        e &&
                                        e.userId &&
                                        !Jt.a.isThreadHidden(e.userId)
                                      ) {
                                        if (
                                          e.userId.startsWith(
                                            R.GROUPID_PREFIX,
                                          ) ||
                                          1 === e.type
                                        ) {
                                          let t = !1;
                                          1 !== e.type ||
                                            e.userId.startsWith(
                                              R.GROUPID_PREFIX,
                                            ) ||
                                            (e.userId =
                                              R.GROUPID_PREFIX + e.userId);
                                          for (let i of s)
                                            if (
                                              i.userId &&
                                              e.userId == i.userId
                                            ) {
                                              t = !0;
                                              break;
                                            }
                                          return (
                                            !!t ||
                                            (_s.a.removeLocalRecentSearchList(
                                              e.userId,
                                            ),
                                            !1)
                                          );
                                        }
                                        return !0;
                                      }
                                      return !1;
                                    })),
                                    e
                                  );
                                }
                                getCacheRecentSearch() {
                                  return (
                                    (this.cacheSearch.items =
                                      this.getRecentSearchItems()),
                                    bt.default.sync_recent_search.enable_kw &&
                                      (this.cacheSearch.keywords =
                                        _s.a.getLocalKeywordList()),
                                    this.cacheSearch
                                  );
                                }
                                getPageLoad() {
                                  return this.pageLoad;
                                }
                                getSearchInputRef() {
                                  return this.searchInput;
                                }
                                getSearchState() {
                                  return this.state;
                                }
                                clearSearch(e) {
                                  if (
                                    (void 0 === e && (e = !0),
                                    this._resetCacheResultSearch(),
                                    this.onAbortSearch(),
                                    (this.dataLoaded = null),
                                    (this.searchInput.value = ""),
                                    (this.lastTextSearch = ""),
                                    e)
                                  ) {
                                    if (
                                      (Is.b.setMode(Is.a.NORMAL),
                                      this.updateState(Object(f.a)({}, Rs)),
                                      this.sidebarController.getState(Qt.c)
                                        .currentTab == Wt.SidebarTab.FILE_TAB)
                                    )
                                      return void this.functionSearchByName(
                                        null,
                                        this.countQuery,
                                        !0,
                                      );
                                  } else
                                    this.updateState(
                                      Object(f.a)(
                                        Object(f.a)({}, this.state),
                                        {},
                                        {
                                          searchText: "",
                                          searching: !0,
                                          highlightId: "",
                                        },
                                      ),
                                    ),
                                      this.functionSearchByName(
                                        "",
                                        this.countQuery,
                                        !0,
                                      );
                                }
                                _resetCacheResultSearch() {
                                  (this.curQuery = ""),
                                    (this.cacheResSearch = null),
                                    (this.trackSearch = !1),
                                    (this.trackSearchVietnamese = !1);
                                }
                                _checkOnAdminMode(e) {
                                  let t = this.__checkOnAdminMode(e);
                                  t &&
                                    (1 === t
                                      ? (this.clearAdminMode &&
                                          clearTimeout(this.clearAdminMode),
                                        (bt.default.adminMode = !0),
                                        this.sidebarController.togglePerfTab(
                                          !0,
                                        ),
                                        (this.clearAdminMode = setTimeout(
                                          () => {
                                            (this.clearAdminMode = void 0),
                                              (bt.default.adminMode = void 0),
                                              this.sidebarController.togglePerfTab();
                                          },
                                          216e5,
                                        )))
                                      : 2 === t &&
                                        (this.clearAdminMode &&
                                          (clearTimeout(this.clearAdminMode),
                                          (this.clearAdminMode = void 0)),
                                        (bt.default.adminMode = !1),
                                        this.sidebarController.togglePerfTab(
                                          !1,
                                        )));
                                }
                                __checkOnAdminMode(e) {
                                  if (
                                    e &&
                                    "string" == typeof e &&
                                    e.startsWith("$##")
                                  ) {
                                    return e.substring(3) ===
                                      bt.default.zAminKey
                                      ? 1
                                      : 2;
                                  }
                                  return 0;
                                }
                                _innerSearchFunc(e, t, s) {
                                  if ((void 0 === s && (s = !0), !Ls.valid(t)))
                                    return;
                                  if (
                                    this.sidebarController.getState(Qt.c)
                                      .currentTab === Wt.SidebarTab.FILE_TAB
                                  )
                                    Mt.default.send(
                                      St.SideBarActions.SEARCH_FILE,
                                      { term: e },
                                    );
                                  else if (this.state.conversation)
                                    this.filterByConversation(
                                      e,
                                      this.state.conversation,
                                    );
                                  else {
                                    const t =
                                        s &&
                                        this.isKeywordStale(
                                          this.lastTextSearch,
                                        ),
                                      n = Ms.a.formatTextSearch(e);
                                    var i;
                                    if (
                                      (this.logSearch(
                                        `[Search flow] start search-------: ${t}, ${n}`,
                                      ),
                                      !n)
                                    )
                                      null === (i = this.searchResultList) ||
                                        void 0 === i ||
                                        i.forceStopSearch(),
                                        this.updateState(
                                          Object(f.a)(
                                            Object(f.a)({}, this.state),
                                            {},
                                            {
                                              searchResult: Object(f.a)(
                                                Object(f.a)(
                                                  {},
                                                  this.state.searchResult,
                                                ),
                                                {},
                                                {
                                                  messages: null,
                                                  files: [],
                                                  rawFileResult: [],
                                                },
                                              ),
                                            },
                                          ),
                                        );
                                    this._searchGlobal(e, t);
                                  }
                                }
                                debounceSearchMsgAndFile(e, t) {
                                  this._timeDebounceSearch &&
                                    clearTimeout(this._timeDebounceSearch),
                                    (this._timeDebounceSearch = setTimeout(
                                      () => {
                                        e();
                                      },
                                      t,
                                    ));
                                }
                                getTimeDebounceSearchMsgAndFile() {
                                  return bt.default
                                    .debounce_search_msg_optimize;
                                }
                                _searchGlobal(e, t) {
                                  var s,
                                    n,
                                    a,
                                    r,
                                    o,
                                    d,
                                    l = this;
                                  void 0 === t && (t = !0),
                                    (this.lastTextSearchTs = Date.now()),
                                    (this.lastTextSearch = e);
                                  let c = 2,
                                    h = 0,
                                    u = {},
                                    g = this.convDataManager.getAllConvSync(),
                                    m =
                                      this.previewDataManager.getAllPreviewsSync(),
                                    p = Ct.default.simpleStripVietnamese(e, !1);
                                  const v = (s, i) => {
                                      s !== Ds.STEP_DIRECTORY &&
                                        s !== Ds.STEP_FILES &&
                                        c--;
                                      let n,
                                        a =
                                          1 == c &&
                                          s === Ds.STEP_CONTACT &&
                                          0 == h;
                                      if (
                                        ((n = !!(c > 1 || a)),
                                        this.updateState(
                                          Object(f.a)(
                                            Object(f.a)({}, this.state),
                                            {},
                                            { searchResult: i, searching: n },
                                          ),
                                        ),
                                        s === Ds.STEP_CONTACT &&
                                          t &&
                                          (bt.default.enable_optimize_search
                                            ? this.debounceSearchMsgAndFile(
                                                () => {
                                                  b()
                                                    ? fs.a.logTrace(
                                                        `abort debound search msg: ${e}`,
                                                      )
                                                    : (fs.a.logTrace(
                                                        `do search msg & file: ${e}`,
                                                      ),
                                                      y(i && !i.all.length),
                                                      bt.default
                                                        .tabbedGlobalSearchResult &&
                                                        Is.b.setMode(
                                                          Is.a.SEARCHING,
                                                        ),
                                                      bt.default
                                                        .enableFileGlobalSearch &&
                                                        I());
                                                },
                                                this.getTimeDebounceSearchMsgAndFile(),
                                              )
                                            : (y(i && !i.all.length),
                                              bt.default
                                                .tabbedGlobalSearchResult &&
                                                Is.b.setMode(Is.a.SEARCHING),
                                              bt.default
                                                .enableFileGlobalSearch &&
                                                I())),
                                        0 == c && !this.isKeywordStale(e))
                                      ) {
                                        let e =
                                          Date.now() - this.lastTextSearchTs;
                                        e > 2e3
                                          ? this._upSearchDelay()
                                          : e < 600 && this._downSearchDelay();
                                      }
                                    },
                                    b = () => !!this.isKeywordStale(e),
                                    I = () => {
                                      if (
                                        bt.default.adminConfig &&
                                        bt.default.adminConfig
                                          .offglobalSearchMessage
                                      )
                                        return setTimeout(() => {
                                          this.state &&
                                            !this.isKeywordStale(e) &&
                                            v(
                                              Ds.STEP_FILES,
                                              this.state.searchResult,
                                            );
                                        }, 100);
                                      const t = function (t, s) {
                                        var n, a, r;
                                        if (
                                          (void 0 === s && (s = !0),
                                          l.isKeywordStale(e))
                                        )
                                          return;
                                        ((null != t && t.length) || !s) &&
                                          ws.a.fileUIVisible(
                                            vs.a.now(),
                                            (null == t ? void 0 : t.length) ||
                                              0,
                                          );
                                        let o = new Set(),
                                          d = [];
                                        var c, u;
                                        if (
                                          (t.forEach((e) => {
                                            e.msgId &&
                                              !o.has(e.msgId) &&
                                              (o.add(e.msgId), d.push(e.msgId));
                                          }),
                                          (null ===
                                            (n = l.state.searchResult) ||
                                          void 0 === n ||
                                          null === (a = n.rawFileResult) ||
                                          void 0 === a
                                            ? void 0
                                            : a.length) >= 20 &&
                                            (null == d ? void 0 : d.length) >=
                                              20) &&
                                          (null ===
                                            (c = l.state.searchResult) ||
                                          void 0 === c
                                            ? void 0
                                            : c.rawFileResult[0]) == d[0] &&
                                          (null ===
                                            (u = l.state.searchResult) ||
                                          void 0 === u
                                            ? void 0
                                            : u.rawFileResult[19]) == d[19]
                                        )
                                          return void l.updateState(
                                            Object(f.a)(
                                              Object(f.a)({}, l.state),
                                              {},
                                              {
                                                searchResult: Object(f.a)(
                                                  Object(f.a)(
                                                    {},
                                                    l.state.searchResult,
                                                  ),
                                                  {},
                                                  {
                                                    rawFileResult: d,
                                                    realFileLen: d.length,
                                                  },
                                                ),
                                              },
                                            ),
                                            !1,
                                          );
                                        const g = d.slice(0, 20);
                                        null ===
                                          (r = i.ModuleContainer.resolve(
                                            ps.a,
                                          )) ||
                                          void 0 === r ||
                                          r
                                            .getMultiMedias("file", g)
                                            .then((t) => {
                                              if (l.isKeywordStale(e)) return;
                                              let s = [],
                                                i = 0,
                                                n = 0;
                                              for (const e of t)
                                                e ? (s.push(e), i++) : n++;
                                              s.sort(
                                                (e, t) =>
                                                  parseInt(t.sendDttm) -
                                                  parseInt(e.sendDttm),
                                              );
                                              let a = l.state.searchResult;
                                              Ct.default.log(
                                                "search files: cur = " +
                                                  a.searchKey +
                                                  " this query = " +
                                                  e,
                                                s.length,
                                              ),
                                                (a = a
                                                  ? Object(f.a)({}, a)
                                                  : {}),
                                                (a.files = s),
                                                (a.realFileLen = d.length - n),
                                                (a.rawFileResult = d),
                                                (a.lastFileOffset = g.length),
                                                (a.searchKey = e),
                                                (h += i),
                                                v(Ds.STEP_FILES, a);
                                            })
                                            .catch((t) => {
                                              Ct.default.logCoreError(
                                                "doSearchFiles " + t,
                                              ),
                                                l.state &&
                                                  !l.isKeywordStale(e) &&
                                                  v(
                                                    Ds.STEP_FILES,
                                                    l.state.searchResult,
                                                  );
                                            });
                                      };
                                      ws.a.startQueryFile(vs.a.now()),
                                        bs.a
                                          .search(
                                            e,
                                            null,
                                            { msgType: R.MSG_FILE },
                                            t,
                                            { enableReject: !0 },
                                          )
                                          .then((e) => {
                                            t(e, !1);
                                          })
                                          .catch((e) => {
                                            (this.state.searchResult.files &&
                                              this.state.searchResult.files
                                                .length) ||
                                              this.updateState(
                                                Object(f.a)(
                                                  Object(f.a)({}, this.state),
                                                  {},
                                                  {
                                                    searchResult: Object(f.a)(
                                                      Object(f.a)(
                                                        {},
                                                        this.state.searchResult,
                                                      ),
                                                      {},
                                                      { files: [] },
                                                    ),
                                                  },
                                                ),
                                                !0,
                                              );
                                          });
                                    },
                                    y = function (t) {
                                      if (
                                        (void 0 === t && (t = !1),
                                        bt.default.adminConfig &&
                                          bt.default.adminConfig
                                            .offglobalSearchMessage)
                                      )
                                        return setTimeout(() => {
                                          l.state &&
                                            !l.isKeywordStale(e) &&
                                            v(
                                              Ds.STEP_MESSAGES,
                                              l.state.searchResult,
                                            );
                                        }, 100);
                                      l.logSearch(
                                        `[Search flow] search msg: ${e}`,
                                      );
                                      const s = function (t, s) {
                                        var i;
                                        if (
                                          (void 0 === s && (s = !1),
                                          s && (l.isSearchingMsg = !1),
                                          l.logSearch(
                                            `[Search flow] search msg res first load: ${e}, ${null === (i = t.arr) || void 0 === i ? void 0 : i.length}`,
                                          ),
                                          (l.pageLoad = 0),
                                          l.timeouResetDataMsg &&
                                            (clearTimeout(l.timeouResetDataMsg),
                                            (l.timeouResetDataMsg = !1),
                                            l.updateState(
                                              Object(f.a)(
                                                Object(f.a)({}, l.state),
                                                {},
                                                {
                                                  searchResult: Object(f.a)(
                                                    Object(f.a)(
                                                      {},
                                                      l.state.searchResult,
                                                    ),
                                                    {},
                                                    { messages: null },
                                                  ),
                                                },
                                              ),
                                              !1,
                                            )),
                                          !l.isKeywordStale(e) && t)
                                        ) {
                                          let i = [],
                                            r = 0;
                                          t &&
                                            t.listConv &&
                                            t.arr &&
                                            g.forEach((e) => {
                                              let s = t.listConv.indexOf(
                                                e.userId,
                                              );
                                              if (
                                                s >= 0 &&
                                                !Jt.a.isThreadHidden(e.userId)
                                              )
                                                for (
                                                  let n = s;
                                                  n < t.listConv.length;
                                                  ++n
                                                )
                                                  t.listConv[n] == e.userId &&
                                                    ((t.arr[n].conversation =
                                                      e),
                                                    (r += 1),
                                                    i.push(t.arr[n]));
                                            });
                                          let o = l.state.searchResult,
                                            d = i;
                                          var n;
                                          if (
                                            (o.messages &&
                                              ((d = o.messages.slice()),
                                              Array.prototype.push.apply(d, i)),
                                            d.sort(
                                              (e, t) =>
                                                parseInt(t.message.sendDttm) -
                                                parseInt(e.message.sendDttm),
                                            ),
                                            (o = o ? Object(f.a)({}, o) : {}),
                                            (o.messages = d),
                                            (o.searchKey = e),
                                            (o.isMoreMsg = t.isMoreMsg),
                                            (l.dataLoaded = t.dataLoaded),
                                            (h += r),
                                            s)
                                          )
                                            (l.isFirstLoadSuccess = !0),
                                              l.searchResultList &&
                                                a &&
                                                l.searchResultList.updateFirstLoadPos(
                                                  a.timeFrom,
                                                ),
                                              Ct.default.logCoreError(
                                                "[Global search] check First data",
                                                e,
                                                null ===
                                                  (n =
                                                    l.state.searchResult
                                                      .messages) || void 0 === n
                                                  ? void 0
                                                  : n.length,
                                              );
                                          else if (!i.length) return;
                                          v(Ds.STEP_MESSAGES, o);
                                        }
                                      };
                                      let i = null;
                                      var n;
                                      l.searchResultList &&
                                        (!l.timeouResetDataMsg &&
                                          l.state.searchResult.messages &&
                                          (l.timeouResetDataMsg = setTimeout(
                                            () => {
                                              (l.timeouResetDataMsg = !1),
                                                l.updateState(
                                                  Object(f.a)(
                                                    Object(f.a)({}, l.state),
                                                    {},
                                                    {
                                                      searchResult: Object(f.a)(
                                                        Object(f.a)(
                                                          {},
                                                          l.state.searchResult,
                                                        ),
                                                        {},
                                                        { messages: null },
                                                      ),
                                                    },
                                                  ),
                                                ),
                                                l.searchResultList &&
                                                  l.searchResultList.resetDataSearch();
                                            },
                                            1e3,
                                          )),
                                        l.searchResultList.resetDataSearch(),
                                        Ss.a.isSearchOnSqlite3() &&
                                          ((i =
                                            null === (n = l.searchResultList) ||
                                            void 0 === n
                                              ? void 0
                                              : n.getRange()),
                                          l.updateState(
                                            Object(f.a)(
                                              Object(f.a)({}, l.state),
                                              {},
                                              {
                                                filter: {
                                                  timeFrom: i.timeFrom,
                                                  timeTo: i.timeTo,
                                                },
                                              },
                                            ),
                                            !1,
                                          )));
                                      const a = Object(f.a)({}, i);
                                      l.updateState(
                                        Object(f.a)(
                                          Object(f.a)({}, l.state),
                                          {},
                                          {
                                            searching: !0,
                                            highlightId: "",
                                            searchResult: Object(f.a)(
                                              Object(f.a)(
                                                {},
                                                l.state.searchResult,
                                              ),
                                              {},
                                              {
                                                messages:
                                                  !l.lastTextSearch ||
                                                  e.length <
                                                    l.lastTextSearch.length
                                                    ? null
                                                    : l.state.searchResult
                                                        .messages,
                                              },
                                            ),
                                          },
                                        ),
                                      ),
                                        (l.loadingMore = !1),
                                        (l.isFirstLoadSuccess = !1);
                                      let r = {};
                                      t || (r.totalItemReq = 4),
                                        ws.a.startQueryMsg(
                                          vs.a.now(),
                                          bs.a.isEnableSearchSqlite,
                                        ),
                                        (l.isSearchingMsg = !0),
                                        bs.a
                                          .searchGlobalMessagesV3(
                                            e,
                                            () =>
                                              !(
                                                !Ss.a.isSearchOnSqlite3() ||
                                                (l.state.filter.timeFrom ==
                                                  a.timeFrom &&
                                                  l.state.filter.timeTo ==
                                                    a.timeTo)
                                              ) || b(),
                                            void 0,
                                            s,
                                            bt.default.limit_result_msg_search +
                                              1,
                                            i,
                                            r,
                                          )
                                          .then((e) => s(e, !0))
                                          .catch((t) => {
                                            if (
                                              (l.logSearch(
                                                `[Search flow] search msg fail: ${t}`,
                                              ),
                                              Ct.default.logCoreError(
                                                "searchGlobalMsg " + t,
                                              ),
                                              l.state && !l.isKeywordStale(e))
                                            ) {
                                              l.searchResultList &&
                                                l.searchResultList.forceStopSearch(),
                                                l.timeouResetDataMsg &&
                                                  (clearTimeout(
                                                    l.timeouResetDataMsg,
                                                  ),
                                                  (l.timeouResetDataMsg = !1));
                                              let e = l.state.searchResult;
                                              (e.messages = []),
                                                v(Ds.STEP_MESSAGES, e);
                                            }
                                          })
                                          .finally(() => {
                                            l.isSearchingMsg = !1;
                                          });
                                    };
                                  if (
                                    (this.curQuery &&
                                      0 !== e.indexOf(this.curQuery) &&
                                      this._resetCacheResultSearch(),
                                    !this.cacheResSearch)
                                  ) {
                                    const e = (e) => {
                                      for (const t of e) {
                                        const e = t.userId || t.convId;
                                        t &&
                                          !u[e] &&
                                          ((null != t && t.userId) ||
                                            (t.userId = e),
                                          null != t &&
                                            t.infoSearch &&
                                            delete t.infoSearch,
                                          null != t &&
                                            t.isDirectory &&
                                            delete t.isDirectory,
                                          (u[e] = t));
                                      }
                                    };
                                    m.length && e(m),
                                      e(Ye.default.getFriendsSync()),
                                      e(ds.default.getGroupsListSync());
                                  }
                                  const _ = vs.a.now();
                                  ws.a.setKeyword(e),
                                    ws.a.resetTracking(),
                                    ys.a
                                      .search(
                                        e,
                                        this.cacheResSearch
                                          ? this.cacheResSearch
                                          : u,
                                        {
                                          hasSection: !0,
                                          suggestGroupWithMember: !0,
                                          searchFriendInGroup: !0,
                                          isCalc: !0,
                                          updateLastChat: !this.cacheResSearch,
                                          searchPb: !0,
                                          searchZName: !0,
                                          searchNumPhone: !0,
                                          filterHidden: Jt.a.isKeyPIN(e),
                                        },
                                      )
                                      .then((t) => {
                                        var s;
                                        ws.a.trackingContact(
                                          vs.a.now() - _,
                                          null == t ||
                                            null === (s = t.all) ||
                                            void 0 === s
                                            ? void 0
                                            : s.length,
                                        );
                                        let i = this.state.searchResult;
                                        if (!this.isKeywordStale(e)) {
                                          {
                                            var n;
                                            let s = [];
                                            if (Jt.a.isKeyPIN(e)) {
                                              Xe.e.logAction(1970601);
                                              const e =
                                                Jt.a.getUidsHiddenChat();
                                              if (e.length)
                                                for (let t of e) {
                                                  let e = !1;
                                                  for (let i of g)
                                                    if (i && i.userId == t) {
                                                      s.push(
                                                        Object(f.a)(
                                                          Object(f.a)({}, i),
                                                          {},
                                                          { infoSearch: {} },
                                                        ),
                                                      ),
                                                        (e = !0);
                                                      break;
                                                    }
                                                  if (!e) {
                                                    let e = null;
                                                    (e = t.startsWith(
                                                      R.GROUPID_PREFIX,
                                                    )
                                                      ? ds.default.getGroupByIdSync(
                                                          t,
                                                        )
                                                      : Ye.default.getProfileFriendSync(
                                                          t,
                                                        )),
                                                      e &&
                                                        (e.lastMessageTime ||
                                                          (e.lastMessageTime = 0),
                                                        s.push(
                                                          Object(f.a)(
                                                            Object(f.a)({}, e),
                                                            {},
                                                            { infoSearch: {} },
                                                          ),
                                                        ));
                                                  }
                                                }
                                            }
                                            this.curQuery ||
                                              (this.curQuery = e),
                                              !this.cacheResSearch &&
                                                t.orderAll &&
                                                t.orderAll.constructor ==
                                                  Array &&
                                                t.orderAll.length > 0 &&
                                                (this.cacheResSearch = u),
                                              null !== (n = t.phone) &&
                                                void 0 !== n &&
                                                n.length &&
                                                (t.phone = t.phone.filter(
                                                  (e) => e.userId,
                                                )),
                                              (i = i ? Object(f.a)({}, i) : {}),
                                              (i.recentChat = t.recentChat),
                                              (i.groups = t.groups),
                                              (i.friends = t.friends),
                                              (i.oa = t.oa),
                                              (i.directory = t.directory),
                                              (i.searchKey = e),
                                              (i.phone = t.phone),
                                              (i.hiddenChat = s),
                                              (i.all = t.all),
                                              (i.orderAll = t.orderAll),
                                              (h +=
                                                (i.groups
                                                  ? i.groups.length
                                                  : 0) +
                                                (i.friends
                                                  ? i.friends.length
                                                  : 0) +
                                                (i.oa ? i.oa.length : 0)),
                                              (h +=
                                                (i.recentChat
                                                  ? i.recentChat.length
                                                  : 0) + i.hiddenChat.length);
                                          }
                                          v(Ds.STEP_CONTACT, i);
                                        }
                                      })
                                      .catch((e) => {
                                        Ct.default.logCoreError(e);
                                      }),
                                    0 ==
                                      (null === (s = this.state.searchResult) ||
                                      void 0 === s ||
                                      null === (n = s.messages) ||
                                      void 0 === n
                                        ? void 0
                                        : n.length) &&
                                      0 ==
                                        (null ===
                                          (a = this.state.searchResult) ||
                                        void 0 === a ||
                                        null === (r = a.all) ||
                                        void 0 === r
                                          ? void 0
                                          : r.length) &&
                                      0 ==
                                        (null ===
                                          (o = this.state.searchResult) ||
                                        void 0 === o ||
                                        null === (d = o.files) ||
                                        void 0 === d
                                          ? void 0
                                          : d.length) &&
                                      Xe.e.logAction(1232201),
                                    p === e ||
                                      this.trackSearchVietnamese ||
                                      ((this.trackSearchVietnamese = !0),
                                      Xe.e.logAction(1232010));
                                }
                                filterByConversation(e, t) {
                                  var s = this;
                                  if (!e)
                                    return (
                                      (this.searchInput.value = ""),
                                      void this.updateState(
                                        Object(f.a)(
                                          Object(f.a)({}, Rs),
                                          {},
                                          {
                                            conversation: t,
                                            searching: !1,
                                            highlightId: "",
                                          },
                                        ),
                                      )
                                    );
                                  let i = function (i, n) {
                                    void 0 === n && (n = !1),
                                      s.isKeywordStale(e)
                                        ? Ct.default.logCoreError(
                                            "search: abort filtermode 1",
                                            s.state.searchText,
                                            e,
                                          )
                                        : (!n || (i && 0 != i.length)) &&
                                          bs.a
                                            .getMessageOfConversation(
                                              i,
                                              t.userId,
                                              20,
                                            )
                                            .then((a) => {
                                              if (s.isKeywordStale(e))
                                                return void Ct.default.logCoreError(
                                                  "search: abort filtermode 2",
                                                  s.state.searchText,
                                                  e,
                                                );
                                              let r = a.list;
                                              if (n && (!r || 0 === r.length))
                                                return;
                                              let o =
                                                r.length < 20 && i.length > 20;
                                              r.length > 0
                                                ? (s.updateState(
                                                    Object(f.a)(
                                                      Object(f.a)({}, s.state),
                                                      {},
                                                      {
                                                        conversation: t,
                                                        searchResult: {
                                                          messageList: r.map(
                                                            (e) => ({
                                                              message: e,
                                                              conversation: t,
                                                            }),
                                                          ),
                                                          realLen: a.len,
                                                          rawSearchResult: i,
                                                          lastOffset: 20,
                                                          progress: n,
                                                        },
                                                        searching: !1,
                                                        highlightId: r[0].msgId,
                                                      },
                                                    ),
                                                  ),
                                                  n ||
                                                    (s.focusSearchBox(),
                                                    o && s.loadMoreMessages()),
                                                  !n &&
                                                    s.searchResultList &&
                                                    s.searchResultList
                                                      .scrollToTop &&
                                                    s.searchResultList.scrollToTop())
                                                : (s.updateState(
                                                    Object(f.a)(
                                                      Object(f.a)({}, s.state),
                                                      {},
                                                      {
                                                        conversation: t,
                                                        searchResult: {
                                                          messageList: [],
                                                          realLen: 0,
                                                          lastOffset: 0,
                                                          progress: !1,
                                                        },
                                                        searching: !1,
                                                        highlightId: "",
                                                      },
                                                    ),
                                                  ),
                                                  s.focusSearchBox(),
                                                  !n &&
                                                    o &&
                                                    s.loadMoreMessages());
                                            });
                                  };
                                  bs.a
                                    .search(
                                      e,
                                      null,
                                      { convId: t.userId + "" },
                                      (e) => {
                                        i(e, !0);
                                      },
                                    )
                                    .then((e) => {
                                      i(e);
                                    });
                                }
                                _getSearchDelaySetting() {
                                  return 70;
                                }
                                _upSearchDelay() {
                                  let e = this.searchDelay;
                                  (this.searchDelay = Math.min(
                                    400,
                                    Math.round(
                                      1.1 * this.searchDelay +
                                        10 * Math.random(),
                                    ),
                                  )),
                                    e !== this.searchDelay &&
                                      this._resetSearchFunction();
                                }
                                _downSearchDelay() {
                                  let e = this.searchDelay;
                                  (this.searchDelay = Math.max(
                                    70,
                                    Math.round(
                                      0.9 * this.searchDelay +
                                        10 * Math.random(),
                                    ),
                                  )),
                                    e !== this.searchDelay &&
                                      this._resetSearchFunction();
                                }
                                _resetSearchFunction() {
                                  Ct.default.logCoreError(
                                    "__rssf__",
                                    this.searchDelay,
                                  ),
                                    (this.functionSearchByName =
                                      Ct.default.throttle(
                                        this._innerSearchFunc,
                                        this.searchDelay,
                                      ));
                                }
                                _isSelectAllSearchText() {
                                  if (this.searchInput) {
                                    const e = this.searchInput.selectionStart,
                                      t = this.searchInput.selectionEnd;
                                    return !(
                                      !this.searchInput.value.length ||
                                      0 != e ||
                                      t != this.searchInput.value.length
                                    );
                                  }
                                  return !1;
                                }
                                init() {}
                                getItem(e) {
                                  return this.state;
                                }
                                getList(e) {
                                  throw new Error("No imp!!!");
                                }
                                onGetItemFailure(e) {}
                                onGetListFailure(e) {}
                                loadOldestTime() {
                                  bs.a
                                    .getOldestTime()
                                    .then((e) => {
                                      null != e && e.length && e[0].ts
                                        ? (this.oldestTime = parseFloat(
                                            e[0].ts,
                                          ))
                                        : (this.oldestTime = 0);
                                    })
                                    .catch((e) => {
                                      this.oldestTime = 0;
                                    });
                                }
                                getOldestTime() {
                                  return this.oldestTime;
                                }
                                getTotalQueriedMsgIds() {
                                  var e, t;
                                  return null === (e = this.dataLoaded) ||
                                    void 0 === e ||
                                    null === (t = e.allMsgIds) ||
                                    void 0 === t
                                    ? void 0
                                    : t.length;
                                }
                              }),
                            ) || ms),
                        ) || ms),
                    ) || ms),
                ) || ms),
            ) || ms),
        );
        var Fs,
          As = s("OlUt"),
          js = s("jnrz"),
          Ps = s("Anfm"),
          Ns = s("BZLJ"),
          Us = s("A9FD"),
          ks = s("BKm0"),
          Bs = s("iKSP");
        const Gs = {
            windowId: Qt.c,
            theme: As.a.default,
            currentTab: Wt.SidebarTab.MESSAGE_TAB,
            previousTab: Wt.SidebarTab.MESSAGE_TAB,
            selectedId: null,
            previousId: null,
            showExportImportEntry: !0,
          },
          xs = "z_sendtome_bubbledot",
          zs = "SIDEBAR CONTROLLER";
        function Vs() {
          for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
            t[s] = arguments[s];
          Ct.default.logCoreInfo(`[${zs}] - `, t);
        }
        Object(V.h)()(
          (Fs =
            Object($t.b)(Wt.SidebarController)(
              (Fs =
                (function (e, t) {
                  return i.ModuleContainer.inject(Wt.ConvListController)(
                    e,
                    void 0,
                    0,
                  );
                })(
                  (Fs =
                    (function (e, t) {
                      return i.ModuleContainer.inject(Cs.b)(e, void 0, 1);
                    })(
                      (Fs =
                        Reflect.metadata(
                          "design:type",
                          Function,
                        )(
                          (Fs =
                            Reflect.metadata("design:paramtypes", [
                              void 0 === Wt.ConvListController
                                ? Object
                                : Wt.ConvListController,
                              void 0 === Cs.b ? Object : Cs.b,
                            ])(
                              (Fs = class {
                                constructor(e, t) {
                                  var s = this;
                                  (this.convListController = e),
                                    (this.searchController = t),
                                    (this.changeTabFromSearch = void 0),
                                    (this._firstTimePageLoad = void 0),
                                    (this._querySelect = void 0),
                                    (this._convsLoaded = void 0),
                                    (this._exportImportFinished = void 0),
                                    (this._exportImportProgressError = void 0),
                                    (this._allowAutoJumpFC = void 0),
                                    (this._es = void 0),
                                    (this._onSendMsg = (e) => {
                                      var t, s;
                                      const i =
                                          (null == e ||
                                          null === (t = e.messages) ||
                                          void 0 === t ||
                                          null === (s = t[0]) ||
                                          void 0 === s
                                            ? void 0
                                            : s.upSrc) &
                                          R.FILE_UP_SRC.TextEditor,
                                        n = this.getState();
                                      if (
                                        n.currentTab ==
                                          Wt.SidebarTab.TODO_TAB ||
                                        n.currentTab ==
                                          Wt.SidebarTab.CATALOG_TAB ||
                                        i ||
                                        e.isChild
                                      )
                                        return;
                                      const a =
                                        this.searchController.getSearchState();
                                      n.currentTab !==
                                        Wt.SidebarTab.MESSAGE_TAB ||
                                      (a && a.searchText)
                                        ? ((n.currentTab =
                                            Wt.SidebarTab.MESSAGE_TAB),
                                          Object(nt.g)(this.name, Qt.c),
                                          Object(Ge.f)({
                                            type: St.SideBarActions
                                              .SHOW_CHAT_VIEW,
                                          }),
                                          a &&
                                            a.searchText &&
                                            Xe.e.logAction(1232007),
                                          this.searchController.clearSearch(!0))
                                        : n.currentTab ==
                                            Wt.SidebarTab.MESSAGE_TAB &&
                                          this.searchController.setRecentSearchFocusState(
                                            !1,
                                            !1,
                                            !0,
                                          ),
                                        (this.searchController.closeBySendingMsg =
                                          !0),
                                        setTimeout(() => {
                                          this.convListController.scrollToTop(
                                            !1,
                                          );
                                        }, 100);
                                    }),
                                    (this.changeTab = function (e, t) {
                                      void 0 === t && (t = Qt.c);
                                      const i = s._getStateByWindowId(t);
                                      i.currentTab !== e &&
                                        ((i.currentTab = e),
                                        Object(nt.g)(s.name, t)),
                                        s._onChangeTab(i.currentTab);
                                    }),
                                    (this.togglePerfTab = (e) => {
                                      const t = this._getStateByWindowId(Qt.c);
                                      t.showPerfTab !== e &&
                                        ((t.showPerfTab = e),
                                        Object(nt.g)(this.name, Qt.c));
                                    }),
                                    (this.changeTheme = async (e) => {
                                      const t = this._getStateByWindowId(Qt.c);
                                      t.theme !== e &&
                                        ((t.theme = e),
                                        Object(nt.g)(this.name, Qt.c));
                                    }),
                                    (this.selectMessageTab = () => {
                                      this.changeTab(Wt.SidebarTab.MESSAGE_TAB);
                                    }),
                                    (this.selectTodoTab = () => {
                                      this.changeTab(Wt.SidebarTab.TODO_TAB),
                                        Xe.e.logAction(171),
                                        Ns.h.setViewPopupTodoSrc(Ns.c.TAB_ICON);
                                    }),
                                    (this.selectContactFromSearch =
                                      async function (e, t) {
                                        if ((void 0 === t && (t = !1), !e))
                                          return (
                                            Vs("Select friend null!"),
                                            Promise.resolve(!1)
                                          );
                                        const n =
                                          await i.ModuleContainer.resolve(
                                            rs.b,
                                          ).openConversation(
                                            e.userId,
                                            rs.c.fromSearchList(e),
                                          );
                                        return (
                                          !0 === t
                                            ? (s.searchController.onCloseSearch(),
                                              s.searchController.resetState())
                                            : s.searchController.updateStateOf(
                                                "highlightId",
                                                e.userId,
                                              ),
                                          n
                                            ? (e &&
                                                e.userId ===
                                                  bt.default.sendToMeId &&
                                                (ts.g.getFlagForCurrentUser(
                                                  s.currUser.userId,
                                                  xs,
                                                ) ||
                                                  (Q.p.getHasShownSendToMeTip()
                                                    ? ts.g.setFlagForCurrentUser(
                                                        s.currUser.userId,
                                                        xs,
                                                        1,
                                                      )
                                                    : setTimeout(() => {
                                                        Mt.default.send(
                                                          St
                                                            .ConversationListActions
                                                            .SHOW_BUBBLE_DOT,
                                                        ),
                                                          Q.p.setHasShownSendToMeTip(
                                                            !0,
                                                          );
                                                      }, 144e5)),
                                                Xe.e.logAction(1390101)),
                                              Promise.resolve(!0))
                                            : (Vs("Open conv failure"),
                                              Promise.resolve(!1))
                                        );
                                      }),
                                    (this.setupSelectConvOnPageLoad = () => {
                                      if (!this._firstTimePageLoad) return;
                                      let e = this._getQueryParams();
                                      if (e.c) {
                                        Ct.default.logCoreInfo(
                                          `[${this.name}] - setup select conv c`,
                                        );
                                        const t = (e) => {
                                            const t = { [e]: !0 };
                                            (this._querySelect = () => {
                                              let s;
                                              (s = e.startsWith(
                                                R.GROUPID_PREFIX,
                                              )
                                                ? Ot.default.fetchGroupsIfNotExpire(
                                                    t,
                                                  )
                                                : Ot.default.fetchFriendsIfNotExist(
                                                    t,
                                                  )),
                                                s
                                                  .then((t) => {
                                                    t && t[e]
                                                      ? this.selectContactFromSearch(
                                                          t[e],
                                                        )
                                                      : Ct.default.logCoreInfo(
                                                          `[${this.name}] - auto open conv with id ${e} does not exist`,
                                                        );
                                                  })
                                                  .catch((e) => {
                                                    Ct.default.logCoreError(e);
                                                  });
                                            }),
                                              this._autoSelectConv();
                                          },
                                          s = e.c;
                                        e.convert
                                          ? Ot.default
                                              .convertOAIds([s])
                                              .then((e) => {
                                                e && e[s] && t(e[s]);
                                              })
                                          : t(s),
                                          (this._firstTimePageLoad = !1);
                                      } else if (e.g)
                                        Ct.default.logCoreInfo(
                                          `[${this.name}] - setup select conv g`,
                                        ),
                                          Qe.a.autoSelectGroupByLink(
                                            `https://${bt.default.CONFIG_DOMAIN}/g/` +
                                              encodeURIComponent(e.g),
                                          );
                                      else if (e.zs);
                                      else if (e.phone) {
                                        let t = e.phone,
                                          s = e.openConv;
                                        !t ||
                                          isNaN(t) ||
                                          this._querySelect ||
                                          (Ct.default.logCoreInfo(
                                            `[${this.name}] - setup select conv p`,
                                          ),
                                          (this._querySelect = () => {
                                            s
                                              ? Qe.a.autoOpenConversationByPhone(
                                                  t,
                                                  Ge.e,
                                                )
                                              : Qe.a.autoSelectConversationByPhone(
                                                  t,
                                                  Ge.e,
                                                );
                                          }),
                                          this._autoSelectConv());
                                      } else if (e.alias) {
                                        Ct.default.logCoreInfo(
                                          `[${this.name}] - setup select conv a`,
                                        );
                                        let t = e.alias;
                                        this._querySelect ||
                                          ((this._querySelect = () => {
                                            Qe.a.autoSelectConversationByAlias(
                                              t,
                                              Ge.e,
                                            );
                                          }),
                                          this._autoSelectConv());
                                      }
                                    }),
                                    (this.name = Wt.SIDEBAR_CONTROLLER),
                                    (this.data = new Map()),
                                    (this.key = "windowId"),
                                    (this.changeTabFromSearch = !1),
                                    (this._firstTimePageLoad = !0),
                                    (this._convsLoaded = !1),
                                    (this._allowAutoJumpFC = !1),
                                    (this.selectConversationForFriend =
                                      this.selectConversationForFriend.bind(
                                        this,
                                      )),
                                    this.listenEvents();
                                }
                                get currUser() {
                                  return Object(is.c)();
                                }
                                get autoJumFC() {
                                  return this._allowAutoJumpFC;
                                }
                                get eventStore() {
                                  return (
                                    this._es || (this._es = s("emRR").default),
                                    this._es
                                  );
                                }
                                onStart(e) {
                                  i.ModuleContainer.resolve(rs.b);
                                }
                                listenEvents() {
                                  Mt.default.subscribe((e, t) => {
                                    switch (e) {
                                      case St.ChatBoxActions.SEND_MSG:
                                        this._onSendMsg(t);
                                        break;
                                      case St.ChatBoxActions.SELECT_FRIEND:
                                        this.selectConversationForFriend(t);
                                        break;
                                      case St.SideBarActions.SHOW_FILE_MANAGER:
                                        (this.getState().currentTab =
                                          Wt.SidebarTab.FILE_TAB),
                                          Object(nt.g)(this.name, Qt.c);
                                        break;
                                      case St.SideBarActions.SELECT_TAB_MSG:
                                        this.changeTab(
                                          Wt.SidebarTab.MESSAGE_TAB,
                                        );
                                        break;
                                      case St.SideBarActions.SELECT_ZAVI_TAB:
                                        this.changeTab(Wt.SidebarTab.ZAVI_TAB);
                                        break;
                                      case St.FetchActions.DELETE_CONVERSATION:
                                      case St.FetchActions.GROUP_LEAVE: {
                                        const e = this.getState();
                                        e.previousId &&
                                          t === e.previousId &&
                                          (e.previousId = null);
                                        break;
                                      }
                                      case St.ChatBoxActions
                                        .JUMP_TO_MESSAGE_SEARCH_HIDDEN_CHAT:
                                      case St.ChatBoxActions
                                        .JUMP_TO_MESSAGE_SEARCH:
                                        this.getState().currentTab ==
                                          Wt.SidebarTab.FILE_TAB &&
                                          this.changeTab(
                                            Wt.SidebarTab.MESSAGE_TAB,
                                          );
                                        break;
                                      case St.TodoActions.OPEN_TODO_LIST: {
                                        const e = as.b.instance().getTodoView();
                                        e
                                          ? e.onCheckOpenTab()
                                          : this.changeTab(
                                              Wt.SidebarTab.TODO_TAB,
                                            );
                                        break;
                                      }
                                      case St.ActionList.ACT_OPEN_TAB_CHAT:
                                        this.selectMessageTab();
                                        break;
                                      case St.ActionList.ACT_OPEN_TAB_CONTACT:
                                        this.changeTab(
                                          Wt.SidebarTab.CONTACT_TAB,
                                        );
                                        break;
                                      case St.ActionList.ACT_OPEN_GROUPLIST:
                                        if (
                                          this.getState().currentTab ===
                                          Wt.SidebarTab.CONTACT_TAB
                                        ) {
                                          const e = as.b
                                            .instance()
                                            .getContactList();
                                          e && e.onJumpGroupCenter();
                                        } else
                                          this.changeTab(
                                            Wt.SidebarTab.CONTACT_TAB,
                                          );
                                        break;
                                      case ks.b.EXPORT_IMPORT_START:
                                        (this._exportImportFinished = !1),
                                          (this._exportImportProgressError =
                                            !1);
                                        break;
                                      case ks.b.EXPORT_IMPORT_FINISHED:
                                        (this._exportImportFinished = !0),
                                          (this._exportImportProgressError =
                                            !1);
                                        break;
                                      case ks.b.IMPORT_DB_PROGRESS:
                                      case ks.b.IMPORT_PROGRESS:
                                      case ks.b.EXPORT_PROGRESS:
                                      case ks.b.EXPORT_DB_PROGRESS:
                                        t &&
                                          t.error &&
                                          (this._exportImportProgressError =
                                            !0);
                                        break;
                                      case St.ConversationListActions
                                        .SELECT_CONVERSATION: {
                                        const e = this.getState();
                                        (e.currentTab !==
                                          Wt.SidebarTab.FILE_TAB &&
                                          e.currentTab !==
                                            Wt.SidebarTab.ZAVI_TAB &&
                                          e.currentTab !==
                                            Wt.SidebarTab.CATALOG_TAB) ||
                                          this.changeTab(
                                            Wt.SidebarTab.MESSAGE_TAB,
                                          );
                                        break;
                                      }
                                    }
                                  }),
                                    Pt.a.ConvInfoDataManager.addEventListener(
                                      Zt.b.DoneLoadDB,
                                      (e) => {
                                        (this._convsLoaded = !0),
                                          this._autoSelectConv();
                                      },
                                    ),
                                    Pt.a.UnreadDataManager.addEventListener(
                                      Zt.b.DoneLoadDB,
                                      (e) => {
                                        js.b.onDoneLoadUnreadDB(
                                          null == e ? void 0 : e.payload,
                                        );
                                      },
                                    );
                                }
                                getState(e) {
                                  return (
                                    void 0 === e && (e = Qt.c),
                                    this._getStateByWindowId(e)
                                  );
                                }
                                getSelectedId(e) {
                                  return this.getState(e).selectedId || null;
                                }
                                getCurrMainConvId() {
                                  const e = this.eventStore.getState();
                                  return e && e.chatview.view === Bs.c.CHAT_VIEW
                                    ? this.getSelectedId()
                                    : null;
                                }
                                updateSelectedId(e, t) {
                                  void 0 === t && (t = Qt.c);
                                  const s = this._getStateByWindowId(t);
                                  s.selectedId !== e &&
                                    ((s.previousId = e ? null : s.selectedId),
                                    (s.selectedId = e),
                                    Object(nt.g)(this.name, t));
                                }
                                updateSelectedIdWithoutPrevious(e, t) {
                                  void 0 === t && (t = Qt.c);
                                  const s = this._getStateByWindowId(t);
                                  s.selectedId !== e &&
                                    ((s.previousId = null),
                                    (s.selectedId = e),
                                    Object(nt.g)(this.name, t));
                                }
                                isInImportExportProcess() {
                                  const e =
                                    this._exportImportFinished ||
                                    this._exportImportProgressError;
                                  return void 0 !== e && !e;
                                }
                                openFriendCenter() {}
                                selectConversationForFriend(e, t) {
                                  if ((void 0 === t && (t = !1), !e))
                                    return void Ct.default.logCoreError(
                                      "friend null",
                                    );
                                  if (
                                    (Ge.f &&
                                      (Object(Ge.f)({
                                        type: St.ConversationListActions
                                          .SELECT_CONV_MINOR,
                                        payload: e,
                                      }),
                                      Object(Ge.f)({
                                        type: St.ChatBoxActions
                                          .READ_CONVERSATION,
                                        payload: { conversationId: e.userId },
                                      })),
                                    e.userId == this.currUser.userId)
                                  )
                                    return void this._showMyProfile();
                                  let s =
                                      this.convListController.getRecentContactWithId(
                                        e.userId,
                                      ),
                                    i = !1;
                                  if (s) i = !0;
                                  else {
                                    let t = (t) => {
                                      t &&
                                        t.includes(e.userId) &&
                                        (s = Object(f.a)({}, t[e.userId]));
                                    };
                                    s || t(ds.default.getGroupsListSync()),
                                      s || t(Ye.default.getFriendsSync()),
                                      s || (s = {}),
                                      Object.assign(s, e),
                                      (s.isFr = s.isFr || 0),
                                      (s.type = s.type || R.FRIEND_TYPE_NORMAL);
                                  }
                                  e.byPassPIN
                                    ? (s.byPassPIN = 1)
                                    : s.byPassPIN && delete s.byPassPIN,
                                    setTimeout(() => {
                                      Object(Ge.f)({
                                        type: St.ConversationListActions
                                          .SELECT_CONVERSATION,
                                        payload: s,
                                      });
                                    }, 0);
                                  const n = this.data.get(Qt.c);
                                  let a = null == n ? void 0 : n.currentTab;
                                  !0 === t
                                    ? ((a = i
                                        ? Wt.SidebarTab.MESSAGE_TAB
                                        : Wt.SidebarTab.CONTACT_TAB),
                                      a === Wt.SidebarTab.CONTACT_TAB &&
                                        (Ct.default.log(
                                          "sidebar: select from search, should highlight thread",
                                        ),
                                        (this.changeTabFromSearch = !0)),
                                      this.searchController.onCloseSearch(),
                                      this.searchController.resetState(),
                                      !e.userId ||
                                        (!e.byPassPIN &&
                                          Jt.a.isThreadHidden(e.userId)) ||
                                        setTimeout(() => {
                                          Mt.default.send(
                                            St.ChatBoxActions.FOCUS_INPUT,
                                            {
                                              userId: e.userId,
                                              windowId: Qt.c,
                                            },
                                          );
                                        }, 0))
                                    : this.searchController.updateStateOf(
                                        "highlightId",
                                        e.userId,
                                      ),
                                    this.updateState(
                                      Object(f.a)(
                                        Object(f.a)({}, n),
                                        {},
                                        { currentTab: a, selectedId: e.userId },
                                      ),
                                    ),
                                    e &&
                                      e.userId === bt.default.sendToMeId &&
                                      (ts.g.getFlagForCurrentUser(
                                        this.currUser.userId,
                                        xs,
                                      ) ||
                                        (Q.p.getHasShownSendToMeTip()
                                          ? ts.g.setFlagForCurrentUser(
                                              this.currUser.userId,
                                              xs,
                                              1,
                                            )
                                          : setTimeout(() => {
                                              Mt.default.send(
                                                St.ConversationListActions
                                                  .SHOW_BUBBLE_DOT,
                                              ),
                                                Q.p.setHasShownSendToMeTip(!0);
                                            }, 144e5)));
                                }
                                showAddFriendModal() {
                                  Xe.e.logAction(1020203),
                                    Xe.e.logAction(12316),
                                    Je.ModalManagerV2.openModal({
                                      windowId: Qt.c,
                                      name: R.ModalIdentitiesDefine.FIND_FRIEND,
                                    });
                                }
                                showGroupCompose() {
                                  Xe.e.logAction(1020202),
                                    Ps.c.markStart(
                                      Ps.a.CREATE_GROUP,
                                      Ps.b.Group.CREATE_GR_HEADER_ICON,
                                    );
                                  const e = Q.p.getSessionUserId(),
                                    t = function (e) {
                                      void 0 === e && (e = !0),
                                        Je.ModalManagerV2.openModal({
                                          windowId: Qt.c,
                                          name: R.ModalIdentitiesDefine
                                            .CREATE_GROUP_COMPOSE,
                                          params: { needInitE2ee: e },
                                          forceCloseAll: !1,
                                        });
                                    };
                                  !ts.g.getTimeEntryPointE2eGroup(
                                    e,
                                    Ps.b.Group.CREATE_GR_HEADER_ICON,
                                  ) &&
                                  bt.default.e2ee.enable_group &&
                                  bt.default.e2ee.group
                                    .can_enable_right_in_creation_step
                                    ? Je.ModalManagerV2.openModal({
                                        windowId: Qt.c,
                                        name: R.ModalIdentitiesDefine
                                          .E2EE_ONBOARDING,
                                        params: {
                                          entry: Us.e.CREATE_GROUP,
                                          entrySrc:
                                            Ps.b.Group.CREATE_GR_HEADER_ICON,
                                          isGroup: !0,
                                          userId: "",
                                          callback: t,
                                          callbackCancel: t,
                                        },
                                        forceCloseAll: !1,
                                      })
                                    : t(!1);
                                }
                                enableAutoJupmFC() {
                                  this._allowAutoJumpFC = !0;
                                }
                                disableAutoJupmFC() {
                                  this._allowAutoJumpFC = !1;
                                }
                                init() {}
                                getItem(e) {
                                  const t = e.key;
                                  return this._getStateByWindowId(t);
                                }
                                getList(e) {
                                  return Array.from(this.data.keys());
                                }
                                onGetItemFailure(e) {}
                                onGetListFailure(e) {}
                                updateState(e, t, s) {
                                  void 0 === t && (t = Qt.c),
                                    void 0 === s && (s = !0),
                                    this.data.set(t, e),
                                    s && Object(nt.g)(this.name, t);
                                }
                                _getStateByWindowId(e) {
                                  let t = this.data.get(e);
                                  return (
                                    t ||
                                      ((t = Object(f.a)({}, Gs)),
                                      this.data.set(e, t)),
                                    t
                                  );
                                }
                                _onChangeTab(e) {
                                  switch (
                                    ((function () {
                                      switch (e) {
                                        case Wt.SidebarTab.MESSAGE_TAB:
                                          Xe.e.logAction(12801);
                                          break;
                                        case Wt.SidebarTab.CONTACT_TAB:
                                          Xe.e.logAction(12802),
                                            3 ===
                                              bt.default.noti_center_config
                                                .entry_position &&
                                              Xe.e.logAction(1281205);
                                          break;
                                        case Wt.SidebarTab.MENTION_TAB:
                                          Xe.e.logAction(12805);
                                          break;
                                        case Wt.SidebarTab.STAR_TAB:
                                          Xe.e.logAction(12806);
                                          break;
                                        case Wt.SidebarTab.FILE_TAB:
                                          Xe.e.logAction(133);
                                          break;
                                        case Wt.SidebarTab.TODO_TAB:
                                          3 ===
                                            bt.default.noti_center_config
                                              .entry_position &&
                                            Xe.e.logAction(1281206);
                                          break;
                                        case Wt.SidebarTab.ZAVI_TAB:
                                          Xe.e.logAction(20701);
                                      }
                                    })(),
                                    Q.p.resetGlobalSearchMode(),
                                    this.searchController.clearSearch(!0),
                                    e)
                                  ) {
                                    case Wt.SidebarTab.MESSAGE_TAB: {
                                      this._resetConversationList();
                                      const e = this.getState();
                                      !e.selectedId &&
                                        e.previousId &&
                                        this.updateSelectedId(e.previousId),
                                        Object(Ge.f)({
                                          type: St.SideBarActions
                                            .SHOW_CHAT_VIEW,
                                        });
                                      break;
                                    }
                                    case Wt.SidebarTab.ZAVI_TAB:
                                      Object(Ge.f)({
                                        type: St.SideBarActions.SELECT_ZAVI,
                                      });
                                    case Wt.SidebarTab.TODO_TAB:
                                  }
                                }
                                _showMyProfile() {
                                  Je.ModalManagerV2.openModal({
                                    windowId: Qt.c,
                                    name: R.ModalIdentitiesDefine
                                      .FRIEND_PROFILE,
                                    params: this.currUser.userId,
                                  });
                                }
                                _resetConversationList() {}
                                _getQueryParams() {
                                  let e = {},
                                    t = window.location.search;
                                  if (
                                    ((t = t ? t.substr(1).split("&") : null), t)
                                  )
                                    for (let s = 0; s < t.length; s++) {
                                      let i = t[s].indexOf("=");
                                      if (i >= 0) {
                                        let n = t[s].slice(0, i),
                                          a = t[s].slice(i + 1, t[s].length);
                                        n &&
                                          n.length > 0 &&
                                          a &&
                                          a.length > 0 &&
                                          (e[n] = decodeURIComponent(a));
                                      }
                                    }
                                  return e;
                                }
                                _autoSelectConv() {
                                  this._querySelect &&
                                    this._convsLoaded &&
                                    (Ct.default.logCoreInfo(
                                      `[${this.name}] - auto select conv start`,
                                    ),
                                    this._querySelect(),
                                    (this._querySelect = null));
                                }
                              }),
                            ) || Fs),
                        ) || Fs),
                    ) || Fs),
                ) || Fs),
            ) || Fs),
        );
        var Hs;
        const $s = {
          id: xt.f,
          color: "#EA87FF",
          conversations: [],
          createTime: 1634956772046,
          emoij: "",
          offset: 100,
          text: "default",
        };
        var Ws;
        !(function (e) {
          (e.ALL = "all"), (e.SELECTED = "selected");
        })(Ws || (Ws = {}));
        Object($t.b)(Wt.LabelDataManager)(
          (Hs =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (Hs =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (Hs = class extends te.b {
                    constructor() {
                      super(),
                        (this.allLabels = void 0),
                        (this.selectedLabel = void 0),
                        (this.name = Wt.LABEL_DATA_MANAGER),
                        (this.data = new Map()),
                        (this.key = "labelId"),
                        (this.allLabels = []),
                        (this.selectedLabel = []);
                    }
                    onLabelChange(e) {
                      const {
                          color: t,
                          conversations: s,
                          createTime: i,
                          emoij: n,
                          offset: a,
                          text: r,
                        } = e,
                        o = "" + e.id,
                        d = this.data.get(o);
                      if (
                        (!o ||
                          (d &&
                            s === d.conversations &&
                            i == (null == d ? void 0 : d.createTime) &&
                            n == d.emoij &&
                            a == d.offset &&
                            r === d.text &&
                            t == d.color) ||
                          (this.data.set(o, e),
                          Object(nt.g)(this.name, o),
                          Object(nt.i)(this.name, "all")),
                        d &&
                          d.conversations &&
                          d.conversations.length !== s.length)
                      ) {
                        let e = [];
                        s.length > d.conversations.length
                          ? ((e = s.filter(
                              (e) => !d.conversations.includes(e),
                            )),
                            this.dispatchEvent(
                              new Kt.c(Kt.d.LabelAddConvs, {
                                labelId: o,
                                convIds: e,
                              }),
                            ))
                          : ((e = d.conversations.filter(
                              (e) => !s.includes(e),
                            )),
                            this.dispatchEvent(
                              new Kt.c(Kt.d.LabelRemoveConvs, {
                                labelId: o,
                                convIds: e,
                              }),
                            ));
                      }
                    }
                    onFetchLabels(e) {
                      if (Array.isArray(e) && !(e.length < 0)) {
                        for (let t = 0; t < e.length; t++)
                          this.onLabelChange(e[t]);
                        this.data.forEach((t) => {
                          const s = "" + t.id;
                          e.some((e) => e.id == s) || this.data.delete(s);
                        }),
                          this._updateAllLabels(e.map((e) => e.id));
                      }
                    }
                    onLabelDeleted(e) {
                      if (
                        ("string" != typeof e &&
                          (Ct.default.logCoreError(
                            `[${this.name}] - delete label invalid lid type ${e}`,
                          ),
                          (e = "" + e)),
                        !this.data.has(e))
                      )
                        return void Ct.default.logCoreError(
                          this.name + "Deleted not exists item!!!",
                        );
                      const t = this.data.get(e);
                      let s = [];
                      t && t.conversations && (s = [...t.conversations]),
                        this.data.delete(e),
                        this._updateAllLabels(
                          this.allLabels.filter((t) => t !== e),
                        ),
                        this.selectedLabel.includes(e) &&
                          this.onDeSelectLabel(e),
                        this.dispatchEvent(
                          new Kt.c(Kt.d.RemoveLabel, { labelId: e, convs: s }),
                        ),
                        Object(nt.e)(this.name, e);
                    }
                    _updateAllLabels(e) {
                      return (
                        !Ct.default.shallowEqual(this.allLabels, e) &&
                        ((this.allLabels = e),
                        Object(nt.i)(this.name, Ws.ALL),
                        !0)
                      );
                    }
                    onSelectLabel(e) {
                      (this.selectedLabel = ["" + e]),
                        Object(nt.i)(this.name, Ws.SELECTED),
                        this.selectedLabelChanged();
                    }
                    onDeSelectLabel(e) {
                      (this.selectedLabel = this.selectedLabel.filter(
                        (t) => t !== e,
                      )),
                        Object(nt.i)(this.name, Ws.SELECTED),
                        this.selectedLabelChanged();
                    }
                    onClearFilter() {
                      (this.selectedLabel = []),
                        Object(nt.i)(this.name, Ws.SELECTED),
                        this.selectedLabelChanged();
                    }
                    getLabelById(e) {
                      return e
                        ? ("string" != typeof e && (e = e.toString()),
                          e == xt.f
                            ? $s
                            : e == xt.g
                              ? { id: xt.g }
                              : this.data.get(e) || null)
                        : null;
                    }
                    getAllLabels() {
                      return Array.from(this.data.values());
                    }
                    getAllLabelIds() {
                      return this.allLabels;
                    }
                    applyNewFilter(e) {
                      (this.selectedLabel = e),
                        Object(nt.i)(this.name, Ws.SELECTED),
                        this.selectedLabelChanged();
                    }
                    selectedLabelChanged() {
                      this.dispatchEvent(
                        new Kt.c(Kt.d.SelectedLabelChange, this.selectedLabel),
                      );
                    }
                    init() {
                      Yt.b.getAll().then((e) => {
                        this.onFetchLabels(e);
                      });
                    }
                    getItem(e) {
                      const t = e.key;
                      return this.getLabelById(t);
                    }
                    getList(e) {
                      const t = e.key;
                      return t === Ws.ALL
                        ? this.allLabels
                        : t === Ws.SELECTED
                          ? this.selectedLabel
                          : [];
                    }
                    onGetItemFailure(e) {}
                    onGetListFailure(e) {}
                  }),
                ) || Hs),
            ) || Hs),
        );
        i.ModuleContainer.register(Bt.b, Vt);
        var Ks = s("k+R1"),
          qs = s("Py3H");
        let Zs;
        !(function (e) {
          (e[(e.FULL = 0)] = "FULL"), (e[(e.WINDOWED = 1)] = "WINDOWED");
        })(Zs || (Zs = {}));
        var Js,
          Qs = s("tQbm"),
          Ys = s("qzuk"),
          Xs = s("NMlV"),
          ei = s("4HQc"),
          ti = s("GpwQ"),
          si = s("lPX+"),
          ii = s("OU7N"),
          ni = s("UYGI"),
          ai = s("X4fA"),
          ri = s("V8Oy"),
          oi = s("7WX+");
        let di;
        Ct.default.isWeb() || (di = s("Dprd").default);
        const li = { conversationId: null, mode: Zs.FULL, windowId: Qt.c };
        Object($t.b)(Qs.b)(
          (Js =
            (function (e, t) {
              return i.ModuleContainer.inject(Wt.SidebarController)(
                e,
                void 0,
                0,
              );
            })(
              (Js =
                Reflect.metadata(
                  "design:type",
                  Function,
                )(
                  (Js =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === Wt.SidebarController
                        ? Object
                        : Wt.SidebarController,
                    ])(
                      (Js = class extends te.b {
                        constructor(e) {
                          super(),
                            (this.sidebar = e),
                            (this.data = new Map()),
                            (this.onLogOut = () => {
                              if (ii.c.isCalling())
                                return void et.a.createWarning(
                                  tt.default.str("STR_SIGNOUT_WITH_CALL"),
                                );
                              let e = Q.p.getSessionUserId(),
                                t = "STR_LOGOUT_CONFIRM",
                                s = +ni.a.isUploading();
                              if (
                                (!s && di && di.isDownloading() && (s = 2),
                                s > 0)
                              ) {
                                const e =
                                  1 === s
                                    ? tt.default.str("STR_TITLE_BAR_SEND")
                                    : tt.default.str("STR_TITLE_BAR_RECEIVE");
                                t =
                                  tt.default.str("STR_LOGOUT_CANCEL_FILE") +
                                  ` ${e} ` +
                                  tt.default.str("STR_TITLE_BAR_EXIT_ZALO_P2");
                              }
                              ai.a.getLogoutToken(),
                                ns.ConfirmManagerV2.openConfirm({
                                  windowId: Qt.c,
                                  name: R.MODAL_CONFIRM.confirmIdentities,
                                  params: {
                                    message: tt.default.str(t),
                                    okText: tt.default.str("STR_LOGOUT_YES"),
                                    cancelText: tt.default.str("STR_LOGOUT_NO"),
                                    onOk: this.doLogout,
                                    options: [
                                      {
                                        default_val: ts.g.isSetClearData(e),
                                        key: "del_history",
                                        title: "STR_LOGOUT_DEL_HISTORY",
                                      },
                                    ],
                                    "data-id": {
                                      confirmBtn: "btn_Logout_Logout",
                                      cancelBtn: "btn_Logout_No",
                                    },
                                  },
                                });
                            }),
                            (this.openConversationInNewWindow = async (e) => {
                              throw new Error("Method not implemented.");
                            }),
                            (this.openScreenCapture = async () => {
                              Xe.e.logAction(12808),
                                Mt.default.send(
                                  St.ChatBoxActions.SIDEBAR_CAPTURE,
                                );
                            }),
                            (this.openZaloSupport = async () => {
                              const e = bt.default.supportPage;
                              return e
                                ? i.ModuleContainer.resolve(
                                    rs.b,
                                  ).openConversation(e, rs.c.fromSupport())
                                : Promise.resolve(!1);
                            }),
                            (this.openUpdateMyProfile = async () => {
                              Je.ModalManagerV2.openModal({
                                windowId: Qt.c,
                                name: R.ModalIdentitiesDefine.UPDATE_PROFILE,
                                params: { showCloseButton: !0 },
                              });
                            }),
                            (this.openUserInfo = async (e) => {
                              qs.a.setFriendRequestSource(
                                e,
                                R.FRIEND_REQUEST_SRC_CONTACT_LIST_SUGGESTION,
                              ),
                                Q.p.setSelectConversationSource(178012),
                                Je.ModalManagerV2.openModal({
                                  windowId: Qt.c,
                                  name: R.ModalIdentitiesDefine.FRIEND_PROFILE,
                                  params: e,
                                });
                            }),
                            (this.openEditAlias = async (e) => {
                              const t = {
                                windowId: Qt.c,
                                name: R.ModalIdentitiesDefine.EDIT_ALIAS,
                                params: Object(f.a)({}, e),
                              };
                              Je.ModalManagerV2.openModal(t);
                            }),
                            (this.sendFile = async (e, t) => {
                              const s = this._getStateByWindowId(Qt.c),
                                i = Ks.default.getChatBoxControllerByConvId(
                                  t || s.conversationId,
                                );
                              null == i || i._uploadDragFile(e, null, t);
                            }),
                            (this.getConvId = () =>
                              this._getStateByWindowId(Qt.c).conversationId),
                            (this.sendDirectMsgToSendToMe = (e, t) => {
                              !bt.default.isOffSendToMe &&
                                this.chatboxController &&
                                Ee.default
                                  .getConversation(bt.default.sendToMeId)
                                  .then((s) => {
                                    if (e === R.MSG_GIF && t.url) {
                                      var i;
                                      let e = {
                                        hd: {
                                          width: t.width ? t.width : 0,
                                          height: t.height ? t.height : 0,
                                          url: t.url,
                                        },
                                        original: {
                                          width: t.width ? t.width : 0,
                                          height: t.height ? t.height : 0,
                                          url: t.url,
                                        },
                                        normal: {
                                          width: t.width ? t.width : 0,
                                          height: t.height ? t.height : 0,
                                          url: t.url,
                                        },
                                      };
                                      null === (i = this.chatboxController) ||
                                        void 0 === i ||
                                        i._sendMessage(
                                          s,
                                          R.MSG_GIF,
                                          e,
                                          null,
                                          null,
                                          null,
                                          null,
                                          null,
                                        );
                                    }
                                    Object(Ge.e)({
                                      type: St.ConversationListActions
                                        .SELECT_CONVERSATION,
                                      payload: s,
                                    }),
                                      this.sidebar.updateSelectedId(
                                        bt.default.sendToMeId,
                                      );
                                  });
                            }),
                            (this.handleSendMessageError = (e, t, s) => {
                              var i, n;
                              if (
                                (Ee.default.deleteMessageById(t.msgId),
                                null === (i = this.chatboxController) ||
                                  void 0 === i ||
                                  i._cleanUpLocalTTLItem(t),
                                Q.p.isDelSendingMsg(t.clientId))
                              )
                                return;
                              const a = t.convertToUIMessageObject();
                              return (
                                null === (n = this.chatboxController) ||
                                  void 0 === n ||
                                  n._handleMessageFailure(e, t, a, s, !0),
                                e
                              );
                            }),
                            (this.broadCastMessage = (e, t, s, i) => {
                              if (e && t)
                                for (let o = 0; o < e.length; o++) {
                                  const d = e[o];
                                  if (d) {
                                    let e = d.userId,
                                      o = e.startsWith(R.GROUPID_PREFIX);
                                    if (t.msgType === R.MSG_STICKER) {
                                      var n;
                                      const l = Xs.a.next();
                                      t &&
                                        t.sendSrc &&
                                        Ps.c.track(l, t.sendSrc);
                                      const c =
                                          Ct.default.getMsgIdSendingFromCliMsgId(
                                            l,
                                          ),
                                        h = new ei.b(
                                          Q.p.getSessionUserId(),
                                          e,
                                          c,
                                          l,
                                          R.MSG_STICKER,
                                          o,
                                        ),
                                        u = ti.a.instance().isOnE2ee(d.userId);
                                      if (
                                        (h.updateMessageContentProp(
                                          ei.a.STICKER,
                                          t.message,
                                        ),
                                        u)
                                      ) {
                                        var a;
                                        const e = {
                                          id: h.content.sticker.id,
                                          catId: h.content.sticker.cateId,
                                          type: h.content.sticker.type,
                                        };
                                        var r;
                                        if (
                                          null !== (a = t.message) &&
                                          void 0 !== a &&
                                          a.fssInfo
                                        )
                                          e.extInfo =
                                            null === (r = t.message) ||
                                            void 0 === r
                                              ? void 0
                                              : r.fssInfo;
                                        h.updateMessageContentProp(
                                          ei.a.STICKER,
                                          e,
                                        ),
                                          (h.e2eeStatus = R.MSG_E2EE);
                                      }
                                      Ot.default
                                        .sendMsgObject(
                                          h,
                                          null,
                                          null,
                                          R.RETRY_MSG_TIMEOUT_DEFAULT,
                                        )
                                        .then((t) => {
                                          if (s) {
                                            var n;
                                            const t = Xs.a.next(),
                                              i =
                                                Ct.default.getMsgIdSendingFromCliMsgId(
                                                  t,
                                                );
                                            let a = new ei.b(
                                              Q.p.getSessionUserId(),
                                              e,
                                              i,
                                              t,
                                              R.MSG_TEXT,
                                              o,
                                            );
                                            a.updateMessageContentProp(
                                              ei.a.TEXT,
                                              s,
                                            ),
                                              u && (a.e2eeStatus = R.MSG_E2EE),
                                              Ot.default
                                                .sendMsgObject(
                                                  a,
                                                  null,
                                                  null,
                                                  R.RETRY_MSG_TIMEOUT_DEFAULT,
                                                )
                                                .then((e) => {
                                                  u &&
                                                    ((e =
                                                      Ct.default.parseE2eeResp(
                                                        e,
                                                      )),
                                                    this.chatboxController._sentMessage(
                                                      a,
                                                      e,
                                                    ));
                                                })
                                                .catch((e) => {
                                                  this.handleSendMessageError(
                                                    e,
                                                    a,
                                                    d,
                                                  );
                                                }),
                                              null ===
                                                (n = this.chatboxController) ||
                                                void 0 === n ||
                                                n._showLocalMessage(a, d);
                                          }
                                          u &&
                                            ((t = Ct.default.parseE2eeResp(t)),
                                            this.chatboxController._sentMessage(
                                              h,
                                              t,
                                            )),
                                            i && i(t);
                                        })
                                        .catch((e) => {
                                          Ct.default.logCoreError(
                                            "BroadcastErr: ",
                                            e,
                                          ),
                                            this.handleSendMessageError(
                                              e,
                                              h,
                                              d,
                                            ),
                                            i && i(e);
                                        }),
                                        null === (n = this.chatboxController) ||
                                          void 0 === n ||
                                          n._showLocalMessage(h, d);
                                    } else if (t.msgType === R.MSG_TEXT && s) {
                                      const t = Xs.a.next(),
                                        n =
                                          Ct.default.getMsgIdSendingFromCliMsgId(
                                            t,
                                          );
                                      let a = new ei.b(
                                        Q.p.getSessionUserId(),
                                        e,
                                        n,
                                        t,
                                        R.MSG_TEXT,
                                        o,
                                      );
                                      a.updateMessageContentProp(ei.a.TEXT, s);
                                      ti.a.instance().isOnE2ee(d.userId) &&
                                        (a.e2eeStatus = R.MSG_E2EE),
                                        Ot.default
                                          .sendMsgObject(
                                            a,
                                            null,
                                            null,
                                            R.RETRY_MSG_TIMEOUT_DEFAULT,
                                          )
                                          .then((e) => {
                                            i && i(e);
                                          })
                                          .catch((e) => {
                                            this.handleSendMessageError(
                                              e,
                                              a,
                                              d,
                                            ),
                                              i && i(e);
                                          });
                                    }
                                  }
                                }
                            }),
                            (this.handleEvent = (e, t) => {
                              if (
                                e ===
                                St.ConversationListActions.SELECT_CONVERSATION
                              ) {
                                const e = this._getStateByWindowId(Qt.c);
                                if (t.userId !== e.conversationId)
                                  return (
                                    this._updateStateByWindowId(Qt.c, (e) =>
                                      Object(f.a)(
                                        Object(f.a)({}, e),
                                        {},
                                        { conversationId: t.userId },
                                      ),
                                    ),
                                    Object(nt.g)(this.name, Qt.c),
                                    void this.dispatchEvent(
                                      new Ys.a(t.userId, Qt.c),
                                    )
                                  );
                              }
                            }),
                            (this.name = Qs.a),
                            (this.key = "windowId"),
                            this.init();
                        }
                        get chatboxController() {
                          const e = this.sidebar.getState().selectedId;
                          return Ks.default.getChatBoxControllerByConvId(
                            e || Qt.b,
                          );
                        }
                        onInviteFriend() {
                          const e = [si.a];
                          Je.ModalManagerV2.openModal({
                            windowId: Qt.c,
                            name: R.ModalIdentitiesDefine.SHARE_MSG_COMPOSE,
                            params: {
                              messages: e,
                              title: tt.default.str("STR_INVITE_FRIEND_1"),
                              disableGroup: !0,
                              disablePcUser: !0,
                              callback: (e, t) => {
                                Mt.default.send(
                                  St.SideBarActions.SEND_INVITATION,
                                  {
                                    target: e,
                                    message:
                                      (null == t ? void 0 : t.length) > 0
                                        ? t[0]
                                        : "",
                                    link: `https://${bt.default.CONFIG_DOMAIN}/may-tinh`,
                                  },
                                );
                              },
                            },
                          });
                        }
                        onWhatNew() {
                          Je.ModalManagerV2.openModal({
                            windowId: Qt.c,
                            name: R.ModalIdentitiesDefine.APP_UPDATE_INFO,
                            params: {
                              data: Ee.default.getCacheRecentUpdate(),
                              isManual: !0,
                            },
                          });
                        }
                        showMyProfile() {
                          let e = Q.p.getSessionUserId();
                          Je.ModalManagerV2.openModal({
                            windowId: Qt.c,
                            name: R.ModalIdentitiesDefine.FRIEND_PROFILE,
                            params: e,
                          });
                        }
                        get mainWindowConversationId() {
                          return this._getStateByWindowId(Qt.c).conversationId;
                        }
                        doLogout(e) {
                          let t = Q.p.getSessionUserId();
                          e && e.del_history
                            ? ts.g.setClearData(t, 1)
                            : ts.g.setClearData(t, 0),
                            ri.a.logout(),
                            oi.a.logout(),
                            ai.a.logout().catch((e) => {
                              e.error_code &&
                                18032 === e.error_code &&
                                Je.ModalManagerV2.openModal({
                                  windowId: Qt.c,
                                  name: R.ModalIdentitiesDefine.CHANGE_PW,
                                });
                            });
                        }
                        init() {
                          Mt.default.subscribe(this.handleEvent);
                        }
                        getItem(e, t) {
                          return this._getStateByWindowId(e.key);
                        }
                        getList(e, t) {
                          return Array.from(this.data.keys());
                        }
                        onGetItemFailure(e) {}
                        onGetListFailure(e) {}
                        _getStateByWindowId(e) {
                          let t = this.data.get(e);
                          return (
                            t ||
                              ((t = Object(f.a)({}, li)), this.data.set(e, t)),
                            t
                          );
                        }
                        _updateStateByWindowId(e, t) {
                          const s = t(this._getStateByWindowId(e));
                          this.data.set(e, s);
                        }
                      }),
                    ) || Js),
                ) || Js),
            ) || Js),
        );
        var ci,
          hi = s("OI//");
        let ui =
          i.ModuleContainer.injectable()(
            (ci = class {
              async get(e) {
                return ds.default.getGroupById(e);
              }
              async getMulti(e) {
                const t = await ds.default.getGroupsByIds(e);
                return Object.values(t);
              }
              async getAll() {
                return await ds.default.getGroupsList();
              }
            }),
          ) || ci;
        var gi;
        let mi =
          i.ModuleContainer.injectable()(
            (gi =
              (function (e, t) {
                return i.ModuleContainer.inject(hi.c)(e, void 0, 0);
              })(
                (gi =
                  (function (e, t) {
                    return i.ModuleContainer.inject(q.ZLoggerFactory)(
                      e,
                      void 0,
                      1,
                    );
                  })(
                    (gi =
                      Reflect.metadata(
                        "design:type",
                        Function,
                      )(
                        (gi =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === hi.c ? Object : hi.c,
                            void 0 === q.ZLoggerFactory
                              ? Object
                              : q.ZLoggerFactory,
                          ])(
                            (gi = class {
                              constructor(e, t) {
                                (this.groupRepository = e),
                                  (this.logger = void 0),
                                  (this.logger = t.createZLogger("groups", [
                                    "group-manager",
                                  ]));
                              }
                              getAll() {
                                return this.groupRepository
                                  .getAll()
                                  .then((e) => e.map((e) => new hi.a(e)))
                                  .catch(
                                    (e) => (
                                      this.logger.zsymb(18, 16623, 3e4, () => [
                                        "getAll error. return [].",
                                        { reason: e },
                                      ]),
                                      []
                                    ),
                                  );
                              }
                              getMulti(e) {
                                return this.groupRepository
                                  .getMulti(e)
                                  .then((e) => e.map((e) => new hi.a(e)));
                              }
                              get(e) {
                                return this.groupRepository
                                  .get(e)
                                  .then((e) => (e ? new hi.a(e) : void 0))
                                  .catch((e) => {
                                    this.logger.zsymb(18, 16623, 30001, () => [
                                      "get error. return undefined.",
                                      { reason: e },
                                    ]);
                                  });
                              }
                            }),
                          ) || gi),
                      ) || gi),
                  ) || gi),
              ) || gi),
          ) || gi;
        i.ModuleContainer.registerSingleton(hi.c, ui),
          i.ModuleContainer.registerSingleton(hi.b, mi);
        var pi = s("MqnV");
        const fi = Object(i.define)("message-controller");
        var vi;
        let bi =
          Object(i.injectable)()(
            (vi =
              (function (e, t) {
                return Object(i.inject)(zt.e)(e, void 0, 0);
              })(
                (vi =
                  (function (e, t) {
                    return Object(i.inject)(fi)(e, void 0, 1);
                  })(
                    (vi =
                      (function (e, t) {
                        return Object(i.inject)(zt.g)(e, void 0, 2);
                      })(
                        (vi =
                          Reflect.metadata(
                            "design:type",
                            Function,
                          )(
                            (vi =
                              Reflect.metadata("design:paramtypes", [
                                void 0 === zt.e ? Object : zt.e,
                                "undefined" == typeof IMessageController
                                  ? Object
                                  : IMessageController,
                                void 0 === zt.g ? Object : zt.g,
                              ])(
                                (vi = class {
                                  constructor(e, t, s) {
                                    (this.conversationRepository = e),
                                      (this.messageLocalController = t),
                                      (this.muteManager = s);
                                  }
                                  async get(e) {
                                    const t = await this.conversationRepository
                                      .get(e)
                                      .catch(() => {});
                                    if (t)
                                      return new zt.c(
                                        t,
                                        this,
                                        this.messageLocalController,
                                      );
                                  }
                                  isPinned(e) {
                                    return this.conversationRepository
                                      .get(e)
                                      .then((e) => !(null == e || !e.pinned))
                                      .catch(() => !1);
                                  }
                                  isMuted(e) {
                                    return !!this.muteManager.isMuted(e);
                                  }
                                }),
                              ) || vi),
                          ) || vi),
                      ) || vi),
                  ) || vi),
              ) || vi),
          ) || vi;
        var Ii;
        let yi =
          i.ModuleContainer.injectable()(
            (Ii =
              (function (e, t) {
                return i.ModuleContainer.inject(zt.b)(e, void 0, 0);
              })(
                (Ii =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (Ii =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === zt.b ? Object : zt.b,
                      ])(
                        (Ii = class {
                          constructor(e) {
                            this.convManager = e;
                          }
                          get(e) {
                            return this.convManager.getConvById(e);
                          }
                        }),
                      ) || Ii),
                  ) || Ii),
              ) || Ii),
          ) || Ii;
        var _i = s("SVh1");
        var Oi,
          Ci = new (class {
            constructor() {}
            showMyProfile() {
              Je.ModalManagerV2.openModal({
                windowId: Qt.c,
                name: R.ModalIdentitiesDefine.FRIEND_PROFILE,
                params: Q.p.getSessionUserId(),
              });
            }
          })(),
          Ei = s("idnp"),
          Mi = s("44Ud"),
          Si = s("SWHF"),
          Ti = s("rkiK"),
          wi = s("oMqy"),
          Ri = s("oq0C");
        function Li() {
          for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
            t[s] = arguments[s];
          Ct.default.logCoreInfo("[Conversation controller] - ", t);
        }
        let Di =
          Object(i.singleton)()(
            (Oi =
              Object(i.injectable)()(
                (Oi =
                  (function (e, t) {
                    return Object(i.inject)(zt.i)(e, void 0, 0);
                  })(
                    (Oi =
                      (function (e, t) {
                        return Object(i.inject)(Si.b)(e, void 0, 1);
                      })(
                        (Oi =
                          (function (e, t) {
                            return Object(i.inject)(wi.e)(e, void 0, 2);
                          })(
                            (Oi =
                              (function (e, t) {
                                return Object(i.inject)(wi.m)(e, void 0, 3);
                              })(
                                (Oi =
                                  (function (e, t) {
                                    return Object(i.inject)(
                                      Wt.SidebarController,
                                    )(e, void 0, 4);
                                  })(
                                    (Oi =
                                      (function (e, t) {
                                        return Object(i.inject)(zt.b)(
                                          e,
                                          void 0,
                                          5,
                                        );
                                      })(
                                        (Oi =
                                          Reflect.metadata(
                                            "design:type",
                                            Function,
                                          )(
                                            (Oi =
                                              Reflect.metadata(
                                                "design:paramtypes",
                                                [
                                                  void 0 === zt.i
                                                    ? Object
                                                    : zt.i,
                                                  void 0 === Si.b
                                                    ? Object
                                                    : Si.b,
                                                  void 0 === wi.e
                                                    ? Object
                                                    : wi.e,
                                                  void 0 === wi.m
                                                    ? Object
                                                    : wi.m,
                                                  void 0 ===
                                                  Wt.SidebarController
                                                    ? Object
                                                    : Wt.SidebarController,
                                                  void 0 === zt.b
                                                    ? Object
                                                    : zt.b,
                                                ],
                                              )(
                                                (Oi = class {
                                                  constructor(
                                                    e,
                                                    t,
                                                    s,
                                                    i,
                                                    n,
                                                    a,
                                                  ) {
                                                    (this.previewManager = e),
                                                      (this.adminSettingController =
                                                        t),
                                                      (this.communityController =
                                                        s),
                                                      (this.groupLoadInfoController =
                                                        i),
                                                      (this.sidebar = n),
                                                      (this.convDataManager =
                                                        a),
                                                      (this.lastOpenConv =
                                                        new Map()),
                                                      (this._es = void 0),
                                                      (this.onRequestJumtoMsg =
                                                        (e, t) => {
                                                          const s =
                                                              t.conversation,
                                                            i =
                                                              e ===
                                                                St
                                                                  .ChatBoxActions
                                                                  .JUMP_TO_MESSAGE_SEARCH_HIDDEN_CHAT ||
                                                              Jt.a
                                                                .getListChatBoxViewCurrent()
                                                                .includes(
                                                                  null == s
                                                                    ? void 0
                                                                    : s.userId,
                                                                ) ||
                                                              s.byPassPIN;
                                                          if (!s) return;
                                                          if (
                                                            s &&
                                                            !i &&
                                                            Jt.a.isThreadHidden(
                                                              s.userId,
                                                            )
                                                          )
                                                            return (
                                                              Object(is.b)(
                                                                {
                                                                  type: e,
                                                                  payload: t,
                                                                },
                                                                !0,
                                                              ),
                                                              void Li(
                                                                "req jum to msg rejected because hidden chat",
                                                              )
                                                            );
                                                          Ti.default.Fps.record(
                                                            Ti.MetricName
                                                              .fps_jump_to_msg,
                                                          ),
                                                            Li(
                                                              "req jum to msg open on main",
                                                            ),
                                                            Object(is.b)(
                                                              {
                                                                type: e,
                                                                payload: t,
                                                              },
                                                              !0,
                                                            );
                                                          const n =
                                                            Ei.b.fromJumpMessage();
                                                          this.openConversationForJump(
                                                            s.userId,
                                                            n,
                                                          );
                                                        }),
                                                      (this.tryToFocusChild = (
                                                        e,
                                                        t,
                                                      ) =>
                                                        !!Ks.default.isOpenChildWindowByConvId(
                                                          e,
                                                        ) &&
                                                        (Li(
                                                          "Open conv forward because already open in child => call focus",
                                                        ),
                                                        Ks.default.focusOnChildWindow(
                                                          e,
                                                          null == t
                                                            ? void 0
                                                            : t.callPoint,
                                                        ),
                                                        !0)),
                                                      (this.handleOutConversation =
                                                        (e) => {
                                                          this.closeConversation(
                                                            e.convId,
                                                            { removed: !0 },
                                                          );
                                                        }),
                                                      this.listenEvent();
                                                  }
                                                  get eventStore() {
                                                    return (
                                                      this._es ||
                                                        (this._es =
                                                          s("emRR").default),
                                                      this._es
                                                    );
                                                  }
                                                  listenEvent() {
                                                    Mt.default.subscribe(
                                                      (e, t) => {
                                                        switch (e) {
                                                          case St
                                                            .ConversationListActions
                                                            .SELECT_CONVERSATION_HIDDEN:
                                                            this.sidebar.updateSelectedId(
                                                              t.userId,
                                                            );
                                                            break;
                                                          case St.ChatBoxActions
                                                            .OPEN_CONV_JUMP_TO_MESSAGE_SEARCH:
                                                            this.onRequestJumtoMsg(
                                                              St.ChatBoxActions
                                                                .JUMP_TO_MESSAGE_SEARCH,
                                                              t,
                                                            );
                                                            break;
                                                          case St.ChatBoxActions
                                                            .OPEN_CONV_JUMP_TO_MESSAGE_SEARCH_HIDDEN_CHAT:
                                                            this.onRequestJumtoMsg(
                                                              St.ChatBoxActions
                                                                .JUMP_TO_MESSAGE_SEARCH_HIDDEN_CHAT,
                                                              t,
                                                            );
                                                        }
                                                      },
                                                    ),
                                                      this.convDataManager.addEventListener(
                                                        Zt.b.DeleteConv,
                                                        this
                                                          .handleOutConversation,
                                                      ),
                                                      this.convDataManager.addEventListener(
                                                        Zt.b.EmptyConv,
                                                        this
                                                          .handleOutConversation,
                                                      ),
                                                      this.convDataManager.addEventListener(
                                                        Zt.b.LeaveGroup,
                                                        this
                                                          .handleOutConversation,
                                                      );
                                                  }
                                                  isConvOpeningInMain(e) {
                                                    const t =
                                                        this.eventStore.getState(),
                                                      s =
                                                        this.sidebar.getState()
                                                          .selectedId;
                                                    return (
                                                      t &&
                                                      t.chatview.view ===
                                                        Bs.c.CHAT_VIEW &&
                                                      s === e
                                                    );
                                                  }
                                                  openConversationForJump(
                                                    e,
                                                    t,
                                                  ) {
                                                    return (
                                                      void 0 === t &&
                                                        (t = Ei.a),
                                                      new Promise(async (s) => {
                                                        if (
                                                          (Li(
                                                            `Request open conv for jum: ${e}`,
                                                          ),
                                                          !e ||
                                                            this.isConvOpeningInMain(
                                                              e,
                                                            ))
                                                        ) {
                                                          if (
                                                            (Li(
                                                              `Open conv rejected because null or opened: ${e}`,
                                                            ),
                                                            e)
                                                          ) {
                                                            this.tryToFocusChild(
                                                              e,
                                                              t,
                                                            ) ||
                                                              Ks.default.focusOnMainWindow();
                                                          }
                                                          return s(!1);
                                                        }
                                                        if (
                                                          !(await this.conversationWillOpen(
                                                            e,
                                                          ))
                                                        )
                                                          return s(!1);
                                                        let i = !1;
                                                        if (
                                                          t.window ===
                                                          _i.b.Child
                                                        )
                                                          return (
                                                            (i =
                                                              this.tryToFocusChild(
                                                                e,
                                                                t,
                                                              )),
                                                            s(i)
                                                          );
                                                        if (
                                                          t.window ===
                                                          _i.b.PreferChild
                                                        ) {
                                                          if (
                                                            ((i =
                                                              this.tryToFocusChild(
                                                                e,
                                                                t,
                                                              )),
                                                            i)
                                                          )
                                                            return s(!0);
                                                        } else
                                                          t.window ===
                                                            _i.b.MainAndChild &&
                                                            (i =
                                                              this.tryToFocusChild(
                                                                e,
                                                                t,
                                                              ));
                                                        i ||
                                                          Ks.default.focusOnMainWindow(),
                                                          Mt.default.send(
                                                            St
                                                              .ConversationListActions
                                                              .SELECT_CONV_MINOR,
                                                            { userId: e },
                                                          ),
                                                          Object(is.b)({
                                                            type: St
                                                              .ConversationListActions
                                                              .OPEN_CONV_FOR_JUMP,
                                                            payload: {
                                                              userId: e,
                                                            },
                                                          }),
                                                          this.sidebar.updateSelectedId(
                                                            e,
                                                          ),
                                                          s(!0),
                                                          this.conversationDidOpen(
                                                            e,
                                                          );
                                                      })
                                                    );
                                                  }
                                                  openConversation(e, t) {
                                                    return (
                                                      void 0 === t &&
                                                        (t = Ei.a),
                                                      new Promise(
                                                        async (s, i) => {
                                                          if (
                                                            (Li(
                                                              `Request open conv from: ${e} - ${t.callPoint}`,
                                                            ),
                                                            !e ||
                                                              (this.isConvOpeningInMain(
                                                                e,
                                                              ) &&
                                                                !t.force))
                                                          ) {
                                                            if (
                                                              (Li(
                                                                `Open conv rejected because null or opened: ${e}`,
                                                              ),
                                                              e)
                                                            ) {
                                                              this.tryToFocusChild(
                                                                e,
                                                                t,
                                                              ) ||
                                                                t.silently ||
                                                                Ks.default.focusOnMainWindow();
                                                            }
                                                            return s(!1);
                                                          }
                                                          const n =
                                                            Q.p.getSessionUserId();
                                                          if (e == n)
                                                            return (
                                                              Ci.showMyProfile(),
                                                              s(!1)
                                                            );
                                                          Ti.default.Fps.record(
                                                            Ti.MetricName
                                                              .fps_switch_conv,
                                                          );
                                                          if (
                                                            !(await this.conversationWillOpen(
                                                              e,
                                                            ))
                                                          )
                                                            return s(!1);
                                                          let a = !1;
                                                          if (
                                                            t.window ===
                                                            _i.b.Child
                                                          )
                                                            return (
                                                              (a =
                                                                this.tryToFocusChild(
                                                                  e,
                                                                  t,
                                                                )),
                                                              s(a)
                                                            );
                                                          if (
                                                            t.window ===
                                                            _i.b.PreferChild
                                                          ) {
                                                            if (
                                                              ((a =
                                                                this.tryToFocusChild(
                                                                  e,
                                                                  t,
                                                                )),
                                                              a)
                                                            )
                                                              return s(!0);
                                                          } else
                                                            t.window ===
                                                              _i.b
                                                                .MainAndChild &&
                                                              (a =
                                                                this.tryToFocusChild(
                                                                  e,
                                                                  t,
                                                                ));
                                                          let r = t.credentConv;
                                                          if (
                                                            (r ||
                                                              ((r =
                                                                await Ee.default
                                                                  .getLikeConversation(
                                                                    e,
                                                                  )
                                                                  .catch(
                                                                    (e) => {
                                                                      Li(
                                                                        `Failure to load conv from store ${e}`,
                                                                      );
                                                                    },
                                                                  )),
                                                              Li(
                                                                `Try to use storage conv: ${!!r}`,
                                                              )),
                                                            r ||
                                                              ((r =
                                                                t.defaultConv),
                                                              Li(
                                                                `Try to use default conv: ${!!r}`,
                                                              )),
                                                            !r)
                                                          )
                                                            return (
                                                              Li(
                                                                `Open conv not exists: ${e}`,
                                                              ),
                                                              s(!1)
                                                            );
                                                          a ||
                                                            t.silently ||
                                                            Ks.default.focusOnMainWindow(),
                                                            Mt.default.send(
                                                              St
                                                                .ConversationListActions
                                                                .SELECT_CONV_MINOR,
                                                              r,
                                                            );
                                                          const o =
                                                            Jt.a.isThreadHidden(
                                                              e,
                                                            );
                                                          o &&
                                                            Jt.a.checkShowUnreadHiddenChat(
                                                              e,
                                                            ),
                                                            t.byPassPIN
                                                              ? ((r = Object(
                                                                  f.a,
                                                                )({}, r)),
                                                                (r.byPassPIN = 1))
                                                              : delete r.byPassPIN,
                                                            this.eventStore.dispatch(
                                                              {
                                                                type: St
                                                                  .ConversationListActions
                                                                  .SELECT_CONVERSATION,
                                                                payload: r,
                                                              },
                                                            ),
                                                            Mt.default.send(
                                                              St
                                                                .ConversationListActions
                                                                .SELECT_CONVERSATION,
                                                              {
                                                                userId:
                                                                  r.userId,
                                                                needScroll:
                                                                  t.callPoint !==
                                                                  _i.a.ConvItem,
                                                                callPoint:
                                                                  t.callPoint,
                                                              },
                                                            );
                                                          (!o ||
                                                            t.byPassPIN ||
                                                            Jt.a
                                                              .getListChatBoxViewCurrent()
                                                              .includes(
                                                                r.userId,
                                                              )) &&
                                                            this.sidebar.updateSelectedId(
                                                              e,
                                                            ),
                                                            s(!0),
                                                            this.conversationDidOpen(
                                                              e,
                                                            );
                                                        },
                                                      )
                                                    );
                                                  }
                                                  closeConversation(e, t) {
                                                    return (
                                                      void 0 === t && (t = {}),
                                                      new Promise((s) => {
                                                        if (
                                                          e &&
                                                          this.sidebar.getState()
                                                            .selectedId !== e
                                                        )
                                                          return s(!1);
                                                        const {
                                                          windowId: i = Qt.c,
                                                          removed: n,
                                                        } = t;
                                                        if (i === Qt.c) {
                                                          const e = {
                                                            conversation: null,
                                                            convId: null,
                                                          };
                                                          this.eventStore.dispatch(
                                                            {
                                                              type: St
                                                                .ConversationListActions
                                                                .SELECT_CONVERSATION,
                                                              payload: e,
                                                            },
                                                          ),
                                                            Mt.default.send(
                                                              St
                                                                .ConversationListActions
                                                                .SELECT_CONVERSATION,
                                                              e,
                                                            ),
                                                            n
                                                              ? this.sidebar.updateSelectedIdWithoutPrevious(
                                                                  null,
                                                                )
                                                              : this.sidebar.updateSelectedId(
                                                                  null,
                                                                );
                                                        }
                                                        s(!0);
                                                      })
                                                    );
                                                  }
                                                  closeAllConversations() {
                                                    return Promise.resolve(!0);
                                                  }
                                                  deleteConversation(e, t) {
                                                    return (
                                                      void 0 === t &&
                                                        (t = Qt.c),
                                                      new Promise(async (s) => {
                                                        if (
                                                          (this.conversationWillDelete(
                                                            e,
                                                          ),
                                                          await Gt.default.deleteConversation(
                                                            e,
                                                            !0,
                                                            t,
                                                          ),
                                                          t === Qt.c)
                                                        ) {
                                                          const t = {
                                                            userId: null,
                                                          };
                                                          this.eventStore.dispatch(
                                                            {
                                                              type: St
                                                                .ConversationListActions
                                                                .SELECT_CONVERSATION,
                                                              payload: t,
                                                            },
                                                          ),
                                                            Mt.default.send(
                                                              St
                                                                .ConversationListActions
                                                                .SELECT_CONVERSATION,
                                                              t,
                                                            ),
                                                            this.sidebar.updateSelectedId(
                                                              null,
                                                            ),
                                                            s(!0),
                                                            this.conversationDidDelete(
                                                              e,
                                                            );
                                                        } else s(!1);
                                                      })
                                                    );
                                                  }
                                                  pinConversation(e) {
                                                    return Promise.resolve(!0);
                                                  }
                                                  renameConversation(e) {
                                                    return Promise.resolve(!0);
                                                  }
                                                  getLastOpenConv(e) {
                                                    return this.lastOpenConv.get(
                                                      e,
                                                    );
                                                  }
                                                  conversationWillOpen(e) {
                                                    return (
                                                      Mi.b.start(Mi.a.ART, {
                                                        convId: e,
                                                      }),
                                                      Li(`Will open conv ${e}`),
                                                      this.lastOpenConv.set(
                                                        e,
                                                        Date.now(),
                                                      ),
                                                      Promise.resolve(!0)
                                                    );
                                                  }
                                                  conversationDidOpen(e) {
                                                    Ti.default.start(
                                                      Ti.MetricName
                                                        .open_conversation,
                                                      e,
                                                    ),
                                                      Li(`Did open conv ${e}`),
                                                      this.adminSettingController.onLoadSetting(
                                                        e,
                                                      ),
                                                      this.communityController.onConversationDidOpen(
                                                        e,
                                                      ),
                                                      this.groupLoadInfoController.onOpenConversation(
                                                        e,
                                                      ),
                                                      i.ModuleContainer.resolve(
                                                        Ri.a,
                                                      ).onOpenConversation(e),
                                                      setTimeout(() => {
                                                        this.previewManager.revalidate(
                                                          e,
                                                        );
                                                      }, 0);
                                                  }
                                                  conversationWillDelete(e) {
                                                    return (
                                                      Li(
                                                        `Will delete conv ${e}`,
                                                      ),
                                                      Promise.resolve()
                                                    );
                                                  }
                                                  conversationDidDelete(e) {
                                                    Li(`Did delete conv ${e}`),
                                                      this.lastOpenConv.delete(
                                                        e,
                                                      );
                                                  }
                                                }),
                                              ) || Oi),
                                          ) || Oi),
                                      ) || Oi),
                                  ) || Oi),
                              ) || Oi),
                          ) || Oi),
                      ) || Oi),
                  ) || Oi),
              ) || Oi),
          ) || Oi;
        var Fi,
          Ai = s("s9sK"),
          ji = s("TeMN"),
          Pi = (s("EHdh"), s("Ln14")),
          Ni = s("bdot"),
          Ui = s("cfFl"),
          ki = s.n(Ui);
        const Bi = {
            userId: R.CONV_FILTER.STRANGER,
            label: null,
            isGroup: !1,
            respondedByMe: !1,
            numMsg: 0,
            pinned: 0,
            outside: 0,
            topOut: !1,
            infoCheckSearch: null,
          },
          Gi = [
            "userId",
            "label",
            "firstSmsLocalId",
            "lastSmsLocalId",
            "isGroup",
            "respondedByMe",
            "numMsg",
            "pinned",
            "outside",
            "lastActionId",
            "topOutImprTimeOut",
            "topOutTimeOut",
            "syncFromMobile",
            "topOut",
            "localType",
            "infoCheckSearch",
            "preLastSmsLocalId",
          ];
        Object($t.b)(Pi.c)(
          (Fi =
            (function (e, t) {
              return i.ModuleContainer.inject(ji.b)(e, void 0, 0);
            })(
              (Fi =
                Reflect.metadata(
                  "design:type",
                  Function,
                )(
                  (Fi =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === Zt.IReactiveDB ? Object : Zt.IReactiveDB,
                    ])(
                      (Fi = class extends te.b {
                        constructor(e) {
                          super(),
                            (this.DBConvInfo = e),
                            (this.name = void 0),
                            (this.key = void 0),
                            (this.data = void 0),
                            (this.didInit = void 0),
                            (this.doneLoadDB = void 0),
                            (this.fetchAllHolder = void 0),
                            (this.preloadCached = void 0),
                            (this._pm = void 0),
                            (this.pinEventQueue = void 0),
                            (this.labelEventQueue = void 0),
                            (this.doneEventQueue = void 0),
                            (this.name = Pi.a),
                            (this.key = "convId"),
                            (this.data = new Map()),
                            (this.didInit = !1),
                            (this.doneLoadDB = !1),
                            (this.fetchAllHolder = null),
                            (this.preloadCached = null),
                            (this._pm = null),
                            (this.pinEventQueue = []),
                            (this.labelEventQueue = []),
                            (this.doneEventQueue = !1);
                        }
                        get previewManager() {
                          return (
                            this._pm ||
                              (this._pm = i.ModuleContainer.resolve(zt.i)),
                            this._pm
                          );
                        }
                        get unreadManager() {
                          return Pt.a.UnreadDataManager;
                        }
                        init() {
                          return this.didInit
                            ? Promise.resolve()
                            : ((this.didInit = !0), this.loadData());
                        }
                        async loadData() {
                          this.fetchAllHolder ||
                            (this.fetchAllHolder = this.DBConvInfo.getAll());
                          const e =
                              (await this.fetchAllHolder.catch((e) => {
                                Ct.default.logCoreInfo(
                                  `[${this.name}] - load conv from DB got error ${e}`,
                                );
                              })) || [],
                            t = await this.onLoadDataFromDB(e);
                          Ct.default.logCoreInfo(
                            `[${this.name}] - done load db ${e.length}`,
                          ),
                            (this.doneLoadDB = !0),
                            this.doIdleTask(),
                            this.broadcastEvent(Zt.b.DoneLoadDB, "", e),
                            this.previewManager.migrate(t.map((e) => e.userId)),
                            this.setCacheData(R.CONV_FILTER.STRANGER, Bi, !0);
                        }
                        async doIdleTask() {
                          const e = this.pinEventQueue.slice(),
                            t = this.labelEventQueue.slice();
                          (this.pinEventQueue = []),
                            (this.labelEventQueue = []);
                          const s = ki.a.series(e),
                            i = ki.a.series(t);
                          return Promise.all([s, i]).then((e) =>
                            this.pinEventQueue.length ||
                            this.labelEventQueue.length
                              ? this.doIdleTask()
                              : ((this.doneEventQueue = !0), e),
                          );
                        }
                        getItem(e, t) {
                          return this.data.get(e.key);
                        }
                        getList(e, t) {
                          return e.key === Pi.b.ALL
                            ? Array.from(this.data.keys())
                            : [];
                        }
                        onGetItemFailure(e) {}
                        onGetListFailure(e) {}
                        async onLoadDataFromDB(e) {
                          const t = await qt.a.filterOutdatedConv(e);
                          Ct.default.logCoreInfo(
                            `[${this.name}] - done filter outdate ${e.length} ${t.length}`,
                          );
                          const s = new Date().getTime().toString(),
                            i = [];
                          Object(nt.j)(s);
                          for (let n = 0; n < t.length; n++) {
                            if (!t[n].userId) continue;
                            const e = Object(f.a)({}, t[n]),
                              a = this.data.get(e.userId);
                            if (
                              ((e.verified = !0),
                              void 0 === e.isGroup &&
                                (e.isGroup = e.userId.startsWith(
                                  R.GROUPID_PREFIX,
                                )),
                              a)
                            ) {
                              if (!a.verified) {
                                const t = this.mergeConv(e, a);
                                (t.verified = !0),
                                  this.setCacheData(e.userId, t),
                                  Object(nt.f)(s, this.name, e.userId),
                                  this.updateInDB(t);
                              }
                            } else
                              this.setCacheData(e.userId, e),
                                Object(nt.f)(s, this.name, e.userId);
                            e.infoCheckSearch &&
                              (e.infoCheckSearch &&
                              Ct.default.msgTypeValid(
                                e.infoCheckSearch.lastType,
                              )
                                ? ys.a.pushCacheLastChat(
                                    e.userId,
                                    e.infoCheckSearch.lastMessageTime,
                                  )
                                : e.numMsg && e.numMsg > 1 && i.push(e.userId));
                          }
                          return (
                            i.length > 0 && ys.a.cacheCheckLastChatInDb(i),
                            Object(nt.c)(s),
                            t
                          );
                        }
                        onReceiveNewMessages(e, t, s) {
                          return (
                            void 0 === s &&
                              (s = { outside: void 0, isGroup: !1 }),
                            new Promise((i, n) => {
                              var a;
                              if (!t || t.length < 0) return n("Empty msgs");
                              const r = t[t.length - 1],
                                o = t[0],
                                d = this.data.get(e),
                                l = qt.a.getLastValidMsg(t);
                              let c;
                              l &&
                                ((c = {
                                  lastMessageTime: Number(l.sendDttm),
                                  lastType: l.msgType,
                                }),
                                ys.a.pushCacheLastChat(e, c.lastMessageTime));
                              const h = {
                                userId: e,
                                firstSmsLocalId: o.msgId,
                                isGroup:
                                  s.isGroup || e.startsWith(R.GROUPID_PREFIX),
                                numMsg: t.length,
                                respondedByMe: ls.b.includeMyMessage(t),
                                pinned: 0,
                                label: null,
                                topOut: r.topOut,
                                verified: !1,
                                lastSmsLocalId: r.msgId,
                                outside: s.outside,
                                cloudMore: !1,
                                infoCheckSearch: c,
                              };
                              if (
                                (this.preloadCached &&
                                  this.preloadCached.onNewMsg(e, r),
                                d)
                              ) {
                                const t = this.mergeConv(Object(f.a)({}, d), h);
                                this.setCacheData(e, t),
                                  this.shouldSignalUpdate(d, t) &&
                                    Object(nt.g)(this.name, e),
                                  d.verified && this.updateInDB(t),
                                  i(t);
                              } else {
                                const t = Yt.b.getLabelObjByConversaionId(e);
                                if (
                                  ((h.label = t ? t.id : null),
                                  this.setCacheData(e, h, !0),
                                  this.doneLoadDB)
                                )
                                  return (
                                    (h.verified = !0), this.updateInDB(h), i(h)
                                  );
                                this.DBConvInfo.getById(e).then((t) => {
                                  const s = this.data.get(e);
                                  if (!s)
                                    return n("Internal logic handle wrong");
                                  let a = Object(f.a)({}, s);
                                  (a.verified = !0),
                                    t
                                      ? s.verified ||
                                        ((a = this.mergeConv(a, t)),
                                        this.setCacheData(e, a),
                                        this.shouldSignalUpdate(a, s) &&
                                          Object(nt.g)(this.name, e),
                                        this.updateInDB(a))
                                      : this.updateInDB(a),
                                    i(a);
                                });
                              }
                              (d && d.respondedByMe) ||
                                null === (a = this.data.get(e)) ||
                                void 0 === a ||
                                !a.respondedByMe ||
                                (Ct.default.logCoreInfo(
                                  `[${this.name}] - Detect first my msg ${e} ${r.msgId}`,
                                ),
                                this.previewManager.forceChangeItem(e));
                            })
                          );
                        }
                        async onDeleteMessages(e, t) {
                          const s = this.data.get(e);
                          if (
                            (Ct.default.logCoreInfo(
                              `[${this.name}] - onDeleteMessages #1 ${e} ${t.length}`,
                            ),
                            s && s.verified)
                          ) {
                            let i = !1;
                            if (
                              t.find((e) => {
                                let { msgId: t } = e;
                                return s.firstSmsLocalId === t;
                              })
                            ) {
                              const t = await (
                                await Ni.b.getFirstMessage(e)
                              ).firstMsg;
                              if (!t)
                                return (
                                  Ct.default.logCoreInfo(
                                    `[${this.name}] - onDeleteMessages #4 ${e} `,
                                  ),
                                  this.forkDeleteCacheAndDB(e),
                                  { deletedId: e }
                                );
                              (s.firstSmsLocalId =
                                null == t ? void 0 : t.msgId),
                                (i = !0);
                            }
                            if (
                              t.find((e) => {
                                let { msgId: t } = e;
                                return s.lastSmsLocalId === t;
                              })
                            ) {
                              const t = await Ni.b.getLastMessage(
                                e,
                                s.lastSmsLocalId,
                              );
                              if (!t || t.length < 1)
                                return (
                                  Ct.default.logCoreInfo(
                                    `[${this.name}] - onDeleteMessages #5 ${e} ${!!t}`,
                                  ),
                                  this.forkDeleteCacheAndDB(e),
                                  { deletedId: e }
                                );
                              (s.lastSmsLocalId = t[0].msgId), (i = !0);
                            }
                            return (
                              Ct.default.logCoreInfo(
                                `[${this.name}] - onDeleteMessages #6 ${e} ${i}`,
                              ),
                              i &&
                                (this.setCacheData(e, Object(f.a)({}, s)),
                                this.updateInDB(s)),
                              { conversation: s, updated: i }
                            );
                          }
                          {
                            const t = await (
                                await Ni.b.getFirstMessage(e)
                              ).firstMsg,
                              s = await Ni.b.getLastMessage(e),
                              i = s && s[0];
                            if (!t || !i)
                              return (
                                Ct.default.logCoreInfo(
                                  `[${this.name}] - onDeleteMessages #2 ${e} ${!!t} ${!!i}`,
                                ),
                                Pt.a.PinDataManager.isPinned(e) ||
                                  this.onDeleteConversation(e),
                                { deletedId: e }
                              );
                            const n = await this.DBConvInfo.getById(e);
                            let a = Ct.default.msgTypeValid(i)
                              ? {
                                  lastMessageTime: i.sendDttm,
                                  lastType: i.msgType,
                                }
                              : void 0;
                            if (
                              (Ct.default.logCoreInfo(
                                `[${this.name}] - onDeleteMessages #3 ${e} ${!!n}`,
                              ),
                              n)
                            ) {
                              let s = !1;
                              n.firstSmsLocalId !==
                                (null == t ? void 0 : t.msgId) &&
                                ((n.firstSmsLocalId =
                                  null == t ? void 0 : t.msgId),
                                (s = !0)),
                                n.lastSmsLocalId !== i.msgId &&
                                  ((n.lastSmsLocalId =
                                    null == i ? void 0 : i.msgId),
                                  (s = !0));
                              const a = Object(f.a)(
                                Object(f.a)({}, n),
                                {},
                                { verified: !0 },
                              );
                              return (
                                this.setCacheData(e, a, !0),
                                s && this.updateInDB(a),
                                { conversation: a, updated: !0 }
                              );
                            }
                            {
                              const s = {
                                userId: e,
                                isGroup: e.startsWith(R.GROUPID_PREFIX),
                                pinned: 0,
                                label: null,
                                topOut: void 0,
                                verified: !0,
                                outside: null,
                                cloudMore: !1,
                                firstSmsLocalId: t.msgId,
                                lastSmsLocalId: i.msgId,
                                numMsg: 2,
                                respondedByMe:
                                  "0" == t.fromUid || "0" == i.fromUid,
                                infoCheckSearch: a,
                              };
                              return (
                                this.setCacheData(e, s, !0),
                                this.updateInDB(s),
                                { conversation: s, updated: !0 }
                              );
                            }
                          }
                        }
                        mergeConv(e, t) {
                          return (
                            (!e.lastSmsLocalId ||
                              (t.lastSmsLocalId &&
                                t.lastSmsLocalId > e.lastSmsLocalId)) &&
                              ((e.preLastSmsLocalId =
                                e.lastSmsLocalId || t.lastSmsLocalId),
                              (e.lastSmsLocalId = t.lastSmsLocalId),
                              (e.outside = t.outside)),
                            (e.numMsg = (e.numMsg || 0) + t.numMsg),
                            (e.respondedByMe =
                              e.respondedByMe || t.respondedByMe),
                            (!e.firstSmsLocalId ||
                              (t.firstSmsLocalId &&
                                t.firstSmsLocalId < e.firstSmsLocalId)) &&
                              (e.firstSmsLocalId = t.firstSmsLocalId),
                            (!e.infoCheckSearch ||
                              !e.infoCheckSearch.lastMessageTime ||
                              (t.infoCheckSearch &&
                                t.infoCheckSearch.lastMessageTime >
                                  e.infoCheckSearch.lastMessageTime)) &&
                              (e.infoCheckSearch = t.infoCheckSearch),
                            e.preLastSmsLocalId ||
                              (e.preLastSmsLocalId = t.lastSmsLocalId),
                            !t.respondedByMe &&
                              t.topOut &&
                              (e.topOut = t.topOut),
                            "string" != typeof e.firstSmsLocalId &&
                              (e.firstSmsLocalId = "" + e.firstSmsLocalId),
                            e
                          );
                        }
                        async onEmptyConversation(e) {
                          const t = await this.getConvById(e);
                          if (
                            (Ct.default.logCoreInfo(
                              `[${this.name}] - onEmptyConversation ${e} ${!!t}`,
                            ),
                            !t)
                          )
                            return;
                          const s = Object(f.a)({}, t);
                          return (
                            delete s.firstSmsLocalId,
                            delete s.lastSmsLocalId,
                            (s.numMsg = 0),
                            (s.respondedByMe = !1),
                            this.setCacheData(e, s, !0),
                            this.broadcastEvent(Zt.b.EmptyConv, e),
                            Object(nt.g)(this.name, e),
                            Pt.a.PinDataManager.isPinned(e) &&
                              Pt.a.PinDataManager.unpin([e]),
                            this.updateInDB(s)
                          );
                        }
                        onDeleteConversation(e) {
                          Ct.default.logCoreInfo(
                            `[${this.name}] - onDeleteConversation ${e}`,
                          );
                          const t = this.data.get(e);
                          return this.doDeleteConversation(e).then((s) => {
                            this.broadcastEvent(Zt.b.DeleteConv, e, t);
                          });
                        }
                        doDeleteConversation(e) {
                          const t = this.data.get(e);
                          return (
                            Ct.default.logCoreInfo(
                              `[${this.name}] - doDeleteConversation ${e} ${!!t}`,
                            ),
                            t &&
                              (this.data.delete(e), Object(nt.e)(this.name, e)),
                            Pt.a.PinDataManager.isPinned(e) &&
                              Pt.a.PinDataManager.unpinLocal([e]),
                            this.deleteInDB(e)
                          );
                        }
                        onPinConversation(e, t) {
                          return new Promise((s) => {
                            this.doneEventQueue
                              ? this.doUpdatePin(e, t).then(s)
                              : this.pinEventQueue.push(async () => {
                                  const i = await this.doUpdatePin(e, t);
                                  s(i);
                                });
                          });
                        }
                        doUpdatePin(e, t) {
                          if (t && qt.a.isStrangerV2(e))
                            return Promise.resolve(null);
                          if (!this.data.get(e)) {
                            if (!t) return Promise.resolve(null);
                            const s = this.getEmptyConv(e);
                            (s.verified = !0), this.setCacheData(e, s);
                          }
                          const s = new Map();
                          return (
                            s.set("pinned", t),
                            this.updateFields(e, s)
                              .then(
                                (s) => (
                                  this.broadcastEvent(Zt.b.ChangePinConv, e, t),
                                  s
                                ),
                              )
                              .catch(
                                (t) => (
                                  Ct.default.logCoreInfo(
                                    `[${this.name}] - doUpdatePin err`,
                                    t,
                                  ),
                                  this.data.get(e)
                                ),
                              )
                          );
                        }
                        onLeaveGroup(e) {
                          return (
                            Ct.default.logCoreInfo(
                              `[${this.name}] - onLeaveGroup ${e}`,
                            ),
                            this.doDeleteConversation(e).then((t) => {
                              this.broadcastEvent(Zt.b.LeaveGroup, e);
                            })
                          );
                        }
                        async onChangeConvLabel(e, t) {
                          return new Promise((s) => {
                            const i = this.data.get(e);
                            if (i && i.label === t) return s(i);
                            this.doneEventQueue
                              ? this.doUpdateConvLabel(e, t).then(s)
                              : this.labelEventQueue.push(async () => {
                                  const i = await this.doUpdateConvLabel(e, t);
                                  s(i);
                                });
                          });
                        }
                        doUpdateConvLabel(e, t) {
                          if (!e)
                            return (
                              Ct.default.logCoreInfo(
                                `[${this.name}] - doUpdateConvLabel with undefined ${t}`,
                              ),
                              Promise.resolve(null)
                            );
                          const s = this.data.get(e);
                          if (s && s.label === t) return Promise.resolve(s);
                          if (!s) {
                            if (!t) return Promise.resolve(null);
                            const s = this.getEmptyConv(e);
                            (s.verified = !0), this.setCacheData(e, s);
                          }
                          const i = new Map();
                          return (
                            i.set("label", t),
                            this.updateFields(e, i).then(
                              (i) => (
                                this.unreadManager.onChangeConvLabel(
                                  e,
                                  null == s ? void 0 : s.label,
                                  t,
                                ),
                                i
                              ),
                            )
                          );
                        }
                        onFetchConvLabels(e) {
                          if (!e || !Array.isArray(e)) return;
                          Ct.default.logCoreInfo(
                            `[${this.name}] - onChangeConvLabel ${e.length}`,
                          );
                          const t = {};
                          this.getAllConv().then((s) => {
                            for (let e = 0; e < s.length; e++)
                              t[s[e].userId] = 1;
                            for (let i = 0; i < e.length; i++) {
                              const s = e[i].id,
                                n = e[i].conversations;
                              if (n)
                                for (let e = 0; e < n.length; e++) {
                                  const i = n[e];
                                  delete t[i], this.onChangeConvLabel(i, s);
                                }
                            }
                            for (const e in t)
                              Object.hasOwnProperty.call(t, e) &&
                                this.onChangeConvLabel(e, null);
                          });
                        }
                        onDeleteConvLabels(e) {
                          Ct.default.logCoreInfo(
                            `[${this.name}] - onDeleteConvLabels ${e.length}`,
                          ),
                            e.forEach((e) => {
                              const t = e.conversations;
                              if (t && t.length)
                                for (let s = 0; s < t.length; s++)
                                  this.data.has(t[s]) &&
                                    this.onChangeConvLabel(t[s], null);
                            });
                        }
                        async onUpdateMsgId(e, t, s) {
                          if (!t || !s || t === s)
                            return Promise.reject(
                              "[Conv-info-manager]- call update with invalid params!",
                            );
                          const i = this.data.get(e);
                          let n = i || {},
                            a = !1;
                          if (!i || !i.verified) {
                            const t = await this.DBConvInfo.getById(e);
                            if (!i && !t) {
                              const t = await this.createEmptyConvForUser(
                                e,
                                0,
                                void 0,
                                { firstSmsLocalId: s, lastSmsLocalId: s },
                              );
                              return this.setCacheData(e, t), t;
                            }
                            i && t
                              ? ((n = this.mergeConv(i, t)), (a = !0))
                              : ((n = i || t), (n.verified = !0), (a = !0));
                          }
                          return (
                            (n.firstSmsLocalId && n.firstSmsLocalId !== t) ||
                              ((a = !0), (n.firstSmsLocalId = s)),
                            (n.lastSmsLocalId && n.lastSmsLocalId !== t) ||
                              ((a = !0), (n.lastSmsLocalId = s)),
                            a && (this.setCacheData(e, n), this.updateInDB(n)),
                            n
                          );
                        }
                        async addOrUpdateConv(e, t, s, i, n, a) {
                          "number" == typeof t && (t = "" + t),
                            "number" == typeof s && (s = "" + s);
                          const r = this.data.get(e);
                          Ct.default.logCoreInfo(
                            `[${this.name}] - addOrUpdateConv ${e} ${!!r} ${s}`,
                          );
                          const o = (e) => (
                            (!e.firstSmsLocalId ||
                              (t && t < e.firstSmsLocalId)) &&
                              (e.firstSmsLocalId = t),
                            (!e.lastSmsLocalId ||
                              (s && s > e.lastSmsLocalId)) &&
                              (e.lastSmsLocalId = s),
                            (e.cloudMore = i),
                            (e.respondedByMe = e.respondedByMe || n),
                            (e.numMsg = (e.numMsg || 0) + a),
                            e
                          );
                          if (r && r.verified) {
                            const t = o(r);
                            return (
                              this.setCacheData(e, Object(f.a)({}, t)),
                              this.updateInDB(t),
                              t
                            );
                          }
                          {
                            const r = await this.DBConvInfo.getById(e);
                            if (
                              (Ct.default.logCoreInfo(
                                `[${this.name}] - addOrUpdateConv #2 ${e} ${!!r}`,
                              ),
                              r)
                            ) {
                              const t = o(r);
                              return (
                                this.setCacheData(
                                  e,
                                  Object(f.a)(
                                    Object(f.a)({}, t),
                                    {},
                                    { verified: !0 },
                                  ),
                                ),
                                this.updateInDB(t),
                                t
                              );
                            }
                            {
                              const r = {
                                userId: e,
                                firstSmsLocalId: t,
                                lastSmsLocalId: s,
                                isGroup: e.startsWith(R.GROUPID_PREFIX),
                                respondedByMe: n,
                                numMsg: a || 2,
                                label: null,
                                pinned: 0,
                                verified: !0,
                                cloudMore: i,
                                outside: null,
                                topOut: null,
                                infoCheckSearch: void 0,
                              };
                              return (
                                this.setCacheData(e, r, !0),
                                this.updateInDB(r),
                                r
                              );
                            }
                          }
                        }
                        async addIfNotExistsConv(e, t, s, i, n, a) {
                          const r = this.data.get(e);
                          if (
                            (Ct.default.logCoreInfo(
                              `[${this.name}] - addIfNotExistsConv #1 ${e} ${!!r} ${i}`,
                            ),
                            r)
                          )
                            return !1;
                          const o = await this.DBConvInfo.getById(e);
                          if (
                            (Ct.default.logCoreInfo(
                              `[${this.name}] - addIfNotExistsConv #2 ${!!o}`,
                            ),
                            o)
                          )
                            return !1;
                          {
                            const r = {
                              userId: e,
                              firstSmsLocalId: s,
                              lastSmsLocalId: i,
                              isGroup: t || e.startsWith(R.GROUPID_PREFIX),
                              respondedByMe: n,
                              numMsg: a || 1,
                              label: null,
                              pinned: 0,
                              verified: !0,
                              outside: null,
                              topOut: null,
                              infoCheckSearch: void 0,
                            };
                            return (
                              this.setCacheData(e, r, !0),
                              this.updateInDB(r),
                              !0
                            );
                          }
                        }
                        createEmptyConvForUser(e, t, s, i) {
                          return (
                            void 0 === s && (s = R.CONV_OT_STATE.none),
                            new Promise((n, a) => {
                              this.getConvById(e)
                                .then((n) => {
                                  let a;
                                  if (
                                    (Ct.default.logCoreInfo(
                                      `[${this.name}] - createEmptyConvForUser ${e} ${!!n}`,
                                    ),
                                    n)
                                  ) {
                                    const i = new Map();
                                    return (
                                      (a = n),
                                      s !== R.CONV_OT_STATE.none &&
                                        void 0 !== s &&
                                        ((a.outside = s), i.set("outside", s)),
                                      t &&
                                        !Pt.a.PinDataManager.isPinned(
                                          a.userId,
                                        ) &&
                                        Pt.a.PinDataManager.pin([a.userId]),
                                      this.updateFields(e, i),
                                      a
                                    );
                                  }
                                  return (
                                    (a = Object(f.a)(
                                      {
                                        userId: e,
                                        lastMessageTime: t
                                          ? 0
                                          : _t.default.getTimeNow(),
                                        isGroup: e.startsWith(R.GROUPID_PREFIX),
                                      },
                                      i,
                                    )),
                                    s !== R.CONV_OT_STATE.none &&
                                      void 0 !== s &&
                                      (a.outside = s),
                                    t && Pt.a.PinDataManager.pin([a.userId]),
                                    (a.verified = !0),
                                    this.setCacheData(e, a, !0),
                                    this.updateInDB(a),
                                    a
                                  );
                                })
                                .then((e) => {
                                  n(e);
                                })
                                .catch((e) => {
                                  Ct.default.logCoreError(e), a(e);
                                });
                            })
                          );
                        }
                        updateLastMsgId(e, t) {
                          const s = this.data.get(e);
                          if (s && s.lastSmsLocalId === t)
                            return Promise.resolve(s);
                          const i = new Map();
                          return (
                            i.set("lastSmsLocalId", t), this.updateFields(e, i)
                          );
                        }
                        updateInfoCheckSearch(e, t, s) {
                          const i = this.data.get(e);
                          if (
                            i &&
                            i.infoCheckSearch &&
                            i.infoCheckSearch.lastMessageTime === t
                          )
                            return Promise.resolve(i);
                          const n = new Map();
                          return (
                            n.set("infoCheckSearch", {
                              lastMessageTime: t,
                              lastType: s,
                            }),
                            this.updateFields(e, n)
                          );
                        }
                        updateConvSetting(e, t) {
                          let s = this.data.get(e);
                          if (!s) {
                            const i = !!this.doneLoadDB;
                            (s = { userId: e, verified: i }),
                              i ||
                                Ct.default.logCoreInfo(
                                  `[${this.name}] - update conv setting before done load db ${e}`,
                                  t,
                                );
                          }
                          Ct.default.shallowEqual(s.setting, t) ||
                            ((s.setting = t),
                            this.setCacheData(e, s, !0),
                            Ct.default.logCoreInfo(
                              `[${this.name}] - update conv setting for conv ${e}`,
                              t,
                            ));
                        }
                        async isRespondedByMe(e) {
                          const t = await this.getConvById(e);
                          return !!t && Boolean(t.respondedByMe);
                        }
                        isRespondedByMeSync(e) {
                          const t = this.data.get(e);
                          return !!t && Boolean(t.respondedByMe);
                        }
                        isDoneLoadDB() {
                          return this.doneLoadDB;
                        }
                        getConvByIdSync(e) {
                          return (
                            "string" != typeof e &&
                              Ct.default.logCoreInfo(
                                `[${this.name}] - getConvByIdSync with invalid id type`,
                                e,
                                !!this.data.get(e),
                                !!this.data.get("" + e),
                              ),
                            this.data.get(e)
                          );
                        }
                        getConvById(e) {
                          return new Promise((t, s) => {
                            if (this.data.has(e)) return t(this.data.get(e));
                            this.DBConvInfo.getById(e)
                              .then((e) => {
                                t(e);
                              })
                              .catch(s);
                          });
                        }
                        getAllConvSync() {
                          return Array.from(this.data.values()) || [];
                        }
                        getAllConv() {
                          return new Promise((e, t) => {
                            if (this.doneLoadDB) {
                              return e(this.getAllConvSync());
                            }
                            this.fetchAllHolder ||
                              (this.fetchAllHolder = this.DBConvInfo.getAll()),
                              this.fetchAllHolder.then(e).catch(t);
                          });
                        }
                        getAllConvIdsSync() {
                          return Array.from(this.data.keys());
                        }
                        setPreloadCache(e) {
                          this.preloadCached = e;
                        }
                        onDoneSyncMobile() {
                          Ct.default.logCoreInfo(
                            `[${this.name}] - onDoneSyncMobile`,
                          ),
                            this.getAllConv().then((e) => {
                              e &&
                                this.previewManager.migrate(
                                  e.map((e) => e.userId),
                                  !0,
                                );
                            });
                        }
                        setCacheData(e, t, s) {
                          void 0 === s && (s = !1),
                            this.data.set(t.userId, t),
                            s && Object(nt.g)(this.name, e);
                        }
                        updateFields(e, t) {
                          return new Promise((s, i) => {
                            const n = this.data.get(e),
                              a = (n) => {
                                Ct.default.logCoreInfo(
                                  `[${this.name}] - updateFields #2`,
                                );
                                const a = Object(f.a)({}, n);
                                t.forEach((e, t) => {
                                  a[t] = e;
                                }),
                                  this.setCacheData(e, a, !0),
                                  this.updateInDB(a)
                                    .then(() => {
                                      s(a);
                                    })
                                    .catch(i);
                              };
                            n
                              ? a(n)
                              : this.DBConvInfo.getById(e).then((e) => {
                                  e && a(e);
                                });
                          });
                        }
                        forkDeleteCacheAndDB(e) {
                          if (
                            (Ct.default.logCoreInfo(
                              `[${this.name}] - forkDeleteCacheAndDB ${e}`,
                            ),
                            !Pt.a.PinDataManager.isPinned(e))
                          ) {
                            const t = this.data.get(e);
                            Ct.default.logCoreInfo(
                              `[${this.name}] - forkDeleteCacheAndDB ${e} ${!!t}`,
                            ),
                              this.data.delete(e),
                              Object(nt.e)(this.name, e),
                              this.deleteInDB(e).then((s) => {
                                this.broadcastEvent(Zt.b.DeleteConv, e, t);
                              });
                          }
                        }
                        broadcastEvent(e, t, s) {
                          void 0 === t && (t = ""),
                            this.dispatchEvent(new Zt.a(e, t, s));
                        }
                        shouldSignalUpdate(e, t) {
                          return (
                            Pt.a.PinDataManager.isPinned(e.userId) !==
                              Pt.a.PinDataManager.isPinned(t.userId) ||
                            e.label !== t.label ||
                            e.respondedByMe !== t.respondedByMe
                          );
                        }
                        cleanConversation(e) {
                          return (
                            Object.keys(e).forEach((t) => {
                              Gi.includes(t) || delete e[t];
                            }),
                            e
                          );
                        }
                        getEmptyConv(e) {
                          return {
                            userId: e,
                            isGroup: e.startsWith(R.GROUPID_PREFIX),
                            numMsg: 0,
                            respondedByMe: !1,
                            pinned: 0,
                            label: null,
                            outside: null,
                            infoCheckSearch: null,
                            topOut: null,
                          };
                        }
                        updateInDB(e) {
                          const t = this.cleanConversation(Object(f.a)({}, e));
                          return this.DBConvInfo.addOrUpdate(t).catch((e) => {
                            Ct.default.logCoreInfo(
                              `[${this.name}] - updateInDB got error ${e}`,
                            );
                          });
                        }
                        deleteInDB(e) {
                          return this.DBConvInfo.remove(e).catch((e) => {
                            Ct.default.logCoreInfo(
                              `[${this.name}] - deleteInDB got error ${e}`,
                            );
                          });
                        }
                      }),
                    ) || Fi),
                ) || Fi),
            ) || Fi),
        );
        var xi = s("NSWB"),
          zi = s("1Abx"),
          Vi = s("XEtq"),
          Hi = s("ZRfj"),
          $i = s("oH3T"),
          Wi = s("13iL"),
          Ki = s("mea/"),
          qi = s("MPLC"),
          Zi = s("WK05");
        var Ji,
          Qi = s("dwTj"),
          Yi = s("RVT8"),
          Xi = s("hkvp"),
          en = s("6tnf"),
          tn = s("sg3c"),
          sn = s("ofhN"),
          nn = s("D8f9"),
          an = s("PGx3");
        const rn = "9999999999999999",
          on = "zum_m",
          dn = "1.0.0",
          ln = !1,
          cn = "total",
          hn = (e) => ({
            convId: e,
            smsUnreadCount: 0,
            smsUnreadNotCount: 0,
            mentionUnreadCount: 0,
            strangerUnreadCount: 0,
            lastProcessMsgId: "",
            lastSeenReactId: "",
            unreadMark: void 0,
          }),
          un = { CALL_INIT: !1 },
          gn = 1,
          mn = 2;
        Object($t.b)(Yi.b)(
          (Ji =
            (function (e, t) {
              return i.ModuleContainer.inject(Xi.b)(e, void 0, 0);
            })(
              (Ji =
                Reflect.metadata(
                  "design:type",
                  Function,
                )(
                  (Ji =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === Zt.IReactiveDB ? Object : Zt.IReactiveDB,
                    ])(
                      (Ji = class extends te.b {
                        constructor(e) {
                          super(),
                            (this.DBConvUnread = e),
                            (this.name = void 0),
                            (this.key = void 0),
                            (this.didInit = void 0),
                            (this.doneLoadDB = void 0),
                            (this.data = void 0),
                            (this.pendingMessage = void 0),
                            (this.previewMsgs = void 0),
                            (this.pendingClearUnread = void 0),
                            (this.fetchAllHolder = void 0),
                            (this.total = void 0),
                            (this.loadState = un),
                            (this.isLoadDBStarted = void 0),
                            (this.updateTotalQueue = void 0),
                            (this._logger = void 0),
                            (this.setupQueue = () =>
                              Object(Ui.queue)(async (e) => {
                                this.doneLoadDB &&
                                  (await this.calculateComputeUnreadCount(e));
                              }, 1)),
                            (this._getDeletedMsgByTTLItem = (e, t) => {
                              if (t)
                                return t.find((t) =>
                                  e.msgId
                                    ? e.msgId === t.msgId
                                    : e.cliMsgId === t.cliMsgId,
                                );
                            }),
                            (this.name = Yi.a),
                            (this.key = "convId"),
                            (this.didInit = !1),
                            (this.doneLoadDB = !1),
                            (this.data = new Map()),
                            (this.isLoadDBStarted = !1),
                            (this.pendingMessage = new Map()),
                            (this.previewMsgs = []),
                            (this.pendingClearUnread = new Map()),
                            (this.fetchAllHolder = null),
                            (this.total = this.getEmptyTotal()),
                            (this.updateTotalQueue = this.setupQueue());
                        }
                        init() {
                          this.didInit ||
                            (this.logger.zsymb(
                              3,
                              16618,
                              3e4,
                              "call init unread",
                            ),
                            (this.didInit = !0),
                            this.addListener(),
                            this.onState("CALL_INIT"));
                        }
                        onState(e) {
                          this.loadState[e] = !0;
                          const t = Object.values(this.loadState).every(
                            (e) => !0 === e,
                          );
                          t &&
                            !this.isLoadDBStarted &&
                            (this.logger.zsymb(
                              3,
                              16618,
                              30001,
                              "done all state, ready to load db...",
                            ),
                            this.loadData());
                        }
                        get logger() {
                          return (
                            this._logger ||
                              (this._logger = i.ModuleContainer.resolve(
                                q.ZLoggerFactory,
                              ).createZLogger(hs.ZLoggerNametags.conversation, [
                                hs.ZLoggerNametags.unread,
                              ])),
                            this._logger
                          );
                        }
                        getEmptyTotal() {
                          return {
                            convId: "total",
                            smsUnreadCount: 0,
                            smsUnreadNotCount: 0,
                            mentionUnreadCount: 0,
                            strangerUnreadCount: 0,
                            lastProcessMsgId: "0",
                            lastSeenReactId: "0",
                            unreadMark: 0,
                            smsUnreadNomute: 0,
                          };
                        }
                        loadData() {
                          const e = E.default
                            .getInstance()
                            .getItemForCurrentUser(on);
                          if (e === dn)
                            (this.isLoadDBStarted = !0),
                              this.logger.zsymb(
                                3,
                                16618,
                                30002,
                                "start load unread {}",
                                e,
                              ),
                              this.fetchAllHolder ||
                                (this.fetchAllHolder =
                                  this.DBConvUnread.getAll()),
                              this.fetchAllHolder.then((e) => {
                                this.onLoadUnreadFromDBV2(mn, e),
                                  this.doDoneLoadDBTask();
                              });
                          else {
                            Pt.a.ConvInfoDataManager.isDoneLoadDB() &&
                              ((this.isLoadDBStarted = !0), this.migrateV2());
                          }
                        }
                        async migrateV2() {
                          const e = E.default.getInstance(),
                            t = e.getItemForCurrentUser(on) === dn;
                          if (
                            (this.logger.zsymb(
                              3,
                              16618,
                              30003,
                              "call migrate unread {}",
                              t,
                            ),
                            t)
                          )
                            return;
                          const s = Pt.a.ConvInfoDataManager.getAllConvSync(),
                            i = [];
                          s.forEach((e) => {
                            const t = e.smsUnreadCount || 0,
                              s = e.smsUnreadNotCount || 0,
                              n = e.mentionUnreadCount || 0,
                              a = e.unreadMark || null;
                            if (!(e && e.userId && (t || s || n || a))) return;
                            const r = {
                              convId: e.userId,
                              smsUnreadCount: t,
                              smsUnreadNotCount: s,
                              strangerUnreadCount: 0,
                              mentionUnreadCount: n,
                              lastProcessMsgId:
                                e.lastMessageIdFromServerv2 || "0",
                              lastSeenReactId: e.lastSeenReactId || "0",
                              unreadMark: a,
                            };
                            i.push(r);
                          }),
                            this.onLoadUnreadFromDBV2(gn, i),
                            this.doDoneLoadDBTask(),
                            this.logger.zsymb(
                              3,
                              16618,
                              30004,
                              "done migrate unread {}",
                              i.length,
                            ),
                            e.setItemForCurrentUser(on, dn);
                        }
                        doDoneLoadDBTask() {
                          const e = Array.from(this.data.values());
                          (this.doneLoadDB = !0),
                            this.broadcastEvent(Zt.b.DoneLoadDB, "total", e),
                            this.logger.zsymb(
                              3,
                              16618,
                              30005,
                              "done load unread {}",
                              e.length,
                            ),
                            Object(an.e)(e),
                            setTimeout(() => {
                              this.unreadChanged("init");
                            }, 200);
                        }
                        addListener() {
                          Pt.a.MuteDataManager.addEventListener(
                            Zt.b.MuteChanged,
                            (e) => {
                              this.onMuteConversation(e.convId, !!e.payload);
                            },
                          ),
                            Pt.a.ConvInfoDataManager.addEventListener(
                              Zt.b.LeaveGroup,
                              (e) => {
                                this.doDeleteUnread(e.convId);
                              },
                            ),
                            Pt.a.ConvInfoDataManager.addEventListener(
                              Zt.b.DeleteConv,
                              (e) => {
                                this.doDeleteUnread(e.convId);
                              },
                            ),
                            Pt.a.ConvInfoDataManager.addEventListener(
                              Zt.b.EmptyConv,
                              (e) => {
                                this.doDeleteUnread(e.convId);
                              },
                            ),
                            Pt.a.ConvInfoDataManager.addEventListener(
                              Zt.b.DoneLoadDB,
                              (e) => {
                                this.onState("CALL_INIT");
                              },
                            ),
                            Pt.a.ArchivedChatManager.addEventListener(
                              Zt.b.UpdateListArchivedChat,
                              (e) => {
                                this.onArchivedChat(e.convId);
                              },
                            ),
                            Mt.default.subscribe((e, t) => {
                              if (
                                null != t &&
                                t.length &&
                                e ===
                                  St.ConversationListActions
                                    .CLEAR_MARK_AS_UNREAD
                              )
                                t.forEach((e) => {
                                  this.updateUnreadMark(e, null);
                                });
                              else if (
                                null != t &&
                                t.length &&
                                e === St.GeneralActions.UPDATE_HIDDEN_CHAT
                              )
                                for (let s = 0; s < t.length; s++) {
                                  const e = t[s];
                                  this.onHiddenConversation(e.uid, e.isHide);
                                }
                            });
                        }
                        getItem(e, t) {
                          if (e.key === cn) return this.total;
                          return this.data.get(e.key);
                        }
                        getList(e, t) {
                          return Array.from(this.data.keys());
                        }
                        onGetItemFailure(e) {}
                        onGetListFailure(e) {
                          throw new Error("Method not implemented.");
                        }
                        onMuteConversation(e, t) {
                          const s = this.data.get(e);
                          !s ||
                            (s.smsUnreadCount < 1 && !s.unreadMark) ||
                            Jt.a.isThreadHidden(e) ||
                            qt.a.isOAType({ userId: e }) ||
                            (this.logger.zsymb(
                              0,
                              16618,
                              30006,
                              "onMuteConversation:",
                              e,
                              t,
                              s.smsUnreadCount,
                              s.smsUnreadNotCount,
                            ),
                            this.unreadChanged(e));
                        }
                        onHiddenConversation(e, t) {
                          const s = this.data.get(e);
                          !s ||
                            (s.smsUnreadCount < 1 && !s.unreadMark) ||
                            Ee.default.isMuted(e) ||
                            qt.a.isOAType({ userId: e }) ||
                            (this.logger.zsymb(
                              0,
                              16618,
                              30007,
                              "onHiddenConversation: ",
                              e,
                              t,
                              s.smsUnreadCount,
                              s.smsUnreadNotCount,
                            ),
                            this.unreadChanged(e));
                        }
                        onArchivedChat(e) {
                          const t = this.data.get(e);
                          !t ||
                            (t.smsUnreadCount < 1 && !t.unreadMark) ||
                            Ee.default.isMuted(e) ||
                            qt.a.isOAType({ userId: e }) ||
                            this.unreadChanged(e);
                        }
                        onChangeConvLabel(e, t, s) {
                          const i = this.data.get(e);
                          t === s ||
                            !i ||
                            i.smsUnreadCount < 1 ||
                            Ee.default.isMuted(e) ||
                            this.unreadChanged(e);
                        }
                        onReceivePreviewMessages(e) {
                          e.length > 0 &&
                            (this.previewMsgs = [...this.previewMsgs, ...e]);
                        }
                        onReceiveNewMessagesOld(e, t, s) {
                          if (!s || !t) return;
                          const i = this.data.get(e);
                          if (i)
                            this.logger.zsymb(
                              0,
                              16618,
                              30008,
                              "receive msg",
                              e,
                              i.lastProcessMsgId,
                              s,
                            ),
                              (!i.lastProcessMsgId || i.lastProcessMsgId < t) &&
                                (this.handleNewMessages(e, s, t),
                                Object(nt.g)(this.name, e));
                          else {
                            const t = this.pendingMessage.get(e),
                              i = t ? s.concat(t) : s;
                            this.pendingMessage.set(e, i),
                              i.length === s.length &&
                                this.DBConvUnread.getById(e).then((t) => {
                                  if (!t) {
                                    const t = this.pendingMessage.get(e);
                                    if (t) {
                                      const s = t.filter(
                                          (e, t, s) => s.indexOf(e) === t,
                                        ),
                                        i = ls.b.getLastMessageInList(s);
                                      if (!i) return;
                                      this.pendingMessage.delete(e),
                                        this.handleNewMessages(e, s, i.msgId),
                                        Object(nt.g)(this.name, e);
                                    }
                                  }
                                });
                          }
                        }
                        onReceiveNewMessages(e, t, s) {
                          if (!s || !s.length || !t) return;
                          const i = this.data.get(e);
                          if (this.doneLoadDB) {
                            if (
                              !i ||
                              !i.lastProcessMsgId ||
                              i.lastProcessMsgId < t
                            ) {
                              const n = s.map((e) => e.msgId).join("-");
                              this.logger.zsymb(
                                0,
                                16618,
                                30009,
                                `onReceiveNewMessages: ${null == i ? void 0 : i.lastProcessMsgId} ${e} ${t} ${n}`,
                              ),
                                this.handleNewMessages(e, s, t),
                                Object(nt.g)(this.name, e);
                            }
                          } else {
                            const t = this.pendingMessage.get(e),
                              i = t ? s.concat(t) : s;
                            this.pendingMessage.set(e, i);
                          }
                        }
                        onDoneOffLineMessages() {
                          this.logger.zsymb(
                            0,
                            16618,
                            30010,
                            "ph7 done offline",
                          ),
                            js.b.onDoneEntry(js.a.FIRST_FETCH),
                            this.previewMsgs.length > 0 &&
                              setTimeout(() => {
                                this.handlePreviewMsgs();
                              }, 0);
                        }
                        doDeleteUnread(e) {
                          if (!e) return;
                          Object(an.a)([e]);
                          const t = this.data.get(e);
                          this.logger.zsymb(
                            0,
                            16618,
                            30011,
                            `doDeleteUnread ${!!t}`,
                          ),
                            this.data.delete(e) &&
                              (Object(nt.e)(this.name, e),
                              this.unreadChanged(e)),
                            this.deleteInDB(e);
                        }
                        onReceiveDeleteConvMsg(e, t) {
                          if (this.doneLoadDB) {
                            const s = this.safeGetUnreadCached(e);
                            if (0 === s.smsUnreadCount) return;
                            if (t >= +s.lastProcessMsgId) {
                              const t = Object(f.a)(
                                Object(f.a)({}, s),
                                {},
                                { smsUnreadCount: 0, smsUnreadNotCount: 0 },
                              );
                              this.data.set(t.convId, t),
                                Object(nt.g)(this.name, e),
                                this.unreadChanged(e);
                            }
                          } else this.pendingClearUnread.set(e, t);
                        }
                        onClearUnreadConversations(e) {
                          if (!e || e.length < 0) return;
                          let t = [];
                          for (let s = 0; s < e.length; s++) {
                            const i = e[s],
                              n = this.data.get(i.userId) || hn(i.userId);
                            this.logger.zsymb(
                              0,
                              16618,
                              30012,
                              "onClearUnreadConversations",
                              !!i,
                              null == n ? void 0 : n.smsUnreadCount,
                            ),
                              i &&
                                (t.push(i.userId),
                                n.smsUnreadCount > 0 &&
                                  Ee.default
                                    .getLastMessageFrom(
                                      i.userId,
                                      i.lastSmsLocalId,
                                      rn,
                                      n.smsUnreadCount,
                                      !0,
                                    )
                                    .then((e) => {
                                      let t = {};
                                      if (e && e.length > 0)
                                        for (let i = 0; i < e.length; i++) {
                                          let s = e[i];
                                          Ct.default.validMessageFromOther(s) &&
                                            (t[s.msgId] = s);
                                        }
                                      const s = {
                                        userId: i.userId,
                                        lastSmsLocalId: i.lastSmsLocalId,
                                        smsUnreadCount: n.smsUnreadCount,
                                      };
                                      this.clearUnreadConversation(s, t),
                                        this.resetUnreadToZero(
                                          i.userId,
                                          n.lastProcessMsgId,
                                        );
                                    })
                                    .catch((e) => {
                                      this.logger.zsymb(
                                        21,
                                        16618,
                                        30013,
                                        "clear unread conv failure {}",
                                        e,
                                      );
                                    }),
                                Zi.a.clearUnreadIfExist({
                                  userId: i.userId,
                                  lastSeenReactId: n.lastSeenReactId,
                                }));
                          }
                          Object(an.a)(t, e.length > 0);
                        }
                        onReadConversation(e, t) {
                          var s;
                          if (bt.default.mark_unread.enable && !Object(an.c)(e))
                            return (
                              this.logger.zsymb(
                                0,
                                16618,
                                30014,
                                `[read-message] dont clear ${e}`,
                                bt.default.mark_unread.enable,
                                Object(an.c)(e),
                              ),
                              !1
                            );
                          Object(an.b)(e) &&
                            (e.startsWith(R.GROUPID_PREFIX)
                              ? Xe.e.logAction(2160024)
                              : Xe.e.logAction(2160023),
                            Xe.e.logAction(2160022));
                          const i = this.data.get(e) || hn(e),
                            n = i.smsUnreadCount;
                          if (!t && !n) {
                            this.logger.zsymb(
                              0,
                              16618,
                              30015,
                              `[read-message] dont clear ${e} unread `,
                              n,
                              t,
                            );
                            const s = Zi.a.sendClearUnread(
                              e,
                              i.lastSeenReactId,
                            );
                            return (
                              Object(an.a)([e], !1),
                              s != i.lastSeenReactId &&
                                ((i.lastSeenReactId = s),
                                this.data.set(e, Object(f.a)({}, i)),
                                Object(nt.g)(this.name, e),
                                this.updateInDB(i)),
                              !1
                            );
                          }
                          const a =
                            this.acquireConvManager().getConvByIdSync(e);
                          if (!a)
                            return (
                              this.logger.zsymb(
                                0,
                                16618,
                                30016,
                                `[read-message] convinfo not exists ${e}`,
                              ),
                              !1
                            );
                          const r = [],
                            o = {},
                            d = a.lastSmsLocalId
                              ? a.lastSmsLocalId.toString().split("_")[0]
                              : "";
                          let l = !1;
                          const c =
                            null === (s = qi.b.messageCache) || void 0 === s
                              ? void 0
                              : s.getLast({ userId: e }, n);
                          for (let g = c.length - 1; g > -1; g--) {
                            let e = c[g];
                            if (
                              Ct.default.validMessageFromOther(e) &&
                              e.zglobalMsgId &&
                              -1 != e.zglobalMsgId &&
                              !r.includes(e.zglobalMsgId) &&
                              (r.push(e.zglobalMsgId),
                              (o[e.zglobalMsgId] = e),
                              e.zglobalMsgId == d && (l = !0),
                              r.length == n)
                            )
                              break;
                          }
                          const h = {
                            userId: e,
                            lastSmsLocalId: a.lastSmsLocalId,
                            smsUnreadCount: n,
                          };
                          var u;
                          !d || l || o[d]
                            ? this.clearUnreadConversation(h, o)
                            : (this.logger.zsymb(
                                0,
                                16618,
                                30017,
                                `[read-message] append lastMsgIdInConv ${d} ${Object.keys(o).length}`,
                              ),
                              null === (u = qi.b.messageCache) ||
                                void 0 === u ||
                                u
                                  .getMessageByMsgIdAsync(d)
                                  .then((e) => {
                                    (o[d] = Object(f.a)({}, e)),
                                      this.clearUnreadConversation(h, o);
                                  })
                                  .catch((e) => {
                                    this.clearUnreadConversation(h, o);
                                  }));
                          return (
                            Object(an.a)([e], !1),
                            (i.lastSeenReactId = Zi.a.sendClearUnread(
                              e,
                              i.lastSeenReactId,
                            )),
                            this.resetUnreadToZero(e, i.lastProcessMsgId),
                            !0
                          );
                        }
                        getUnreadByConvIdSync(e) {
                          return this.data.get(e);
                        }
                        getUnreadByConvId(e) {
                          return new Promise((t, s) => {
                            if (this.data.has(e))
                              return t(this.getUnreadByConvIdSync(e));
                            this.DBConvUnread.getById(e)
                              .then((e) => t(e))
                              .catch(s);
                          });
                        }
                        getAllUnreadsSync() {
                          return Array.from(this.data.values());
                        }
                        getAllUnreads() {
                          return new Promise((e, t) => {
                            if (this.doneLoadDB)
                              return e(this.getAllUnreadsSync());
                            this.fetchAllHolder ||
                              (this.fetchAllHolder =
                                this.DBConvUnread.getAll()),
                              this.fetchAllHolder.then((t) => e(t)).catch(t);
                          });
                        }
                        resetUnreadToZero(e, t) {
                          return this.getUnreadByConvId(e).then((s) => {
                            if (
                              ($i.b.onClearUnreadConv(e),
                              !s || (!s.smsUnreadCount && !s.smsUnreadNotCount))
                            )
                              return !1;
                            if (
                              (this.logger.zsymb(
                                3,
                                16618,
                                30018,
                                "resetUnreadToZero {} {} {}",
                                e,
                                t,
                                s.smsUnreadCount,
                              ),
                              !qt.b.assertString(t, this.logger))
                            )
                              return !1;
                            const i = {
                              convId: e,
                              smsUnreadCount: 0,
                              mentionUnreadCount: 0,
                              strangerUnreadCount: 0,
                              smsUnreadNotCount: 0,
                              lastProcessMsgId: t,
                              lastSeenReactId: s.lastSeenReactId || "",
                              unreadMark: s.unreadMark,
                            };
                            return (
                              s.smsUnreadCount > 0 &&
                                Hi.a.notiMainClearunread(e),
                              this.forkUpdateCacheAndDB(i)
                                .then(
                                  (t) => (
                                    this.broadcastEvent(Zt.b.ReadConv, e), !0
                                  ),
                                )
                                .catch(
                                  (t) => (
                                    this.logger.zsymb(
                                      21,
                                      16618,
                                      30019,
                                      "resetUnreadToZero failure {} {}",
                                      e,
                                      t,
                                    ),
                                    !1
                                  ),
                                )
                            );
                          });
                        }
                        isUnreadMessage(e) {
                          const {
                              message: t,
                              convId: s,
                              lastProcessMsgId: i,
                            } = e,
                            n = ls.b.isMyMessage(t),
                            a = zi.b.isRead({
                              userId: s,
                              msgId: t.msgId,
                              msgSendDttm: t.ts || t.serverTime || t.sendDttm,
                              msgLocalId: void 0,
                              e2eeStatus: Object(tn.f)(t),
                            }),
                            r = !t.msgId || !i || t.msgId <= i;
                          return !a && r && !n;
                        }
                        _updateTTLUnreadCount(e, t, s) {
                          const i = this.data.get(e) || null;
                          if (
                            (this.logger.zsymb(
                              0,
                              16618,
                              30020,
                              "_updateTTLUnreadCount",
                              e,
                              null == i ? void 0 : i.smsUnreadCount,
                            ),
                            i &&
                              i.smsUnreadCount === t &&
                              i.smsUnreadNotCount === s)
                          )
                            return;
                          let n = this.safeGetUnreadCached(e);
                          (n.smsUnreadCount = t),
                            (n.smsUnreadNotCount = s),
                            this.forkUpdateCacheAndDB(n);
                        }
                        updateUnreadTTLConversation(e, t, s) {
                          const i = this.getUnreadByConvIdSync(e);
                          if (i) {
                            let n = i.smsUnreadCount,
                              a = i.smsUnreadNotCount;
                            t
                              .filter(
                                (t) =>
                                  t.ttlType === nn.a.Message &&
                                  this.isUnreadMessage({
                                    message: this._getDeletedMsgByTTLItem(t, s),
                                    convId: e,
                                    lastProcessMsgId: i.lastProcessMsgId,
                                  }),
                              )
                              .forEach((e) => {
                                const t = this._getDeletedMsgByTTLItem(e, s),
                                  i = Ct.default.getDataReminder(t),
                                  r = ls.b.isMyMessage(t);
                                i &&
                                r &&
                                (t.idTo === bt.default.sendToMeId || r)
                                  ? ((a -= 1), (n -= 1))
                                  : (n -= 1);
                              }),
                              this._updateTTLUnreadCount(
                                e,
                                Math.max(n, 0),
                                Math.max(a, 0),
                              );
                          }
                        }
                        updateUnreadCount(e, t) {
                          const s = this.data.get(e) || null;
                          if (
                            (this.logger.zsymb(
                              0,
                              16618,
                              30021,
                              "updateUnreadCount",
                              e,
                              null == s ? void 0 : s.smsUnreadCount,
                            ),
                            s && s.smsUnreadCount === t)
                          )
                            return;
                          let i = this.safeGetUnreadCached(e);
                          (i.smsUnreadCount = t), this.forkUpdateCacheAndDB(i);
                        }
                        updateMentionCount(e, t) {
                          this.logger.zsymb(
                            0,
                            16618,
                            30022,
                            "updateMentionCount",
                            e,
                            t,
                          );
                          let s = this.safeGetUnreadCached(e);
                          (s.mentionUnreadCount = t),
                            this.forkUpdateCacheAndDB(s, !1),
                            en.a.updateUnreadMentions(
                              this.getTotalMentionCount(),
                            );
                        }
                        updateLastSeenReactId(e, t) {
                          let s = this.safeGetUnreadCached(e);
                          (s.lastSeenReactId = t),
                            this.forkUpdateCacheAndDB(s, !1);
                        }
                        updateUnreadMark(e, t) {
                          let s = this.safeGetUnreadCached(e);
                          s.unreadMark || (s.unreadMark = null),
                            t || (t = null),
                            t !== s.unreadMark &&
                              ((this.total.unreadMark += t ? 1 : -1),
                              Object(nt.g)(this.name, cn),
                              (s.unreadMark = t),
                              this.forkUpdateCacheAndDB(s));
                        }
                        shouldClearUnread(e, t) {
                          const s = this.data.get(e),
                            i = null == s ? void 0 : s.smsUnreadCount,
                            n = null == s ? void 0 : s.lastProcessMsgId;
                          return !!i && !!(n && t && +t >= +n);
                        }
                        async forkUpdateCacheAndDB(e, t) {
                          void 0 === t && (t = !0),
                            this.data.set(e.convId, e),
                            Object(nt.g)(this.name, e.convId),
                            t &&
                              this.isValidConvKey(e.convId) &&
                              this.unreadChanged(e.convId),
                            await this.updateInDB(e);
                        }
                        safeGetUnreadCached(e) {
                          const t = this.data.get(e);
                          let s;
                          return (
                            (s = t
                              ? Object(f.a)({}, t)
                              : {
                                  convId: e,
                                  smsUnreadCount: 0,
                                  smsUnreadNotCount: 0,
                                  mentionUnreadCount: 0,
                                  strangerUnreadCount: 0,
                                  lastProcessMsgId: "0",
                                  lastSeenReactId: "0",
                                  unreadMark: null,
                                }),
                            s
                          );
                        }
                        getTotalMentionCount() {
                          let e = 0;
                          return (
                            this.data.forEach((t) => {
                              e += t.mentionUnreadCount;
                            }),
                            e
                          );
                        }
                        isValidConvKey(e) {
                          return (
                            !(!e || e.length < 3) &&
                            "null" != e &&
                            e !== R.CONV_FILTER.STRANGER &&
                            e !== cn
                          );
                        }
                        unreadChanged(e) {
                          "null" != e &&
                            (this.updateTotalQueue.remove((e) => !0),
                            this.updateTotalQueue.push(e));
                        }
                        async calculateComputeUnreadCount(e) {
                          try {
                            var t;
                            const n = this.getEmptyTotal(),
                              a =
                                (null ===
                                  (t = this.data.get(R.CONV_FILTER.STRANGER)) ||
                                void 0 === t
                                  ? void 0
                                  : t.smsUnreadCount) || 0;
                            let r = 0,
                              o = 0;
                            const d = new Map(),
                              l = new Map(),
                              c = new Map();
                            Pt.a.LabelDataManager.getAllLabelIds().map((e) => {
                              const t = "" + e;
                              c.set(t, t);
                            });
                            const h = new Map(),
                              u = [];
                            for (let e of Array.from(this.data.keys())) {
                              if (!this.isValidConvKey(e)) continue;
                              const t = this.data.get(e);
                              if (!t || Jt.a.isThreadHidden(e)) continue;
                              const s =
                                Boolean(t.smsUnreadCount) ||
                                Boolean(t.smsUnreadNotCount) ||
                                Boolean(t.unreadMark);
                              if (s)
                                if (
                                  s &&
                                  cs.a.isArchivedChat(e) &&
                                  !Ee.default.isMuted(e)
                                ) {
                                  let t = i.ModuleContainer.resolve(
                                    zt.i,
                                  ).getPreviewByIDSync(e);
                                  t &&
                                    o < parseInt(t.messageTime) &&
                                    (o = parseInt(t.messageTime) || 0);
                                } else h.set(e, t), u.push(e);
                            }
                            ln;
                            if (
                              ((await qt.a.verifyOATypeAsync(u)).forEach(
                                (e) => {
                                  let { cid: t, isOA: s } = e;
                                  const i = h.get(t),
                                    a = i.convId,
                                    o =
                                      this.acquireConvManager().getConvByIdSync(
                                        a,
                                      ),
                                    c = Ee.default.isMuted(a);
                                  const u = i.smsUnreadCount || 0,
                                    g = i.smsUnreadNotCount || 0;
                                  if (
                                    ((n.smsUnreadCount += u),
                                    o &&
                                      !c &&
                                      !s &&
                                      o.userId !==
                                        R.FAKE_CONVERSATION_ID.FRIEND_CENTER)
                                  ) {
                                    const e = Math.max(u - g, 0);
                                    n.smsUnreadNomute += e;
                                    const t = o.label ? "" + o.label : "",
                                      s = "0" == t || !!t;
                                    if (
                                      (s &&
                                        (d.has(t)
                                          ? d.set(t, d.get(t) + e)
                                          : d.set(t, e)),
                                      i.unreadMark)
                                    ) {
                                      const e = n.unreadMark || 0;
                                      (n.unreadMark = e + 1),
                                        s &&
                                          (l.has(t)
                                            ? l.set(t, l.get(t) + 1)
                                            : l.set(t, 1));
                                    }
                                    e > 0 &&
                                      this.isInStrangerBox(a) &&
                                      (r += e);
                                  }
                                },
                              ),
                              this.total.smsUnreadCount !== n.smsUnreadCount ||
                                this.total.smsUnreadNomute !==
                                  n.smsUnreadNomute ||
                                this.total.unreadMark !== n.unreadMark)
                            ) {
                              var s;
                              const t =
                                  null === (s = this.data.get(e)) ||
                                  void 0 === s
                                    ? void 0
                                    : s.smsUnreadCount,
                                i = Ee.default.isMuted(e);
                              (this.total = n),
                                this.dispatchEvent(
                                  new Zt.a(Zt.b.ChangeUnreadCount, cn, {
                                    unreadNoMute: n.smsUnreadNomute,
                                    totalUnread: n.smsUnreadCount,
                                    convId: e,
                                    currentUnread: t,
                                    curentUnreadNoMute: i ? 0 : t,
                                  }),
                                ),
                                this.data.set(cn, n),
                                Object(nt.g)(this.name, cn);
                            }
                            const g = i.ModuleContainer.resolve(
                                Os.b,
                              ).isShowUnreadArchivedChat(),
                              m =
                                E.default
                                  .getInstance()
                                  .getItemForCurrentUser(
                                    "last_time_clear_archive_chat",
                                  ) || "0",
                              p = o > parseInt(m);
                            if (
                              (p !== g &&
                                this.dispatchEvent(
                                  new Zt.a(Zt.b.ChangeUnreadArchiveChat, cn, {
                                    hasUnreadArchivedChat: p,
                                  }),
                                ),
                              a !== r)
                            ) {
                              const e = this.safeGetUnreadCached("");
                              (e.smsUnreadCount = r),
                                (e.convId = R.CONV_FILTER.STRANGER),
                                this.data.set(R.CONV_FILTER.STRANGER, e),
                                Object(nt.g)(this.name, R.CONV_FILTER.STRANGER);
                            }
                            for (let e of Array.from(d.keys())) {
                              const t = this.safeGetUnreadCached("");
                              (t.smsUnreadCount = d.get(e)),
                                (t.unreadMark = l.get(e)),
                                this.data.set(e, t),
                                c.delete(e),
                                Object(nt.g)(this.name, e);
                            }
                            for (let e of Array.from(c.keys()))
                              this.data.delete(e) && Object(nt.g)(this.name, e);
                          } catch (n) {
                            this.logger.zsymb(
                              21,
                              16618,
                              30027,
                              " unread err - contact phucnh7 please!!! {}",
                              n,
                            );
                          }
                        }
                        acquireConvManager() {
                          return Pt.a.ConvInfoDataManager;
                        }
                        onLoadUnreadFromDBV2(e, t) {
                          if (
                            (this.logger.zsymb(
                              0,
                              16618,
                              30029,
                              "onLoadUnreadFromDB",
                              t.length,
                            ),
                            t.length < 1)
                          )
                            return;
                          const s = new Date().getTime().toString();
                          Object(nt.j)(s);
                          for (let i = 0; i < t.length; i++) {
                            const n = t[i];
                            if (
                              ("object" == typeof n.lastProcessMsgId ||
                              ("string" == typeof n.lastProcessMsgId &&
                                n.lastProcessMsgId.includes("object"))
                                ? ((n.lastProcessMsgId = "0"),
                                  this.logger.zsymb(
                                    18,
                                    16618,
                                    30030,
                                    "Corrected lastProcessMsgId!",
                                  ),
                                  B.default.increaseFailed(
                                    151101,
                                    0,
                                    0,
                                    0,
                                    Date.now(),
                                  ))
                                : zi.b.isRead({
                                    userId: n.convId,
                                    msgId: +n.lastProcessMsgId,
                                    e2eeStatus: void 0,
                                    msgSendDttm: void 0,
                                    msgLocalId: void 0,
                                  }) &&
                                  (n.smsUnreadCount || n.smsUnreadNotCount) &&
                                  (this.logger.zsymb(
                                    0,
                                    16618,
                                    30031,
                                    "clear offline",
                                    n.convId,
                                    n.smsUnreadCount,
                                  ),
                                  (n.smsUnreadCount = 0),
                                  (n.strangerUnreadCount = 0),
                                  (n.smsUnreadNotCount = 0)),
                              this.pendingClearUnread.has(n.convId))
                            ) {
                              const e = this.pendingClearUnread.get(n.convId);
                              e &&
                                e >= +n.lastProcessMsgId &&
                                (this.logger.zsymb(
                                  0,
                                  16618,
                                  30032,
                                  "clear pending",
                                  this.pendingClearUnread.size,
                                  n.convId,
                                ),
                                (n.smsUnreadCount = 0),
                                (n.strangerUnreadCount = 0),
                                (n.smsUnreadNotCount = 0));
                            }
                            "null" === n.lastProcessMsgId &&
                              (n.lastProcessMsgId = ""),
                              this.data.set(n.convId, n),
                              Object(nt.f)(s, this.name, n.convId),
                              e === gn && this.updateInDB(n),
                              n.unreadMark && this.total.unreadMark++;
                          }
                          this.pendingClearUnread.clear(),
                            this.processPendingMessages(),
                            Object(nt.c)(s);
                        }
                        processPendingMessages() {
                          this.logger.zsymb(
                            0,
                            16618,
                            30033,
                            "start processPendingMessages",
                            this.pendingMessage.size,
                          ),
                            this.pendingMessage.forEach((e, t) => {
                              const s = new Map(),
                                i = this.data.get(t);
                              e.forEach((e) => {
                                var t;
                                (!i || i.lastProcessMsgId < e.msgId) &&
                                  s.set(
                                    `${(t = e).uidFrom || t.fromUid}_${t.idTo || t.toUid}_${t.cliMsgId}`,
                                    e,
                                  );
                              }),
                                this.logger.zsymb(
                                  0,
                                  16618,
                                  30034,
                                  "check processPendingMessages #2",
                                  t,
                                  null == i ? void 0 : i.smsUnreadCount,
                                  e.map((e) => e.msgId),
                                  s.keys(),
                                );
                              const n = Array.from(s.values()),
                                a = ls.b.getLastMessageInList(n);
                              this.handleNewMessages(
                                t,
                                n,
                                null == a ? void 0 : a.msgId,
                              );
                            }),
                            this.pendingMessage.clear();
                        }
                        handleNewMessages(e, t, s) {
                          if (!t || !t.length) return;
                          if (!qt.b.assertString(s, this.logger)) return;
                          let i = !1;
                          const n = {
                              convId: e,
                              strangerUnreadCount: 0,
                              smsUnreadCount: 0,
                              smsUnreadNotCount: 0,
                              mentionUnreadCount: 0,
                              lastProcessMsgId: s,
                              lastSeenReactId: "0",
                            },
                            a = Date.now(),
                            r = new Set();
                          if (
                            (t.forEach((t) => {
                              const o = ls.b.isMyMessage(t);
                              if (t.status !== R.MSG_READ && !o) {
                                const s = t.ts || t.serverTime || t.sendDttm;
                                zi.b.isRead({
                                  userId: e,
                                  msgId: t.msgId,
                                  msgSendDttm: s,
                                  msgLocalId: void 0,
                                  e2eeStatus: Object(tn.f)(t),
                                }) &&
                                  (bt.default.stagingAccount &&
                                    this.logger.zsymb(
                                      0,
                                      16618,
                                      30035,
                                      `mark msg status as read ${e} ${t.msgId}`,
                                    ),
                                  (t.status = R.MSG_READ));
                              }
                              let d = Vi.a.get(t.msgId, t.status);
                              d != t.status &&
                                bt.default.stagingAccount &&
                                this.logger.zsymb(
                                  0,
                                  16618,
                                  30036,
                                  `change msg status ${t.status} => ${d}`,
                                ),
                                (t.status = d);
                              let l = !1;
                              if ("chat.todo" === t.msgType) {
                                let e = t.content;
                                if (e) {
                                  "todo.remind" === e.action && (l = !0);
                                }
                              }
                              let c = Ct.default.getDataReminder(t);
                              var h, u;
                              (t.status !== R.MSG_READ && !o) || !0 === l
                                ? (t.paramsExt &&
                                    Ct.default.valueValid(
                                      t.paramsExt.countUnread,
                                    ) &&
                                    0 == t.paramsExt.countUnread &&
                                    (n.smsUnreadNotCount += 1),
                                  this.isCallTimeMessage(t) ||
                                    ((n.smsUnreadCount += 1),
                                    (n.strangerUnreadCount += 1)),
                                  xi.b.isMessageMentionMe(t) &&
                                    n.mentionUnreadCount++)
                                : c &&
                                    o &&
                                    (t.idTo === bt.default.sendToMeId || o)
                                  ? ((n.smsUnreadCount += 1),
                                    (n.smsUnreadNotCount += 1),
                                    this.logger.zsymb(
                                      0,
                                      16618,
                                      30037,
                                      `new unread #2: ${a} ${e} ${t.msgId} ${t.idTo} ${t.toUid} ${t.src} ${s}`,
                                    ))
                                  : !(h = t) ||
                                      ("0" == h.uidFrom &&
                                        (null === (u = h.paramsExt) ||
                                        void 0 === u
                                          ? void 0
                                          : u.platformType) ==
                                          Us.i.DeviceIds.SYSTEM)
                                    ? (r.add(t.msgId),
                                      this.logger.zsymb(
                                        0,
                                        16618,
                                        30038,
                                        "_addMessages: skipped clear unread for",
                                        t.idTo,
                                      ))
                                    : t.isCallMessage ||
                                      ((n.smsUnreadCount = 0),
                                      (n.strangerUnreadCount = 0),
                                      (n.mentionUnreadCount = 0),
                                      (i = !0)),
                                n.smsUnreadCount > 0 &&
                                  js.b.markGotUnread(e, t.msgId),
                                js.b.isLastMsgV2(t) &&
                                  this.onDoneOffLineMessages();
                            }),
                            r.has(s))
                          )
                            for (let d = t.length - 1; d >= 0; d--) {
                              const s = t[d];
                              if (
                                Ct.default.validMessageFromServer(s) &&
                                !r.has(s.msgId)
                              ) {
                                if (
                                  (this.logger.zsymb(
                                    0,
                                    16618,
                                    30039,
                                    "update last process id",
                                    e,
                                    n.lastProcessMsgId,
                                    s.msgId,
                                  ),
                                  (n.lastProcessMsgId = s.msgId),
                                  !qt.b.assertString(s.msgId, this.logger))
                                )
                                  return;
                                break;
                              }
                              var o;
                              0 == d &&
                                (n.lastProcessMsgId =
                                  (null === (o = this.data.get(e)) ||
                                  void 0 === o
                                    ? void 0
                                    : o.lastProcessMsgId) || "0");
                            }
                          return Object(an.a)([e]), this.updateUnread(e, i, n);
                        }
                        handlePreviewMsgs() {
                          if (!this.previewMsgs.length) return;
                          const e = [...this.previewMsgs];
                          (this.previewMsgs = []),
                            this.logger.zsymb(
                              0,
                              16618,
                              30040,
                              "handle preview",
                              e.map((e) => e.msgId),
                            ),
                            e.forEach((e) => {
                              const t = e.toUid,
                                s = Qi.default.checkDuplicate(t, {
                                  uidFrom: e.fromUid,
                                  cliMsgId: e.cliMsgId,
                                });
                              s &&
                                s.src &&
                                s.msgId !== e.msgId &&
                                (this.logger.zsymb(
                                  0,
                                  16618,
                                  30041,
                                  "detect dup msg",
                                  e.msgId,
                                  s.msgId,
                                ),
                                (e.msgId = s.msgId)),
                                this.onReceiveNewMessages(t, e.msgId, [e]);
                            });
                        }
                        updateUnread(e, t, s) {
                          let i = this.data.get(e);
                          if (i) {
                            const e = i.lastSeenReactId || "0";
                            t
                              ? (i = s)
                              : ((i.smsUnreadNotCount += s.smsUnreadNotCount),
                                (i.smsUnreadCount += s.smsUnreadCount),
                                (i.strangerUnreadCount +=
                                  s.strangerUnreadCount),
                                (i.mentionUnreadCount += s.mentionUnreadCount),
                                (i.lastProcessMsgId = s.lastProcessMsgId)),
                              (i.lastSeenReactId = e);
                          } else {
                            if (((i = s), !i))
                              return void this.logger.zsymb(
                                18,
                                16618,
                                30042,
                                `updateUnread undefined item ${e}`,
                              );
                            i.lastSeenReactId = sn.a.getLastSeen(e) || "0";
                          }
                          this.data.set(e, Object.assign({}, i)),
                            this.updateInDB(i),
                            0 != s.mentionUnreadCount &&
                              en.a.updateUnreadMentions(
                                this.getTotalMentionCount(),
                              ),
                            this.unreadChanged(e);
                        }
                        isInStrangerBox(e) {
                          const t = Pt.a.ConvInfoDataManager.getConvByIdSync(e);
                          return Hi.a.isInStrangerBox(t);
                        }
                        isCallTimeMessage(e) {
                          if ("chat.recommended" === e.msgType && e.content) {
                            if (
                              e.content.action === R.CallMessageAction.CallTime
                            )
                              return !0;
                            if (
                              e.content.action === R.CallMessageAction.MissCall
                            ) {
                              let s = e.content.params;
                              if ("string" == typeof s)
                                try {
                                  s = JSON.parse(e.content.params);
                                } catch (t) {}
                              if (s && 3 === s.reason) return !0;
                            }
                          }
                          return !1;
                        }
                        clearUnreadConversation(e, t) {
                          if ((void 0 === t && (t = {}), e && e.smsUnreadCount))
                            try {
                              let s = !0,
                                i = Object.keys(t);
                              (i && 0 != i.length) ||
                                ((s = !1),
                                this.logger.zsymb(
                                  0,
                                  16618,
                                  30044,
                                  `[read-message] actually, no need send seen in that case 2: ${i.length}`,
                                )),
                                !s &&
                                  bt.default.chat_aggressive_send_seen &&
                                  (s = !0),
                                s
                                  ? i && 0 !== i.length
                                    ? this.sendClearUnreadToServer(t, e.userId)
                                    : Ee.default
                                        .getLastMessageFrom(
                                          e.userId,
                                          e.lastSmsLocalId,
                                          rn,
                                          e.smsUnreadCount,
                                          !0,
                                        )
                                        .then((t) => {
                                          let s = [],
                                            i = {};
                                          if (t && t.length)
                                            for (let e = 0; e < t.length; e++) {
                                              let n = t[e];
                                              Ct.default.validMessageFromOther(
                                                n,
                                              ) &&
                                                n.zglobalMsgId &&
                                                -1 != n.zglobalMsgId &&
                                                (s.push(n.zglobalMsgId),
                                                (i[n.zglobalMsgId] = n));
                                            }
                                          0 === s.length
                                            ? this.logger.zsymb(
                                                3,
                                                16618,
                                                30045,
                                                "- [read-message] get ids.length == 0 {}",
                                                e.userId,
                                              )
                                            : this.sendClearUnreadToServer(
                                                i,
                                                e.userId,
                                              );
                                        })
                                        .catch((e) => {
                                          this.logger.zsymb(
                                            21,
                                            16618,
                                            30046,
                                            " [read-message] get msgs err {}",
                                            e,
                                          );
                                        })
                                  : this.logger.zsymb(
                                      3,
                                      16618,
                                      30047,
                                      "[read-message] no send {}",
                                      e.userId,
                                    );
                            } catch (s) {
                              this.logger.zsymb(
                                21,
                                16618,
                                30048,
                                "[read-message] err {}",
                                s,
                              );
                            }
                          else
                            this.logger.zsymb(
                              0,
                              16618,
                              30043,
                              `[read-message] actually, no need send seen in that case 1: ${null == e ? void 0 : e.userId}`,
                            );
                        }
                        async sendClearUnreadToServer(e, t) {
                          void 0 === e && (e = {});
                          const s = Object.keys(e),
                            i = Hi.a.isGroup(t),
                            n = Ki.a.newReq();
                          try {
                            await Ot.default.sendSeen(e, t, i, n),
                              bt.default.stagingAccount &&
                                this.logger.zsymb(
                                  0,
                                  16618,
                                  30049,
                                  `[read-message] done ${t} msgId:\n\t\t\t\t\t${s && s.length ? s[s.length - 1] : 0}`,
                                );
                          } catch (a) {
                            if (
                              (this.logger.zsymb(
                                21,
                                16618,
                                30050,
                                "[read-message] err {}",
                                a,
                              ),
                              !(s && s.length > 0))
                            )
                              throw (
                                (this.logger.zsymb(
                                  21,
                                  16618,
                                  30052,
                                  "[read-message] send seen fail!!! convId:{} msgId len = 0",
                                  t,
                                ),
                                a)
                              );
                            if (
                              (this.logger.zsymb(
                                21,
                                16618,
                                30051,
                                "[read-message] send seen fail!! convId:{} msgId:{}",
                                t,
                                s[s.length - 1],
                              ),
                              a &&
                                (114 === a.error_code || -69 === a.error_code))
                            )
                              throw (
                                (this.logger.zsymb(
                                  21,
                                  16618,
                                  30053,
                                  "[read-message] send seen fail!!! no need retry {}",
                                  a.error_code,
                                ),
                                a)
                              );
                            throw (
                              (bt.default.retrySendSeen
                                ? (this.logger.zsymb(
                                    21,
                                    16618,
                                    30054,
                                    "[read-message] send seen fail!!! retry",
                                  ),
                                  Wi.b.retryAction(
                                    Wi.a.SEND_SEEN_V2,
                                    [e, t, i, n],
                                    {
                                      startedTime: Date.now(),
                                      duration:
                                        bt.default.retrySendSeen.timeout,
                                    },
                                  ))
                                : this.logger.zsymb(
                                    21,
                                    16618,
                                    30055,
                                    "[read-message] send seen fail!!! not retry",
                                  ),
                              a)
                            );
                          }
                        }
                        broadcastEvent(e, t, s) {
                          this.dispatchEvent(new Zt.a(e, t, s));
                        }
                        updateInDB(e) {
                          null == e.lastSeenReactId &&
                            ((e.lastSeenReactId =
                              sn.a.getLastSeen(e.convId) || "0"),
                            this.logger.zsymb(
                              18,
                              16618,
                              30056,
                              `update invalid lastSeen ${e.convId}`,
                            )),
                            qt.b.assertString(
                              e.lastProcessMsgId,
                              this.logger,
                            ) && this.DBConvUnread.addOrUpdate(e);
                        }
                        deleteInDB(e) {
                          this.DBConvUnread.remove(e);
                        }
                      }),
                    ) || Ji),
                ) || Ji),
            ) || Ji),
        );
        var pn = s("8Nax"),
          fn = s("GSHL"),
          vn = s("w5bt");
        let bn;
        var In, yn;
        ((In = bn || (bn = {})).modelToEntity = function (e) {
          if (!e)
            throw new Error(
              "[PreviewHelper] Convert undefined model to entity",
            );
          return {
            convId: e.convId,
            msgId: e.msgId,
            dName: e.dName,
            message: e.message,
            messageType: e.messageType,
            messageTime: e.messageTime,
            isGroup: e.isGroup,
            fromUid: e.fromUid,
            toUid: e.toUid,
            urgencyLevel: e.urgencyLevel,
            properties: e.properties ? { type: e.properties.type } : null,
            mentions: e.mentions ? e.mentions : null,
            ttl: e.ttl,
            cliMsgId: e.cliMsgId,
            status: e.status,
            substate: e.substate,
            computedMessage: e.computedMessage,
            computedIcon: e.computedIcon,
          };
        }),
          (In.entityToModel = function (e) {
            return e
              ? {
                  convId: e.convId,
                  msgId: e.msgId,
                  dName: e.dName,
                  message: e.message,
                  messageType: e.messageType,
                  messageTime: e.messageTime,
                  isGroup: e.isGroup,
                  fromUid: e.fromUid,
                  toUid: e.toUid,
                  urgencyLevel: e.urgencyLevel,
                  properties: e.properties,
                  mentions: e.mentions,
                  ttl: e.ttl,
                  cliMsgId: e.cliMsgId,
                  status: e.status,
                  substate: e.substate,
                  computedMessage: e.computedMessage,
                  computedIcon: e.computedIcon,
                  src: "db.preview",
                  verified: !1,
                }
              : null;
          });
        const _n = "zpm_m",
          On = "1.0.0";
        Object($t.b)(vn.b)(
          (yn =
            (function (e, t) {
              return i.ModuleContainer.inject(fn.b)(e, void 0, 0);
            })(
              (yn =
                Reflect.metadata(
                  "design:type",
                  Function,
                )(
                  (yn =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === Zt.IReactiveDB ? Object : Zt.IReactiveDB,
                    ])(
                      (yn = class extends te.b {
                        constructor(e) {
                          super(),
                            (this.DBConvPreview = e),
                            (this.name = void 0),
                            (this.key = void 0),
                            (this.didInit = void 0),
                            (this.data = void 0),
                            (this.list = void 0),
                            (this.deleteQueue = void 0),
                            (this.doneLoadDB = void 0),
                            (this.migrating = void 0),
                            (this._Logger = void 0),
                            (this.name = vn.a),
                            (this.key = "convId"),
                            (this.didInit = !1),
                            (this.data = new Map()),
                            (this.list = new Map()),
                            (this.deleteQueue = []),
                            (this.doneLoadDB = !1),
                            (this.migrating = !1);
                        }
                        init() {
                          return this.didInit
                            ? Promise.resolve()
                            : ((this.didInit = !0), this.loadData());
                        }
                        get Logger() {
                          return (
                            this._Logger ||
                              (this._Logger = i.ModuleContainer.resolve(
                                q.ZLoggerFactory,
                              ).createZLogger("conversation", [this.name])),
                            this._Logger
                          );
                        }
                        signalRenderItem(e, t) {
                          Object(nt.g)(e, t),
                            this.broadcastEvent(Zt.b.PreviewChanged, t, {
                              changedItem: this.data.get(t),
                              all: Array.from(this.data.values()),
                            });
                        }
                        loadData() {
                          return new Promise((e, t) => {
                            E.default
                              .getInstance()
                              .getItemForCurrentUser(_n) !== On ||
                            this.migrating
                              ? e()
                              : (this.Logger.zsymb(
                                  3,
                                  16619,
                                  3e4,
                                  "start load preview",
                                ),
                                this.DBConvPreview.getAll()
                                  .then((t) => {
                                    this.onLoadPreviewsFromDB(t)
                                      .then(e)
                                      .catch((t) => {
                                        this.Logger.zsymb(
                                          21,
                                          16619,
                                          30001,
                                          "load previews from db failure #1! {}",
                                          t,
                                        ),
                                          e();
                                      });
                                  })
                                  .catch((t) => {
                                    this.Logger.zsymb(
                                      21,
                                      16619,
                                      30002,
                                      "load preview from db failure #2! {}",
                                      t,
                                    ),
                                      e();
                                  }));
                          });
                        }
                        async revalidate(e) {
                          const t = !!this.getPreviewByIDSync(e),
                            s = await Ni.b
                              .getPreviewMessage(e)
                              .catch(
                                (s) => (
                                  this.Logger.zsymb(
                                    21,
                                    16619,
                                    30003,
                                    "revalidate failure #1 {} {} {}",
                                    e,
                                    t,
                                    s,
                                  ),
                                  { previewMsg: void 0 }
                                ),
                              );
                          return (
                            !!s.previewMsg &&
                            this.onReceiveNewMessage("db.message", s.previewMsg)
                              .then(
                                (s) => (
                                  this.Logger.zsymb(
                                    3,
                                    16619,
                                    30004,
                                    "revalidate success {} {} {}",
                                    e,
                                    t,
                                    s,
                                  ),
                                  !0
                                ),
                              )
                              .catch(
                                (s) => (
                                  this.Logger.zsymb(
                                    21,
                                    16619,
                                    30005,
                                    "revalidate failure #2 {} {} {}",
                                    e,
                                    t,
                                    s,
                                  ),
                                  !1
                                ),
                              )
                          );
                        }
                        migrate(e, t) {
                          return (
                            void 0 === t && (t = !1),
                            new Promise((s) => {
                              const i = E.default
                                .getInstance()
                                .getItemForCurrentUser(_n);
                              if (i === On && !t) return;
                              if (
                                (this.Logger.zsymb(
                                  3,
                                  16619,
                                  30006,
                                  "start migrate {} {}",
                                  i,
                                  t,
                                ),
                                (this.migrating = !0),
                                0 === e.length)
                              )
                                return this.doneMigratePreivew(0), s(0);
                              let n = 0,
                                a = 0;
                              const r = () => {
                                  if ((n++, n === e.length))
                                    return this.doneMigratePreivew(a), s(a);
                                },
                                o = () => {
                                  a++, r();
                                },
                                d = () => {
                                  for (let t = 0; t < e.length; t++)
                                    Ni.b
                                      .getPreviewMessage(e[t])
                                      .then((s) => {
                                        s && s.previewMsg
                                          ? this.onReceiveNewMessage(
                                              "db.message",
                                              s.previewMsg,
                                            )
                                              .then(o)
                                              .catch(r)
                                          : (this.Logger.zsymb(
                                              3,
                                              16619,
                                              30007,
                                              "migrate not exists msg {}",
                                              e[t],
                                            ),
                                            r());
                                      })
                                      .catch((s) => {
                                        r(),
                                          this.Logger.zsymb(
                                            21,
                                            16619,
                                            30008,
                                            "migrate failure for conv {} {}",
                                            e[t],
                                            s,
                                          );
                                      });
                                };
                              let l = e.filter(
                                (e) =>
                                  e !== R.FAKE_CONVERSATION_ID.FRIEND_CENTER &&
                                  e !== R.FAKE_CONVERSATION_ID.GROUP_CENTER &&
                                  !e.startsWith(R.GROUPID_PREFIX),
                              );
                              if (l.length > 0)
                                return Ye.default
                                  .getProfileFriendByIds(
                                    l,
                                    R.SRC_GET_PROFILE.FETCH_MINI_INFO,
                                  )
                                  .then(() => {
                                    d();
                                  })
                                  .catch(() => {
                                    d();
                                  });
                              d();
                            })
                          );
                        }
                        doneMigratePreivew(e) {
                          this.Logger.zsymb(
                            3,
                            16619,
                            30009,
                            "done migrate preview {}",
                            e,
                          );
                          E.default.getInstance().setItemForCurrentUser(_n, On),
                            this.broadcastEvent(Zt.b.DoneMigratePreview, "");
                        }
                        upgradeItemsVersion(e) {
                          void 0 === e && (e = []),
                            this.Logger.zsymb(
                              3,
                              16619,
                              30010,
                              "upgradeItemsVersion",
                            );
                          const t = new Date().getTime().toString();
                          Object(nt.j)(t),
                            0 !== e.length
                              ? e.forEach((e) => {
                                  Object(nt.f)(t, this.name, e);
                                })
                              : this.data.forEach((e) => {
                                  Object(nt.f)(t, this.name, e.convId);
                                }),
                            Object(nt.c)(t);
                        }
                        updateStrangerBox(e) {
                          const t = this.data.get(e);
                          t &&
                            (this.data.set(
                              R.CONV_FILTER.STRANGER,
                              Object(f.a)({}, t),
                            ),
                            Object(nt.g)(this.name, R.CONV_FILTER.STRANGER));
                        }
                        forceChangeItem(e) {
                          this.signalRenderItem(this.name, e);
                        }
                        getItem(e, t) {
                          const s = this.data.get(e.key);
                          return (
                            s ||
                              this.Logger.zsymb(
                                5,
                                16619,
                                30011,
                                "try to get item not exist in cache {}",
                                e.key,
                              ),
                            s
                          );
                        }
                        getList(e, t) {
                          return Array.from(this.data.keys());
                        }
                        onGetItemFailure(e) {
                          this.Logger.zsymb(
                            11,
                            16619,
                            30012,
                            "onGetItemFailure {}",
                            e,
                          );
                        }
                        onGetListFailure(e, t) {
                          this.Logger.zsymb(
                            11,
                            16619,
                            30013,
                            "onGetListFailure {} {}",
                            e,
                            t,
                          );
                        }
                        onLoadPreviewsFromDB(e) {
                          return new Promise((t, s) => {
                            if (
                              (this.Logger.zsymb(
                                3,
                                16619,
                                30014,
                                "onLoadPreviewsFromDB {}",
                                null == e ? void 0 : e.length,
                              ),
                              !e || 0 === e.length)
                            )
                              return this.doneLoadPreview(0), t();
                            let i = 0;
                            const n = () => {
                              i++,
                                i === e.length &&
                                  (this.doneLoadPreview(i), t());
                            };
                            for (let a = 0; a < e.length; a++) {
                              const t = bn.entityToModel(e[a]);
                              t &&
                                !pn.a.instance.filterExpiredPreview(t) &&
                                ((t.messageType = R.MSG_VANISH),
                                (t.message = ""),
                                this.updateInDB(t)),
                                this.addPreviewToManager(t)
                                  .then(() => {
                                    n();
                                  })
                                  .catch((e) => {
                                    n(),
                                      this.Logger.zsymb(
                                        21,
                                        16619,
                                        30015,
                                        "onload preview failure for item {} {}",
                                        null == t ? void 0 : t.convId,
                                        e,
                                      );
                                  });
                            }
                          });
                        }
                        doneLoadPreview(e) {
                          this.Logger.zsymb(
                            3,
                            16619,
                            30016,
                            "doneLoadPreview {}",
                            e,
                          ),
                            (this.doneLoadDB = !0),
                            this.broadcastEvent(
                              Zt.b.DoneLoadPreview,
                              "",
                              Array.from(this.data.values()),
                            ),
                            Object(nt.i)(this.name, "all");
                        }
                        onReceiveNewMessage(e, t) {
                          return new Promise((s, i) => {
                            if (!t) return s(!1);
                            const n = this.convertDBMessageToPreviewItem(e, t);
                            this.addPreviewToManager(n)
                              .then((e) =>
                                e
                                  ? (this.signalRenderItem(this.name, t.toUid),
                                    s(!0))
                                  : s(!1),
                              )
                              .catch(i);
                          });
                        }
                        onReceiveNewMessages(e, t) {
                          return new Promise((s) => {
                            if (!t) return s(!1);
                            const i = this.groupMessageByConvId(t),
                              n = [];
                            for (const e in i) {
                              if (!Object.prototype.hasOwnProperty.call(i, e))
                                continue;
                              const t = i[e];
                              for (let e = t.length - 1; e >= 0; e--) {
                                if (ls.b.isValidPreviewMessage(t[e])) {
                                  n.push(t[e]);
                                  break;
                                }
                                this.Logger.zsymb(
                                  3,
                                  16619,
                                  30017,
                                  "receive msg but not preview {}",
                                  t[e].msgId,
                                );
                              }
                            }
                            return n.length
                              ? Promise.all(
                                  n.map(async (t) =>
                                    this.onReceiveNewMessage(e, t),
                                  ),
                                )
                                  .then((e) => {
                                    const t = e.some((e) => 1 == e);
                                    s(t);
                                  })
                                  .catch((e) => {
                                    this.Logger.zsymb(
                                      21,
                                      16619,
                                      30018,
                                      "add messages to preview got error {}",
                                      e,
                                    ),
                                      s(!1);
                                  })
                              : s(!1);
                          });
                        }
                        onUndoMessage(e, t) {
                          if (!t) return;
                          this.Logger.zsymb(
                            3,
                            16619,
                            30019,
                            "onUndoMessage {}",
                            t.msgId,
                          );
                          const s = this.convertDBMessageToPreviewItem(e, t);
                          (s.messageType = R.MSG_UNDO),
                            (s.message = ""),
                            this.addPreviewToManager(s).then((e) => {
                              e && this.signalRenderItem(this.name, t.toUid);
                            });
                        }
                        onUpdateE2EEMessage(e, t) {
                          if (!t) return;
                          const s = t.toUid,
                            i = this.data.get(s);
                          if (
                            (this.Logger.zsymb(
                              3,
                              16619,
                              30020,
                              "onUpdateE2EEMessage {} {} {}",
                              s,
                              null == i ? void 0 : i.msgId,
                              t.msgId,
                            ),
                            i && (i.msgId !== t.msgId || !xi.b.isSameMsg(i, t)))
                          )
                            return;
                          const n = this.convertDBMessageToPreviewItem(e, t),
                            a =
                              Ct.default.normalizeMessageTypeFromSubState(
                                null == t ? void 0 : t.e2eeStatus,
                              ) || t.msgType;
                          (n.message =
                            n.message || ls.b.getPlainText({ msgType: a })),
                            (n.verified = !0),
                            (n.messageType = a),
                            this.data.set(t.toUid, n),
                            this.updateInDB(n),
                            this.signalRenderItem(this.name, t.toUid);
                        }
                        onDeleteMessage(e, t) {
                          return new Promise((e, s) => {
                            if (!t) return e(!1);
                            this.Logger.zsymb(
                              3,
                              16619,
                              30021,
                              "onDeleteMessage {}",
                              t.msgId,
                            );
                            const i = this.convertDBMessageToPreviewItem(
                              "db.message",
                              t,
                            );
                            this.deleteMessageInManager(i).then((s) => {
                              s
                                ? (this.Logger.zsymb(
                                    3,
                                    16619,
                                    30022,
                                    "onDeleteMessage success {}",
                                    t.msgId,
                                  ),
                                  this.signalRenderItem(this.name, t.toUid),
                                  e(!0))
                                : e(!1);
                            });
                          });
                        }
                        onDeleteMessages(e, t) {
                          if (!t || t.length < 1) return;
                          const s = this.groupMessageByConvId(t);
                          for (const i in s)
                            if (Object.prototype.hasOwnProperty.call(s, i)) {
                              const t = s[i];
                              let n = this.convertDBMessageToPreviewItem(
                                  e,
                                  t[0],
                                ),
                                a = 0;
                              for (let s = 1; s < t.length; s++) {
                                const i = this.convertDBMessageToPreviewItem(
                                  e,
                                  t[s],
                                );
                                this.isSecondItemNewer(n, i) &&
                                  ((a = s), (n = i));
                              }
                              this.onDeleteMessage(e, t[a]);
                            }
                        }
                        onDeleteConversation(e) {
                          e &&
                            (this.Logger.zsymb(
                              3,
                              16619,
                              30023,
                              "onDeleteConversation {}",
                              e,
                            ),
                            this.data.delete(e) && Object(nt.e)(this.name, e),
                            this.deleteInDB(e));
                        }
                        onChangeDraft(e, t) {
                          let s = this.getPreviewByIDSync(e);
                          return !e ||
                            !s ||
                            s.draft === t ||
                            (s.draft && t && s.draft.draftTime === t.draftTime)
                            ? (!s &&
                                t &&
                                (this.data.set(e, {
                                  convId: e,
                                  msgId: R.FAKE_DRAFT_MSG_ID,
                                  draft: t,
                                  messageTime: -1,
                                }),
                                this.signalRenderItem(this.name, e)),
                              void this.Logger.zsymb(
                                3,
                                16619,
                                30024,
                                "onChangeDraft - reject {}",
                                !!s,
                              ))
                            : (this.Logger.zsymb(
                                3,
                                16619,
                                30025,
                                "onChangeDraft - call update {}",
                                !!s,
                              ),
                              s.msgId !== R.FAKE_DRAFT_MSG_ID || t
                                ? ((s = Object(f.a)(
                                    Object(f.a)({}, s),
                                    {},
                                    { draft: t },
                                  )),
                                  this.data.set(e, s),
                                  this.signalRenderItem(this.name, e),
                                  void this.broadcastEvent(Zt.b.DraftChanged))
                                : (this.data.set(e, {
                                    convId: e,
                                    msgId: R.FAKE_DRAFT_MSG_ID,
                                    draft: void 0,
                                    messageTime: -1,
                                  }),
                                  this.signalRenderItem(this.name, e),
                                  void this.data.delete(e)));
                        }
                        getPreviewById(e) {
                          return new Promise((t, s) => {
                            if (this.data.has(e)) return t(this.data.get(e));
                            this.DBConvPreview.getById(e)
                              .then((s) => {
                                s ||
                                  this.Logger.zsymb(
                                    3,
                                    16619,
                                    30026,
                                    "get item not exist with id {}",
                                    e,
                                  );
                                const i = bn.entityToModel(s);
                                t(i || void 0);
                              })
                              .catch(s);
                          });
                        }
                        getPreviewByIDSync(e) {
                          return this.data.get(e);
                        }
                        getAllPreviews() {
                          return new Promise((e, t) => {
                            if (this.doneLoadDB)
                              return e(this.getAllPreviewsSync());
                            this.DBConvPreview.getAll()
                              .then((t) => {
                                const s = t.map((e) => bn.entityToModel(e));
                                e(s);
                              })
                              .catch(t);
                          });
                        }
                        getAllPreviewsSync() {
                          return Array.from(this.data.values()) || [];
                        }
                        setPreview(e, t, s, i, n, a, r) {
                          void 0 === a && (a = 1), void 0 === r && (r = {});
                          const o = this.data.get(e);
                          this.Logger.zsymb(
                            3,
                            16619,
                            30027,
                            "call set preview {} {}",
                            e,
                            !!o,
                          );
                          const d = {
                            convId: e,
                            msgId: r.msgId || "unset",
                            src: "ui",
                            dName: r.dName || "",
                            message: t,
                            messageType: "",
                            isGroup: e.startsWith(R.GROUPID_PREFIX),
                            messageTime: s,
                            fromUid: i,
                            toUid: n,
                            urgencyLevel: r.urgencyLevel,
                            properties: null,
                            verified: !0,
                            status: a,
                            computedMessage: t,
                            computedIcon: r.icon,
                          };
                          this.data.set(e, d),
                            this.signalRenderItem(this.name, e),
                            this.updateInDB(d);
                        }
                        async addPreviewToManager(e) {
                          if (!e) return !1;
                          const t = e.convId,
                            s = this.data.get(t);
                          let i = !1;
                          return (
                            s
                              ? this.isSecondItemNewer(s, e) &&
                                (this.data.set(t, e),
                                (i = !0),
                                s.verified
                                  ? ((e.verified = !0), this.updateInDB(e))
                                  : (i = await this.compareCacheWithDBAndUpdate(
                                      t,
                                      e,
                                    )))
                              : (this.data.set(t, e),
                                (i = !0),
                                "db.preview" !== e.src &&
                                  (i = await this.compareCacheWithDBAndUpdate(
                                    t,
                                    e,
                                  ))),
                            i
                          );
                        }
                        async deleteMessageInManager(e) {
                          if (!e) return !1;
                          const t = e.convId,
                            s = this.data.get(t);
                          if (
                            !s ||
                            (!xi.b.isSameMsg(e, s) &&
                              this.isSecondItemNewer(e, s))
                          )
                            return (
                              0 !== this.deleteQueue.length &&
                                this.deleteQueue.push(e),
                              !1
                            );
                          const i = async () => {
                            const e = await Ni.b.getPreviewMessage(t),
                              i = this.deleteQueue.find((t) => {
                                var s;
                                return (
                                  t.msgId ===
                                  (null === (s = e.previewMsg) || void 0 === s
                                    ? void 0
                                    : s.msgId)
                                );
                              });
                            if (i)
                              return (
                                this.data.set(t, i),
                                await this.deleteMessageInManager(i)
                              );
                            this.deleteQueue = [];
                            const n = this.data.get(t);
                            if (n && this.isSecondItemNewer(s, n)) return !1;
                            if (e.previewMsg) {
                              const s = this.convertDBMessageToPreviewItem(
                                "db.message",
                                e.previewMsg,
                              );
                              return (
                                (s.verified = !0),
                                this.data.set(t, s),
                                this.updateInDB(s),
                                !0
                              );
                            }
                            return (
                              this.data.delete(t),
                              this.deleteInDB(t),
                              Object(nt.e)(this.name, t),
                              !1
                            );
                          };
                          if (s.verified) return await i();
                          {
                            const s = await this.DBConvPreview.getById(t),
                              n = s && bn.entityToModel(s);
                            return n && this.isSecondItemNewer(e, n)
                              ? (this.data.set(t, n), !0)
                              : await i();
                          }
                        }
                        convertDBMessageToPreviewItem(e, t) {
                          let s = t.sendDttm || t.serverTime;
                          s = s ? s.toString() : "";
                          const i = t.fromUid || t.uidFrom,
                            n = t.toUid || t.idTo,
                            a = n && n.startsWith(R.GROUPID_PREFIX);
                          return {
                            convId: t.toUid,
                            msgId: t.msgId,
                            src: e,
                            dName: t.dName || "",
                            message: t.message,
                            messageType: t.msgType,
                            mentions: t.mentions,
                            isGroup: a,
                            messageTime: s,
                            fromUid: i,
                            properties: t.properties,
                            urgencyLevel: t.urgency,
                            verified: !1,
                            ttl: t.ttl,
                            status: t.status || 1,
                            substate: t.e2eeStatus,
                            cliMsgId: t.cliMsgId,
                            toUid: t.toUid,
                          };
                        }
                        isSecondItemNewer(e, t) {
                          return (
                            !e ||
                            ((t.msgId === e.msgId &&
                              t.messageTime === e.messageTime) ||
                            xi.b.isSameMsg(e, t)
                              ? (t.messageType === R.MSG_UNDO &&
                                  e.messageType !== R.MSG_UNDO) ||
                                qt.a.comparePreviewStt(t.status, e.status) > 0
                              : e.messageTime !== t.messageTime
                                ? t.messageTime > e.messageTime
                                : t.msgId > e.msgId)
                          );
                        }
                        compareCacheWithDBAndUpdate(e, t) {
                          return new Promise((s, i) => {
                            this.DBConvPreview.getById(e)
                              .then((i) => {
                                this.Logger.zsymb(
                                  3,
                                  16619,
                                  30028,
                                  "compareCacheWithDBAndUpdate {} {}",
                                  e,
                                  !!i,
                                );
                                const n = bn.entityToModel(i),
                                  a = this.data.get(e);
                                if (JSON.stringify(a) !== JSON.stringify(t))
                                  return s(!1);
                                (!n && a) ||
                                (n && a && this.isSecondItemNewer(n, a))
                                  ? ((a.verified = !0), this.updateInDB(a))
                                  : n && this.data.set(e, n),
                                  s(!0);
                              })
                              .catch(i);
                          });
                        }
                        groupMessageByConvId(e) {
                          const t = {};
                          for (let s = 0; s < e.length; s++)
                            t[e[s].toUid]
                              ? t[e[s].toUid].push(e[s])
                              : (t[e[s].toUid] = [e[s]]);
                          return t;
                        }
                        broadcastEvent(e, t, s) {
                          void 0 === t && (t = ""),
                            this.dispatchEvent(new Zt.a(e, t, s));
                        }
                        updateInDB(e) {
                          this.Logger.zsymb(
                            3,
                            16619,
                            30029,
                            "update in db {}",
                            e.msgId,
                          );
                          try {
                            const t = bn.modelToEntity(e);
                            this.DBConvPreview.addOrUpdate(t);
                          } catch (t) {
                            this.Logger.zsymb(
                              21,
                              16619,
                              30030,
                              "update in db got err{}",
                              t,
                            );
                          }
                        }
                        deleteInDB(e) {
                          this.DBConvPreview.remove(e).catch((e) => {
                            this.Logger.zsymb(
                              18,
                              16619,
                              30031,
                              `[${this.name}] - deleteInDB got error ${e}`,
                            );
                          });
                        }
                      }),
                    ) || yn),
                ) || yn),
            ) || yn),
        );
        var Cn = s("rKwX"),
          En = s("SWKE");
        class Mn {
          constructor() {
            (this.cache = void 0), (this.cache = {});
          }
          localKey(e) {
            return "z_ml_" + e;
          }
          muteConversation(e, t) {
            const s = E.default.getInstance(),
              i = "z_ml_" + e;
            t
              ? t.constructor === Object
                ? s.setItemForCurrentUser(this.localKey(e), JSON.stringify(t))
                : s.setItemForCurrentUser(this.localKey(e), `${t}`)
              : s.removeItemForCurrentUser(i),
              (this.cache[e] = t || !1);
          }
          isMuted(e) {
            if (this.cache.hasOwnProperty(e)) return this.cache[e];
            let t,
              s = E.default
                .getInstance()
                .getItemForCurrentUser(this.localKey(e));
            if (!s) return null;
            try {
              return (t = JSON.parse(s)), (this.cache[e] = t), t;
            } catch (i) {
              Ct.default.logCoreError(i);
            }
            return (this.cache[e] = !1), !1;
          }
          setMutedConversations(e) {
            let t = [];
            e.chatEntries &&
              e.chatEntries.length > 0 &&
              e.chatEntries.reduce((e, t) => (e.push(t), e), t),
              e.groupChatEntries &&
                e.groupChatEntries.length > 0 &&
                e.groupChatEntries.reduce(
                  (e, t) => ((t.id = R.GROUPID_PREFIX + t.id), e.push(t), e),
                  t,
                );
            En.a.getInstance().cleanupLocalStorageMatchConditions((e) => {
              const t = E.default
                .getInstance()
                .getKeyNameForCurrentUser(this.localKey(""));
              return e.startsWith(t);
            }),
              (this.cache = {});
            for (let s = 0; s < t.length; s++)
              this.muteConversation(t[s].id, t[s]);
            return t;
          }
        }
        var Sn;
        Object($t.b)(zt.g)(
          (Sn =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (Sn =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (Sn = class extends te.b {
                    constructor() {
                      super(),
                        (this.name = void 0),
                        (this.key = void 0),
                        (this.didInit = void 0),
                        (this._muteManager = void 0),
                        (this.userId = void 0),
                        (this.mapTimeout = void 0),
                        (this.name = zt.f),
                        (this.key = "id"),
                        (this.didInit = !1),
                        (this.userId = ""),
                        (this.mapTimeout = {});
                    }
                    init(e) {
                      this.didInit || ((this.didInit = !0), (this.userId = e));
                    }
                    get muteManager() {
                      return (
                        (this._muteManager && "" !== this.userId) ||
                          (this.userId, (this._muteManager = new Mn())),
                        this._muteManager
                      );
                    }
                    getItem(e, t) {
                      return this.muteManager.isMuted(e.key);
                    }
                    getList(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    onGetItemFailure(e) {}
                    onGetListFailure(e, t) {}
                    onMute(e, t) {
                      return new Promise((s, i) => {
                        this._clearTimeout(e);
                        let n = -1;
                        switch (t) {
                          case 1:
                            n = 3600;
                            break;
                          case 2:
                            n = 14400;
                            break;
                          case 3:
                            n = Math.round(this._getNowTo8Am() / 1e3);
                        }
                        Ct.default.logCoreInfo(
                          `[${this.name}] - onMute ${e} ${n}`,
                        ),
                          Cn.a
                            .lock(e, n, !0)
                            .then((t) => {
                              this.muteManager.muteConversation(e, {
                                id: e,
                                startTime: t.startTime,
                                duration: t.duration,
                                systemTime: t.systemTime,
                                currentTime: t.currentTime,
                                muteMode: t.muteMode,
                              }),
                                s(!0);
                            })
                            .catch(i);
                      });
                    }
                    onUnMute(e, t, s) {
                      return (
                        void 0 === t && (t = !0),
                        void 0 === s && (s = !1),
                        new Promise((i, n) => {
                          this._clearTimeout(e),
                            Ct.default.logCoreInfo(
                              `[${this.name}] - onUnMute ${e} ${t} ${s}`,
                            ),
                            Cn.a
                              .unlock(e, t, s)
                              .then((t) => {
                                this.muteManager.muteConversation(e, 0), i(!!t);
                              })
                              .catch(n);
                        })
                      );
                    }
                    onFetchMute(e) {
                      Ct.default.logCoreInfo(`[${this.name}] - onFetchMute`);
                      let t = this.muteManager.setMutedConversations(e);
                      return this.processFetchData(e), t;
                    }
                    onCtrMute(e, t) {
                      t
                        ? (this.doLock(t, !1),
                          this.muteManager.muteConversation(e, t),
                          this.muteChanged(e, !!t))
                        : this.onUnMute(e, !1).then((s) => {
                            this.muteChanged(e, !!t);
                          });
                    }
                    isMuted(e) {
                      return this.muteManager.isMuted(e);
                    }
                    processFetchData(e) {
                      try {
                        e.chatEntries &&
                          (e.chatEntries.forEach((e) => {
                            this.doLock(e, !0);
                          }),
                          e.groupChatEntries.forEach((e) => {
                            this.doLock(e, !0);
                          }));
                      } catch (t) {
                        Ct.default.logCoreError(t);
                      }
                    }
                    doLock(e, t) {
                      if (
                        (void 0 === t && (t = !0),
                        this.mapTimeout.hasOwnProperty(e.id) && (t = !0),
                        this._clearTimeout(e.id),
                        -1 != e.duration)
                      ) {
                        Ct.default.log("setTimer", e);
                        let s = e.duration - (e.currentTime - e.systemTime);
                        s >= 0
                          ? (Ct.default.log("setTimer: lock1", e.id),
                            Ct.default.logCoreInfo(
                              "[Unmute timeout] setTimer: lock1",
                              e.id,
                              s,
                            ),
                            (this.mapTimeout[e.id] = setTimeout(() => {
                              this.onUnMute(e.id, t, !0),
                                Ct.default.logCoreInfo(
                                  "[Unmute timeout] setTimer: unlock1",
                                  e.id,
                                );
                            }, 1e3 * s)))
                          : (Ct.default.log("setTimer: unlock", s),
                            Ct.default.logCoreInfo(
                              "[Unmute timeout] setTimer: unlock",
                              e.id,
                            ),
                            this.onUnMute(e.id, t));
                      }
                    }
                    _clearTimeout(e) {
                      this.mapTimeout.hasOwnProperty(e) &&
                        (clearTimeout(this.mapTimeout[e]),
                        delete this.mapTimeout[e]);
                    }
                    _getNowTo8Am() {
                      let e = new Date().getTime(),
                        t = new Date(e);
                      return (
                        t.setHours(8, 0, 0, 0),
                        t.getTime() <= e
                          ? t.getTime() + 864e5 - e
                          : t.getTime() - e
                      );
                    }
                    muteChanged(e, t) {
                      Object(nt.g)(this.name, e),
                        this.broadcastEvent(Zt.b.MuteChanged, e, t);
                    }
                    broadcastEvent(e, t, s) {
                      void 0 === t && (t = ""),
                        this.dispatchEvent(new Zt.a(e, t, s));
                    }
                  }),
                ) || Sn),
            ) || Sn),
        );
        var Tn,
          wn = s("kCOK"),
          Rn = s("qvRd"),
          Ln = s("fBUP"),
          Dn = s("gwig");
        const Fn = "zpinc",
          An = "ver_pin",
          jn = 0,
          Pn = 1,
          Nn = 2;
        Object($t.b)(Rn.b)(
          (Tn =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (Tn =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (Tn = class extends te.b {
                    get Logger() {
                      return (
                        this._Logger ||
                          (this._Logger = i.ModuleContainer.resolve(
                            q.ZLoggerFactory,
                          ).createZLogger("conversation", [this.name])),
                        this._Logger
                      );
                    }
                    constructor() {
                      super(),
                        (this.name = void 0),
                        (this.key = void 0),
                        (this.didInit = void 0),
                        (this.doneLoadDB = void 0),
                        (this.data = void 0),
                        (this._Logger = void 0),
                        (this.reFetchCount = void 0),
                        (this.retryTimeout = void 0),
                        (this.refetchInterval = void 0),
                        (this.lastFetchTime = void 0),
                        (this.isDataLastest = void 0),
                        (this.requestingIds = void 0),
                        (this.name = Rn.a),
                        (this.key = "convId"),
                        (this.didInit = !1),
                        (this.doneLoadDB = !1),
                        (this.data = new Map()),
                        (this.reFetchCount = 0),
                        (this.isDataLastest = !1),
                        (this.lastFetchTime = 0),
                        (this.requestingIds = new Map());
                    }
                    init() {
                      this.didInit ||
                        ((this.didInit = !0),
                        this._loadData(),
                        this._fetchPinnedConversations(),
                        this._addListener());
                    }
                    _loadData() {
                      const e = E.default
                        .getInstance()
                        .getItemForCurrentUser(Fn);
                      if (e && e.length)
                        try {
                          const s = JSON.parse(e);
                          Object.keys(s).map((e) => {
                            this._verifyPin(s[e].id) &&
                              this.data.set(s[e].id, {
                                id: s[e].id,
                                priority:
                                  +s[e].priority || _t.default.getTimeNow(),
                              });
                          });
                          try {
                            this.Logger.zsymb(
                              0,
                              9682,
                              3e4,
                              "pin conversations loaded from local",
                              JSON.stringify(Object.fromEntries(this.data)),
                            );
                          } catch (t) {
                            this.Logger.zsymb(
                              18,
                              9682,
                              30001,
                              "stringify fail",
                            );
                          }
                          this.doneLoadDB = !0;
                          const i = this.getAllPinnedConversations();
                          i.length &&
                            this._broadcastEvent(Zt.b.ChangePinConv, i);
                        } catch (s) {
                          0;
                        }
                    }
                    _addListener() {
                      Ye.default.subscribeEventFriend(
                        R.EventFriend.REMOVE_FRIEND,
                        (e) => {
                          this.Logger.zsymb(
                            0,
                            9682,
                            30002,
                            "remove friend - unpin",
                            e.userId,
                          ),
                            this.updateListPin([e.userId], Nn);
                        },
                      ),
                        this._setFetchInterval();
                    }
                    _setFetchInterval() {
                      this.refetchInterval &&
                        clearTimeout(this.refetchInterval),
                        (this.refetchInterval = setInterval(() => {
                          this._fetchPinnedConversations();
                        }, 864e5));
                    }
                    _broadcastEvent(e, t) {
                      this.dispatchEvent(new Zt.e(e, t));
                    }
                    _newPinItem(e, t) {
                      return { id: e, priority: t };
                    }
                    _syncServer(e, t) {
                      return this._updatePinnedConversationsV2(e, t);
                    }
                    getLastFetchTime() {
                      return this.lastFetchTime;
                    }
                    isPinned(e) {
                      return this.data.has(e);
                    }
                    getPinTime(e) {
                      const t = this.data.get(e);
                      return t ? t.priority : 0;
                    }
                    async _checkAndSyncDataBeforeAction() {
                      if (!this.isDataLastest)
                        try {
                          return await this._fetchPinnedConversations(), !0;
                        } catch (e) {
                          return !1;
                        }
                      return !0;
                    }
                    pin(e) {
                      return (
                        this.Logger.zsymb(0, 9682, 30003, "client pin", e),
                        new Promise(async (t, s) => {
                          const i = await this._checkAndSyncDataBeforeAction();
                          if (!e || !e.length) return s(null);
                          if (i) {
                            if (
                              this.data.size + e.length >
                              bt.default.limit_pin_messages
                            )
                              return s(null);
                            let i = [];
                            for (let t = 0; t < e.length; ++t)
                              this.isPinned(e[t]) || i.push(e[t]);
                            if (i.length > 0)
                              try {
                                const s = await this._syncServer(i, Pn);
                                return this.updateListPin(e, Pn), t(s);
                              } catch (n) {
                                return s(n);
                              }
                          }
                          return s(null);
                        })
                      );
                    }
                    pinLocal(e) {
                      this.updateListPin(e, Pn);
                    }
                    unpin(e, t) {
                      return (
                        void 0 === t && (t = !1),
                        this.Logger.zsymb(
                          0,
                          9682,
                          30004,
                          "client unpin",
                          e,
                          "force sync",
                          t,
                        ),
                        new Promise(async (s, i) => {
                          if (!e || !e.length) return i(null);
                          if (await this._checkAndSyncDataBeforeAction()) {
                            let a = [];
                            for (let s = 0; s < e.length; ++s)
                              (this.isPinned(e[s]) || t) && a.push(e[s]);
                            if (a.length > 0)
                              try {
                                await this._syncServer(a, Nn),
                                  this.updateListPin(e, Nn),
                                  s(1);
                              } catch (n) {
                                i(n);
                              }
                          }
                          return i(null);
                        })
                      );
                    }
                    unpinLocal(e) {
                      this.Logger.zsymb(0, 9682, 30005, "unpin local", e),
                        this.updateListPin(e, Nn);
                    }
                    getAllPinnedConversations() {
                      return Array.from(this.data.values());
                    }
                    getAllPinnedConversationsSync() {
                      return Array.from(this.data.values());
                    }
                    getTotalPinnedConversation() {
                      return (
                        this.data.size +
                        Array.from(this.requestingIds.values()).filter(
                          (e) => e === Pn,
                        ).length
                      );
                    }
                    _verifyPin(e) {
                      return (
                        this.Logger.zsymb(
                          0,
                          9682,
                          30006,
                          "verify conversation",
                          e,
                          Ye.default.isFriend(e),
                          !!ds.default.getGroupByIdSync(e),
                          e === bt.default.sendToMeId,
                        ),
                        Ye.default.isFriend(e) ||
                          !!ds.default.getGroupByIdSync(e) ||
                          e === bt.default.sendToMeId
                      );
                    }
                    updateListPin(e, t) {
                      if (
                        (this.Logger.zsymb(
                          0,
                          9682,
                          30007,
                          "updateListPin",
                          e,
                          t,
                        ),
                        !e || !e.length)
                      )
                        return;
                      const s = [];
                      switch (t) {
                        case Pn:
                          let t = _t.default.getTimeNow();
                          for (let i = 0; i < e.length; i++)
                            if (this._verifyPin(e[i]) && !this.data.has(e[i])) {
                              ++t,
                                this.requestingIds.get(e[i]) &&
                                  this.requestingIds.set(e[i], jn);
                              const n = this._newPinItem(e[i], t);
                              this.data.set(e[i], n),
                                s.push(n),
                                Object(nt.g)(this.name, e[i]);
                            }
                          break;
                        case Nn:
                          for (let i = 0; i < e.length; i++)
                            if (this.data.has(e[i])) {
                              this.requestingIds.get(e[i]) &&
                                this.requestingIds.set(e[i], jn),
                                this.data.delete(e[i]);
                              const t = this._newPinItem(e[i], 0);
                              s.push(t), Object(nt.g)(this.name, e[i]);
                            }
                          break;
                        default:
                          return;
                      }
                      s.length && this._broadcastEvent(Zt.b.ChangePinConv, s),
                        this._updateInDB();
                    }
                    _retryFetch(e) {
                      if (this.reFetchCount > 5) return;
                      let t = 0;
                      switch (e) {
                        case "ERR_NO_NETWORK":
                        case -69:
                          break;
                        case 212:
                          this.Logger.zsymb(
                            20,
                            9682,
                            30008,
                            "hasn't pinned conversation from server",
                          );
                          E.default
                            .getInstance()
                            .setItemForCurrentUser(An, "0"),
                            this._sendToServer();
                          break;
                        case "ERR_CONNECTION_TIMED_OUT":
                        case 112:
                          t = 5e3 * this.reFetchCount;
                          break;
                        default:
                          t = 36e5;
                      }
                      this.Logger.zsymb(
                        21,
                        9682,
                        30009,
                        "Handle request error fail with error: {}, retry after time= {}",
                        e,
                        t,
                      ),
                        this.retryTimeout ||
                          (t > 0 &&
                            (this.retryTimeout = setTimeout(() => {
                              this._fetchPinnedConversations(),
                                (this.retryTimeout = void 0);
                            }, t)));
                    }
                    _parseData(e) {
                      let t = [];
                      for (let s = 0; s < e.length; ++s)
                        "m1" === e[s] ||
                          (e[s].startsWith("g")
                            ? t.push(e[s])
                            : t.push(e[s].slice(1)));
                      return t;
                    }
                    _fetchPinnedConversations() {
                      return (
                        this.reFetchCount++,
                        this.Logger.zsymb(
                          0,
                          9682,
                          30010,
                          "_fetchPinnedConversations",
                          this.reFetchCount,
                        ),
                        new Promise((e, t) => {
                          Ln.default
                            .getPinnedConversations()
                            .then(wn.a)
                            .then((t) => {
                              if (t && t.conversations) {
                                const e = E.default.getInstance();
                                (void 0 === t.version && null === t.version) ||
                                  e.setItemForCurrentUser(An, t.version),
                                  this._onFetchPin(
                                    this._parseData(t.conversations),
                                  );
                              }
                              e(t);
                            })
                            .catch((e) => {
                              (this.isDataLastest = !1),
                                e &&
                                  (e.error_code
                                    ? this._retryFetch(e.error_code)
                                    : e.code
                                      ? this._retryFetch(e.code)
                                      : this._retryFetch("UNKNOWN_ERROR")),
                                t(e);
                            });
                        })
                      );
                    }
                    _updatePinnedConversationsV2(e, t) {
                      return new Promise((s, i) => {
                        if (!bt.default.enable_sync_pinned) return;
                        if (!Dn.b.getStateNetwork())
                          return void i(
                            t === Pn
                              ? tt.default.str(
                                  "STR_ERR_NETWORK_PIN_CONVERSATION",
                                )
                              : tt.default.str(
                                  "STR_ERR_NETWORK_UNPIN_CONVERSATION",
                                ),
                          );
                        let n = [];
                        for (let a = 0; a < e.length; ++a)
                          e[a].startsWith("g") ||
                            e[a].startsWith("u") ||
                            (e[a] = "u" + e[a]),
                            n.includes(e[a]) ||
                              (this.requestingIds.has(e[a]) &&
                                this.requestingIds.get(e[a]) !== jn) ||
                              (n.push(e[a]), this.requestingIds.set(e[a], t));
                        n.length &&
                          Ln.default
                            .updatePinnedConversationsV2(n, t)
                            .then(wn.a)
                            .then(() => {
                              n.forEach((e) => {
                                this.requestingIds.set(e, jn);
                              }),
                                s(!0);
                            })
                            .catch((e) => {
                              n.forEach((e) => {
                                this.requestingIds.set(e, jn);
                              }),
                                this.Logger.zsymb(
                                  20,
                                  9682,
                                  30011,
                                  "Update sync pin conv v2 FAIL: " + e,
                                );
                              let s = "";
                              if (e)
                                if (e.error_code)
                                  if (160 === e.error_code)
                                    this._fetchPinnedConversations();
                                  else
                                    s =
                                      tt.default.str(
                                        "STR_ERR_PIN_CONVERSATION",
                                      ) +
                                      " (" +
                                      e.error_code +
                                      ")";
                                else
                                  "ERR_NO_NETWORK" === e.code &&
                                    Dn.b.getStateNetwork() == Dn.a.DISCONNECT &&
                                    (s =
                                      t === Pn
                                        ? tt.default.str(
                                            "STR_ERR_NETWORK_PIN_CONVERSATION",
                                          )
                                        : tt.default.str(
                                            "STR_ERR_NETWORK_UNPIN_CONVERSATION",
                                          ));
                              i(s);
                            });
                      });
                    }
                    _isRemoteDataChanged(e) {
                      const t = Array.from(this.data.values())
                        .sort((e, t) => t.priority - e.priority)
                        .map((e) => e.id);
                      if (e.length !== t.length) return !0;
                      let s = !1;
                      return (
                        e.forEach((e, i) => {
                          e !== t[i] && (s = !0);
                        }),
                        s
                      );
                    }
                    _onFetchPin(e) {
                      this.Logger.zsymb(0, 9682, 30012, "onFetchPin", e),
                        (this.isDataLastest = !0),
                        (this.lastFetchTime = _t.default.getTimeNow()),
                        (this.reFetchCount = 0);
                      let t = _t.default.getTimeNow();
                      this._setFetchInterval();
                      const s = [],
                        i = [];
                      for (let n = 0; n < e.length; n++)
                        this._verifyPin(e[n])
                          ? i.push(e[n])
                          : this.unpin([e[n]], !0);
                      if (this._isRemoteDataChanged(i)) {
                        for (const e of Array.from(this.data.values()))
                          i.find((t) => t === e.id) ||
                            (this.data.delete(e.id),
                            Object(nt.g)(this.name, e.id),
                            s.push({ id: e.id, priority: 0 }));
                        for (let e = 0; e < i.length; e++) {
                          const n = this._newPinItem(i[e], t),
                            a = this.isPinned(i[e]);
                          this.data.set(i[e], n),
                            a || Object(nt.g)(this.name, i[e]),
                            t--,
                            s.push(n);
                        }
                        this.Logger.zsymb(
                          0,
                          9682,
                          30013,
                          "[After Fetch]",
                          Array.from(this.data.values()),
                        ),
                          s.length &&
                            this._broadcastEvent(Zt.b.ChangePinConv, s),
                          this._updateInDB();
                      }
                    }
                    _sendToServer() {
                      this._syncServer(Array.from(this.data.keys()), Pn);
                    }
                    getItem(e, t) {
                      return this.data.get(e.key);
                    }
                    getList(e, t) {
                      return Array.from(this.data.keys());
                    }
                    onGetItemFailure(e, t) {
                      this.Logger.zsymb(
                        18,
                        9682,
                        30014,
                        "onGetItemFailure - key:",
                        e,
                        " - error",
                        t,
                      );
                    }
                    onGetListFailure(e, t) {
                      this.Logger.zsymb(
                        18,
                        9682,
                        30015,
                        "onGetItemFailure - key:",
                        e,
                        " - error",
                        t,
                      );
                    }
                    _updateInDB() {
                      if (!this.data) return;
                      const e = E.default.getInstance();
                      this.data.size
                        ? e.setItemForCurrentUser(
                            Fn,
                            JSON.stringify(Array.from(this.data.values())),
                          )
                        : e.removeItemForCurrentUser(Fn);
                    }
                  }),
                ) || Tn),
            ) || Tn),
        );
        var Un,
          kn = s("MnJw");
        Object($t.b)(kn.a)(
          (Un =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (Un =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (Un = class extends te.b {
                    constructor() {
                      super();
                    }
                    onUpdateListArchivedChat(e) {
                      this.dispatchEvent(
                        new Zt.a(Zt.b.UpdateListArchivedChat, e),
                      );
                    }
                    onOffArchivedChat(e) {
                      this.dispatchEvent(
                        new Zt.a(Zt.b.OnOffArchivedChat, "", { status: e }),
                      );
                    }
                  }),
                ) || Un),
            ) || Un),
        );
        i.ModuleContainer.registerSingleton(pi.b, yi),
          i.ModuleContainer.registerSingleton(Ai.a, Di),
          i.ModuleContainer.registerSingleton(pi.a, bi);
        var Bn,
          Gn = s("Xvw2"),
          xn = s("5uwv"),
          zn = s("lCn6"),
          Vn = s("kg13"),
          Hn = s("dJFb");
        const $n = 2,
          Wn = { userId: "", friendRequestType: $n, friendRequestSource: 85 };
        var Kn;
        !(function (e) {
          (e.SUGGEST = "suggest"),
            (e.REQUEST = "request"),
            (e.UNREADREQ = "unread-req");
        })(Kn || (Kn = {}));
        Object($t.b)(Gn.b)(
          (Bn =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (Bn =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (Bn = class extends te.b {
                    constructor() {
                      super(),
                        (this.sugguestList = void 0),
                        (this.requestList = void 0),
                        (this.unreadFRList = void 0),
                        (this._ebFriendRequestSend = (e) => {
                          const t = this.unreadFRList.filter((t) => t !== e);
                          t.length !== this.unreadFRList.length &&
                            (Ee.default.removeFriend(e),
                            Ct.default.logCoreError(
                              "[reddot-check] SEND_FRIEND_REQUEST: " +
                                JSON.stringify(e),
                            ),
                            (this.unreadFRList = t),
                            Object(nt.i)(this.name, Kn.UNREADREQ));
                        }),
                        (this._ebFriendFetch = (e) => {
                          for (let t in e)
                            if (e.hasOwnProperty(t)) {
                              const e = this.requestList.slice();
                              for (let s = 0; s < e.length; s++)
                                if (e[s] === t) {
                                  e.splice(s, 1);
                                  break;
                                }
                              e.length !== this.requestList.length &&
                                ((this.requestList = e),
                                Object(nt.i)(this.name, Kn.REQUEST));
                            }
                        }),
                        (this._ebFrReqFetch = (e) => {
                          Ct.default.log(
                            "friendNotificationAction: friend requests fetched",
                            e,
                          );
                          const t = this.requestList.reduce(
                              (e, t) => (e[t] || (e[t] = !0), e),
                              {},
                            ),
                            s = this.requestList.slice();
                          for (let i of e) t[i.userId] || s.unshift(i);
                          (this.requestList = s),
                            Object(nt.i)(this.name, Kn.REQUEST);
                        }),
                        (this._ebFrReqRemove = (e) => {
                          Ct.default.log(
                            "friendNotificationAction: friend requests removed",
                            e,
                          );
                          const t = this.requestList.filter(
                            (t) => -1 === e.indexOf(t),
                          );
                          t.length !== this.requestList.length &&
                            ((this.requestList = t),
                            Object(nt.i)(this.name, Kn.REQUEST)),
                            this.onFriendListNotificationsChange({
                              action: "remove",
                              ids: e,
                            });
                        }),
                        (this.name = Gn.a),
                        (this.data = new Map()),
                        (this.key = "userId"),
                        (this.sugguestList = []),
                        (this.requestList = []),
                        (this.unreadFRList = []),
                        this.listenEvents();
                    }
                    listenEvents() {
                      Mt.default.subscribe((e, t) => {
                        switch (e) {
                          case St.ChatBoxActions.SEND_FRIEND_REQUEST:
                            this._ebFriendRequestSend(t);
                            break;
                          case St.FetchActions.FRIENDS_FETCHED:
                            this._ebFriendFetch(t);
                            break;
                          case St.FetchActions.FRIEND_REQUESTS_FETCHED:
                            this._ebFrReqFetch(t);
                            break;
                          case St.FetchActions.FRIEND_REQUESTS_REMOVED:
                            this._ebFrReqRemove(t);
                        }
                      });
                    }
                    onAddFriend(e) {
                      Vn.a.removeSuggest(e.userId),
                        this.onFriendListNotificationsChange({
                          action: "remove",
                          ids: [e.userId],
                        });
                    }
                    onReceiveFriendRequests(e) {
                      if (!e || e.length < 1) return;
                      for (let s = 0; s < e.length; s++) {
                        let t = e[s];
                        t && Vn.a.removeSuggest(t.userId);
                      }
                      Hn.d.setUnreadRequest(1);
                      for (let s = 0; s < e.length; s++)
                        e[s] && Q.p.addNewFriendItem(e[s].userId);
                      Pt.a.UnreadDataManager.updateUnreadCount(
                        R.FAKE_CONVERSATION_ID.FRIEND_CENTER,
                        Hn.d.getUnreadRequest(),
                      );
                      let t = e.map((e) => ({
                        dataInfo: Object(f.a)(
                          Object(f.a)({}, e),
                          {},
                          {
                            recommInfo: {
                              message: e.friendRequestMsg,
                              source: e.friendRequestSource,
                            },
                            recommType: $n,
                          },
                        ),
                        recommItemType: e.friendRequestType,
                      }));
                      Vn.a.addRequest(t),
                        this.broadcastEvent(xn.b.ReceiveRequest, "", {
                          uids: e.map((e) => e.userId),
                        });
                    }
                    onRemoveSuggest(e, t, s) {
                      return Vn.a.removeSuggestFriend(e, t, s).then((t) => {
                        this.broadcastEvent(xn.b.RemoveSuggest, e);
                      });
                    }
                    onPromoteFriends() {
                      Pt.a.UnreadDataManager.updateUnreadCount(
                        R.FAKE_CONVERSATION_ID.FRIEND_CENTER,
                        1,
                      );
                    }
                    onFriendRequestFetched() {}
                    onFriendListNotificationsChange(e) {
                      if (!e.ids || !e.ids.length)
                        return void (
                          "clear" === e.action &&
                          ((this.unreadFRList = []),
                          Object(nt.i)(this.name, Kn.UNREADREQ))
                        );
                      let t = this.unreadFRList;
                      if ("remove" === e.action)
                        t = t.filter((t) => -1 === e.ids.indexOf(t));
                      else if ("add" === e.action) {
                        const s = [];
                        for (let i of e.ids) -1 === t.indexOf(i) && s.push(i);
                        s.length && (t = t.concat(s));
                      }
                      t.length !== this.unreadFRList.length &&
                        ((this.unreadFRList = t),
                        Object(nt.i)(this.name, Kn.UNREADREQ));
                    }
                    acceptFriendRequest(e, t) {
                      return (
                        void 0 === t && (t = Qt.c),
                        new Promise((s, i) => {
                          const n = this.data.get(e);
                          if (!n)
                            return qs.a
                              .acceptAddFriend(e)
                              .then((i) => {
                                Je.ModalManagerV2.openModal({
                                  windowId: t,
                                  name: R.ModalIdentitiesDefine.BLOCK_STORIES,
                                  params: { userId: e, windowId: t },
                                }),
                                  s(!0);
                              })
                              .catch(i);
                          let a;
                          if (
                            n.friendRequestType ===
                            R.FRIEND_REQUEST_TYPE_SUGGEST
                          ) {
                            if (n.requested)
                              return (a = 104097), Xe.e.logAction(a), s(!1);
                            const r = tt.default.trans(
                              "STR_MSG_DEFAULT_REQ_ADD_FR",
                              Ye.default.getMiniProfileMe().zaloName,
                            );
                            qs.a
                              .requestAddFriend(e, r, n.friendRequestSource)
                              .then(() => {
                                Je.ModalManagerV2.openModal({
                                  windowId: t,
                                  name: R.ModalIdentitiesDefine.BLOCK_STORIES,
                                  params: { userId: e, windowId: t },
                                }),
                                  Ee.default.removeFriend(e),
                                  Vn.a.removeSuggest(e);
                                const i = Object(f.a)(
                                  Object(f.a)({}, n),
                                  {},
                                  { requested: !0 },
                                );
                                this.broadcastEvent(xn.b.SentFriendReq, e),
                                  this.data.set(e, i),
                                  this.onFriendListNotificationsChange({
                                    action: "remove",
                                    ids: [e],
                                  }),
                                  s(!0);
                              })
                              .catch((e) => {
                                this.handleFailureFriendRq(e), i(e);
                              }),
                              (a = 104096);
                          } else
                            qs.a
                              .acceptAddFriend(e)
                              .then(() => {
                                this.data.delete(e),
                                  Object(nt.e)(this.name, e),
                                  this.onFriendListNotificationsChange({
                                    action: "remove",
                                    ids: [e],
                                  }),
                                  this.broadcastEvent(xn.b.AcceptRequest, e),
                                  zn.a.getUser(e).then((t) => {
                                    Mt.default.send(
                                      St.FetchActions.FRIENDS_FETCHED,
                                      {
                                        [e]: Object(f.a)(
                                          Object(f.a)(
                                            {},
                                            Ct.default.reformatConversationFromFriend(
                                              t,
                                            ),
                                          ),
                                          {},
                                          { isFr: 1 },
                                        ),
                                      },
                                    );
                                  }),
                                  Ee.default.getAcceptNewFriend(n),
                                  Je.ModalManagerV2.openModal({
                                    windowId: t,
                                    name: R.ModalIdentitiesDefine.BLOCK_STORIES,
                                    params: { userId: e, windowId: t },
                                  }),
                                  s(!0);
                              })
                              .catch((e) => {
                                this.handleFailureFriendRq(e), i(e);
                              }),
                              (a = 104095);
                          a && Xe.e.logAction(a);
                        })
                      );
                    }
                    async rejectFriendRequest(e) {
                      const t = this.data.get(e),
                        s = () => {
                          et.a.createSuccess(
                            tt.default.str("STR_TOAST_REJECT_REQUEST"),
                          ),
                            Ee.default.removeFriend(e),
                            Vn.a.removeSuggest(e),
                            this.broadcastEvent(xn.b.RejectRequest, e);
                        },
                        i = (e) => {
                          Ct.default.logCoreError(e),
                            e &&
                              e.error_message &&
                              et.a.createError(e.error_message);
                        };
                      t && t.friendRequestSource
                        ? Ot.default
                            .removeRecommendedFriend(e, t.friendRequestSource)
                            .then(s)
                            .catch(i)
                        : qs.a.rejectRequestAddFriend(e).then(s).catch(i),
                        this.data.delete(e),
                        this.onFriendListNotificationsChange({
                          action: "remove",
                          ids: [e],
                        }),
                        Xe.e.logAction(104094);
                    }
                    undoRequestFriend(e) {
                      e &&
                        qs.a.undoRequestAddFriend(e).catch((e) => {
                          e.error_message && et.a.createError(e.error_message);
                        });
                    }
                    clearUnreadFriendRequest() {
                      Pt.a.UnreadDataManager.updateUnreadCount(
                        R.FAKE_CONVERSATION_ID.FRIEND_CENTER,
                        0,
                      ),
                        (this.unreadFRList = []),
                        Object(nt.i)(this.name, Kn.UNREADREQ);
                    }
                    getAllFriendRequests() {
                      return new Promise((e, t) => {
                        const s = Vn.a.getRecommendedFriendsV2(!1, !1);
                        if (!s) return e({});
                        e(this.filterFriendRequest(s));
                      });
                    }
                    getAllFriendRequestsSync() {
                      const e = Vn.a.getRecommendedFriendsSync();
                      return e ? this.filterFriendRequest(e) : {};
                    }
                    init() {
                      Ee.default.getFriends(null, !0).then((e) => {
                        if (e) {
                          const t = Ee.default.getLastContactListOpenTime(),
                            s = e
                              .filter((e) => e && e.friendRequestFetchTime > t)
                              .map((e) => e.userId);
                          s.length &&
                            this.onFriendListNotificationsChange({
                              action: "add",
                              ids: s,
                            });
                        }
                      });
                    }
                    getItem(e) {
                      return Wn;
                    }
                    getList(e) {
                      return e.key === Kn.UNREADREQ ? this.unreadFRList : [];
                    }
                    onGetItemFailure(e) {}
                    onGetListFailure(e) {}
                    handleFailureFriendRq(e) {
                      if ((Ct.default.logCoreError(e), e && e.error_message)) {
                        let t = e.error_message;
                        [224, 251].includes(e.error_code) &&
                          (t = tt.default.trans(
                            `STR_FRIEND_REQUEST_FAIL_${e.error_code}`,
                            ["" + bt.default.limitFriends],
                          )),
                          et.a.createMessage(t, 3e3);
                      }
                    }
                    filterFriendRequest(e) {
                      const t = {};
                      for (let s in e)
                        if (e.hasOwnProperty(s)) {
                          let i = e[s];
                          i &&
                            i.dataInfo.recommType === $n &&
                            ((t[s] = i),
                            (t[s].friendRequestType = i.dataInfo.recommType));
                        }
                      return t;
                    }
                    broadcastEvent(e, t, s) {
                      this.dispatchEvent(new xn.a(e, t, s)),
                        this.dispatchEvent(
                          new xn.a(
                            xn.b.FriendCenterChange,
                            t,
                            Object(f.a)(Object(f.a)({}, s), {}, { act: e }),
                          ),
                        );
                    }
                  }),
                ) || Bn),
            ) || Bn),
        );
        var qn = s("5cla"),
          Zn = s("WV6O");
        class Jn {
          static resetNewFriendList() {
            delete this.newListFriend, (this.newListFriend = void 0);
          }
          static addNewFriendUid(e) {
            void 0 === this.newListFriend && this.getNewFriendList(),
              this.newListFriend.push(e);
          }
          static getNewFriendList() {
            Ee.default.removeNewFriend("", !0);
            let e = [];
            try {
              const t = E.default.getInstance().getItemForCurrentUser("f_nf");
              t && (e = JSON.parse(t));
            } catch (t) {}
            this.newListFriend = e.map((e) => e.userId);
          }
          static getFriendList(e) {
            const { userId: t } = e,
              s = [];
            return new Promise((e, i) => {
              Ye.default
                .getFriends()
                .then((i) => {
                  if (i) {
                    const n = Boolean(ts.g.getConfigShowAllUser(t));
                    for (let e = 0; e < i.length; e++)
                      (1 === i[e].isFr ||
                        i[e].isFr ||
                        i[e].userId === bt.default.supportPage) &&
                        i[e].userId != t &&
                        i[e].isValid &&
                        i[e].userId != bt.default.sendToMeId &&
                        (n ||
                          i[e].isActive ||
                          i[e].isActivePC ||
                          i[e].isActiveWeb) &&
                        s.push(i[e].userId);
                    e(s);
                  } else e([]);
                })
                .catch((e) => i(e));
            });
          }
          static getFriendInfo(e) {
            var t;
            const { userId: s } = e,
              i = Ye.default.getProfileFriendSync(s);
            return i
              ? (void 0 === this.newListFriend && this.getNewFriendList(),
                {
                  userId: i.userId,
                  avatar: i.avatar,
                  displayName: i.displayName,
                  isFr: i.isFr,
                  zaloName: i.zaloName,
                  bizPkg: i.bizPkg,
                  bizInfo: i.bizInfo,
                  isNewFriend:
                    (null === (t = this.newListFriend) || void 0 === t
                      ? void 0
                      : t.includes(s)) || !1,
                  isBlocked: i.isBlocked,
                })
              : null;
          }
        }
        Jn.newListFriend = void 0;
        class Qn {
          static getGroupList(e) {
            return new Promise((e, t) => {
              ds.default
                .getGroupsList()
                .then((t) => {
                  const s = t.map((e) => e.userId);
                  e(s);
                })
                .catch(t);
            });
          }
          static getGroupInfo(e) {
            const { userId: t } = e;
            return new Promise((e, s) => {
              ds.default
                .getGroupById(t)
                .then((t) => {
                  e({
                    userId: t.userId,
                    avatar: t.avatar,
                    displayName: t.displayName,
                    topMember: t.topMember,
                    totalMember: t.totalMember,
                    creatorId: t.creatorId,
                  });
                })
                .catch(s);
            });
          }
          static getGroupInfoSync(e) {
            const { userId: t } = e,
              s = ds.default.getGroupByIdSync(t);
            return s
              ? {
                  userId: s.userId,
                  avatar: s.avatar,
                  displayName: s.displayName,
                  topMember: s.topMember,
                  totalMember: s.totalMember,
                  creatorId: s.creatorId,
                }
              : null;
          }
        }
        class Yn {
          static getRecommendFriendList() {
            return new Promise((e, t) => {
              Ot.default
                .getRecommendedFriends()
                .then((t) => e(t.recommItems))
                .catch(t);
            });
          }
          static getRelatedGroup(e) {
            return new Promise((t, s) => {
              Ot.default.getRelatedGroup(e).then(t).catch(s);
            });
          }
          static getRequestedFriendList() {
            return new Promise((e, t) => {
              Ot.default.getRequestedFriends().then(e).catch(t);
            });
          }
          static acceptAddFriend(e) {
            return qs.a.acceptAddFriend(e);
          }
          static rejectAddFriend(e) {
            return qs.a.rejectRequestAddFriend(e);
          }
          static makeUndoSentRequestFriend(e) {
            return qs.a.undoRequestAddFriend(e.userId);
          }
          static removeSuggestFriend(e) {
            return new Promise((t, s) => {
              Ot.default
                .removeRecommendedFriendV2(e.uid, e.src, e.type)
                .then(t)
                .catch(s);
            });
          }
        }
        var Xn;
        const ea = {
            currentView: Zn.f.FRIEND_LIST,
            unread: {
              newFriendRequests: [],
              newGroupRequests: [],
              newGroupInvitations: new Set(),
              isUnread: !1,
            },
          },
          ta = "1",
          sa = "ctt_l_a",
          ia = "ctt_l_r",
          na = "ctt_u_ginv";
        Object($t.b)(qn.b)(
          (Xn =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (Xn =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (Xn = class {
                    constructor() {
                      (this.type = void 0),
                        (this.name = void 0),
                        (this.key = void 0),
                        (this.currentTab = void 0),
                        (this.data = new Map()),
                        (this._Logger = void 0),
                        (this.name = qn.a),
                        (this.key = qn.a),
                        this.data.set(ta, ea),
                        (this.currentTab = "");
                    }
                    get Logger() {
                      return (
                        this._Logger ||
                          (this._Logger = i.ModuleContainer.resolve(
                            q.ZLoggerFactory,
                          ).createZLogger(hs.ZLoggerNametags.contactTabV2, [
                            this.name,
                          ])),
                        this._Logger
                      );
                    }
                    _updateState(e, t, s) {
                      void 0 === t && (t = ta),
                        void 0 === s && (s = !0),
                        this.data.set(t, e),
                        s && Object(nt.g)(this.name, t);
                    }
                    _getState(e) {
                      void 0 === e && (e = ta);
                      return this.data.get(e);
                    }
                    _getAccessTime() {
                      try {
                        return JSON.parse(
                          E.default.getInstance().getItemForCurrentUser(sa),
                        );
                      } catch (e) {
                        return (
                          this.Logger.zsymb(
                            18,
                            14824,
                            3e4,
                            "[_getAccessTime], error: " + JSON.stringify(e),
                          ),
                          null
                        );
                      }
                    }
                    _setAccessTime(e) {
                      E.default
                        .getInstance()
                        .setItemForCurrentUser(sa, JSON.stringify(e));
                    }
                    _setLastRequestFriendTime(e, t, s) {
                      let i = [];
                      try {
                        i =
                          JSON.parse(
                            E.default.getInstance().getItemForCurrentUser(ia),
                          ) || [];
                      } catch (a) {
                        this.Logger.zsymb(
                          18,
                          14824,
                          30001,
                          "[_setLastRequestFriendTime], error: " +
                            JSON.stringify(a),
                        );
                      }
                      let n = [];
                      switch (e) {
                        case "NEW":
                          i.find((e) => (null == e ? void 0 : e.userId) === s)
                            ? ((n = i.filter((e) => e.userId !== s)),
                              (n = [{ ts: t, userId: s }, ...i]))
                            : (n = [{ ts: t, userId: s }, ...i]);
                          break;
                        case "REMOVE":
                          n = i.filter((e) => e.userId !== s);
                      }
                      E.default
                        .getInstance()
                        .setItemForCurrentUser(ia, JSON.stringify(n));
                    }
                    _setLastReceivedGroupInvitationTime(e, t, s) {
                      let i = [];
                      try {
                        const e = E.default
                          .getInstance()
                          .getItemForCurrentUser(na);
                        i = (e && JSON.parse(e)) || [];
                      } catch (a) {
                        this.Logger.zsymb(
                          18,
                          14824,
                          30002,
                          "[_setListReceivedGroupInvitationTime], error: " +
                            JSON.stringify(a),
                        );
                      }
                      let n = [];
                      switch (e) {
                        case "NEW":
                          i.some(
                            (e) => (null == e ? void 0 : e.groupId) == s,
                          ) && (n = i.filter((e) => e.groupId != s)),
                            (n = [{ ts: t, groupId: s }, ...i]);
                          break;
                        case "REMOVE":
                          n = i.filter(
                            (e) => (null == e ? void 0 : e.groupId) !== s,
                          );
                      }
                      E.default
                        .getInstance()
                        .setItemForCurrentUser(na, JSON.stringify(n));
                    }
                    _getLastRequestAddFriendTime() {
                      let e;
                      try {
                        e = JSON.parse(
                          E.default.getInstance().getItemForCurrentUser(ia),
                        );
                      } catch (t) {
                        this.Logger.zsymb(
                          18,
                          14824,
                          30003,
                          "[_getLastRequestAddFriendTime], error: " +
                            JSON.stringify(t),
                        );
                      }
                      return e ? e[0] : null;
                    }
                    _getLastReceivedGroupInvitationTime() {
                      let e;
                      try {
                        const t = E.default
                          .getInstance()
                          .getItemForCurrentUser(na);
                        e = t ? JSON.parse(t) : null;
                      } catch (t) {
                        this.Logger.zsymb(
                          18,
                          14824,
                          30004,
                          "[_getLastReceivedGroupInvitationTime], error: " +
                            JSON.stringify(t),
                        );
                      }
                      return e ? e[0] : null;
                    }
                    _onChangeView(e) {
                      switch (
                        (i.ModuleContainer.resolve(
                          Wt.SidebarController,
                        ).updateSelectedId(null),
                        e)
                      ) {
                        case Zn.f.FRIEND_LIST:
                          Object(Ge.f)({
                            type: St.SideBarActions.SELECT_FRIEND_LIST,
                            payload: { userId: "999" },
                          });
                          break;
                        case Zn.f.GROUP_LIST:
                          Object(Ge.f)({
                            type: St.SideBarActions.SELECT_GROUP_CENTER,
                            payload: { userId: "999" },
                          });
                          break;
                        case Zn.f.FRIEND_REQUEST:
                          Object(Ge.f)({
                            type: St.SideBarActions.SELECT_FRIEND_CENTER,
                            payload: { userId: "999" },
                          }),
                            this._clearUnreadOnOpenView();
                          break;
                        case Zn.f.GROUP_INVITATION:
                          Object(Ge.f)({
                            type: St.SideBarActions
                              .SELECT_GROUP_INVITATION_CENTER,
                            payload: { userId: "999" },
                          }),
                            this._clearUnreadOnOpenView();
                      }
                    }
                    _onUpdateUnreadRequest(e, t) {
                      const s = this._getState();
                      if (!s) return;
                      let i = s.unread;
                      switch (t) {
                        case "FRIEND":
                          s.currentView !== Zn.f.FRIEND_REQUEST &&
                            (i.newFriendRequests.push(e), (i.isUnread = !0));
                          break;
                        case "GROUP":
                          i.newGroupRequests.push(e);
                          break;
                        case "GROUP_INV":
                          bt.default.group_privacy.invitation_box.enable &&
                            s.currentView !== Zn.f.GROUP_INVITATION &&
                            (i.newGroupInvitations.add(e), (i.isUnread = !0));
                      }
                      this._updateState(
                        Object(f.a)(Object(f.a)({}, s), {}, { unread: i }),
                        ta,
                        !0,
                      );
                    }
                    _clearUnreadOnOpenView() {
                      const e = this._getState();
                      if (!e) return;
                      let t = e.unread;
                      if (e.currentView === Zn.f.GROUP_INVITATION) {
                        t.newGroupInvitations.size > 0 && (t.isUnread = !1),
                          t.newGroupInvitations.clear();
                        const e = this._getLastReceivedGroupInvitationTime();
                        e &&
                          E.default
                            .getInstance()
                            .setItemForCurrentUser(na, JSON.stringify([e]));
                      } else
                        t.newFriendRequests.length + t.newGroupRequests.length >
                          0 && (t.isUnread = !1),
                          (t.newFriendRequests = []),
                          (t.newGroupRequests = []);
                      this._updateState(
                        Object(f.a)(Object(f.a)({}, e), {}, { unread: t }),
                        ta,
                        !0,
                      );
                    }
                    _clearGroupInvitationUnreadItem(e) {
                      const t = this._getState();
                      if (!t) return;
                      let s = t.unread;
                      s.newGroupInvitations.delete(e);
                      0 ===
                        s.newGroupInvitations.size +
                          s.newFriendRequests.length +
                          s.newGroupRequests.length && (s.isUnread = !1),
                        this._updateState(
                          Object(f.a)(Object(f.a)({}, t), {}, { unread: s }),
                          ta,
                          !0,
                        );
                    }
                    _clearFriendRequestUnreadItem() {
                      const e = this._getState();
                      if (!e) return;
                      let t = e.unread;
                      (t.newFriendRequests = []),
                        (t.newGroupRequests = []),
                        0 === t.newGroupInvitations.size && (t.isUnread = !1),
                        this._updateState(
                          Object(f.a)(Object(f.a)({}, e), {}, { unread: t }),
                          ta,
                          !0,
                        );
                    }
                    init(e) {
                      throw new Error("Method not implemented.");
                    }
                    getItem(e, t) {
                      return this._getState(e.key);
                    }
                    getList(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    onGetItemFailure(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    onGetListFailure(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    getDefaultItem() {
                      throw new Error("Method not implemented.");
                    }
                    getDefaultList() {
                      throw new Error("Method not implemented.");
                    }
                    resetTabData() {
                      (this.currentTab = ""),
                        Jn.resetNewFriendList(),
                        i.ModuleContainer.resolve(qn.b).resetData(),
                        i.ModuleContainer.resolve(qn.f).resetData(),
                        i.ModuleContainer.resolve(qn.e).resetData(),
                        i.ModuleContainer.resolve(qn.k).resetData(),
                        i.ModuleContainer.resolve(qn.i).resetData(),
                        i.ModuleContainer.resolve(qn.n).resetData();
                    }
                    resetData() {
                      const e = this._getState();
                      e &&
                        this._updateState(
                          Object(f.a)(
                            Object(f.a)({}, e),
                            {},
                            { currentView: Zn.f.FRIEND_LIST },
                          ),
                        );
                    }
                    changeView(e) {
                      const t = this._getState();
                      t &&
                        this._updateState(
                          Object(f.a)(
                            Object(f.a)({}, t),
                            {},
                            { currentView: e },
                          ),
                          ta,
                          !0,
                        ),
                        (this.currentTab = e),
                        this._onChangeView(e);
                    }
                    onClickContabTabEntry() {
                      if (document.getElementById("ContactTabV2")) {
                        const e = this._getState(),
                          t =
                            (null == e ? void 0 : e.currentView) ||
                            ea.currentView;
                        this._onChangeView(t);
                      }
                    }
                    onContactTab(e) {
                      this._setAccessTime(e), this._clearUnreadOnOpenView();
                    }
                    getDefaultView() {
                      if (this.currentTab) return this.currentTab;
                      const e = this._getAccessTime(),
                        t = this._getLastRequestAddFriendTime(),
                        s = this._getLastReceivedGroupInvitationTime();
                      if (!t)
                        return (
                          bt.default.group_privacy.invitation_box.enable &&
                          s &&
                          s.ts >=
                            _t.default.getTimeNow() -
                              bt.default.group_privacy.invitation_box
                                .max_auto_focus_time
                            ? (this.currentTab = Zn.f.GROUP_INVITATION)
                            : (this.currentTab = Zn.f.FRIEND_LIST),
                          this.currentTab
                        );
                      const i =
                          !bt.default.contactTabV2
                            .enable_rule_last_view_friend_req ||
                          (e && t.ts < e),
                        n = t.ts < _t.default.getTimeNow() - 864e5;
                      return bt.default.group_privacy.invitation_box.enable &&
                        s &&
                        s.ts > t.ts &&
                        s.ts >=
                          _t.default.getTimeNow() -
                            bt.default.group_privacy.invitation_box
                              .max_auto_focus_time
                        ? ((this.currentTab = Zn.f.GROUP_INVITATION),
                          this.currentTab)
                        : ((this.currentTab =
                            n && i ? Zn.f.FRIEND_LIST : Zn.f.FRIEND_REQUEST),
                          this.currentTab);
                    }
                    onUpdateRequestTracking(e, t, s, i) {
                      switch (
                        ("NEW" === t
                          ? this._onUpdateUnreadRequest(i, e)
                          : "REMOVE" === t &&
                            (bt.default.group_privacy.invitation_box.enable &&
                            "GROUP_INV" === e &&
                            i
                              ? this._clearGroupInvitationUnreadItem(i)
                              : this._clearFriendRequestUnreadItem()),
                        e)
                      ) {
                        case "FRIEND":
                          this._setLastRequestFriendTime(t, s || 0, i);
                          break;
                        case "GROUP":
                        default:
                          break;
                        case "GROUP_INV":
                          bt.default.group_privacy.invitation_box.enable &&
                            this._setLastReceivedGroupInvitationTime(
                              t,
                              s || 0,
                              i,
                            );
                      }
                    }
                    onInitUnreadRequest() {
                      const e = this._getState();
                      let t = (null == e ? void 0 : e.unread) || ea.unread;
                      const s =
                          (null == e ? void 0 : e.currentView) ||
                          ea.currentView,
                        i = this._getAccessTime(),
                        n = this._getLastRequestAddFriendTime(),
                        a = this._getLastReceivedGroupInvitationTime();
                      n &&
                        i &&
                        (i < n.ts && t.newFriendRequests.push(n.userId),
                        bt.default.group_privacy.invitation_box.enable &&
                          i < a.ts &&
                          t.newGroupInvitations.add(a.groupId),
                        (t.isUnread =
                          t.newFriendRequests.length > 0 ||
                          t.newGroupInvitations.size > 0),
                        this._updateState(
                          { currentView: s, unread: t },
                          ta,
                          !0,
                        ));
                    }
                  }),
                ) || Xn),
            ) || Xn),
        );
        var aa = s("iq5K");
        const ra = (e, t) => {
            const s = Ct.default.simpleStripVietnamese(t).split(" "),
              i = Ct.default.simpleStripVietnamese(e).split(" ");
            return (() => {
              const e = [];
              for (const t of s) {
                let s = !1;
                for (let n = 0; n < i.length; ++n)
                  if (i[n].startsWith(t) && !e.includes(n)) {
                    e.push(n), (s = !0);
                    break;
                  }
                if (!s) return !1;
              }
              return !0;
            })();
          },
          oa = (e) =>
            new Promise((t, s) => {
              if (!e) return t(e);
              setTimeout(() => {
                t(e);
              }, e);
            });
        var da;
        Object($t.b)(qn.f)(
          (da =
            Object(i.injectable)()(
              (da =
                (function (e, t) {
                  return i.ModuleContainer.inject(qn.e)(e, void 0, 0);
                })(
                  (da =
                    (function (e, t) {
                      return i.ModuleContainer.inject(Wt.LabelDataManager)(
                        e,
                        void 0,
                        1,
                      );
                    })(
                      (da =
                        Reflect.metadata(
                          "design:type",
                          Function,
                        )(
                          (da =
                            Reflect.metadata("design:paramtypes", [
                              void 0 === qn.e ? Object : qn.e,
                              void 0 === Wt.LabelDataManager
                                ? Object
                                : Wt.LabelDataManager,
                            ])(
                              (da = class {
                                constructor(e, t) {
                                  (this.friendInfoManager = e),
                                    (this.labelDataManager = t),
                                    (this.type = void 0),
                                    (this.name = void 0),
                                    (this.key = void 0),
                                    (this.listState = void 0),
                                    (this.listFriend = void 0),
                                    (this.initListFriend = void 0),
                                    (this.currentPage = void 0),
                                    (this.didSort = void 0),
                                    (this.eventBusInstance = void 0),
                                    (this._Logger = void 0),
                                    (this.name = qn.d),
                                    (this.key = qn.d),
                                    (this.listState = aa.d),
                                    (this.listFriend = []),
                                    (this.initListFriend = []),
                                    (this.currentPage = 1),
                                    (this.didSort = !1),
                                    (this.eventBusInstance = null),
                                    (this._onHandleConvRemoveLabel =
                                      this._onHandleConvRemoveLabel.bind(this)),
                                    (this._onHandleConvAddLabel =
                                      this._onHandleConvAddLabel.bind(this)),
                                    (this._onHandleRemoveLabel =
                                      this._onHandleRemoveLabel.bind(this));
                                }
                                get Logger() {
                                  return (
                                    this._Logger ||
                                      (this._Logger = i.ModuleContainer.resolve(
                                        q.ZLoggerFactory,
                                      ).createZLogger(
                                        hs.ZLoggerNametags.contactTabV2,
                                        [this.name],
                                      )),
                                    this._Logger
                                  );
                                }
                                _signalRenderList() {
                                  Object(nt.i)(this.name, "all");
                                }
                                _signalRenderItem() {
                                  Object(nt.g)(this.name, "all");
                                }
                                _signalRenderBoth() {
                                  Object(nt.g)(this.name, "all"),
                                    Object(nt.i)(this.name, "all");
                                }
                                _onRemoveFriend(e) {
                                  this.listFriend.includes(e.userId) &&
                                    (this.listFriend.splice(
                                      this.listFriend.indexOf(e.userId),
                                      1,
                                    ),
                                    this.initListFriend.splice(
                                      this.initListFriend.indexOf(e.userId),
                                      1,
                                    ),
                                    (this.listState.totalRecord =
                                      this.listFriend.length),
                                    this._signalRenderBoth());
                                }
                                _onAddFriend(e) {
                                  this.listFriend.includes(e.userId) ||
                                    (this.listFriend.unshift(e.userId),
                                    this.initListFriend.unshift(e.userId),
                                    Jn.addNewFriendUid(e.userId),
                                    this._signalRenderList());
                                }
                                _getItemInfo(e) {
                                  return (
                                    this.friendInfoManager.getItem(
                                      { key: e, version: 1, extraData: null },
                                      null,
                                    ) ||
                                    this.friendInfoManager.loadInfoNotRender({
                                      userId: e,
                                    })
                                  );
                                }
                                _onBlockFriend(e) {
                                  this.friendInfoManager.onLoadInfo({
                                    userId: e.userId,
                                  });
                                }
                                _onUnBlockFriend(e) {
                                  this.friendInfoManager.onLoadInfo({
                                    userId: e.userId,
                                  });
                                }
                                _onEditAlias(e) {
                                  this.friendInfoManager.onLoadInfo({
                                    userId: e.userId,
                                  }),
                                    (this.listFriend = this._handleFilter(
                                      this.listState.searching.searchText,
                                      this.listState.searching.sorter,
                                      this.listState.searching.filter,
                                      !this.isDidSort(),
                                      !1,
                                    )),
                                    (this.listState.totalRecord =
                                      this.listFriend.length),
                                    this._signalRenderBoth();
                                }
                                _onUpdateTagConv(e, t) {
                                  void 0 === t && (t = "add");
                                  let s = !1;
                                  e.convIds.forEach((i) => {
                                    if (
                                      (this.friendInfoManager.onLoadInfo({
                                        userId: i,
                                      }),
                                      this.listState.searching.filter.label
                                        .id &&
                                        this.listState.searching.filter.label
                                          .id === +e.labelId)
                                    ) {
                                      const e = this.listFriend.findIndex(
                                        (e) => e === i,
                                      );
                                      "remove" === t && -1 !== e
                                        ? (this.listFriend.splice(e, 1),
                                          (this.listState.totalRecord =
                                            Math.max(
                                              this.listState.totalRecord - 1,
                                              0,
                                            )),
                                          (s = !0))
                                        : "add" === t &&
                                          -1 === e &&
                                          (this.listFriend.push(i),
                                          (this.listFriend = this._handleFilter(
                                            this.listState.searching.searchText,
                                            this.listState.searching.sorter,
                                            this.listState.searching.filter,
                                            !1,
                                            !1,
                                          )),
                                          (this.listState.totalRecord =
                                            this.listFriend.length),
                                          (s = !0));
                                    }
                                  }),
                                    s && this._signalRenderBoth();
                                }
                                _onHandleConvAddLabel(e) {
                                  this._onUpdateTagConv(e.payload, "add");
                                }
                                _onHandleConvRemoveLabel(e) {
                                  this._onUpdateTagConv(e.payload, "remove");
                                }
                                _onHandleRemoveLabel(e) {
                                  if (
                                    e.payload &&
                                    e.payload.convs &&
                                    e.payload.convs.length
                                  ) {
                                    for (const t of e.payload.convs)
                                      this.friendInfoManager.onLoadInfo({
                                        userId: t,
                                      });
                                    this._signalRenderBoth();
                                  }
                                }
                                addComponentListeners() {
                                  Ye.default.subscribeEventFriend(
                                    R.EventFriend.REMOVE_FRIEND,
                                    this._onRemoveFriend.bind(this),
                                  ),
                                    Ye.default.subscribeEventFriend(
                                      R.EventFriend.ADD_FRIEND,
                                      this._onAddFriend.bind(this),
                                    ),
                                    Ye.default.subscribeEventFriend(
                                      R.EventFriend.BLOCK_FRIEND,
                                      this._onBlockFriend.bind(this),
                                    ),
                                    Ye.default.subscribeEventFriend(
                                      R.EventFriend.UNBLOCK_FRIEND,
                                      this._onUnBlockFriend.bind(this),
                                    ),
                                    (this.eventBusInstance = Mt.default.on(
                                      St.FetchActions.UPDATE_NAME,
                                      this._onEditAlias.bind(this),
                                    )),
                                    this.labelDataManager.addEventListener(
                                      Wt.LabelEvents.LabelAddConvs,
                                      this._onHandleConvAddLabel,
                                    ),
                                    this.labelDataManager.addEventListener(
                                      Wt.LabelEvents.LabelRemoveConvs,
                                      this._onHandleConvRemoveLabel,
                                    ),
                                    this.labelDataManager.addEventListener(
                                      Wt.LabelEvents.RemoveLabel,
                                      this._onHandleRemoveLabel,
                                    );
                                }
                                removeComponentListeners() {
                                  Ye.default.unsubscribeEventFriend(
                                    R.EventFriend.REMOVE_FRIEND,
                                    this._onRemoveFriend.bind(this),
                                  ),
                                    Ye.default.unsubscribeEventFriend(
                                      R.EventFriend.ADD_FRIEND,
                                      this._onAddFriend.bind(this),
                                    ),
                                    Ye.default.unsubscribeEventFriend(
                                      R.EventFriend.BLOCK_FRIEND,
                                      this._onBlockFriend.bind(this),
                                    ),
                                    Ye.default.unsubscribeEventFriend(
                                      R.EventFriend.UNBLOCK_FRIEND,
                                      this._onUnBlockFriend.bind(this),
                                    ),
                                    this.eventBusInstance &&
                                      this.eventBusInstance.remove(),
                                    this.labelDataManager.removeEventListener(
                                      Wt.LabelEvents.LabelAddConvs,
                                      this._onHandleConvAddLabel,
                                    ),
                                    this.labelDataManager.removeEventListener(
                                      Wt.LabelEvents.LabelRemoveConvs,
                                      this._onHandleConvRemoveLabel,
                                    ),
                                    this.labelDataManager.removeEventListener(
                                      Wt.LabelEvents.RemoveLabel,
                                      this._onHandleRemoveLabel,
                                    );
                                }
                                async onLoadList(e) {
                                  try {
                                    const t = await Jn.getFriendList(e);
                                    (this.listFriend = t),
                                      (this.initListFriend = t),
                                      (this.listState.totalRecord = t.length),
                                      (this.listFriend = this._handleFilter(
                                        aa.g.searching.searchText,
                                        aa.g.searching.sorter,
                                        aa.g.searching.filter,
                                        !0,
                                        !1,
                                      )),
                                      (this.initListFriend = this._handleFilter(
                                        aa.g.searching.searchText,
                                        aa.g.searching.sorter,
                                        aa.g.searching.filter,
                                        !0,
                                        !0,
                                      )),
                                      (this.listState.totalRecord =
                                        this.listFriend.length),
                                      this._signalRenderItem(),
                                      this._signalRenderList();
                                  } catch (t) {
                                    this.Logger.zsymb(
                                      18,
                                      11663,
                                      3e4,
                                      "[FriendListController] -> [onLoadList], error: " +
                                        JSON.stringify(t),
                                    );
                                  }
                                }
                                onLoadMore() {
                                  this.currentPage++, this._signalRenderList();
                                }
                                onFilterByName(e) {
                                  if (!e) return [...this.initListFriend];
                                  return [...this.initListFriend].filter(
                                    (t) => {
                                      const s = this._getItemInfo(t);
                                      return ra(
                                        (null == s
                                          ? void 0
                                          : s.displayName.toLowerCase()) || "",
                                        e.toLowerCase(),
                                      );
                                    },
                                  );
                                }
                                onFilterByLabel(e, t) {
                                  if (!e) return t;
                                  if (0 === e.length) return [];
                                  return t.filter((t) => e.includes(t));
                                }
                                onFilterAll(e) {
                                  return e;
                                }
                                onFilterHidden(e, t, s) {
                                  return t || e
                                    ? s
                                    : s.filter((e) => !Jt.a.isThreadHidden(e));
                                }
                                onSortAlpha(e, t) {
                                  if (e === aa.p.DEFAULT) return t;
                                  return t.sort((t, s) => {
                                    const i = this._getItemInfo(t),
                                      n = this._getItemInfo(s);
                                    return ((t, s) => {
                                      const i = /^[a-zA-Z]/,
                                        n = i.test(
                                          Ct.default.simpleStripVietnamese(t),
                                        ),
                                        a = i.test(
                                          Ct.default.simpleStripVietnamese(s),
                                        );
                                      switch (e) {
                                        case aa.p.ALPHA_INCREASE:
                                          return !n && a
                                            ? 1
                                            : n && !a
                                              ? -1
                                              : t.localeCompare(s);
                                        case aa.p.ALPHA_DECREASE:
                                          return !n && a
                                            ? -1
                                            : n && !a
                                              ? 1
                                              : s.localeCompare(t);
                                        default:
                                          return 0;
                                      }
                                    })(
                                      (null == i
                                        ? void 0
                                        : i.displayName.toLowerCase()) ||
                                        (null == i
                                          ? void 0
                                          : i.zaloName.toLowerCase()) ||
                                        "",
                                      (null == n
                                        ? void 0
                                        : n.displayName.toLowerCase()) ||
                                        (null == n
                                          ? void 0
                                          : n.zaloName.toLowerCase()) ||
                                        "",
                                    );
                                  });
                                }
                                onMovingNewFriend(e) {
                                  let t = [],
                                    s = [];
                                  for (let i = e.length - 1; i >= 0; i--) {
                                    const n = this._getItemInfo(e[i]);
                                    null != n && n.isNewFriend
                                      ? t.unshift(null == n ? void 0 : n.userId)
                                      : s.unshift(
                                          null == n ? void 0 : n.userId,
                                        );
                                  }
                                  return [...t, ...s];
                                }
                                _handleFilter(e, t, s, i, n) {
                                  var a;
                                  let r = [];
                                  return (
                                    (r = this.onFilterByName(e)),
                                    (r = this.onFilterByLabel(
                                      null == s ||
                                        null === (a = s.label) ||
                                        void 0 === a
                                        ? void 0
                                        : a.convs,
                                      r,
                                    )),
                                    (r = this.onFilterAll(r)),
                                    (r = this.onSortAlpha(t, r)),
                                    (r = this.onFilterHidden(n, e, r)),
                                    i && (r = this.onMovingNewFriend(r)),
                                    r
                                  );
                                }
                                _checkDidSort(e) {
                                  return (
                                    e !== aa.p.ALPHA_INCREASE
                                      ? (this.didSort = !0)
                                      : (this.didSort = !1),
                                    this.didSort
                                  );
                                }
                                isDidSort() {
                                  return this.didSort;
                                }
                                _updateInitListFriendWithoutDockNewFriends() {
                                  (this.initListFriend = this._handleFilter(
                                    aa.g.searching.searchText,
                                    aa.g.searching.sorter,
                                    aa.g.searching.filter,
                                    !1,
                                    !0,
                                  )),
                                    (this.listState.totalRecord =
                                      this.listFriend.length);
                                }
                                onFilter(e, t, s) {
                                  const i = this._checkDidSort(t);
                                  i &&
                                    this._updateInitListFriendWithoutDockNewFriends(),
                                    (this.listFriend = this._handleFilter(
                                      e,
                                      t,
                                      s,
                                      !i,
                                      !1,
                                    )),
                                    (this.listState.totalRecord =
                                      this.listFriend.length),
                                    this._signalRenderItem(),
                                    this._signalRenderList();
                                }
                                init(e) {
                                  throw new Error("Method not implemented.");
                                }
                                getItem(e, t) {
                                  return this.listState;
                                }
                                getList(e, t) {
                                  return this.listFriend;
                                }
                                onGetItemFailure(e, t) {
                                  throw new Error("Method not implemented.");
                                }
                                onGetListFailure(e, t) {
                                  throw new Error("Method not implemented.");
                                }
                                getDefaultItem() {
                                  throw new Error("Method not implemented.");
                                }
                                getDefaultList() {
                                  throw new Error("Method not implemented.");
                                }
                                setSearchText(e) {
                                  (this.listState.searching.searchText = e),
                                    this._signalRenderItem();
                                }
                                setSorter(e) {
                                  (this.listState.searching.sorter = e),
                                    this._signalRenderItem();
                                }
                                setFilter(e) {
                                  (this.listState.searching.filter = e),
                                    this._signalRenderItem();
                                }
                                getFilter() {
                                  return this.listState.searching.filter;
                                }
                                getSorter() {
                                  return this.listState.searching.sorter;
                                }
                                resetData() {
                                  (this.listFriend = []),
                                    (this.initListFriend = []);
                                }
                                resetState() {
                                  (this.listState = {
                                    totalRecord: 0,
                                    searching: {
                                      searchText: "",
                                      sorter: aa.p.ALPHA_INCREASE,
                                      filter: {
                                        label: { convs: null, id: null },
                                        admin: "",
                                        all: !0,
                                      },
                                    },
                                  }),
                                    (this.currentPage = 1),
                                    (this.didSort = !1);
                                }
                              }),
                            ) || da),
                        ) || da),
                    ) || da),
                ) || da),
            ) || da),
        );
        var la;
        Object($t.b)(qn.e)(
          (la =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (la =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (la = class {
                    constructor() {
                      (this.type = void 0),
                        (this.name = void 0),
                        (this.key = void 0),
                        (this.data = new Map()),
                        (this.name = qn.c),
                        (this.key = qn.c);
                    }
                    init(e) {
                      throw new Error("Method not implemented.");
                    }
                    onLoadInfo(e) {
                      const t = Jn.getFriendInfo(e);
                      t &&
                        (this.data.set(e.userId, t),
                        Object(nt.g)(this.name, e.userId));
                    }
                    loadInfoNotRender(e) {
                      const t = Jn.getFriendInfo(e);
                      return t ? (this.data.set(e.userId, t), t) : null;
                    }
                    getItem(e, t) {
                      return this.data.get(e.key);
                    }
                    getList(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    onGetItemFailure(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    onGetListFailure(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    getDefaultItem() {
                      throw new Error("Method not implemented.");
                    }
                    getDefaultList() {
                      throw new Error("Method not implemented.");
                    }
                    resetData() {
                      this.data.clear();
                    }
                  }),
                ) || la),
            ) || la),
        );
        var ca;
        Object($t.b)(qn.k)(
          (ca =
            Object(i.injectable)()(
              (ca =
                (function (e, t) {
                  return i.ModuleContainer.inject(qn.i)(e, void 0, 0);
                })(
                  (ca =
                    (function (e, t) {
                      return i.ModuleContainer.inject(zt.i)(e, void 0, 1);
                    })(
                      (ca =
                        (function (e, t) {
                          return i.ModuleContainer.inject(Wt.LabelDataManager)(
                            e,
                            void 0,
                            2,
                          );
                        })(
                          (ca =
                            Reflect.metadata(
                              "design:type",
                              Function,
                            )(
                              (ca =
                                Reflect.metadata("design:paramtypes", [
                                  void 0 === qn.i ? Object : qn.i,
                                  void 0 === zt.i ? Object : zt.i,
                                  void 0 === Wt.LabelDataManager
                                    ? Object
                                    : Wt.LabelDataManager,
                                ])(
                                  (ca = class {
                                    constructor(e, t, s) {
                                      (this.groupInfoManager = e),
                                        (this.previewDataManager = t),
                                        (this.labelDataManager = s),
                                        (this.type = void 0),
                                        (this.name = void 0),
                                        (this.key = void 0),
                                        (this.listState = void 0),
                                        (this.listGroup = void 0),
                                        (this.initListGroup = void 0),
                                        (this.currentPage = void 0),
                                        (this._Logger = void 0),
                                        (this.name = qn.h),
                                        (this.key = qn.h),
                                        (this.listState = aa.e),
                                        (this.listGroup = []),
                                        (this.initListGroup = []),
                                        (this.currentPage = 1),
                                        (this._onHandleConvRemoveLabel =
                                          this._onHandleConvRemoveLabel.bind(
                                            this,
                                          )),
                                        (this._onHandleConvAddLabel =
                                          this._onHandleConvAddLabel.bind(
                                            this,
                                          )),
                                        (this._onHandleRemoveLabel =
                                          this._onHandleRemoveLabel.bind(this));
                                    }
                                    get Logger() {
                                      return (
                                        this._Logger ||
                                          (this._Logger =
                                            i.ModuleContainer.resolve(
                                              q.ZLoggerFactory,
                                            ).createZLogger(
                                              hs.ZLoggerNametags.contactTabV2,
                                              [this.name],
                                            )),
                                        this._Logger
                                      );
                                    }
                                    _signalRenderList() {
                                      Object(nt.i)(this.name, "all");
                                    }
                                    _signalRenderItem() {
                                      Object(nt.g)(this.name, "all");
                                    }
                                    _signalRenderBoth() {
                                      Object(nt.g)(this.name, "all"),
                                        Object(nt.i)(this.name, "all");
                                    }
                                    _getItemInfo(e) {
                                      return (
                                        this.groupInfoManager.getItem(
                                          {
                                            key: e,
                                            version: 1,
                                            extraData: null,
                                          },
                                          null,
                                        ) ||
                                        this.groupInfoManager.loadInfoNotRender(
                                          { userId: e },
                                        )
                                      );
                                    }
                                    init(e) {
                                      throw new Error(
                                        "Method not implemented.",
                                      );
                                    }
                                    getItem(e, t) {
                                      return this.listState;
                                    }
                                    async onLoadList() {
                                      try {
                                        const e = await Qn.getGroupList({});
                                        (this.listGroup = e),
                                          (this.initListGroup = e),
                                          (this.listState.totalRecord =
                                            e.length),
                                          this.groupInfoManager.loadMultiGroupInfo(
                                            this.initListGroup,
                                          ),
                                          (this.listGroup = this._handleFilter(
                                            aa.h.searching.searchText,
                                            aa.h.searching.sorter,
                                            aa.h.searching.filter,
                                            !1,
                                          )),
                                          (this.initListGroup =
                                            this._handleFilter(
                                              aa.h.searching.searchText,
                                              aa.h.searching.sorter,
                                              aa.h.searching.filter,
                                              !0,
                                            )),
                                          (this.listState.totalRecord =
                                            this.listGroup.length),
                                          this._signalRenderItem(),
                                          this._signalRenderList();
                                      } catch (e) {
                                        this.Logger.zsymb(
                                          18,
                                          11662,
                                          3e4,
                                          "[GroupListController] -> [onLoadList], error: " +
                                            JSON.stringify(e),
                                        );
                                      }
                                    }
                                    onLoadMore() {
                                      this.currentPage++,
                                        this._signalRenderList();
                                    }
                                    onFilterByName(e) {
                                      if (!e) return [...this.initListGroup];
                                      return this.initListGroup.filter((t) => {
                                        const s = this._getItemInfo(t);
                                        return ra(
                                          (null == s
                                            ? void 0
                                            : s.displayName.toLowerCase()) ||
                                            "",
                                          e.toLowerCase(),
                                        );
                                      });
                                    }
                                    onFilterByLabel(e, t) {
                                      if (!e) return t;
                                      if (0 === e.length) return [];
                                      return t.filter((t) => e.includes(t));
                                    }
                                    onFilterMyAdminGroup(e, t) {
                                      if (!e) return t;
                                      return t.filter((t) => {
                                        const s = this._getItemInfo(t);
                                        return (
                                          (null == s ? void 0 : s.creatorId) ===
                                          e
                                        );
                                      });
                                    }
                                    onFilterAll(e) {
                                      return e;
                                    }
                                    onSortAlpha(e, t) {
                                      return e === aa.p.DEFAULT ||
                                        e === aa.p.ACTION_INCREASE ||
                                        e === aa.p.ACTION_DECREASE
                                        ? t
                                        : t.sort((t, s) => {
                                            const i = this._getItemInfo(t),
                                              n = this._getItemInfo(s),
                                              a =
                                                (null == i
                                                  ? void 0
                                                  : i.displayName.toLowerCase()) ||
                                                "",
                                              r =
                                                (null == n
                                                  ? void 0
                                                  : n.displayName.toLowerCase()) ||
                                                "";
                                            switch (e) {
                                              case aa.p.ALPHA_INCREASE:
                                                return a.localeCompare(r);
                                              case aa.p.ALPHA_DECREASE:
                                                return r.localeCompare(a);
                                              default:
                                                return 0;
                                            }
                                          });
                                    }
                                    onFilterHidden(e, t, s) {
                                      return t || e
                                        ? s
                                        : s.filter(
                                            (e) => !Jt.a.isThreadHidden(e),
                                          );
                                    }
                                    onSortActionTime(e, t) {
                                      return e === aa.p.DEFAULT ||
                                        e === aa.p.ALPHA_INCREASE ||
                                        e === aa.p.ALPHA_DECREASE
                                        ? t
                                        : t.sort((t, s) => {
                                            var i, n;
                                            const a =
                                                (null ===
                                                  (i =
                                                    this.previewDataManager.getPreviewByIDSync(
                                                      t,
                                                    )) || void 0 === i
                                                  ? void 0
                                                  : i.messageTime) || 0,
                                              r =
                                                (null ===
                                                  (n =
                                                    this.previewDataManager.getPreviewByIDSync(
                                                      s,
                                                    )) || void 0 === n
                                                  ? void 0
                                                  : n.messageTime) || 0;
                                            switch (e) {
                                              case aa.p.ACTION_DECREASE:
                                                if (r && a) {
                                                  if (r > a) return 1;
                                                  if (r < a) return -1;
                                                }
                                                return r && !a
                                                  ? 1
                                                  : !r && a
                                                    ? -1
                                                    : 0;
                                              case aa.p.ACTION_INCREASE:
                                                if (r && a) {
                                                  if (r < a) return 1;
                                                  if (r > a) return -1;
                                                }
                                                return !r && a
                                                  ? 1
                                                  : r && !a
                                                    ? -1
                                                    : 0;
                                              default:
                                                return 0;
                                            }
                                          });
                                    }
                                    _handleFilter(e, t, s, i) {
                                      var n;
                                      let a = [];
                                      return (
                                        (a = this.onFilterByName(e)),
                                        (a = this.onFilterByLabel(
                                          null == s ||
                                            null === (n = s.label) ||
                                            void 0 === n
                                            ? void 0
                                            : n.convs,
                                          a,
                                        )),
                                        (a = this.onFilterMyAdminGroup(
                                          (null == s ? void 0 : s.admin) || "",
                                          a,
                                        )),
                                        (a = this.onFilterAll(a)),
                                        (a = this.onSortAlpha(t, a)),
                                        (a = this.onSortActionTime(t, a)),
                                        (a = this.onFilterHidden(i, e, a)),
                                        a
                                      );
                                    }
                                    onFilter(e, t, s) {
                                      (this.listGroup = this._handleFilter(
                                        e,
                                        t,
                                        s,
                                        !1,
                                      )),
                                        (this.listState.totalRecord =
                                          this.listGroup.length),
                                        this._signalRenderItem(),
                                        this._signalRenderList();
                                    }
                                    _onUpdateTagConv(e, t) {
                                      void 0 === t && (t = "add");
                                      let s = !1;
                                      e.convIds.forEach((i) => {
                                        if (
                                          (this.groupInfoManager.onLoadInfo({
                                            userId: i,
                                          }),
                                          this.listState.searching.filter.label
                                            .id &&
                                            this.listState.searching.filter
                                              .label.id === +e.labelId)
                                        ) {
                                          const e = this.listGroup.findIndex(
                                            (e) => e === i,
                                          );
                                          "remove" === t && -1 !== e
                                            ? (this.listGroup.splice(e, 1),
                                              (this.listState.totalRecord =
                                                Math.max(
                                                  this.listState.totalRecord -
                                                    1,
                                                  0,
                                                )),
                                              (s = !0))
                                            : "add" === t &&
                                              -1 === e &&
                                              (this.listGroup.push(i),
                                              (this.listGroup =
                                                this._handleFilter(
                                                  this.listState.searching
                                                    .searchText,
                                                  this.listState.searching
                                                    .sorter,
                                                  this.listState.searching
                                                    .filter,
                                                  !1,
                                                )),
                                              (this.listState.totalRecord =
                                                this.listGroup.length),
                                              (s = !0));
                                        }
                                      }),
                                        s && this._signalRenderBoth();
                                    }
                                    _onHandleConvAddLabel(e) {
                                      this._onUpdateTagConv(e.payload, "add");
                                    }
                                    _onHandleConvRemoveLabel(e) {
                                      this._onUpdateTagConv(
                                        e.payload,
                                        "remove",
                                      );
                                    }
                                    _onHandleRemoveLabel(e) {
                                      if (
                                        e.payload &&
                                        e.payload.convs &&
                                        e.payload.convs.length
                                      ) {
                                        for (const t of e.payload.convs)
                                          this.groupInfoManager.onLoadInfo({
                                            userId: t,
                                          });
                                        this._signalRenderBoth();
                                      }
                                    }
                                    _onLeaveGroup(e) {
                                      for (let t = 0; t < e.length; t++) {
                                        if (!this.listGroup.includes(e[t]))
                                          return;
                                        this.listGroup.splice(
                                          this.listGroup.indexOf(e[t]),
                                          1,
                                        ),
                                          this.initListGroup.splice(
                                            this.listGroup.indexOf(e[t]),
                                            1,
                                          ),
                                          (this.listState.totalRecord =
                                            this.listGroup.length);
                                      }
                                      this._signalRenderBoth();
                                    }
                                    addComponentListeners() {
                                      ds.default.subscribeEventGroup(
                                        R.EventGroup.LEAVE_GROUP,
                                        this._onLeaveGroup.bind(this),
                                      ),
                                        this.labelDataManager.addEventListener(
                                          Wt.LabelEvents.LabelAddConvs,
                                          this._onHandleConvAddLabel,
                                        ),
                                        this.labelDataManager.addEventListener(
                                          Wt.LabelEvents.LabelRemoveConvs,
                                          this._onHandleConvRemoveLabel,
                                        ),
                                        this.labelDataManager.addEventListener(
                                          Wt.LabelEvents.RemoveLabel,
                                          this._onHandleRemoveLabel,
                                        );
                                    }
                                    removeComponentListeners() {
                                      ds.default.unsubscribeEventGroup(
                                        R.EventGroup.LEAVE_GROUP,
                                        this._onLeaveGroup.bind(this),
                                      ),
                                        this.labelDataManager.removeEventListener(
                                          Wt.LabelEvents.LabelAddConvs,
                                          this._onHandleConvAddLabel,
                                        ),
                                        this.labelDataManager.removeEventListener(
                                          Wt.LabelEvents.LabelRemoveConvs,
                                          this._onHandleConvRemoveLabel,
                                        ),
                                        this.labelDataManager.removeEventListener(
                                          Wt.LabelEvents.RemoveLabel,
                                          this._onHandleRemoveLabel,
                                        );
                                    }
                                    getList(e, t) {
                                      return this.listGroup;
                                    }
                                    onGetItemFailure(e, t) {
                                      throw new Error(
                                        "Method not implemented.",
                                      );
                                    }
                                    onGetListFailure(e, t) {
                                      throw new Error(
                                        "Method not implemented.",
                                      );
                                    }
                                    getDefaultItem() {
                                      throw new Error(
                                        "Method not implemented.",
                                      );
                                    }
                                    getDefaultList() {
                                      throw new Error(
                                        "Method not implemented.",
                                      );
                                    }
                                    setSearchText(e) {
                                      (this.listState.searching.searchText = e),
                                        this._signalRenderItem();
                                    }
                                    setSorter(e) {
                                      (this.listState.searching.sorter = e),
                                        this._signalRenderItem();
                                    }
                                    setFilter(e) {
                                      (this.listState.searching.filter = e),
                                        this._signalRenderItem();
                                    }
                                    getFilter() {
                                      return this.listState.searching.filter;
                                    }
                                    getSorter() {
                                      return this.listState.searching.sorter;
                                    }
                                    resetData() {
                                      (this.listGroup = []),
                                        (this.initListGroup = []);
                                    }
                                    resetState() {
                                      (this.listState = {
                                        totalRecord: 0,
                                        searching: {
                                          searchText: "",
                                          sorter: aa.p.ACTION_DECREASE,
                                          filter: {
                                            label: { convs: null, id: null },
                                            admin: "",
                                            all: !0,
                                          },
                                        },
                                      }),
                                        (this.currentPage = 1);
                                    }
                                  }),
                                ) || ca),
                            ) || ca),
                        ) || ca),
                    ) || ca),
                ) || ca),
            ) || ca),
        );
        var ha;
        let ua;
        Object($t.b)(qn.i)(
          (ha =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (ha =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (ha = class {
                    constructor() {
                      (this.type = void 0),
                        (this.name = void 0),
                        (this.key = void 0),
                        (this.data = new Map()),
                        (this.name = qn.g),
                        (this.key = qn.g);
                    }
                    init(e) {
                      throw new Error("Method not implemented.");
                    }
                    async onLoadInfo(e) {
                      const t = Qn.getGroupInfoSync(e);
                      t &&
                        (this.data.set(e.userId, t),
                        Object(nt.g)(this.name, e.userId));
                    }
                    loadInfoNotRender(e) {
                      const t = Qn.getGroupInfoSync(e);
                      return t ? (this.data.set(e.userId, t), t) : null;
                    }
                    loadMultiGroupInfo(e) {
                      for (const t of e) this.loadInfoNotRender({ userId: t });
                    }
                    openGroupMemberPopup(e) {
                      const t = this.data.get(e);
                      Je.ModalManagerV2.openModal({
                        windowId: "1",
                        name: R.ModalIdentitiesDefine.FRIEND_PROFILE,
                        params: { group_member: t },
                      });
                    }
                    getItem(e, t) {
                      return this.data.get(e.key);
                    }
                    getList(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    onGetItemFailure(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    onGetListFailure(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    getDefaultItem() {
                      throw new Error("Method not implemented.");
                    }
                    getDefaultList() {
                      throw new Error("Method not implemented.");
                    }
                    resetData() {
                      this.data.clear();
                    }
                  }),
                ) || ha),
            ) || ha),
        );
        !(function (e) {
          (e[(e.RECOMMEND = 1)] = "RECOMMEND"),
            (e[(e.RECEIVE = 2)] = "RECEIVE");
        })(ua || (ua = {}));
        const ga = 500,
          ma = 500;
        var pa;
        Object($t.b)(qn.n)(
          (pa =
            (function (e, t) {
              return i.ModuleContainer.inject(qn.b)(e, void 0, 0);
            })(
              (pa =
                Reflect.metadata(
                  "design:type",
                  Function,
                )(
                  (pa =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === qn.b ? Object : qn.b,
                    ])(
                      (pa = class extends te.b {
                        constructor(e) {
                          super(),
                            (this.contactTabController = e),
                            (this.type = void 0),
                            (this.name = void 0),
                            (this.key = void 0),
                            (this.data = new Map()),
                            (this._Logger = void 0),
                            (this.name = qn.l),
                            (this.key = qn.l),
                            this.data.set("all", {
                              isLoadingRecommendFriendList: !1,
                              isLoadingRequestedFriendList: !1,
                              listFriendReceived: [],
                              listFriendSent: [],
                              listFriendSuggest: [],
                              mapRelatedGroup: {},
                            }),
                            this.addPublicListeners();
                        }
                        get Logger() {
                          return (
                            this._Logger ||
                              (this._Logger = i.ModuleContainer.resolve(
                                q.ZLoggerFactory,
                              ).createZLogger(hs.ZLoggerNametags.contactTabV2, [
                                this.name,
                              ])),
                            this._Logger
                          );
                        }
                        _signalRenderItem() {
                          Object(nt.g)(this.name, "all");
                        }
                        init(e) {
                          throw new Error("Method not implemented.");
                        }
                        getItem(e, t) {
                          return this.data.get(e.key);
                        }
                        _updateLoadingState(e, t) {
                          const {
                            listFriendReceived: s = [],
                            listFriendSuggest: i = [],
                            listFriendSent: n = [],
                          } = this.data.get("all") || {};
                          let {
                            isLoadingRecommendFriendList: a,
                            isLoadingRequestedFriendList: r,
                          } = this.data.get("all") || {};
                          if ("RecommendFriendList" === e)
                            switch (t) {
                              case "ON":
                                a ||
                                  0 !== s.length ||
                                  0 !== i.length ||
                                  (a = !0);
                                break;
                              case "OFF":
                                a && (a = !1);
                            }
                          if ("RequestedFriendList" === e)
                            switch (t) {
                              case "ON":
                                r || 0 !== n.length || (r = !0);
                                break;
                              case "OFF":
                                r && (r = !1);
                            }
                          this.data.set(
                            "all",
                            Object(f.a)(
                              Object(f.a)({}, this.data.get("all")),
                              {},
                              {
                                isLoadingRecommendFriendList: a,
                                isLoadingRequestedFriendList: r,
                              },
                            ),
                          ),
                            this._signalRenderItem();
                        }
                        async onLoadRequestedFriendList() {
                          const e = Date.now();
                          try {
                            this._updateLoadingState(
                              "RequestedFriendList",
                              "ON",
                            );
                            const t = await Yn.getRequestedFriendList();
                            Date.now() - e < ga && (await oa(ma)),
                              this._updateLoadingState(
                                "RequestedFriendList",
                                "OFF",
                              );
                            const s = Object.keys(t)
                                .map((e) => t[e])
                                .sort((e, t) => {
                                  var s, i;
                                  const n =
                                      null === (s = e.fReqInfo) || void 0 === s
                                        ? void 0
                                        : s.time,
                                    a =
                                      null === (i = t.fReqInfo) || void 0 === i
                                        ? void 0
                                        : i.time;
                                  return a > n ? 1 : a < n ? -1 : 0;
                                }),
                              {
                                listFriendReceived: i = [],
                                listFriendSuggest: n = [],
                                mapRelatedGroup: a = {},
                              } = this.data.get("all") || {};
                            this.data.set(
                              "all",
                              Object(f.a)(
                                Object(f.a)({}, this.data.get("all")),
                                {},
                                {
                                  listFriendReceived: i,
                                  listFriendSent: s,
                                  listFriendSuggest: n,
                                  mapRelatedGroup: a,
                                },
                              ),
                            ),
                              this._signalRenderItem();
                          } catch (t) {
                            Date.now() - e < ga && (await oa(ma)),
                              this._updateLoadingState(
                                "RequestedFriendList",
                                "OFF",
                              ),
                              this.Logger.zsymb(
                                18,
                                12907,
                                3e4,
                                "[InvitationController] -> [onLoadRequestedFriendList], error: " +
                                  JSON.stringify(t),
                              );
                          }
                        }
                        async onLoadRecommendFriendList() {
                          const e = Date.now();
                          try {
                            this._updateLoadingState(
                              "RecommendFriendList",
                              "ON",
                            );
                            const t = await Yn.getRecommendFriendList();
                            if (
                              (Date.now() - e < ga && (await oa(ma)),
                              this._updateLoadingState(
                                "RecommendFriendList",
                                "OFF",
                              ),
                              Array.isArray(t) && t.length > 0)
                            ) {
                              const e = t.filter((e) => {
                                  var t;
                                  return (
                                    (null === (t = e.dataInfo) || void 0 === t
                                      ? void 0
                                      : t.recommType) === ua.RECEIVE
                                  );
                                }),
                                s = t.filter((e) => {
                                  var t;
                                  return (
                                    (null === (t = e.dataInfo) || void 0 === t
                                      ? void 0
                                      : t.recommType) === ua.RECOMMEND
                                  );
                                }),
                                {
                                  listFriendSent: i = [],
                                  mapRelatedGroup: n = {},
                                } = this.data.get("all") || {};
                              this.data.set(
                                "all",
                                Object(f.a)(
                                  Object(f.a)({}, this.data.get("all")),
                                  {},
                                  {
                                    listFriendReceived: e,
                                    listFriendSent: i,
                                    listFriendSuggest: s,
                                    mapRelatedGroup: n,
                                  },
                                ),
                              ),
                                s.length > 0 &&
                                  this.dispatchEvent(
                                    new Zn.e(Zn.d.LoadRelatedGroups, "", {}),
                                  ),
                                this._signalRenderItem();
                            }
                          } catch (t) {
                            Date.now() - e < ga && (await oa(ma)),
                              this._updateLoadingState(
                                "RecommendFriendList",
                                "OFF",
                              ),
                              this.Logger.zsymb(
                                18,
                                12907,
                                30001,
                                "[InvitationController] -> [onLoadRecommendFriendList], error: " +
                                  JSON.stringify(t),
                              );
                          }
                        }
                        _handleSortFriendSuggestList(e, t) {
                          return 0 === e.length
                            ? e
                            : e.sort((e, s) => {
                                var i, n, a, r, o, d;
                                const l =
                                    t[
                                      null === (i = e.dataInfo) || void 0 === i
                                        ? void 0
                                        : i.userId
                                    ] &&
                                    t[
                                      null === (n = e.dataInfo) || void 0 === n
                                        ? void 0
                                        : n.userId
                                    ].length,
                                  c =
                                    (null === (a = e.dataInfo) || void 0 === a
                                      ? void 0
                                      : a.displayName) || "",
                                  h =
                                    t[
                                      null === (r = s.dataInfo) || void 0 === r
                                        ? void 0
                                        : r.userId
                                    ] &&
                                    t[
                                      null === (o = s.dataInfo) || void 0 === o
                                        ? void 0
                                        : o.userId
                                    ].length,
                                  u =
                                    (null === (d = s.dataInfo) || void 0 === d
                                      ? void 0
                                      : d.displayName) || "";
                                return l && h
                                  ? l === h
                                    ? c.localeCompare(u)
                                    : h > l
                                      ? 1
                                      : -1
                                  : l && !h
                                    ? -1
                                    : !l && h
                                      ? 1
                                      : l || h
                                        ? 0
                                        : c.localeCompare(u);
                              });
                        }
                        async onLoadRelatedGroupList() {
                          try {
                            const { listFriendSuggest: e = [] } =
                                this.data.get("all") || {},
                              t = e.map((e) => {
                                var t;
                                return null == e ||
                                  null === (t = e.dataInfo) ||
                                  void 0 === t
                                  ? void 0
                                  : t.userId;
                              }),
                              s = await Yn.getRelatedGroup(t),
                              {
                                listFriendReceived: i = [],
                                listFriendSent: n = [],
                              } = this.data.get("all") || {},
                              a = this._handleSortFriendSuggestList(
                                e,
                                s.groupRelateds,
                              );
                            this.data.set(
                              "all",
                              Object(f.a)(
                                Object(f.a)({}, this.data.get("all")),
                                {},
                                {
                                  listFriendReceived: i,
                                  listFriendSent: n,
                                  listFriendSuggest: a,
                                  mapRelatedGroup: s.groupRelateds || {},
                                },
                              ),
                            ),
                              this._signalRenderItem();
                          } catch (e) {
                            this.Logger.zsymb(
                              18,
                              12907,
                              30002,
                              "[InvitationController] -> [onLoadRelatedGroupList], error: " +
                                JSON.stringify(e),
                            );
                          }
                        }
                        handleFriendProfileChange(e) {
                          const {
                            listFriendReceived: t = [],
                            listFriendSuggest: s = [],
                            listFriendSent: i = [],
                          } = this.data.get("all") || {};
                          Object.keys(e).forEach((e) => {
                            const n = Ye.default.getDName(e),
                              a = t.findIndex((t) => t.dataInfo.userId === e);
                            -1 !== a && (t[a].displayName = n);
                            const r = s.findIndex(
                              (t) => t.dataInfo.userId === e,
                            );
                            -1 !== r && (s[r].displayName = n);
                            const o = i.findIndex((t) => t.userId === e);
                            -1 !== o && (i[o].displayName = n);
                          }),
                            this._signalRenderItem();
                        }
                        handlePublicFriendEvents(e) {
                          const t = e.payload;
                          if (t)
                            for (let i = 0; i < t.length; i++) {
                              var s;
                              const n = t[i].ts,
                                a =
                                  ("add" === t[i].act && t[i].data) ||
                                  (null === (s = t[i].data) || void 0 === s
                                    ? void 0
                                    : s.fromUid),
                                r = a === e.userId;
                              if (n && a && !r && "fr" === t[i].act_type)
                                switch (t[i].act) {
                                  case "req_v2":
                                    this.contactTabController.onUpdateRequestTracking(
                                      "FRIEND",
                                      "NEW",
                                      n,
                                      a,
                                    );
                                    break;
                                  case "undo_req":
                                    this.contactTabController.onUpdateRequestTracking(
                                      "FRIEND",
                                      "REMOVE",
                                      n,
                                      a,
                                    ),
                                      this.dispatchEvent(
                                        new Zn.e(
                                          Zn.d.UndoAddFriendEvent,
                                          "",
                                          a,
                                        ),
                                      );
                                    break;
                                  case "add":
                                    this.contactTabController.onUpdateRequestTracking(
                                      "FRIEND",
                                      "REMOVE",
                                      n,
                                      a,
                                    ),
                                      this.dispatchEvent(
                                        new Zn.e(
                                          Zn.d.AcceptAddFriendEvent,
                                          "",
                                          a,
                                        ),
                                      );
                                    break;
                                  case "reject":
                                    this.contactTabController.onUpdateRequestTracking(
                                      "FRIEND",
                                      "REMOVE",
                                      n,
                                      a,
                                    ),
                                      this.dispatchEvent(
                                        new Zn.e(
                                          Zn.d.RejectAddFriendEvent,
                                          "",
                                          a,
                                        ),
                                      );
                                }
                            }
                        }
                        handlePublicAddFriendEvent(e) {
                          let t = [];
                          const s = e.payload;
                          if (s) {
                            for (let e = 0; e < s.length; e++) {
                              let i = {};
                              (i.userId = s[e].userId),
                                (i.zaloName = s[e].zaloName),
                                (i.avatar = s[e].avatar),
                                (i.displayName = s[e].displayName),
                                (i.recommInfo = {
                                  message: s[e].friendRequestMsg,
                                  source: s[e].friendRequestSource,
                                }),
                                (i.recommTime = s[e].friendRequestFetchTime),
                                (i.recommType = s[e].friendRequestType),
                                t.push({ dataInfo: i, recommItemType: 1 });
                            }
                            this.dispatchEvent(
                              new Zn.e(Zn.d.ReceiveAddFriendEvent, "", t),
                            );
                          }
                        }
                        addPublicListeners() {
                          this.addEventListener(
                            Zn.d.PublicInvitationEvents,
                            this.handlePublicFriendEvents.bind(this),
                          ),
                            this.addEventListener(
                              Zn.d.PublicReceiveAddFriendEvent,
                              this.handlePublicAddFriendEvent.bind(this),
                            ),
                            Ye.default.connectSignalChangeDNameAndAvatar(
                              this.handleFriendProfileChange.bind(this),
                            );
                        }
                        addComponentListeners() {}
                        removeComponentListeners() {}
                        _addFriendReceived(e) {
                          const {
                              listFriendReceived: t = [],
                              listFriendSent: s = [],
                              listFriendSuggest: i = [],
                              mapRelatedGroup: n = {},
                            } = this.data.get("all") || {},
                            a = e.concat(t);
                          this.data.set(
                            "all",
                            Object(f.a)(
                              Object(f.a)({}, this.data.get("all")),
                              {},
                              {
                                listFriendReceived: a,
                                listFriendSent: s,
                                listFriendSuggest: i,
                                mapRelatedGroup: n,
                              },
                            ),
                          ),
                            this._signalRenderItem();
                        }
                        _removeFriendReceived(e) {
                          const {
                              listFriendReceived: t = [],
                              listFriendSent: s = [],
                              listFriendSuggest: i = [],
                              mapRelatedGroup: n = {},
                            } = this.data.get("all") || {},
                            a = t.filter((t) => {
                              var s;
                              return (
                                (null === (s = t.dataInfo) || void 0 === s
                                  ? void 0
                                  : s.userId) !== e
                              );
                            });
                          this.data.set(
                            "all",
                            Object(f.a)(
                              Object(f.a)({}, this.data.get("all")),
                              {},
                              {
                                listFriendReceived: a,
                                listFriendSent: s,
                                listFriendSuggest: i,
                                mapRelatedGroup: n,
                              },
                            ),
                          ),
                            this._signalRenderItem();
                        }
                        onUpdateFriendRequests(e, t) {
                          switch (t) {
                            case "ADD":
                              this._addFriendReceived(e);
                              break;
                            case "REMOVE":
                              this._removeFriendReceived(e);
                          }
                        }
                        async onRejectFriend(e) {
                          return new Promise((t, s) => {
                            Yn.rejectAddFriend(e)
                              .then(() => {
                                this._removeFriendReceived(e), t(e);
                              })
                              .catch((e) => {
                                this.Logger.zsymb(
                                  18,
                                  12907,
                                  30003,
                                  "[InvitationController] -> [onRejectFriend], error: " +
                                    JSON.stringify(e),
                                ),
                                  s(e);
                              });
                          });
                        }
                        async onAddFriend(e) {
                          return new Promise((t, s) => {
                            Yn.acceptAddFriend(e)
                              .then(t)
                              .catch((e) => {
                                this.Logger.zsymb(
                                  18,
                                  12907,
                                  30004,
                                  "[InvitationController] -> [onAddFriend], error: " +
                                    JSON.stringify(e),
                                ),
                                  s(e);
                              });
                          });
                        }
                        removeFriendSent(e) {
                          const {
                              listFriendReceived: t = [],
                              listFriendSent: s = [],
                              listFriendSuggest: i = [],
                              mapRelatedGroup: n = {},
                            } = this.data.get("all") || {},
                            a = s.filter(
                              (t) => (null == t ? void 0 : t.userId) !== e,
                            );
                          this.data.set(
                            "all",
                            Object(f.a)(
                              Object(f.a)({}, this.data.get("all")),
                              {},
                              {
                                listFriendReceived: t,
                                listFriendSent: a,
                                listFriendSuggest: i,
                                mapRelatedGroup: n,
                              },
                            ),
                          ),
                            this._signalRenderItem();
                        }
                        onRemoveFriendSent(e) {
                          Yn.makeUndoSentRequestFriend(e)
                            .then(() => {
                              this.removeFriendSent(e.userId);
                            })
                            .catch((e) => {
                              this.Logger.zsymb(
                                18,
                                12907,
                                30005,
                                "[InvitationController] -> [onRemoveFriendSent], error: " +
                                  JSON.stringify(e),
                              ),
                                e && 301 == e.error_code
                                  ? et.a.createError(
                                      tt.default.str(
                                        "STR_UNDO_REQUEST_ERROR_301",
                                      ),
                                    )
                                  : e && "ERR_NO_NETWORK" === e.code
                                    ? et.a.createError(
                                        tt.default.str("STR_CHECK_NET"),
                                      )
                                    : et.a.createError(
                                        tt.default.str(
                                          "STR_UNDO_REQUEST_ERROR_UNKNOWN",
                                        ),
                                      );
                            });
                        }
                        _removeFriendSuggest(e) {
                          const {
                              listFriendReceived: t = [],
                              listFriendSent: s = [],
                              listFriendSuggest: i = [],
                              mapRelatedGroup: n = {},
                            } = this.data.get("all") || {},
                            a = i.filter((t) => {
                              var s;
                              return (
                                (null == t ||
                                null === (s = t.dataInfo) ||
                                void 0 === s
                                  ? void 0
                                  : s.userId) !== e
                              );
                            });
                          this.data.set(
                            "all",
                            Object(f.a)(
                              Object(f.a)({}, this.data.get("all")),
                              {},
                              {
                                listFriendReceived: t,
                                listFriendSent: s,
                                listFriendSuggest: a,
                                mapRelatedGroup: n,
                              },
                            ),
                          ),
                            this._signalRenderItem();
                        }
                        onAddFriendSuggest(e) {
                          zn.a
                            .doAddFriend(e.uid, e.src, null, e.windowId)
                            .then(() => {
                              this._removeFriendSuggest(e.uid),
                                this.onLoadRequestedFriendList();
                            })
                            .catch((e) => {
                              this.Logger.zsymb(
                                18,
                                12907,
                                30006,
                                "[InvitationController] -> [onAddFriendSuggest], error: " +
                                  JSON.stringify(e),
                              );
                            });
                        }
                        onRemoveFriendSuggest(e) {
                          Yn.removeSuggestFriend(e)
                            .then(() => {
                              this._removeFriendSuggest(e.uid);
                            })
                            .catch((e) => {
                              this.Logger.zsymb(
                                18,
                                12907,
                                30007,
                                "[InvitationController] -> [onRemoveFriendSuggest], error: " +
                                  JSON.stringify(e),
                              );
                            });
                        }
                        openMutualGroupPopup(e) {
                          Je.ModalManagerV2.openModal({
                            windowId: "1",
                            name: R.ModalIdentitiesDefine.FRIEND_PROFILE,
                            params: { userId: e, showMutualGroups: !0 },
                          });
                        }
                        resetData() {
                          this.data.set("all", {
                            isLoadingRecommendFriendList: !1,
                            isLoadingRequestedFriendList: !1,
                            listFriendReceived: [],
                            listFriendSent: [],
                            listFriendSuggest: [],
                            mapRelatedGroup: {},
                          });
                        }
                        makeExpiredReceivedFriendRequest() {
                          let {
                            listFriendReceived: e = [],
                            listFriendSent: t = [],
                            listFriendSuggest: s = [],
                            mapRelatedGroup: i = {},
                          } = this.data.get("all") || {};
                          if (0 !== e.length) {
                            for (let t = 0; t < e.length; t++)
                              (e[t].dataInfo.recommTime = -1),
                                (e[t].dataInfo.recommInfo.source = -1),
                                (e[t].dataInfo.recommInfo.message = "");
                            this.data.set(
                              "all",
                              Object(f.a)(
                                Object(f.a)({}, this.data.get("all")),
                                {},
                                {
                                  listFriendReceived: e,
                                  listFriendSent: t,
                                  listFriendSuggest: s,
                                  mapRelatedGroup: i,
                                },
                              ),
                            ),
                              this._signalRenderItem();
                          }
                        }
                        makeExpiredSentFriendSentRequest() {
                          let {
                            listFriendReceived: e = [],
                            listFriendSent: t = [],
                            listFriendSuggest: s = [],
                            mapRelatedGroup: i = {},
                          } = this.data.get("all") || {};
                          if (0 !== t.length) {
                            for (let e = 0; e < t.length; e++)
                              (t[e].fReqInfo.time = -1),
                                (t[e].fReqInfo.src = -1),
                                (t[e].fReqInfo.message = "");
                            this.data.set(
                              "all",
                              Object(f.a)(
                                Object(f.a)({}, this.data.get("all")),
                                {},
                                {
                                  listFriendReceived: e,
                                  listFriendSent: t,
                                  listFriendSuggest: s,
                                  mapRelatedGroup: i,
                                },
                              ),
                            ),
                              this._signalRenderItem();
                          }
                        }
                        getList(e, t) {
                          throw new Error("Method not implemented.");
                        }
                        onGetItemFailure(e, t) {
                          throw new Error("Method not implemented.");
                        }
                        onGetListFailure(e, t) {
                          throw new Error("Method not implemented.");
                        }
                        getDefaultItem() {
                          throw new Error("Method not implemented.");
                        }
                        getDefaultList() {
                          throw new Error("Method not implemented.");
                        }
                      }),
                    ) || pa),
                ) || pa),
            ) || pa),
        );
        var fa,
          va = s("2x/M"),
          ba = s("FhUL"),
          Ia = s("zU/x"),
          ya = s("dhU0"),
          _a = s("2e02"),
          Oa = s("HnA5");
        function Ca(e) {
          return {
            avatar: e.avatar,
            displayName: Ye.default.getDName(e.id) || e.dName || e.zaloName,
            userId: e.id,
            zaloName: e.zaloName,
            type: e.type,
          };
        }
        Object($t.b)(_a.b)(
          (fa =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (fa =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (fa = class extends te.b {
                    constructor() {
                      super(),
                        (this.name = void 0),
                        (this.key = void 0),
                        (this._Logger = void 0),
                        (this.data = void 0),
                        (this.metadata = void 0),
                        (this.timer = void 0),
                        (this.isOpeningInvitationBox = void 0),
                        (this.handleNetworkStatusChange = (e) => {
                          e === Dn.a.CONNECTED &&
                            0 === this.data.size &&
                            this.getReceivedInvitations({ page: 0 });
                        }),
                        (this.name = _a.a),
                        (this.key = "groupId"),
                        (this.data = new Map()),
                        (this.metadata = {
                          total: 0,
                          page: 0,
                          hasMore: !0,
                          loading: !0,
                        }),
                        (this.timer = {
                          instance: new ut.b(),
                          intervalId: null,
                        }),
                        (this.isOpeningInvitationBox = !1);
                    }
                    init() {
                      throw new Error("Method not implemented.");
                    }
                    getList() {
                      return Array.from(this.data.keys());
                    }
                    getItem(e) {
                      const t = this.data.get(e.key);
                      return (
                        t ||
                          this.Logger.zsymb(
                            5,
                            16234,
                            3e4,
                            "try to get item not exist in cache {}",
                            e.key,
                          ),
                        t
                      );
                    }
                    onGetItemFailure(e) {
                      this.Logger.zsymb(
                        18,
                        16234,
                        30001,
                        "Get group invitation item failed with id",
                        e,
                      );
                    }
                    onGetListFailure(e) {
                      this.Logger.zsymb(
                        18,
                        16234,
                        30002,
                        "Get group invitation list failed",
                        e,
                      );
                    }
                    signalUpdateList() {
                      Object(nt.i)(this.name, "all");
                    }
                    signalUpdateItem(e) {
                      Object(nt.g)(this.name, e);
                    }
                    signalUpdateListMeta() {
                      this.dispatchEvent(
                        new Zn.c(Zn.a.UpdateUIListMetadata, this.metadata),
                      );
                    }
                    get Logger() {
                      return (
                        this._Logger ||
                          (this._Logger = i.ModuleContainer.resolve(
                            q.ZLoggerFactory,
                          ).createZLogger(hs.ZLoggerNametags.contactTabV2, [
                            this.name,
                          ])),
                        this._Logger
                      );
                    }
                    async getCreatorInfos(e) {
                      const t = await Ye.default.getProfileFriendForGroup(
                        Object.fromEntries(e.map((e) => [e.creatorId || e, 0])),
                      );
                      return new Map(e.map((e) => [e.groupId, t[e.creatorId]]));
                    }
                    async getCreatorInfoForGroup(e) {
                      return Ye.default.getProfileFriendForGroup({ [e]: 0 });
                    }
                    startTimer() {
                      this.stopTimer(),
                        (this.timer.intervalId = window.setInterval(
                          () =>
                            this.timer.instance.publish(
                              _t.default.getTimeNow(),
                            ),
                          Zn.b.COUNT_INTERVAL,
                        ));
                    }
                    stopTimer() {
                      null !== this.timer.intervalId &&
                        window.clearInterval(this.timer.intervalId),
                        (this.timer.intervalId = null);
                    }
                    getTimer() {
                      return this.timer.instance;
                    }
                    isValidInvitation(e) {
                      var t;
                      return (
                        !!(
                          null !== (t = e.groupInfo) &&
                          void 0 !== t &&
                          t.groupId &&
                          e.grCreatorInfo &&
                          e.inviterInfo
                        ) && e.expiredTs - _t.default.getTimeNow() > 0
                      );
                    }
                    convertToGroupInvitation(e) {
                      const t = R.GROUPID_PREFIX + e.groupInfo.groupId,
                        s = (function (e) {
                          return {
                            avatar: e.avt,
                            creatorId: e.creatorId,
                            displayName: e.name,
                            name: e.name,
                            setting: e.setting,
                            adminIds: e.adminIds,
                            totalMember: e.totalMember,
                            userId: e.groupId,
                            type: e.type,
                            topMember: e.currentMems.map(Ca),
                            isGroup: !0,
                          };
                        })(e.groupInfo),
                        i = Ca(e.inviterInfo),
                        n = Ca(e.grCreatorInfo);
                      return Object(f.a)(
                        Object(f.a)({}, e),
                        {},
                        {
                          groupId: t,
                          groupInfo: s,
                          inviterInfo: i,
                          grCreatorInfo: n,
                        },
                      );
                    }
                    async loadServerReceivedInvitations() {
                      var e;
                      const {
                        invitations: t,
                        hasMore: s,
                        total: i,
                      } = await Ot.default.getGroupInvitationList(
                        this.metadata.page,
                        bt.default.group_privacy.invitation_box.paging_limit,
                        bt.default.group_privacy.invitation_box.mcount_item,
                        null === (e = this.metadata) || void 0 === e
                          ? void 0
                          : e.lastGroupId,
                      );
                      this.metadata = Object(f.a)(
                        Object(f.a)({}, this.metadata),
                        {},
                        { hasMore: s, total: i },
                      );
                      const n = await this.getCreatorInfos(
                          t.map((e) => e.groupInfo),
                        ),
                        a = [];
                      for (let r = 0; r < t.length; r++) {
                        const e = t[r];
                        if (
                          (e.grCreatorInfo ||
                            (e.grCreatorInfo = n.get(e.groupInfo.groupId)),
                          this.isValidInvitation(e))
                        ) {
                          const s = R.GROUPID_PREFIX + e.groupInfo.groupId,
                            i = this.convertToGroupInvitation(e);
                          a.push(i),
                            r === t.length - 1 &&
                              (this.metadata.lastGroupId = s);
                        }
                      }
                      return a;
                    }
                    onInvitationListUIAppear() {
                      (this.isOpeningInvitationBox = !0),
                        this.startTimer(),
                        this.getReceivedInvitations({ page: 0 })
                          .catch((e) => {
                            this.Logger.zsymb(
                              18,
                              16234,
                              30003,
                              "Init load invitation failed",
                              e,
                            );
                          })
                          .finally(() => {
                            this.metadata.loading &&
                              ((this.metadata.loading = !1),
                              setTimeout(() => {
                                this.signalUpdateListMeta();
                              }, 300));
                          }),
                        Q.p.listenEvent(Q.j, this.handleNetworkStatusChange);
                    }
                    onInvitationListUIDisappear() {
                      this.stopTimer(),
                        (this.metadata = {
                          total: 0,
                          page: 0,
                          hasMore: !0,
                          loading: !0,
                        }),
                        this.data.clear(),
                        Q.p.removeListenEvent(
                          Q.j,
                          this.handleNetworkStatusChange,
                        ),
                        (this.isOpeningInvitationBox = !1);
                    }
                    getUIListMeta() {
                      return this.metadata;
                    }
                    async getReceivedInvitations(e) {
                      void 0 === e && (e = {});
                      const { page: t = 0 } = e;
                      if (!this.metadata.hasMore) return [];
                      (this.metadata.page = t),
                        (this.data = new Map(this.data));
                      const s = await this.loadServerReceivedInvitations();
                      return (
                        s.forEach((e) => {
                          this.data.set(e.groupId, e);
                        }),
                        this.signalUpdateListMeta(),
                        this.signalUpdateList(),
                        s
                      );
                    }
                    async loadMoreReceivedInvitations() {
                      const e =
                          bt.default.group_privacy.invitation_box.paging_limit,
                        t = Math.trunc(this.data.size / e);
                      return this.getReceivedInvitations({ page: t });
                    }
                    handleNewInvitation(e, t) {
                      (this.metadata.total += 1),
                        (this.data = new Map([
                          [e, t],
                          ...Array.from(this.data.entries()),
                        ])),
                        this.signalUpdateListMeta(),
                        this.signalUpdateList();
                    }
                    async acceptInvitation(e, t) {
                      try {
                        if (e.type === ba.a.PENDING_REVIEW)
                          throw { error_code: Ia.a.WAITING_APPROVE };
                        const t = Ct.default.getRawGroupId(e.groupId);
                        await Ot.default.joinGroupFromInvitation(t),
                          this.Logger.zsymb(
                            2,
                            16234,
                            30004,
                            "Join group success",
                            e.groupId,
                          ),
                          i.ModuleContainer.resolve(rs.b).openConversation(
                            e.groupId,
                            rs.c.fromGroupInvitation(),
                          ),
                          this.deleteInvitationsFromCache([e.groupId]);
                      } catch (s) {
                        this.Logger.zsymb(
                          18,
                          16234,
                          30005,
                          "Join group failed",
                          e.groupId,
                          s,
                        ),
                          this.handleJoinInvitationError(
                            e,
                            null == s ? void 0 : s.error_code,
                            t,
                          );
                      }
                    }
                    async rejectInvitation(e, t) {
                      void 0 === t && (t = {});
                      try {
                        if (e.type === ba.a.PENDING_REVIEW)
                          throw { error_code: Ia.a.WAITING_APPROVE };
                        const s = Ct.default.getRawGroupId(e.groupId);
                        await Ot.default.deleteGroupInvitation(
                          [{ grid: s }],
                          t.blockGroup,
                        ),
                          this.Logger.zsymb(
                            2,
                            16234,
                            30006,
                            "Reject group invitation success",
                            e.groupId,
                            t,
                          ),
                          t.blockInviter &&
                            Ye.default.blockFriend(
                              e.inviterInfo.userId,
                              R.SET_BLOCK,
                            ),
                          this.deleteInvitationsFromCache([e.groupId]),
                          et.a.createInfo(
                            tt.default.str(
                              Oa.a.get(
                                "STR_GROUP_INVITATION_DELETED",
                                e.groupInfo,
                              ),
                            ),
                          );
                      } catch (s) {
                        this.Logger.zsymb(
                          18,
                          16234,
                          30007,
                          "Reject group invitation failed",
                          e.groupId,
                          s,
                        ),
                          et.a.createError(tt.default.str("STR_ERROR_OCCUR"));
                      }
                    }
                    async deleteInvitations(e) {
                      const t = e.map((e) => ({
                        grid: Ct.default.getRawGroupId(e.groupId),
                      }));
                      try {
                        await Ot.default.deleteGroupInvitation(t, !1),
                          this.Logger.zsymb(
                            2,
                            16234,
                            30008,
                            "Delete group invitations success",
                            t,
                          ),
                          this.deleteInvitationsFromCache(
                            e.map((e) => e.groupId),
                          );
                      } catch (s) {
                        this.Logger.zsymb(
                          18,
                          16234,
                          30009,
                          "Delete group invitations failed",
                          t,
                          s,
                        ),
                          et.a.createError(tt.default.str("STR_ERROR_OCCUR"));
                      }
                    }
                    deleteInvitationsFromCache(e) {
                      let t = 0;
                      for (const s of e)
                        this.data.has(s) && (this.data.delete(s), (t += 1));
                      0 !== t &&
                        ((this.metadata.total = Math.max(
                          this.metadata.total - t,
                          0,
                        )),
                        this.signalUpdateListMeta(),
                        this.signalUpdateList(),
                        this.metadata.hasMore &&
                          this.data.size <
                            bt.default.group_privacy.invitation_box
                              .paging_limit &&
                          this.loadMoreReceivedInvitations());
                    }
                    getInvitationSync(e) {
                      return this.data.get(e) || null;
                    }
                    getInvitation(e) {
                      return new Promise((t) => {
                        const s = Ct.default.getRawGroupId(e);
                        Ot.default
                          .getGroupInvitationInfo(s)
                          .then((e) => {
                            e.grCreatorInfo
                              ? t(this.convertToGroupInvitation(e))
                              : this.getCreatorInfoForGroup(
                                  e.groupInfo.creatorId,
                                )
                                  .then((s) => {
                                    (e.grCreatorInfo = s),
                                      t(this.convertToGroupInvitation(e));
                                  })
                                  .catch(() => t(null));
                          })
                          .catch((s) => {
                            this.Logger.zsymb(
                              18,
                              16234,
                              30010,
                              "Get invitation info failed",
                              e,
                              s,
                            ),
                              t(null);
                          });
                      });
                    }
                    updateInvitationFromCache(e) {
                      const { groupId: t } = e;
                      this.data.has(t) && this.data.set(t, e);
                    }
                    updateInvitationStatus(e, t) {
                      const s = this.data.get(e);
                      if (s) {
                        const i = Object(f.a)(
                          Object(f.a)({}, s),
                          {},
                          { type: t },
                        );
                        this.updateInvitationFromCache(i),
                          this.data.set(e, i),
                          this.signalUpdateItem(e);
                      }
                    }
                    onReceivedInvitationEvents(e, t) {
                      const s = t.groupId;
                      if (!s) return;
                      const n = R.GROUPID_PREFIX + s;
                      switch (
                        (this.Logger.zsymb(
                          0,
                          16234,
                          30011,
                          "Received new event",
                          e,
                          n,
                        ),
                        e)
                      ) {
                        case va.b.NEW_INVITATION:
                          this.isOpeningInvitationBox &&
                            this.getInvitation(n)
                              .then((e) => {
                                e && this.handleNewInvitation(n, e);
                              })
                              .catch((e) => {
                                this.Logger.zsymb(
                                  18,
                                  16234,
                                  30012,
                                  "Load new invitation item by event failed",
                                  n,
                                  e,
                                );
                              }),
                            i.ModuleContainer.resolve(
                              ya.b,
                            ).onUpdateRequestTracking(
                              "GROUP_INV",
                              "NEW",
                              _t.default.getTimeNow(),
                              n,
                            );
                          break;
                        case va.b.UPDATE_INVITATION:
                          const e = this.data.get(n);
                          "number" == typeof t.invitationType &&
                            (null == e ? void 0 : e.type) !==
                              t.invitationType &&
                            this.updateInvitationStatus(n, t.invitationType);
                          break;
                        case va.b.REMOVE_INVITATION:
                          this.deleteInvitationsFromCache([n]),
                            i.ModuleContainer.resolve(
                              ya.b,
                            ).onUpdateRequestTracking(
                              "GROUP_INV",
                              "REMOVE",
                              _t.default.getTimeNow(),
                              n,
                            );
                      }
                    }
                    handleJoinInvitationError(e, t, s) {
                      switch (t) {
                        case Ia.a.WAITING_APPROVE:
                          this.updateInvitationStatus(
                            e.groupId,
                            ba.a.PENDING_REVIEW,
                          ),
                            et.a.createInfo(
                              tt.default.str(
                                Oa.a.get(
                                  "STR_GROUP_INVITATION_JOIN_ERR_240",
                                  e.groupInfo,
                                ),
                              ),
                            );
                          break;
                        case Ia.a.EXCEED_MAX_GROUP:
                        case Ia.a.CANNOT_CHANGE:
                        case Ia.a.BANNED:
                        case Ia.a.NOT_PERMITTED:
                          et.a.createInfo(
                            tt.default.str(
                              Oa.a.get(
                                "STR_GROUP_INVITATION_JOIN_ERR_" + t,
                                e.groupInfo,
                              ),
                            ),
                          );
                          break;
                        case Ia.a.NOT_EXIST:
                        case Ia.a.ALREADY_MEMBER:
                        case Ia.a.EXPIRED:
                          this.deleteInvitationsFromCache([e.groupId]),
                            et.a.createInfo(
                              tt.default.str(
                                Oa.a.get(
                                  "STR_GROUP_INVITATION_JOIN_ERR_" + t,
                                  e.groupInfo,
                                ),
                              ),
                            );
                          break;
                        case R.GROUP_MEMBER_ERROR.REACHED_LIMIT_MEMBER_GROUP:
                        case R.GROUP_MEMBER_ERROR.OWNER_NEED_VERIFY_PROFILE:
                          bt.default.group_privacy.community.enable_upgrade
                            ? i.ModuleContainer.resolve(
                                wi.e,
                              ).onReceivedCommunityError({
                                errorCode: t,
                                windowId: s,
                                groupId: e.groupId,
                              })
                            : et.a.createError(
                                tt.default.str("STR_ERROR_OCCUR"),
                              );
                          break;
                        default:
                          et.a.createError(tt.default.str("STR_ERROR_OCCUR"));
                      }
                    }
                  }),
                ) || fa),
            ) || fa),
        );
        var Ea = s("hd49");
        let Ma;
        !(function (e) {
          e.MessageDelivered = "MessageDelivered";
        })(Ma || (Ma = {}));
        class Sa extends Event {
          constructor(e, t, s) {
            super(e),
              (this.msgId = void 0),
              (this.payload = void 0),
              (this.msgId = t),
              (this.payload = s);
          }
        }
        var Ta,
          wa = s("Y/Cm");
        Object(V.h)()(
          (Ta =
            Object(V.g)()(
              (Ta =
                Object(i.singleton)(Ea.a)(
                  (Ta =
                    Object(i.injectable)()(
                      (Ta =
                        (function (e, t) {
                          return Object(i.inject)(q.ZLoggerFactory)(
                            e,
                            void 0,
                            0,
                          );
                        })(
                          (Ta =
                            Reflect.metadata(
                              "design:type",
                              Function,
                            )(
                              (Ta =
                                Reflect.metadata("design:paramtypes", [
                                  void 0 === q.ZLoggerFactory
                                    ? Object
                                    : q.ZLoggerFactory,
                                ])(
                                  (Ta = class extends te.b {
                                    constructor(e) {
                                      super(),
                                        (this.logger = void 0),
                                        (this.logger = e.createZLogger("feat", [
                                          "message-service",
                                        ]));
                                    }
                                    onStart() {}
                                    onDispose() {}
                                    onPollingMessages(e, t) {
                                      return new Promise((s, i) => {
                                        if (!e || 0 === e.length) return s(!1);
                                        const n = t
                                            ? { userId: t }
                                            : { userId: e[0].toUid },
                                          a = [...e],
                                          r = () => {
                                            this.messagesDelivered(a);
                                          };
                                        wa.a.preparse(a, n, r, r);
                                      });
                                    }
                                    loadMessage(e) {
                                      return Promise.resolve({});
                                    }
                                    loadMessagesBefore(e, t, s) {}
                                    loadMessagesAfter(e, t, s) {}
                                    loadLastMessage(e, t) {}
                                    messagesDelivered(e) {
                                      this.broadcastEvent(
                                        Ma.MessageDelivered,
                                        "",
                                        e,
                                      );
                                    }
                                    broadcastEvent(e, t, s) {
                                      void 0 === t && (t = ""),
                                        Ct.default.log([
                                          e,
                                          "- id: ",
                                          t,
                                          " - payload: ",
                                          null == s ? void 0 : s.length,
                                        ]),
                                        this.dispatchEvent(new Sa(e, t, s));
                                    }
                                  }),
                                ) || Ta),
                            ) || Ta),
                        ) || Ta),
                    ) || Ta),
                ) || Ta),
            ) || Ta),
        );
        var Ra,
          La = s("hLuk");
        Object(V.h)()(
          (Ra = class {
            onStart() {
              La.default.init();
            }
          }),
        );
        var Da,
          Fa = s("xdZB"),
          Aa = s("wH4e"),
          ja = s("hWjG"),
          Pa = s("mE25"),
          Na = s("mlG1");
        let Ua =
          Object(i.singleton)()(
            (Da =
              (function (e, t) {
                return Object(i.inject)(q.ZLoggerFactory)(e, void 0, 0);
              })(
                (Da =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (Da =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === q.ZLoggerFactory ? Object : q.ZLoggerFactory,
                      ])(
                        (Da = class extends ja.a {
                          constructor(e) {
                            super("Core", "Message", "", e);
                          }
                          countMessages(e, t) {
                            return (
                              void 0 === t &&
                                (t = { from: [], to: [Pa.b, Pa.a] }),
                              this._dbCollection.count(
                                { from: [e, ...t.from], to: [e, ...t.to] },
                                { index: "userId_sendDttm_msgId" },
                              )
                            );
                          }
                          async getLastMessage(e) {
                            var t;
                            let s = null;
                            const i = {
                                from: [e, "", ""],
                                to: [e, Pa.b, Pa.a],
                                excludeFrom: !0,
                                excludeTo: !0,
                              },
                              n = {
                                index: "userId_sendDttm_msgId",
                                direction: Aa.CursorDirection.PREV,
                                limit: 1,
                                predicate: (t) => {
                                  !s && t && (s = t);
                                  const i = Na.d.reduceDeleteMsgs(e, [t], !0);
                                  return (
                                    ls.b.isValidPreviewMessage(t) &&
                                    0 !== i.length
                                  );
                                },
                              },
                              a = await this._dbCollection.getAll(i, n);
                            return null !== (t = null == a ? void 0 : a[0]) &&
                              void 0 !== t
                              ? t
                              : s;
                          }
                          async getPrevMessageIds(e, t, s) {
                            const i = {
                                from: [e, "", ""],
                                to: [e, (await this.get(t)).sendDttm, t],
                                excludeFrom: !0,
                                excludeTo: !0,
                              },
                              n = {
                                index: "userId_sendDttm_msgId",
                                direction: Aa.CursorDirection.PREV,
                                limit: s,
                                predicate: (e) => !isNaN(Number(e.msgId)),
                              };
                            return (await this._dbCollection.getAll(i, n)).map(
                              (e) => e.msgId,
                            );
                          }
                        }),
                      ) || Da),
                  ) || Da),
              ) || Da),
          ) || Da;
        const ka = (e, t) => {
          if (e) throw t;
        };
        var Ba = s("Uzj0"),
          Ga = s("S8fy");
        class xa extends Error {
          constructor(e, t, s, i) {
            void 0 === i && (i = []),
              super(s),
              (this.code = void 0),
              (this.qosParams = void 0),
              (this.name = e),
              (this.qosParams = [s, ...i]),
              (this.code = t);
          }
          setStack(e) {
            const t = `${this.name}: ${this.message}`;
            this.stack = t + (e || "");
          }
          toObject() {
            return {
              name: this.name,
              code: this.code,
              message: this.message,
              stack: this.stack,
              qosParams: this.qosParams,
            };
          }
          static createFromObject(e) {
            const {
                name: t = "ZError Unknown",
                code: s = -1,
                message: i,
                stack: n,
                qosParams: a = [],
              } = e,
              r = new xa(t, s, i, a);
            return r.setStack(n), r;
          }
        }
        let za;
        !(function (e) {
          (e[(e.FETCH_ERROR = 0)] = "FETCH_ERROR"),
            (e[(e.FETCH_CONV_HAS_MSG_OFFLINE_ERROR = 1)] =
              "FETCH_CONV_HAS_MSG_OFFLINE_ERROR"),
            (e[(e.INVALID_RESPONSE = 2)] = "INVALID_RESPONSE"),
            (e[(e.INSERT_MULTI_ERROR = 3)] = "INSERT_MULTI_ERROR");
        })(za || (za = {}));
        class Va extends xa {
          constructor(e, t, s, i) {
            super(
              "FetchMessageCloudError",
              za.FETCH_ERROR,
              `ConvId: ${e}. RequestMsgId: ${t}. OriginError: ${JSON.stringify(s)}`,
              i,
            );
          }
        }
        class Ha extends xa {
          constructor(e, t) {
            super("InvalidResponse", za.INVALID_RESPONSE, e, t);
          }
        }
        class $a extends xa {
          constructor(e, t) {
            super(
              "FetchConvHasMessageOfflineError",
              za.FETCH_CONV_HAS_MSG_OFFLINE_ERROR,
              e,
              t,
            );
          }
        }
        var Wa;
        let Ka =
          Object(Ga.g)()(
            (Wa = class {
              async fetchMessagesCloud(e, t, s, i, n) {
                const a = Ki.a.newReq(),
                  [r, o] = await Ba.b.catchPromise(
                    Ln.default.getCM(e, Number(t), 0, s, a, n, i),
                  );
                ka(r, new Va(e, t, r));
                const [d, l] = await Ba.b.catchPromise(Object(wn.a)(o));
                ka(
                  d,
                  new Ha(
                    `ConvId: ${e}. RequestMsgId: ${t}. Cannot handle response: ${JSON.stringify(d)}`,
                  ),
                );
                const [c, h] = Ba.b.catchFn(() => JSON.parse(l));
                return (
                  ka(
                    c,
                    new Ha(
                      `ConvId: ${e}. RequestMsgId: ${t}. Cannot parse json object`,
                    ),
                  ),
                  h
                );
              }
              async fetchListConvHasMessageOffline(e, t, s) {
                const [i, n] = await Ba.b.catchPromise(
                  Ln.default.getConvHasMessageOffline(e, t, s),
                );
                ka(i, new $a(JSON.stringify(i)));
                const [a, r] = await Ba.b.catchPromise(Object(wn.a)(n));
                return (
                  ka(a, new Ha(`Cannot handle response: ${JSON.stringify(a)}`)),
                  r
                );
              }
            }),
          ) || Wa;
        var qa,
          Za = s("/Bne");
        class Ja {
          constructor(e, t) {
            (this.convId = e),
              (this.messageCloudRaw = t),
              (this.userId = void 0),
              (this.idTo = void 0),
              (this.uidFrom = void 0),
              (this.uin = void 0),
              (this.cliMsgId = void 0),
              (this.msgId = void 0),
              (this.content = void 0),
              (this.dName = void 0),
              (this.msgType = void 0),
              (this.status = void 0),
              (this.ts = void 0),
              (this.isFromCloud = void 0),
              (this.msgKey = void 0),
              (this.isGroup = void 0),
              (this.mentions = void 0),
              (this.quote = void 0),
              (this.st = void 0),
              (this.at = void 0),
              (this.ttl = void 0),
              (this.src = void 0),
              (this.cmd = void 0),
              (this.footer = void 0),
              (this.footerv2 = void 0),
              (this.previewThumb = void 0),
              (this.property = void 0),
              (this.propertyExt = void 0),
              (this.specialMsgType = void 0),
              (this.topOut = void 0),
              (this.topOutImprTimeOut = void 0),
              (this.topOutTimeOut = void 0),
              (this.userId = t.userId),
              (this.idTo = t.idTo),
              (this.uidFrom = t.uidFrom),
              (this.uin = t.uin),
              (this.cliMsgId = t.cliMsgId),
              (this.msgId = t.msgId),
              (this.content = t.content),
              (this.dName = t.dName),
              (this.msgType = t.msgType),
              (this.status = t.status),
              (this.ts = t.ts),
              (this.mentions = t.mentions),
              (this.quote = t.quote),
              (this.st = t.st),
              (this.at = t.at),
              (this.ttl = t.ttl),
              (this.cmd = t.cmd),
              (this.footer = t.footer),
              (this.footerv2 = t.footerv2),
              (this.previewThumb = t.previewThumb),
              (this.property = t.property),
              (this.propertyExt = t.propertyExt),
              (this.specialMsgType = t.specialMsgType),
              (this.topOut = t.topOut),
              (this.topOutImprTimeOut = t.topOutImprTimeOut),
              (this.topOutTimeOut = t.topOutTimeOut),
              (this.isFromCloud = !0),
              (this.msgKey = e),
              (this.isGroup = t.isGroup);
          }
          toEntity() {
            return Za.a.transformMessageFromServer(
              this.messageCloudRaw,
              this.convId,
            );
          }
          setSrc(e) {
            this.src = e;
          }
        }
        let Qa =
          Object(Ga.g)()(
            (qa =
              Reflect.metadata(
                "design:type",
                Function,
              )(
                (qa =
                  Reflect.metadata(
                    "design:paramtypes",
                    [],
                  )(
                    (qa = class {
                      constructor() {
                        (this.apiAdapter = void 0),
                          (this.apiAdapter =
                            i.ModuleContainer.resolveToken(Ka));
                      }
                      async fetchMessagesCloud(e, t, s, i) {
                        var n;
                        const [a, r] = await Ba.b.catchPromise(
                          this.apiAdapter.fetchMessagesCloud(e, t, s, i),
                        );
                        ka(a, a);
                        const o = (
                          null !== (n = r.groupMsgs) && void 0 !== n ? n : []
                        ).map((t) => new Ja(e, t));
                        return Object(f.a)(
                          Object(f.a)({}, r),
                          {},
                          { groupMsgs: o },
                        );
                      }
                      async fetchConvHasMessageOffline(e, t, s) {
                        return await this.apiAdapter.fetchListConvHasMessageOffline(
                          e,
                          t,
                          s,
                        );
                      }
                    }),
                  ) || qa),
              ) || qa),
          ) || qa;
        var Ya;
        Object(i.singleton)(fi)(
          (Ya =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (Ya =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (Ya = class {
                    constructor() {
                      (this.messageRespository = void 0),
                        (this.messageService = void 0),
                        (this.messageRespository =
                          i.ModuleContainer.resolveToken(Ua)),
                        (this.messageService =
                          i.ModuleContainer.resolveToken(Qa));
                    }
                    async fetchMessagesCloud(e, t, s, i) {
                      return await this.messageService.fetchMessagesCloud(
                        e,
                        t,
                        s,
                        i,
                      );
                    }
                    async getLastMessage(e) {
                      return await this.messageRespository.getLastMessage(e);
                    }
                    async getPrevMessageIds(e, t, s) {
                      return this.messageRespository.getPrevMessageIds(e, t, s);
                    }
                    async countMessages(e, t) {
                      return await this.messageRespository.countMessages(e, t);
                    }
                    async getGroupHasMessageOffline(e, t, s) {
                      const i =
                        await this.messageService.fetchConvHasMessageOffline(
                          e,
                          t,
                          s,
                        );
                      return {
                        listConvIds: i.grids.map((e) => R.GROUPID_PREFIX + e),
                        evict: !!i.evict,
                      };
                    }
                    reloadMessage(e) {
                      var t;
                      null === (t = qi.b.messageCache) ||
                        void 0 === t ||
                        t.deleteConversation(e);
                      Fa.a.getExistConvIds().includes(e) &&
                        Es.a.getLastMessagesForConversation(e, {});
                    }
                  }),
                ) || Ya),
            ) || Ya),
        );
        var Xa = s("ZCU6");
        const er = Object(i.define)("cloud-segment-controller");
        var tr = s("npvr"),
          sr = s("t3h5");
        let ir;
        !(function (e) {
          e[(e.UPDATE_FAILED = 0)] = "UPDATE_FAILED";
        })(ir || (ir = {}));
        class nr extends xa {
          constructor(e, t) {
            super("UpdateSegmentError", ir.UPDATE_FAILED, e, t);
          }
        }
        var ar;
        let rr =
          Object(i.singleton)()(
            (ar = class {
              async get(e) {
                return sr.a.getSegmentByConvId(e);
              }
              async update(e, t) {
                const [s] = await Ba.b.catchPromise(tr.b.updateSegmentDB(e, t));
                return (
                  ka(s, new nr(JSON.stringify(s))),
                  sr.a.setSegmentCacheByConvId(e, t),
                  t
                );
              }
            }),
          ) || ar;
        var or;
        Object(i.injectable)()(
          (or =
            Object(i.singleton)(er)(
              (or =
                (function (e, t) {
                  return Object(i.inject)(q.ZLoggerFactory)(e, void 0, 0);
                })(
                  (or =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (or =
                        Reflect.metadata("design:paramtypes", [
                          void 0 === q.ZLoggerFactory
                            ? Object
                            : q.ZLoggerFactory,
                        ])(
                          (or = class {
                            constructor(e) {
                              (this.logger = void 0),
                                (this.repository = void 0),
                                (this.repository =
                                  i.ModuleContainer.resolveToken(rr)),
                                (this.logger = e.createZLogger(
                                  hs.ZLoggerNametags.messageCloudSegment,
                                  [hs.ZLoggerNametags.controller],
                                ));
                            }
                            async get(e) {
                              return this.repository.get(e);
                            }
                            async update(e) {
                              return await this.repository.update(
                                e.conversationId,
                                e,
                              );
                            }
                            async updateSegment(e, t) {
                              const s = Xa.a.addOrUpdateSegmentCache(
                                e.conversationId,
                                t.messages,
                                e,
                                {
                                  requestMsgId: t.requestMsgId,
                                  lastMsgId: t.lastMsgId,
                                  checkLoadTop: t.checkLoadTop,
                                  hasMore: t.hasMore,
                                },
                              ).segmentObj;
                              return await this.repository.update(
                                e.conversationId,
                                s,
                              );
                            }
                          }),
                        ) || or),
                    ) || or),
                ) || or),
            ) || or),
        );
        const dr = Object(i.define)("cloud-segment-repository"),
          lr = Object(i.define)("cloud-segment-manager"),
          cr = Object(i.define)("cloud-message-manager");
        class hr {
          constructor(e) {
            this.entity = e;
          }
          get conversationId() {
            return this.entity.conversationId;
          }
          get cloudFirstSmsLocalId() {
            return this.entity.cloudFirstSmsLocalId;
          }
          get cloudSegmentCheck() {
            return this.entity.cloudSegmentCheck;
          }
          get hasMore() {
            return this.entity.hasMore;
          }
          get lastCloudVerifiedDttm() {
            return this.entity.lastCloudVerifiedDttm;
          }
          get lastDeletedMsgID() {
            return this.entity.lastDeletedMsgID;
          }
          get lastGetMaxRecentTs() {
            return this.entity.lastGetMaxRecentTs;
          }
          get maxCloudMsgId() {
            return this.entity.maxCloudMsgId;
          }
        }
        var ur;
        let gr =
          i.ModuleContainer.injectable()(
            (ur =
              Reflect.metadata(
                "design:type",
                Function,
              )(
                (ur =
                  Reflect.metadata(
                    "design:paramtypes",
                    [],
                  )(
                    (ur = class {
                      constructor() {}
                      get(e) {
                        return sr.a.getSegmentByConvId(e);
                      }
                    }),
                  ) || ur),
              ) || ur),
          ) || ur;
        var mr,
          pr = s("D8Ji");
        let fr,
          vr =
            i.ModuleContainer.injectable()(
              (mr =
                (function (e, t) {
                  return i.ModuleContainer.inject(dr)(e, void 0, 0);
                })(
                  (mr =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (mr =
                        Reflect.metadata("design:paramtypes", [
                          void 0 === dr ? Object : dr,
                        ])(
                          (mr = class {
                            constructor(e) {
                              this.segmentRepository = e;
                            }
                            get(e) {
                              return this.segmentRepository
                                .get(e)
                                .then((e) => e && new hr(e))
                                .catch((e) => {});
                            }
                            async createOrExtendSegment(e, t) {
                              const s = await this.segmentRepository.get(e);
                              (s.cloudSegmentCheck = pr.a.mergeNewSegment(
                                t.verifiedRange,
                                null == s ? void 0 : s.cloudSegmentCheck,
                              )),
                                (s.maxCloudMsgId = Math.max(
                                  s.maxCloudMsgId || 0,
                                  t.verifiedRange[1],
                                )),
                                sr.a.setSegmentCacheByConvId(e, s),
                                await tr.b.updateSegmentDB(e, s);
                            }
                          }),
                        ) || mr),
                    ) || mr),
                ) || mr),
            ) || mr;
        !(function (e) {
          (e[(e.STOP_RETRY = -69)] = "STOP_RETRY"),
            (e[(e.RETRY_LATER = -71)] = "RETRY_LATER"),
            (e[(e.FORCE_UPDATE_CONFIG = -72)] = "FORCE_UPDATE_CONFIG"),
            (e[(e.UNKNOWN_EXCEPTION = 112)] = "UNKNOWN_EXCEPTION"),
            (e[(e.PARAMS_INVALID = 114)] = "PARAMS_INVALID"),
            (e[(e.CLIENT_NOT_SUPPORT = 211)] = "CLIENT_NOT_SUPPORT"),
            (e[(e.LIMIT_GROUPS_PER_REQUEST = 300)] =
              "LIMIT_GROUPS_PER_REQUEST"),
            (e[(e.LIMIT_MSG_PER_GROUP = 301)] = "LIMIT_MSG_PER_GROUP"),
            (e[(e.LIMIT_TOTAL_SYNC_MSG_PER_GROUP = 303)] =
              "LIMIT_TOTAL_SYNC_MSG_PER_GROUP"),
            (e[(e.MISSING_PARAM = 111)] = "MISSING_PARAM"),
            (e[(e.GROUP_NOT_EXIST = 161)] = "GROUP_NOT_EXIST"),
            (e[(e.NOT_BELONG_TO_GROUP = 164)] = "NOT_BELONG_TO_GROUP"),
            (e[(e.IS_DIRTY_GROUP = 302)] = "IS_DIRTY_GROUP");
        })(fr || (fr = {}));
        class br extends Error {
          constructor(e, t, s) {
            super(s), (this.code = e), (this.data = t);
          }
        }
        var Ir;
        let yr =
          i.ModuleContainer.injectable()(
            (Ir =
              (function (e, t) {
                return i.ModuleContainer.inject(_.a)(e, void 0, 0);
              })(
                (Ir =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (Ir =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === _.a ? Object : _.a,
                      ])(
                        (Ir = class {
                          constructor(e) {
                            this.config = e;
                          }
                          get settings() {
                            return this.config.get("cloud.auto_download");
                          }
                          async crawlMissingMessage(e, t) {
                            void 0 === t && (t = { nRetry: 0, count: 50 });
                            let s = e.conversationId;
                            s.startsWith("g") && (s = s.slice(1));
                            const i = `${s}_${e.requestMsgId}`;
                            let n = this.settings.limit.minMsgDttm,
                              a = this.settings.limit.maxMsgFirstSegment;
                            const r = {
                              groupId: s,
                              fromMsgId: e.requestMsgId,
                              globalMsgIds: e.globalMsgIds,
                              curTotalMsgs: e.curTotalMsgs,
                              tsJoinGroup: e.tsJoinGroup,
                              minMsgTs: n,
                              maxTotalSyncMsg: a,
                            };
                            return await Ln.default
                              .crawlMissingMessage(i, r, {
                                requestTimeout: this.settings.fetching.timeout,
                                count: t.count,
                                nRetry: t.nRetry,
                                usePostApi: !0,
                              })
                              .then((e) => Object(wn.a)(e))
                              .then((e) => {
                                try {
                                  return JSON.parse(e);
                                } catch (t) {
                                  throw {
                                    error_code: -1,
                                    error_message: "invalid response",
                                  };
                                }
                              })
                              .then((e) => {
                                const t = e[s];
                                if (t.error > 0)
                                  throw {
                                    error_code: t.error,
                                    error_message: "inner error",
                                  };
                                return t;
                              })
                              .catch((e) => {
                                if ("number" == typeof e.error_code) {
                                  let s = e.data;
                                  try {
                                    s = JSON.parse(s);
                                  } catch (t) {}
                                  throw new br(
                                    e.error_code,
                                    s,
                                    e.error_message,
                                  );
                                }
                                throw e;
                              });
                          }
                        }),
                      ) || Ir),
                  ) || Ir),
              ) || Ir),
          ) || Ir;
        var _r,
          Or = s("yEZN"),
          Cr = s("EO3V"),
          Er = s("enz2");
        const Mr = {
          totalMsgCount: 0,
          fetchedMsgCount: 0,
          serverMsgCount: 0,
          newMsgCount: 0,
          phaseDone: !1,
          isFilteredByTimeJoin: !1,
          done: !0,
          tsJoinGroup: "0",
        };
        let Sr =
          i.ModuleContainer.injectable()(
            (_r =
              (function (e, t) {
                return i.ModuleContainer.injectToken(yr)(e, void 0, 0);
              })(
                (_r =
                  (function (e, t) {
                    return i.ModuleContainer.inject(lr)(e, void 0, 1);
                  })(
                    (_r =
                      (function (e, t) {
                        return i.ModuleContainer.inject(Or.c)(e, void 0, 2);
                      })(
                        (_r =
                          (function (e, t) {
                            return i.ModuleContainer.inject(Or.b)(e, void 0, 3);
                          })(
                            (_r =
                              (function (e, t) {
                                return i.ModuleContainer.inject(
                                  q.ZLoggerFactory,
                                )(e, void 0, 4);
                              })(
                                (_r =
                                  Reflect.metadata(
                                    "design:type",
                                    Function,
                                  )(
                                    (_r =
                                      Reflect.metadata("design:paramtypes", [
                                        void 0 === yr ? Object : yr,
                                        void 0 === lr ? Object : lr,
                                        void 0 === Or.c ? Object : Or.c,
                                        void 0 === Or.b ? Object : Or.b,
                                        void 0 === q.ZLoggerFactory
                                          ? Object
                                          : q.ZLoggerFactory,
                                      ])(
                                        (_r = class {
                                          constructor(e, t, s, i, n) {
                                            (this.api = e),
                                              (this.segmentManager = t),
                                              (this.messageRepository = s),
                                              (this.messageManager = i),
                                              (this.logger = void 0),
                                              (this.logger = n.createZLogger(
                                                "cld-msg",
                                                ["manager"],
                                              ));
                                          }
                                          async crawlMissingMessage(e, t, s) {
                                            const i =
                                                await this.segmentManager.get(
                                                  e,
                                                ),
                                              n = (() => {
                                                var e;
                                                let t =
                                                  s.minMsgId &&
                                                  Number.parseInt(s.minMsgId);
                                                return (
                                                  i &&
                                                    i.lastDeletedMsgID &&
                                                    (t = t
                                                      ? Math.max(
                                                          i.lastDeletedMsgID,
                                                          t,
                                                        )
                                                      : i.lastDeletedMsgID),
                                                  null === (e = t) ||
                                                  void 0 === e
                                                    ? void 0
                                                    : e.toString()
                                                );
                                              })(),
                                              a = "0" !== t,
                                              r = a ? s.count + 1 : s.count;
                                            if (a && t <= n) return Mr;
                                            const o = await this.messageManager
                                                .findPrevMessagesFromMsgId(e, {
                                                  maxMsgId:
                                                    "0" !== t ? t : void 0,
                                                  minMsgId: n,
                                                  limit: r,
                                                })
                                                .then((e) =>
                                                  e.map((e) => e.entity),
                                                ),
                                              d = new Set();
                                            o.forEach((e) => {
                                              try {
                                                const t = Number.parseInt(
                                                  e.msgId,
                                                );
                                                Number.isInteger(t) &&
                                                  d.add(t.toString());
                                              } catch (t) {}
                                            });
                                            const l = Array.from(d.values()),
                                              c =
                                                await this.api.crawlMissingMessage(
                                                  {
                                                    conversationId: e,
                                                    requestMsgId: t,
                                                    globalMsgIds: l,
                                                    curTotalMsgs:
                                                      s.curTotalMsgs,
                                                    tsJoinGroup: s.tsJoinGroup,
                                                  },
                                                  {
                                                    nRetry: s.nRetry,
                                                    count: s.count,
                                                  },
                                                );
                                            if (
                                              0 === c.groupMsgs.length &&
                                              "0" === c.maxMsgId
                                            )
                                              return Mr;
                                            let h =
                                              Cr.a.checkDupMessageFromCloud(
                                                e,
                                                c.groupMsgs,
                                              );
                                            n &&
                                              n > "0" &&
                                              (h = h.filter(
                                                (e) => e.msgId > n,
                                              ));
                                            const u = [...o, ...h];
                                            if (0 === u.length) return Mr;
                                            const g = Number.parseInt(
                                              c.lastMsgId,
                                              10,
                                            );
                                            let m = Number.parseInt(t);
                                            const p = Cr.a.findMinMaxGroupMsg(
                                                u,
                                                m,
                                                g,
                                                null == i
                                                  ? void 0
                                                  : i.lastDeletedMsgID,
                                              ),
                                              {
                                                groupMsgsToView: v,
                                                groupMsgsAddDb: b,
                                                groupMsgsSearch: I,
                                              } = Er.a.findMsgsAddDb(
                                                t,
                                                h,
                                                [],
                                                o,
                                                Object(f.a)(
                                                  {
                                                    apiType: 2,
                                                    conversationId: e,
                                                  },
                                                  p,
                                                ),
                                              );
                                            b.forEach((e) => {
                                              e.src = R.MSG_SRC.AUTO_LOADER;
                                            }),
                                              await this.messageRepository.saveMessages(
                                                b,
                                              ),
                                              await Er.a.updateSearchV3(I, e);
                                            const y = !!c.isFilteredByPhase,
                                              _ = c.maxMsgId;
                                            p.minMsgId &&
                                              p.maxMsgId &&
                                              (await this.segmentManager.createOrExtendSegment(
                                                e,
                                                {
                                                  verifiedRange: [
                                                    p.minMsgId,
                                                    p.maxMsgId,
                                                  ],
                                                },
                                              ));
                                            let O = "0";
                                            Number.isInteger(
                                              Number.parseInt(c.tsJoinGroup),
                                            )
                                              ? (O = c.tsJoinGroup)
                                              : this.logger.zsymb(
                                                  18,
                                                  8177,
                                                  3e4,
                                                  () => [
                                                    "api res invalid ts join group",
                                                    {
                                                      tsJoinGroup:
                                                        c.tsJoinGroup,
                                                    },
                                                  ],
                                                );
                                            const C = !!c.isFilteredByTimeJoin,
                                              E = {
                                                totalMsgCount: v.length,
                                                fetchedMsgCount: b.length,
                                                serverMsgCount: h.length,
                                                newMsgCount: b.length,
                                                phaseDone: y,
                                                isFilteredByTimeJoin: C,
                                                done: !(y || (!C && c.hasMore)),
                                                minMsgId: n,
                                                maxMsgId: _.toString(),
                                                tsJoinGroup: O,
                                              };
                                            return (
                                              this.logger.zsymb(
                                                3,
                                                8177,
                                                30001,
                                                "[auto-dl-msg] crawl result",
                                                E,
                                              ),
                                              E
                                            );
                                          }
                                        }),
                                      ) || _r),
                                  ) || _r),
                              ) || _r),
                          ) || _r),
                      ) || _r),
                  ) || _r),
              ) || _r),
          ) || _r;
        i.ModuleContainer.registerSingleton(dr, gr),
          i.ModuleContainer.registerSingleton(lr, vr),
          i.ModuleContainer.registerSingleton(cr, Sr);
        var Tr,
          wr = s("rfrl"),
          Rr = s("KP/S"),
          Lr = s("wiGx"),
          Dr = s("ttnr");
        const Fr = {
          screen: Lr.a.Hidden,
          error: Rr.b.NO_ERROR,
          progress: 0,
          totalProgress: 0,
          numOfSyncedConv: 0,
          popupVisible: !1,
          startSyncTime: 0,
          closing: !1,
          syncingConversation: null,
        };
        Object($t.b)(Lr.b)(
          (Tr =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (Tr =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (Tr = class {
                    constructor() {
                      (this.progressRecording = void 0),
                        (this.downloadBackupTime = void 0),
                        (this.state = Object(f.a)({}, Fr)),
                        (this.name = "sync-message-ui"),
                        (this.key = "window_id"),
                        (this.progressRecording = new Map()),
                        this.initialRecordProgress(),
                        (this.downloadBackupTime = null);
                    }
                    initialRecordProgress() {
                      this.progressRecording.set(Lr.a.DownloadingBackup, 0),
                        this.progressRecording.set(Lr.a.DecryptingBackup, 0),
                        this.progressRecording.set(Lr.a.SyncInProgress, 0);
                    }
                    recordProgress(e) {
                      const t = this.state.screen,
                        s = (e) => (e > 100 ? 100 : e);
                      switch (t) {
                        case Lr.a.DownloadingBackup:
                          this.progressRecording.set(t, s(e));
                          break;
                        case Lr.a.DecryptingBackup:
                          this.progressRecording.set(
                            Lr.a.DownloadingBackup,
                            100,
                          ),
                            this.progressRecording.set(t, s(e));
                          break;
                        case Lr.a.SyncInProgress:
                          this.progressRecording.set(
                            Lr.a.DownloadingBackup,
                            100,
                          ),
                            this.progressRecording.set(
                              Lr.a.DecryptingBackup,
                              100,
                            ),
                            this.progressRecording.set(t, s(e));
                      }
                    }
                    calculateTotalProgressTransfer() {
                      const e = this.state.screen,
                        t =
                          this.progressRecording.get(Lr.a.DownloadingBackup) ||
                          0,
                        s =
                          this.progressRecording.get(Lr.a.DecryptingBackup) ||
                          0,
                        i =
                          this.progressRecording.get(Lr.a.SyncInProgress) || 0,
                        n = (e, t) => {
                          let s = 0;
                          switch (t) {
                            case Lr.a.DownloadingBackup:
                              s = Dr.a.getPercentDownload();
                              break;
                            case Lr.a.DecryptingBackup:
                              s = Dr.a.getPercentDecrypt();
                              break;
                            case Lr.a.SyncInProgress:
                              s = Dr.a.getPercentRestore();
                          }
                          return Math.round((e * s) / 100);
                        };
                      switch (e) {
                        case Lr.a.DownloadingBackup:
                          return n(t, e);
                        case Lr.a.DecryptingBackup:
                          return n(t, Lr.a.DownloadingBackup) + n(s, e);
                        case Lr.a.SyncInProgress:
                          return (
                            n(t, Lr.a.DownloadingBackup) +
                            n(s, Lr.a.DecryptingBackup) +
                            n(i, e)
                          );
                        default:
                          return 0;
                      }
                    }
                    showPopup() {
                      this.setState((e) => {
                        e.popupVisible = !0;
                      });
                    }
                    setSyncingConversation(e) {
                      this.setState((t) => {
                        t.syncingConversation = e;
                      });
                    }
                    hidePopup() {
                      this.setState((e) => {
                        e.popupVisible = !1;
                      });
                    }
                    hideAllUI() {
                      this.setState((e) => {
                        (e.screen = Lr.a.Hidden), (e.closing = !1);
                      });
                    }
                    showError(e) {
                      this.setState((t) => {
                        (t.error = e),
                          (t.screen = Lr.a.Error),
                          (t.syncingConversation = null);
                      });
                    }
                    showSuggestNewSync(e) {
                      this.setState((t) => {
                        (t.screen = Lr.a.SuggestNewSync), (t.popupVisible = e);
                      });
                    }
                    showSuggestResume() {
                      this.setState((e) => {
                        (e.screen = Lr.a.SuggestResume), (e.popupVisible = !1);
                      });
                    }
                    showSyncGuide() {
                      this.setState((e) => {
                        (e.screen = Lr.a.SyncGuide), (e.popupVisible = !0);
                      });
                    }
                    showWaitForBackup() {
                      this.setState((e) => {
                        e.screen = Lr.a.WaitForBackup;
                      });
                    }
                    showMobileIdleInBackup() {
                      this.setState((e) => {
                        e.screen = Lr.a.MobileIdleInBackup;
                      });
                    }
                    showDownloadingBackup() {
                      this.setDownloadBackupTime(performance.now()),
                        this.setState((e) => {
                          (e.screen = Lr.a.DownloadingBackup),
                            (e.progress = 0),
                            (e.totalProgress =
                              this.calculateTotalProgressTransfer());
                        });
                    }
                    showDecryptingBackup() {
                      this.setState((e) => {
                        (e.screen = Lr.a.DecryptingBackup),
                          (e.progress = 0),
                          (e.totalProgress =
                            this.calculateTotalProgressTransfer());
                      });
                    }
                    showInProgress() {
                      this.setState((e) => {
                        (e.screen = Lr.a.SyncInProgress),
                          (e.progress = 0),
                          (e.totalProgress =
                            this.calculateTotalProgressTransfer());
                      });
                    }
                    showCloseNotice() {
                      this.setState((e) => {
                        e.closing = !0;
                      });
                    }
                    showSuccessMessage() {
                      this.setState((e) => {
                        (e.screen = Lr.a.SyncSuccess),
                          (e.syncingConversation = null);
                      });
                    }
                    showWaitForNetwork() {
                      this.setState((e) => {
                        e.screen = Lr.a.WaitForNetwork;
                      });
                    }
                    setProgress(e) {
                      this.recordProgress(e),
                        this.setState((t) => {
                          (t.progress = e),
                            (t.totalProgress =
                              this.calculateTotalProgressTransfer());
                        });
                    }
                    setNumOfSyncedConv(e) {
                      this.setState((t) => {
                        t.numOfSyncedConv = e;
                      });
                    }
                    resetStartSyncTime() {
                      this.setState((e) => {
                        e.startSyncTime = Date.now();
                      });
                    }
                    clearError() {
                      this.setState((e) => {
                        e.error = Rr.b.NO_ERROR;
                      });
                    }
                    getStartSyncTime() {
                      return this.state.startSyncTime;
                    }
                    getCurrentError() {
                      return this.state.error;
                    }
                    getCurrentScreen() {
                      return this.state.screen;
                    }
                    getPopupVisible() {
                      return this.state.popupVisible;
                    }
                    setDownloadBackupTime(e) {
                      this.downloadBackupTime = e;
                    }
                    getDownloadBackupTime() {
                      return this.downloadBackupTime;
                    }
                    init() {}
                    getItem() {
                      return this.state;
                    }
                    getList() {
                      return [];
                    }
                    onGetItemFailure() {}
                    onGetListFailure() {}
                    setState(e) {
                      const t = Object(wr.a)(this.state, e);
                      this.state !== t &&
                        ((this.state = t), Object(nt.g)(this.name, "current"));
                    }
                  }),
                ) || Tr),
            ) || Tr),
        );
        var Ar,
          jr = s("cPHW");
        let Pr =
          i.ModuleContainer.injectable()(
            (Ar = class {
              start() {}
              isEnable() {
                return !1;
              }
              canSync() {
                return Rr.a.DISABLED;
              }
              delayedSuggestSync() {
                throw new Error("Method not implemented.");
              }
              suggestSync() {
                throw new Error("Method not implemented.");
              }
              suggestResume() {
                throw new Error("Method not implemented.");
              }
              sync() {
                throw new Error("Method not implemented.");
              }
              resume() {
                throw new Error("Method not implemented.");
              }
              cancel() {
                throw new Error("Method not implemented.");
              }
              confirmCancelSyncInSuggestingPopup() {
                throw new Error("Method not implemented.");
              }
              cleanupInMobileBusyBackup() {
                throw new Error("Method not implemented.");
              }
              closeCancelSyncInSuggestingPopup() {
                throw new Error("Method not implemented.");
              }
              pause() {
                throw new Error("Method not implemented.");
              }
              retry() {
                throw new Error("Method not implemented.");
              }
              rejectSuggest() {
                throw new Error("Method not implemented.");
              }
              showSuggestPopup() {
                throw new Error("Method not implemented.");
              }
              closeSuggestPopup() {
                throw new Error("Method not implemented.");
              }
              setRequestBackupTimeout() {
                throw new Error("Method not implemented.");
              }
              setMobileTransferConfirmTimeout() {
                throw new Error("Method not implemented.");
              }
              clearRequestBackupTimeout() {
                throw new Error("Method not implemented.");
              }
              setAutoCloseSuccessTimeout() {
                throw new Error("Method not implemented.");
              }
              clearAutoCloseSuccessTimeout() {
                throw new Error("Method not implemented.");
              }
              resendRequest() {
                throw new Error("Method not implemented.");
              }
              reset() {
                throw new Error("Method not implemented.");
              }
              hideProgress() {
                throw new Error("Method not implemented.");
              }
              handleCtrlEvents() {}
              makeMobileIdle() {
                throw new Error("Method not implemented.");
              }
              makeMobileActive() {
                throw new Error("Method not implemented.");
              }
              set tempKeySource(e) {
                throw new Error("Method not implemented.");
              }
              get tempKeySource() {
                throw new Error("Method not implemented.");
              }
            }),
          ) || Ar;
        i.ModuleContainer.registerSingleton(jr.a, Pr);
        var Nr = s("Erqw");
        const Ur = (e) => {
          var t;
          const s = e.step,
            i = e.registry;
          let n = null !== (t = e.timeout) && void 0 !== t ? t : 0;
          const a = e.callback,
            r = e.args,
            o = performance.now() + n;
          let d;
          function l() {
            let e = Math.min(o - performance.now(), s);
            return (
              performance.now() > o
                ? (i[d] = setTimeout(a, 0, r))
                : (i[d] = setTimeout(l, e)),
              i[d]
            );
          }
          return (function () {
            let e = Math.min(o - performance.now(), s);
            return (d = setTimeout(l, e)), (i[d] = d), d;
          })();
        };
        const { setTimeoutUnlimited: kr, clearTimeoutUnlimited: Br } =
          (function (e) {
            var t, s;
            void 0 === e && (e = {});
            const i = null !== (t = e.step) && void 0 !== t && t ? 1e4 : 36e5,
              n = null !== (s = e.registry) && void 0 !== s ? s : {};
            return {
              setTimeoutUnlimited: function (e, t) {
                for (
                  var s = arguments.length,
                    a = new Array(s > 2 ? s - 2 : 0),
                    r = 2;
                  r < s;
                  r++
                )
                  a[r - 2] = arguments[r];
                const o = Ur({
                  step: i,
                  registry: n,
                  callback: e,
                  timeout: t,
                  args: a,
                });
                return o;
              },
              clearTimeoutUnlimited: (e) => {
                ((e) => {
                  const t = e.id,
                    s = e.registry;
                  clearTimeout(s[t]), delete s[t];
                })({ id: e, registry: n });
              },
            };
          })({ registry: {} });
        var Gr,
          xr = s("1p+n"),
          zr = s("UYft"),
          Vr = s("AULX");
        Object(i.injectable)()(
          (Gr =
            Object(i.singleton)(Vr.a)(
              (Gr =
                Object(V.g)()(
                  (Gr =
                    Object(V.e)()(
                      (Gr =
                        (function (e, t) {
                          return Object(i.inject)(A)(e, void 0, 0);
                        })(
                          (Gr =
                            (function (e, t) {
                              return Object(i.inject)(q.ZLoggerFactory)(
                                e,
                                void 0,
                                1,
                              );
                            })(
                              (Gr =
                                Reflect.metadata(
                                  "design:type",
                                  Function,
                                )(
                                  (Gr =
                                    Reflect.metadata("design:paramtypes", [
                                      void 0 === F ? Object : F,
                                      void 0 === q.ZLoggerFactory
                                        ? Object
                                        : q.ZLoggerFactory,
                                    ])(
                                      (Gr = class {
                                        constructor(e, t) {
                                          (this.kvCacheFactory = e),
                                            (this.loggerFactory = t),
                                            (this._logger = void 0),
                                            (this._authEvent = void 0),
                                            (this.__cache = void 0),
                                            (this._renewRegistry = {}),
                                            (this.updateEmitter = new xr.a()),
                                            (this._logger =
                                              this.loggerFactory.createZLogger(
                                                "feat",
                                                ["group-link"],
                                              ));
                                        }
                                        onAuthenticated(e) {
                                          this._authEvent = e;
                                        }
                                        _makeCache() {
                                          if (!this._authEvent)
                                            throw new Error(
                                              "Not authenticated",
                                            );
                                          return this.kvCacheFactory.createCache(
                                            `group-link-v3-${this._authEvent.getSession().userId}`,
                                            { maxSize: 50 },
                                          );
                                        }
                                        get _cache() {
                                          return (
                                            this.__cache ||
                                              (this.__cache =
                                                this._makeCache()),
                                            this.__cache
                                          );
                                        }
                                        _scheduleRenew(e, t) {
                                          if (
                                            (this._clearRenewSchedule(e),
                                            !t.enabled)
                                          )
                                            return this;
                                          if (
                                            !bt.default.groupLink
                                              .enableScheduleRenew
                                          )
                                            return (
                                              this._logger.debug([
                                                "_scheduleRenew skipped, enableScheduleRenew:",
                                                bt.default.groupLink
                                                  .enableScheduleRenew,
                                              ]),
                                              this
                                            );
                                          let s =
                                              t.expirationDate -
                                              _t.default.getTimeNow(),
                                            i = kr(() => {
                                              this._clearRenewSchedule(e),
                                                this._emitGroupLinkUpdated(
                                                  e,
                                                  !0,
                                                );
                                            }, s);
                                          return (
                                            (this._renewRegistry[e] = () => {
                                              Br(i),
                                                delete this._renewRegistry[e];
                                            }),
                                            this
                                          );
                                        }
                                        _clearRenewSchedule(e) {
                                          var t, s;
                                          return (
                                            null ===
                                              (t = (s = this._renewRegistry)[
                                                e
                                              ]) ||
                                              void 0 === t ||
                                              t.call(s),
                                            this
                                          );
                                        }
                                        onDispose() {
                                          (this._authEvent = void 0),
                                            (this.__cache = void 0);
                                        }
                                        async _getFromCache(e) {
                                          if (!bt.default.groupLink.enableCache)
                                            return void this._logger.debug([
                                              "cache skipped, enableCache:",
                                              bt.default.groupLink.enableCache,
                                            ]);
                                          e = Hr(e);
                                          let t = await this._cache.getItem(e);
                                          if (t) {
                                            if (
                                              (function (e) {
                                                if (!e) return !1;
                                                let { data: t, meta: s } = e;
                                                if (!t) return !1;
                                                if (!s) return !1;
                                                if (Nr.a.isOverflowAtTime(s.ts))
                                                  return !1;
                                                const i =
                                                  _t.default.getTimeNow();
                                                if (
                                                  s.ts +
                                                    bt.default.groupLink
                                                      .maxCacheDuration <
                                                  i
                                                )
                                                  return !1;
                                                if (
                                                  t.enabled &&
                                                  t.expirationDate < i
                                                )
                                                  return !1;
                                                return !0;
                                              })(t)
                                            )
                                              return t.data;
                                            await this._cache.removeItem(e);
                                          }
                                        }
                                        async _fetchAndPutToCache(e, t) {
                                          const s = _t.default.getTimeNow(),
                                            i = await t(),
                                            n = {
                                              enabled: i.enabled,
                                              expirationDate: i.expiration_date,
                                              link: i.link,
                                            };
                                          let a = { ts: s };
                                          return (
                                            await this._cache.setItem(e, {
                                              data: n,
                                              meta: a,
                                            }),
                                            n
                                          );
                                        }
                                        async _deleteCache(e) {
                                          await this._cache.removeItem(e);
                                        }
                                        async getGroupLinkDetail(e, t) {
                                          void 0 === t && (t = !1),
                                            this._logger.zsymb(12, 9640, 3e4, [
                                              "getting",
                                              e,
                                            ]);
                                          let s = Hr(e),
                                            i = await this._getFromCache(s);
                                          if (i && !t)
                                            return (
                                              this._logger.zsymb(
                                                12,
                                                9640,
                                                30001,
                                                ["cache hit", s],
                                              ),
                                              this._scheduleRenew(s, i),
                                              i
                                            );
                                          this._logger.zsymb(12, 9640, 30002, [
                                            "fetching",
                                            s,
                                          ]);
                                          let n = Ct.default.getRawGroupId(s);
                                          let a =
                                            await this._fetchAndPutToCache(
                                              s,
                                              () =>
                                                Ot.default.getGroupLinkDetail(
                                                  n,
                                                ),
                                            ).catch(
                                              zr.a.catch((e) =>
                                                this._logger.zsymb(
                                                  18,
                                                  9640,
                                                  30003,
                                                  ["get failed", s, e],
                                                ),
                                              ),
                                            );
                                          return (
                                            this._scheduleRenew(s, a),
                                            t &&
                                              (await this._emitGroupLinkUpdated(
                                                e,
                                              )),
                                            this._logger.zsymb(
                                              12,
                                              9640,
                                              30004,
                                              ["done", s],
                                            ),
                                            a
                                          );
                                        }
                                        async renewGroupLink(e) {
                                          this._logger.zsymb(12, 9640, 30005, [
                                            "renewing",
                                            e,
                                          ]);
                                          let t = Hr(e),
                                            s = Ct.default.getRawGroupId(t);
                                          let i =
                                            await this._fetchAndPutToCache(
                                              t,
                                              () =>
                                                Ot.default.renewGroupLink(s),
                                            ).catch(
                                              zr.a.catch((e) =>
                                                this._logger.zsymb(
                                                  18,
                                                  9640,
                                                  30006,
                                                  ["renew failed", t, e],
                                                ),
                                              ),
                                            );
                                          return (
                                            this._scheduleRenew(t, i),
                                            await this._emitGroupLinkUpdated(t),
                                            this._logger.zsymb(
                                              12,
                                              9640,
                                              30007,
                                              ["renew done", e],
                                            ),
                                            i
                                          );
                                        }
                                        async disableGroupLink(e) {
                                          this._logger.zsymb(12, 9640, 30008, [
                                            "disabling",
                                            e,
                                          ]);
                                          let t = Hr(e),
                                            s = Ct.default.getRawGroupId(t);
                                          await Ot.default
                                            .disableGroupLink(s)
                                            .catch(
                                              zr.a.catch((e) =>
                                                this._logger.zsymb(
                                                  18,
                                                  9640,
                                                  30009,
                                                  ["disable failed", t, e],
                                                ),
                                              ),
                                            ),
                                            await this._emitGroupLinkUpdated(
                                              t,
                                              !0,
                                            ),
                                            this._logger.zsymb(
                                              12,
                                              9640,
                                              30010,
                                              ["disable done", e],
                                            );
                                        }
                                        async _emitGroupLinkUpdated(e, t) {
                                          void 0 === t && (t = !1);
                                          const s = Hr(e);
                                          t && (await this._deleteCache(s)),
                                            this.updateEmitter.emit(s, s),
                                            this.updateEmitter.emit("*", s);
                                        }
                                        async emitGroupLinkUpdated(e) {
                                          return await this._emitGroupLinkUpdated(
                                            e,
                                            !0,
                                          );
                                        }
                                      }),
                                    ) || Gr),
                                ) || Gr),
                            ) || Gr),
                        ) || Gr),
                    ) || Gr),
                ) || Gr),
            ) || Gr),
        );
        function Hr(e) {
          return R.GROUPID_PREFIX + Ct.default.getRawGroupId(e);
        }
        var $r,
          Wr = s("TO4U");
        const Kr = { loading: !0 };
        Object($t.b)(Wr.a)(
          ($r =
            (function (e, t) {
              return Object(i.inject)(Vr.a)(e, void 0, 0);
            })(
              ($r =
                Reflect.metadata(
                  "design:type",
                  Function,
                )(
                  ($r =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === Vr.a ? Object : Vr.a,
                    ])(
                      ($r = class e {
                        constructor(e) {
                          (this._groupLink = e),
                            (this.type = void 0),
                            (this.name = "group-link-ui"),
                            (this.key = "group-link-ui"),
                            (this._cache = new U.default({ maxSize: 50 })),
                            (this._handleUpdate = (e) => {
                              const t = qr(e);
                              this._cache.delete(t),
                                this._startFetchAndSetToSession(t);
                            }),
                            this._groupLink.updateEmitter.on(
                              "*",
                              this._handleUpdate,
                            );
                        }
                        init() {}
                        getItem(e, t) {
                          if (!e.key.startsWith(R.GROUPID_PREFIX)) return;
                          const s = qr(e.key);
                          this._startFetchAndSetToSession(s);
                          let i = this._cache.get(s);
                          return i || Kr;
                        }
                        static shouldSignal(e, t) {
                          var s, i, n, a, r, o;
                          return (
                            !e ||
                            (null == e || e.error,
                            null == t || t.error,
                            null == t ||
                              null === (s = t.data) ||
                              void 0 === s ||
                              s.enabled,
                            null == t ||
                              null === (i = t.data) ||
                              void 0 === i ||
                              i.enabled,
                            null != e &&
                              null !== (n = e.data) &&
                              void 0 !== n &&
                              n.enabled &&
                              null != t &&
                              null !== (a = t.data) &&
                              void 0 !== a &&
                              a.enabled &&
                              (null == e ||
                                null === (r = e.data) ||
                                void 0 === r ||
                                r.link,
                              null == t ||
                                null === (o = t.data) ||
                                void 0 === o ||
                                o.link),
                            !1)
                          );
                        }
                        signalIfNeeded(t, s, i) {
                          e.shouldSignal(s, i) && Object(nt.g)(this.name, t);
                        }
                        _startFetchAndSetToSession(e) {
                          const t = this._cache.get(e);
                          setTimeout(() => {
                            this._groupLink
                              .getGroupLinkDetail(e)
                              .then((s) => {
                                const i = { loading: !1, data: s };
                                this._cache.set(e, i),
                                  this.signalIfNeeded(e, t, i);
                              })
                              .catch((s) => {
                                const i = { loading: !1, error: s };
                                this._cache.set(e, i),
                                  this.signalIfNeeded(e, t, i);
                              });
                          }, 0);
                        }
                        getList(e, t) {
                          throw new Error("Method not implemented.");
                        }
                        onGetItemFailure(e, t) {
                          throw new Error("Method not implemented.");
                        }
                        onGetListFailure(e, t) {
                          throw new Error("Method not implemented.");
                        }
                      }),
                    ) || $r),
                ) || $r),
            ) || $r),
        );
        function qr(e) {
          return R.GROUPID_PREFIX + Ct.default.getRawGroupId(e);
        }
        var Zr = s("akSd"),
          Jr = s("xQyS"),
          Qr = s("fqRP"),
          Yr = s("L904"),
          Xr = s("EiAw"),
          eo = s("IoRb");
        let to;
        class so {
          static get instance() {
            return to || (to = new so()), to;
          }
          get _eventStore() {
            return (
              this.__eventStore || (this.__eventStore = s("emRR").default),
              this.__eventStore
            );
          }
          constructor() {
            (this.__eventStore = void 0),
              (this._emitConversationDeleted = (e) => {
                let t,
                  s,
                  i = [];
                if (
                  (e.ok
                    ? ({ conversation: t, toUid: s, allItems: i } = e.value)
                    : ({ conversation: t, toUid: s, allItems: i } = e.error),
                  t)
                )
                  return;
                if (i.length && i.every((e) => e.ttlType === nn.a.Quote))
                  return;
                const n = {
                  type: St.FetchActions.DELETE_CONVERSATION,
                  payload: s,
                };
                this._eventStore.dispatch(n),
                  Ze.a.dispatch(n),
                  Mt.default.send(n.type, n.payload);
              }),
              (this._emitDeletedMsgs = (e) => {
                let t, s;
                e.ok
                  ? ({ allItems: s, conversation: t } = e.value)
                  : ({ allItems: s, conversation: t } = e.error);
                const i = s
                  .filter((e) => e.ttlType === nn.a.Message)
                  .map((e) => e.msgId);
                Object(Xr.a)({ msgId: i, conversation: t });
              }),
              (this._emitUpdateUnread = (e, t) => {
                let s,
                  i = [];
                e.ok
                  ? ({ toUid: s, allItems: i } = e.value)
                  : ({ toUid: s, allItems: i } = e.error),
                  Pt.a.UnreadDataManager.updateUnreadTTLConversation(
                    s,
                    i,
                    null == t ? void 0 : t.get(s),
                  );
              }),
              (this.emitPerConversation = async (e, t) => {
                let s = await Object(Jr.a)(this._emitConversationDeleted, e);
                s.ok ||
                  Object(eo.a)("_emitConversationDeleted failed", s.error),
                  (s = await Object(Jr.a)(this._emitDeletedMsgs, e)),
                  s.ok || Object(eo.a)("_emitDeletedMsgs failed", s.error),
                  (s = await Object(Jr.a)(this._emitUpdateUnread, e, t)),
                  s.ok || Object(eo.a)("_emitUpdateUnread failed", s.error);
              });
          }
        }
        var io,
          no = s("LA52"),
          ao = s("GSaP");
        const ro = (e) => (null == e ? void 0 : e.toUid),
          oo = (e) => (null != e && e.ok ? "success" : "error");
        Object(i.singleton)(no.a)(
          (io =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (io =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (io = class {
                    constructor() {
                      var e = this;
                      (this._pruning = !1),
                        (this._task = void 0),
                        (this._ttl = i.ModuleContainer.resolve(Qr.a)),
                        (this._logger = void 0),
                        (this.dispose = () => {}),
                        (this.prune = async () =>
                          this._pruning
                            ? await this._task
                            : ((this._pruning = !0),
                              (this._task = this._pruneFromDB()),
                              (this._pruning = !1),
                              this._task)),
                        (this._pruneFromDB = async () => {
                          const e = _t.default.getTimeNow();
                          this._logger.zsymb(
                            0,
                            16228,
                            3e4,
                            "Pruner execute task",
                            e,
                          );
                          const t = await Object(Jr.b)(
                            this._ttl.getExpireItemsBefore,
                            e,
                          );
                          if (!t.ok)
                            return (
                              this._logger.zsymb(
                                18,
                                16228,
                                30001,
                                "Pruner getExpireItemsBefore failed",
                                t.error,
                              ),
                              { ok: !1, error: null }
                            );
                          const s = t.ok ? t.value : [];
                          return await this._pruneTTLItems(s);
                        }),
                        (this._pruneByMsgsBatch = []),
                        (this.pruneByMsgs = async (e) => {
                          const t = Object(Tt.a)(e);
                          this._pruneByMsgsBatch.push(...t),
                            setTimeout(() => {
                              const e = this._pruneByMsgsBatch;
                              (this._pruneByMsgsBatch = []),
                                e.length &&
                                  (this._logger.zsymb(
                                    15,
                                    16228,
                                    30002,
                                    "running a batch {}",
                                    e.length,
                                  ),
                                  this._pruneByMsgs(e));
                            }, 2e3);
                        }),
                        (this._pruneByMsgs = async (e) => {
                          const t = _t.default.getTimeNow();
                          this._logger.zsymb(
                            15,
                            16228,
                            30003,
                            "deriving {}",
                            e.length,
                          );
                          let s = ao.a
                            .createFromCurrentSession()
                            .deriveTTLItems(e);
                          this._logger.zsymb(
                            15,
                            16228,
                            30004,
                            "ttlItems count: {}",
                            s.length,
                          ),
                            (s = s.filter((e) => {
                              const s =
                                +e.expireOn +
                                bt.default.ttl
                                  .enable_delete_on_filter_minimum_overtime;
                              return !isNaN(s) && s < t;
                            })),
                            this._logger.zsymb(
                              15,
                              16228,
                              30005,
                              "expired count: {}",
                              s.length,
                            ),
                            (s = s.filter((e) => !this._hasPruneMsgCache(e))),
                            s.forEach((e) => {
                              this._setPruneMsgCache(e);
                            }),
                            this._logger.zsymb(
                              15,
                              16228,
                              30006,
                              "no cache count: {}",
                              s.length,
                            ),
                            s.length
                              ? (this._logger.zsymb(
                                  3,
                                  16228,
                                  30007,
                                  "pruning {}, {}",
                                  s.length,
                                  s,
                                ),
                                await this._deleteMsgsAndEmit(s))
                              : this._logger.zsymb(
                                  15,
                                  16228,
                                  30008,
                                  "no items to prune",
                                );
                        }),
                        (this._pruneMsgCache = new U.default({ maxSize: 1e4 })),
                        (this._pruneTTLItems = async (e) => {
                          const t = e.map((e) => [e.msgId, e.ttlType]);
                          this._logger.zsymb(
                            3,
                            16228,
                            30009,
                            "pruning {} items: {}",
                            t.length,
                            t,
                          ),
                            await this._deleteMsgsAndEmit(e);
                          const s = await Object(Jr.b)(this._ttl.deletes, t);
                          return (
                            s.ok ||
                              this._logger.zsymb(
                                18,
                                16228,
                                30010,
                                "Pruner deletes ttl failed",
                                s.error,
                              ),
                            s
                          );
                        }),
                        (this._retryErrorMsgsIfNeeded = (e) => {
                          for (const s of e) {
                            var t;
                            if (s.ok) continue;
                            const { errorItems: e, toUid: i } = s.error;
                            this._logger.zsymb(
                              0,
                              16228,
                              30011,
                              "_retryErrorDelete " + i,
                              null == e || null === (t = e[0]) || void 0 === t
                                ? void 0
                                : t.msgId,
                            ),
                              setTimeout(() => {
                                Object(Jr.b)(
                                  this._deleteMsgsBelongToTTLItems,
                                  e,
                                );
                              }, 5e3);
                          }
                        }),
                        (this._retryErrorDelete = (e) =>
                          setTimeout(async () => {
                            const t =
                                await this._ttl.getMappedMsgsByConvIdFromTTLItems(
                                  e,
                                ),
                              s = await Object(Jr.b)(
                                this._deleteMsgsBelongToTTLItems,
                                e,
                              );
                            !s.ok &&
                              this._logger.zsymb(
                                18,
                                16228,
                                30012,
                                "Pruner _retryErrorDelete",
                                s.error,
                              ),
                              s.ok && this._emitPruneResult(s.value, t);
                          }, 5e3)),
                        (this._emitPruneResult = async (e, t) => {
                          for (const s of e)
                            await Object(Jr.b)(
                              so.instance.emitPerConversation,
                              s,
                              t,
                            );
                        }),
                        (this._deletePerConversation = async function (e, t) {
                          var s, i, n, a, r, o, d, l, c;
                          void 0 === t && (t = []);
                          const h = await Object(Jr.b)(
                            Ni.b.vanishMessages,
                            e,
                            t,
                          );
                          if (!h.ok)
                            return {
                              ok: !1,
                              error: {
                                toUid: e,
                                allItems: [],
                                errorItems: t,
                                successItems: [],
                              },
                            };
                          const u =
                              null === (s = h.value.vanish) || void 0 === s
                                ? void 0
                                : s[0],
                            g =
                              null === (i = h.value.quote) || void 0 === i
                                ? void 0
                                : i[0];
                          if (!u && !g)
                            return {
                              ok: !1,
                              error: {
                                toUid: e,
                                conversation: {},
                                allItems: [],
                                errorItems: t,
                                successItems: [],
                              },
                            };
                          const m =
                            null === (n = h.value.vanish) ||
                            void 0 === n ||
                            null === (a = n[0]) ||
                            void 0 === a ||
                            null === (r = a.conv) ||
                            void 0 === r
                              ? void 0
                              : r.conversation;
                          let p = [
                            ...(null !==
                              (o =
                                null === (d = h.value.vanish) || void 0 === d
                                  ? void 0
                                  : d.map((e) => e.res).flat()) && void 0 !== o
                              ? o
                              : []),
                            ...(null !==
                              (l =
                                null === (c = h.value.quote) || void 0 === c
                                  ? void 0
                                  : c.flat()) && void 0 !== l
                              ? l
                              : []),
                          ];
                          p = p.filter((e) => e);
                          const { success: f = [], error: v = [] } = Object(
                              Yr.a,
                            )(p, oo),
                            b = f.map((e) => e.info),
                            I = v.map((e) => e.info),
                            y = [...b, ...I];
                          return I.length
                            ? {
                                ok: !1,
                                error: {
                                  toUid: e,
                                  conversation: m,
                                  allItems: y,
                                  successItems: b,
                                  errorItems: I,
                                },
                              }
                            : {
                                ok: !0,
                                value: {
                                  toUid: e,
                                  conversation: m,
                                  allItems: y,
                                  successItems: b,
                                },
                              };
                        }),
                        (this._deleteMsgsBelongToTTLItems = async (e) => {
                          const t = Object(Yr.a)(e, ro),
                            s = Object.keys(t).map(
                              async (e) => (
                                Object(Jr.b)(this._sideEffect, e, t[e]),
                                this._deletePerConversation(e, t[e])
                              ),
                            );
                          return await Promise.all(s);
                        }),
                        (this._sideEffect = async function (t, s) {
                          return (
                            void 0 === s && (s = []),
                            setTimeout(async () => {
                              const i = await Object(Jr.b)(
                                e._cancelSendingPerConversation,
                                t,
                                s,
                              );
                              i.ok ||
                                e._logger.zsymb(
                                  18,
                                  16228,
                                  30013,
                                  "cancelSendingPerConversation failed",
                                  i.error,
                                );
                              const n = await Object(Jr.b)(
                                e._syncDeletePerConversation,
                                t,
                                s,
                              );
                              n.ok ||
                                e._logger.zsymb(
                                  18,
                                  16228,
                                  30014,
                                  "syncDeletePerConversation failed",
                                  n.error,
                                );
                            }, 0)
                          );
                        }),
                        (this._cancelSendingPerConversation = async function (
                          e,
                          t,
                        ) {
                          void 0 === t && (t = []),
                            t.forEach((t) =>
                              Object(Jr.b)(
                                () => {},
                                e,
                                null == t ? void 0 : t.cliMsgId,
                              ),
                            );
                        }),
                        (this._syncDeletePerConversation = async function (
                          e,
                          t,
                        ) {
                          if (
                            (void 0 === t && (t = []),
                            !bt.default.ttl.enable_sync_delete)
                          )
                            return;
                          const s = (t) => {
                            +t.msgId &&
                              Object(Zr.e)(e, {
                                cliMsgId: t.cliMsgId,
                                msgId: t.msgId,
                                sendDttm: t.sendDttm,
                                toUid: e,
                                fromUid: t.fromUid,
                              });
                          };
                          t.forEach((e) => Object(Jr.b)(s, e));
                        }),
                        (this._pruning = !1),
                        (this._logger = i.ModuleContainer.resolve(
                          q.ZLoggerFactory,
                        ).createZLogger("utils", [
                          "ttl",
                          "destructor",
                          "pruner",
                        ]));
                    }
                    _getPruneMsgKey(e) {
                      return e ? `${e.msgId}|${e.ttlType}` : "";
                    }
                    _hasPruneMsgCache(e) {
                      return this._pruneMsgCache.has(this._getPruneMsgKey(e));
                    }
                    _setPruneMsgCache(e) {
                      this._pruneMsgCache.set(this._getPruneMsgKey(e), void 0);
                    }
                    async _deleteMsgsAndEmit(e) {
                      const t =
                          await this._ttl.getMappedMsgsByConvIdFromTTLItems(e),
                        s = await Object(Jr.b)(
                          this._deleteMsgsBelongToTTLItems,
                          e,
                        );
                      s.ok ||
                        (this._logger.zsymb(
                          18,
                          16228,
                          30015,
                          "Pruner",
                          "deleteMessages failed",
                        ),
                        this._retryErrorDelete(e)),
                        s.ok && this._retryErrorMsgsIfNeeded(s.value),
                        s.ok && this._emitPruneResult(s.value, t);
                    }
                  }),
                ) || io),
            ) || io),
        );
        function lo(e, t) {
          return e.reduce(
            (e, s, i, n) => (e[t(s, i, n) ? 0 : 1].push(s), e),
            [[], []],
          );
        }
        var co;
        const ho = R.MessageConstants.MAX_MSG_ID;
        Object(i.singleton)(Qr.a)(
          (co =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (co =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (co = class {
                    constructor() {
                      (this._logger = void 0),
                        (this.dispose = () => {}),
                        (this._safePut = async (e) => {
                          const t = [],
                            s = [],
                            i = K.default.getInstance();
                          for (const a of e)
                            try {
                              await i.MsgInfo.TTLItem.insert(a, {
                                replace: !0,
                              }),
                                t.push(a);
                            } catch (n) {
                              s.push([a, n]);
                            }
                          return [t, s];
                        }),
                        (this.putMsgs = async (e) => {
                          let t = e.map((e) => mo(e));
                          const [s, i] = lo(t, (e) => e.ok),
                            n = s.map((e) => e.value);
                          let a = [],
                            r = [];
                          [r, a] = await this._safePut(n);
                          const o = i.map((e) => e.error);
                          return a.lastItem || o.length
                            ? {
                                ok: !1,
                                error: { invalidItems: o, errorItems: a },
                              }
                            : { ok: !0, value: r };
                        }),
                        (this.deletes = (e) =>
                          K.default
                            .getInstance()
                            .MsgInfo.TTLItem.deleteMulti(e)),
                        (this.getExpireItemsBefore = async (e, t) => {
                          const s = t
                              ? {
                                  from: [
                                    t.expireOn,
                                    t.toUid,
                                    t.msgId,
                                    t.ttlType,
                                  ],
                                  to: [e, ho, ho, Number.MAX_VALUE],
                                  excludeFrom: !1,
                                  excludeTo: !0,
                                }
                              : {
                                  to: [e, ho, Number.MAX_VALUE],
                                  excludeTo: !1,
                                },
                            i = { limit: 50, index: "expireOn_toUid_pk" },
                            n = K.default.getInstance();
                          return await n.MsgInfo.TTLItem.getAll(s, i);
                        }),
                        (this.getYoungestExpiredItem = async () => {
                          const e = {
                              to: [Number.MAX_VALUE, ho, ho, Number.MAX_VALUE],
                              excludeTo: !0,
                            },
                            t = K.default.getInstance();
                          return (
                            await t.MsgInfo.TTLItem.getAll(e, {
                              limit: 1,
                              index: "expireOn_toUid_pk",
                            })
                          )[0];
                        }),
                        (this.getMappedMsgsByConvIdFromTTLItems = async (e) => {
                          const t = qi.b.messageCache;
                          let s;
                          return (
                            t &&
                              (s = await t.getMappedMessagesByConvIdAsync(e)),
                            s
                          );
                        }),
                        (this._logger = i.ModuleContainer.resolve(
                          q.ZLoggerFactory,
                        ).createZLogger("utils", ["ttl", "destructor", "ttl"]));
                    }
                  }),
                ) || co),
            ) || co),
        );
        const uo = (e) => ("number" == typeof e ? String(e) : e),
          go = [nn.a.Message, nn.a.Quote],
          mo = function (e) {
            void 0 === e && (e = {});
            const t = Object(f.a)({}, e);
            return (
              (t.cliMsgId = uo(t.cliMsgId)),
              t.cliMsgId
                ? ((t.fromUid = uo(t.fromUid)),
                  t.fromUid
                    ? ((t.toUid = uo(t.toUid)),
                      t.toUid
                        ? ((t.msgId = uo(t.msgId)),
                          (s = t.ttlType),
                          go.includes(s)
                            ? ((t.expireOn = +t.expireOn),
                              "number" != typeof t.expireOn
                                ? { ok: !1, error: e }
                                : { ok: !0, value: t })
                            : { ok: !1, error: e })
                        : { ok: !1, error: e })
                    : { ok: !1, error: e })
                : { ok: !1, error: e }
            );
            var s;
          };
        var po = s("oOjv"),
          fo = s("bB26"),
          vo = s("lteq");
        const bo = { [Qt.c]: {} };
        i.ModuleContainer.registerSingleton(
          po.b,
          class {
            constructor() {
              (this.state = bo),
                (this.animationControllers = new Map()),
                (this._manuallyOff = !1),
                (this.name = po.a),
                (this.key = "convId"),
                (this.isFeatEnabled = () =>
                  !this._manuallyOff && bt.default.preview_msg_time.enable),
                (this.state = bo);
            }
            offFeature() {
              this._manuallyOff = !0;
            }
            enableFeature() {
              this._manuallyOff = !1;
            }
            getAnimController(e) {
              if (!this.isFeatEnabled()) return null;
              if (!this.animationControllers.has(e)) {
                const t = new fo.a(e);
                this.animationControllers.set(e, t);
              }
              return this.animationControllers.get(e) || null;
            }
            setScrollDirection(e, t) {
              if (!this.isFeatEnabled()) return;
              const s = this.getAnimController(e);
              null == s || s.setScrollDirection(t);
            }
            hasNewMsgInView(e, t) {
              if (!this.isFeatEnabled()) return;
              const s = this.getAnimController(e);
              null == s || s.hasNewMsgInView(t);
            }
            hasViewOverflowMsg(e, t) {
              if (!this.isFeatEnabled()) return;
              const s = this.getAnimController(e);
              null == s || s.hasViewOverflowMsg(t);
            }
            hitBottom(e, t) {
              if (!this.isFeatEnabled()) return;
              const s = this.getAnimController(e);
              null == s || s.hitBottom(t);
            }
            triggerActiveScroll(e, t) {
              if (!this.isFeatEnabled()) return;
              const s = this.getAnimController(e);
              null == s || s.triggerActiveScroll(t);
            }
            onChangeConversation(e) {
              var t;
              const s = this.getAnimController(e);
              null == s || s.resetAnimation(),
                null === (t = vo.a.getInViewController(e)) ||
                  void 0 === t ||
                  t.resetPreviewTimestamp(),
                Ts.a.onNewSession(e);
            }
            clearAnimations(e) {
              const t = this.getAnimController(e);
              null == t || t.clearAnimations();
            }
            onMouseEnterPreviewTime(e, t) {
              if (!this.isFeatEnabled() || !t) return;
              const s = this.getAnimController(e);
              (null == s ? void 0 : s.mountedPreviewTime) === t &&
                (null == s || s.pause());
            }
            onMouseLeavePreviewTime(e, t) {
              if (!this.isFeatEnabled() || !t) return;
              const s = this.getAnimController(e);
              (null == s ? void 0 : s.mountedPreviewTime) === t &&
                (null == s || s.resume());
            }
            setTopMost(e, t, s) {
              if (!this.isFeatEnabled()) return;
              const i = this.getAnimController(e);
              null == i || i.setTopMost(t, s);
            }
            setSecondTopMost(e, t, s) {
              if (!this.isFeatEnabled()) return;
              const i = this.getAnimController(e);
              null == i || i.setSecondTopMost(t, s);
            }
            init() {}
            getItem(e) {
              return this.state[e.key];
            }
            getList(e) {
              return Object.keys(this.state);
            }
            onGetItemFailure(e) {}
            onGetListFailure(e) {}
          },
        );
        var Io,
          yo = s("tDXj"),
          _o = s("AqnK"),
          Oo = s("KweF");
        let Co =
          Object(i.injectable)()(
            (Io = class {
              constructor() {
                (this._blobURLMapping = new Map()),
                  (this._conversationCache = new Map());
              }
              async preload(e, t, s) {
                let i = e;
                if (this._isHttpURL(e))
                  try {
                    if (this._blobURLMapping.has(e))
                      return _o.k.Success({ mediaURL: e });
                    const t = Object(Oo.h)().toString(),
                      s = await Object(Oo.g)(t, e, Oo.a.dev, void 0, {
                        useDiskCache: !1,
                      });
                    if (s.error)
                      return _o.k.Failure({
                        code: _o.d.FAILURE_BY_FETCH,
                        error: s.error,
                      });
                    i = s.data;
                  } catch (n) {
                    return _o.k.Failure({
                      code: _o.d.FAILURE_BY_FETCH,
                      error: n,
                    });
                  }
                else if (this._isBlobURL(e)) {
                  if (this._blobURLMapping.has(e))
                    return _o.k.Success({ mediaURL: e });
                  if (!(await this.isBlobURLAlive(e)))
                    return _o.k.Failure({
                      code: _o.d.FAILURE_BY_FETCH,
                      error: "blob url expired",
                    });
                }
                return this._cache(i, t, s), _o.k.Success({ mediaURL: i });
              }
              async isBlobURLAlive(e, t) {
                const s =
                  null != t && t.document
                    ? t.document.createElement("img")
                    : new Image();
                s.src = e;
                try {
                  return await s.decode(), !0;
                } catch (i) {
                  return !1;
                }
              }
              async preloadImageDOM(e, t) {
                let s = 0,
                  i = null,
                  n = 1;
                if (
                  "async" ===
                  (t &&
                  "async" !== (null == t ? void 0 : t.mode) &&
                  "auto" !== (null == t ? void 0 : t.mode)
                    ? "sync"
                    : "async")
                ) {
                  n = 2;
                  try {
                    return await this._preloadImageAsync(e);
                  } catch (a) {
                    s++, (i = a);
                  }
                }
                try {
                  return await this.preloadImageSync(e);
                } catch (a) {
                  s++, (i = a);
                }
                if (s === n) throw new Error(`preloadImageDOM failed ${i}`);
                return null;
              }
              async _preloadImageAsync(e) {
                try {
                  const t = new Image();
                  for (const s in e) s && e[s] && t.setAttribute(s, e[s]);
                  return await t.decode(), t;
                } catch (t) {
                  throw t;
                }
              }
              async preloadImageSync(e) {
                const t = new Image();
                for (const n in e) n && e[n] && t.setAttribute(n, e[n]);
                const s = new Promise((e, s) => {
                  (t.onload = e), (t.onerror = s);
                });
                try {
                  return await s, t;
                } catch (i) {
                  throw i;
                }
              }
              _cache(e, t, s) {
                if (
                  (this._blobURLMapping.set(e, {
                    blobURL: e,
                    cacheMode: t,
                    convId: s,
                  }),
                  s)
                ) {
                  const t = this._conversationCache.get(s) || [];
                  t.push(e), this._conversationCache.set(s, t);
                }
              }
              _isHttpURL(e) {
                return e.startsWith("http") || e.startsWith("https");
              }
              _isBlobURL(e) {
                return e.startsWith("blob");
              }
            }),
          ) || Io;
        i.ModuleContainer.registerSingleton(yo.a, Co);
        var Eo = s("UeuQ"),
          Mo = s("XDVU");
        function So(e) {
          return e.startsWith("http") || e.startsWith("https");
        }
        var To = s("/I0A"),
          wo = s("N3F0"),
          Ro = s("3Mje"),
          Lo = s("jjJf");
        const Do = 0,
          Fo = 1,
          Ao = 2,
          jo = 4;
        class Po extends Error {
          constructor(e) {
            super(`ExpBackoff error:${e}`), (this.code = e);
          }
        }
        function No(e, t) {
          return Math.floor(Math.random() * (t - e + 1) + e);
        }
        function* Uo(e) {
          var t, s, i, n, a, r, o, d, l;
          const c =
              null !== (t = null == e ? void 0 : e.retries) && void 0 !== t
                ? t
                : 3,
            h =
              null !== (s = null == e ? void 0 : e.min) && void 0 !== s
                ? s
                : 100,
            u =
              null !== (i = null == e ? void 0 : e.max) && void 0 !== i
                ? i
                : 1e4,
            g =
              null !== (n = null == e ? void 0 : e.step) && void 0 !== n
                ? n
                : 2,
            m =
              null !== (a = null == e ? void 0 : e.jitter) && void 0 !== a
                ? a
                : 0,
            p =
              "number" ==
              typeof (null == e ||
              null === (r = e.lastTryDelayTime) ||
              void 0 === r
                ? void 0
                : r.min)
                ? null == e || null === (o = e.lastTryDelayTime) || void 0 === o
                  ? void 0
                  : o.min
                : h,
            f = {
              min: p,
              max: No(
                p,
                "number" ==
                  typeof (null == e ||
                  null === (d = e.lastTryDelayTime) ||
                  void 0 === d
                    ? void 0
                    : d.max)
                  ? null == e ||
                    null === (l = e.lastTryDelayTime) ||
                    void 0 === l
                    ? void 0
                    : l.max
                  : u,
              ),
            };
          if (h <= 0) throw new Po(Ao);
          if (m < 0 || m > 1) throw new Po(Fo);
          let v = 0;
          for (; v <= c; ) {
            let e = h,
              t = u;
            v === c - 1 && ((e = f.min), (t = f.max));
            const s = ko({ nTry: v, step: g, jitter: m, min: e, max: t });
            yield {
              nTry: v,
              duration: s,
              sleep: () =>
                new Promise((e) => {
                  setTimeout(e, s);
                }),
            },
              v++;
          }
        }
        function ko(e) {
          let { step: t, nTry: s, jitter: i, min: n, max: a } = e,
            r = n * Math.pow(t, s);
          if (i) {
            const e = Math.random(),
              t = Math.floor(e * i * r);
            r = 0 == (1 & Math.floor(10 * e)) ? r - t : r + t;
          }
          return 0 | Math.min(r, a);
        }
        function Bo(e, t) {
          return async function () {
            for (var s = arguments.length, i = new Array(s), n = 0; n < s; n++)
              i[n] = arguments[n];
            for await (const { sleep: r, duration: o, nTry: d } of Uo(t))
              try {
                const s = await e(...i);
                return (
                  null != t &&
                    t.afterRetry &&
                    (null == t ||
                      t.afterRetry({
                        nTry: d,
                        duration: o,
                        sleep: r,
                        success: !0,
                        shouldRetry: !1,
                      })),
                  s
                );
              } catch (a) {
                const e =
                    null != t && t.shouldRetryOnError
                      ? null == t
                        ? void 0
                        : t.shouldRetryOnError
                      : () => Promise.resolve(!0),
                  s = await e({
                    error: a,
                    currentState: { nTry: d, duration: o, sleep: r },
                    input: i,
                  });
                if (
                  (null != t &&
                    t.afterRetry &&
                    (null == t ||
                      t.afterRetry({
                        nTry: d,
                        duration: o,
                        sleep: r,
                        shouldRetry: s,
                        success: !1,
                      })),
                  !s)
                )
                  throw new Po(jo);
                await r();
              }
            throw new Po(Do);
          };
        }
        var Go,
          xo = s("tqrY");
        let zo =
          Object(i.injectable)()(
            (Go = class {
              constructor() {
                (this._responsesCache = new Map()),
                  (this._blobURLReserveMap = new Map()),
                  (this.onRevokeFetchedURL = (e) => {
                    const { blobURL: t, remoteURL: s } = e;
                    this.Logger.zsymb(
                      0,
                      15245,
                      30002,
                      "ImageLoader: onRevoke",
                      t,
                      s,
                    );
                    let i = this._responsesCache.get(s);
                    return i
                      ? (i.blobURL === t &&
                          (i = Object(f.a)(
                            Object(f.a)({}, i),
                            {},
                            { isRevoked: !0 },
                          )),
                        this._responsesCache.set(s, i),
                        i)
                      : null;
                  });
              }
              get Logger() {
                return Object(To.a)();
              }
              async fetch(e, t) {
                Object(Mo.a)(
                  "string" == typeof t && So(t),
                  `Media source must be a (http|https) URL. Got ${t}`,
                );
                const s = this._responsesCache.get(t);
                if (s && !s.isRevoked)
                  return _o.k.Success({
                    mediaURL: this._responsesCache.get(t).blobURL,
                  });
                try {
                  const s = Object(Oo.h)().toString(),
                    i = Bo(
                      Object(Lo.b)().isEnableUserPCloud()
                        ? Object(wo.a)(Oo.g, null, Object(Ro.d)(e))
                        : Oo.g,
                      {
                        min: xo.a.image_loader.retryMin,
                        max: xo.a.image_loader.retryMax,
                        retries: 3,
                        lastTryDelayTime: {
                          min: xo.a.image_loader.lastTryDelayTime.min,
                          max: xo.a.image_loader.lastTryDelayTime.max,
                        },
                        afterRetry: async (e) => {
                          let {
                            success: t,
                            shouldRetry: s,
                            nTry: i,
                            duration: n,
                          } = e;
                          t ||
                            this.Logger.zsymb(
                              0,
                              15245,
                              3e4,
                              `MediaBlobFetcher: Try ${i}: failed. Should retry: ${s} after ${n}ms`,
                            ),
                            t ||
                              s ||
                              this.Logger.zsymb(
                                0,
                                15245,
                                30001,
                                `MediaBlobFetcher: Download failed after ${i} tries`,
                              );
                        },
                      },
                    ),
                    n = await i(s, t, Oo.a.dev, void 0, { useDiskCache: !1 });
                  if (n.error)
                    return _o.k.Failure({
                      code: _o.d.FAILURE_BY_FETCH,
                      error: { mediaURL: t, error: n.error },
                    });
                  const a = this._responsesCache.get(t) || {};
                  return (
                    this._cacheResponse(
                      t,
                      Object(f.a)(
                        Object(f.a)({}, a),
                        {},
                        {
                          remoteURL: t,
                          blobURL: n.data,
                          mediaId: e,
                          isRevoked: !1,
                        },
                      ),
                    ),
                    _o.k.Success({ mediaURL: n.data })
                  );
                } catch (i) {
                  return _o.k.Failure({
                    code: _o.d.FAILURE_BY_FETCH,
                    error: { mediaURL: t, error: i },
                  });
                }
              }
              isAlive(e, t) {
                const s = this._responsesCache.get(e);
                return s && !s.isRevoked && s.blobURL === t;
              }
              _cacheResponse(e, t) {
                this._responsesCache.set(e, t),
                  this._blobURLReserveMap.set(t.blobURL, e);
              }
            }),
          ) || Go;
        i.ModuleContainer.registerSingleton(Eo.a, zo);
        class Vo extends Event {
          constructor(e) {
            super(_o.j.Revoke_BlobURL), (this.payload = e);
          }
        }
        var Ho;
        let $o =
          Object(i.injectable)()(
            (Ho = class extends te.b {
              async fetch(e) {
                const {
                  mediaId: t,
                  source: s,
                  diskFetcherConfig: n,
                  sendDttm: a,
                } = e;
                let r;
                Object(Mo.a)(
                  "string" == typeof t,
                  `MediaFetcherImpl: mediaId must be a string. Got ${t}`,
                ),
                  Object(Mo.a)(
                    "string" == typeof s,
                    `MediaFetcherImpl: source must be a string. Got ${s}`,
                  ),
                  (r = _o.h.MemoryCache);
                const o = So(s),
                  d = s.startsWith("blob");
                if (!o && d) return _o.k.Success({ mediaURL: s });
                if (r === _o.h.MemoryCache)
                  try {
                    return await i.ModuleContainer.resolve(Eo.a).fetch(t, s, {
                      sendDttm: a,
                    });
                  } catch (h) {
                    return Promise.reject(h);
                  }
                Object(Mo.a)(
                  "object" == typeof n &&
                    "string" == typeof n.savePath &&
                    !!n.downloadEntrySerial,
                  `MediaFetcherImpl: invalid diskFetcherConfig. Got ${n}`,
                );
                const { savePath: l, downloadEntrySerial: c } = n;
                return i.ModuleContainer.resolve(Eo.b).fetch(t, s, {
                  entrySerial: c,
                  savePath: l,
                  sendDttm: a,
                });
              }
              onRevokeFetchedURL(e) {
                const t = i.ModuleContainer.resolve(Eo.a).onRevokeFetchedURL(e);
                t && this._broadcastEvent(_o.j.Revoke_BlobURL, t);
              }
              _broadcastEvent(e, t) {
                if (e === _o.j.Revoke_BlobURL) this.dispatchEvent(new Vo(t));
              }
            }),
          ) || Ho;
        i.ModuleContainer.registerSingleton(Eo.c, $o);
        var Wo,
          Ko = s("Evs5");
        class qo {
          constructor() {
            (this.aborted = void 0), (this.aborted = !0);
          }
        }
        class Zo {
          constructor(e, t) {
            var s = this;
            void 0 === t && (t = []),
              (this._task = e),
              (this.args = t),
              (this._abortController = void 0),
              (this._aborted = !1),
              (this._fulfilled = !1),
              (this._promise = null),
              (this._abortableTask = void 0),
              (this.abort = () => {
                this._abortController.abort();
              }),
              (this._abortController = new AbortController()),
              (this._abortableTask = function () {
                for (
                  var e = arguments.length, t = new Array(e), i = 0;
                  i < e;
                  i++
                )
                  t[i] = arguments[i];
                return new Promise((e, i) => {
                  const n = () => {
                    (s._aborted = !0),
                      i(new qo()),
                      s._abortController.signal.removeEventListener("abort", n);
                  };
                  s._abortController.signal.addEventListener("abort", n),
                    s
                      ._task(...t)
                      .then(e)
                      .catch(i)
                      .finally(() => {
                        s._abortController.signal.removeEventListener(
                          "abort",
                          n,
                        ),
                          (s._fulfilled = !0);
                      });
                });
              });
          }
          get aborted() {
            return this._aborted;
          }
          get fulfilled() {
            return this._fulfilled;
          }
          get promise() {
            return (
              this._promise ||
                (this._promise = this._abortableTask(...this.args)),
              this._promise
            );
          }
        }
        function Jo(e) {
          for (
            var t = arguments.length, s = new Array(t > 1 ? t - 1 : 0), i = 1;
            i < t;
            i++
          )
            s[i - 1] = arguments[i];
          return new Zo(e, s);
        }
        let Qo =
          Object(i.injectable)()(
            (Wo = class {
              constructor() {
                (this._taskMapper = new Map()),
                  (this._runningTask = new Map()),
                  (this._buildFetchConfig = async (e) => {
                    Object(Mo.a)(
                      !!e && "object" == typeof e,
                      `_buildDownloadConfig: config must be object, got ${e}`,
                    );
                    const t = Object(e);
                    Object(Mo.a)(
                      "string" == typeof t.mediaId,
                      `_buildDownloadConfig: mediaId must be string, got ${null == t ? void 0 : t.mediaId}`,
                    ),
                      Object(Mo.a)(
                        t.entry in _o.i,
                        `_buildDownloadConfig: entry must be MediaDisplayTarget, got ${null == t ? void 0 : t.entry}`,
                      ),
                      Object(Mo.a)(
                        "string" == typeof t.source,
                        `_buildDownloadConfig: source must be string, got ${null == t ? void 0 : t.source}`,
                      ),
                      Object(Mo.a)(
                        t.type in _o.m,
                        `_buildDownloadConfig: type must be MediaQuality, got ${null == t ? void 0 : t.type}`,
                      );
                    const s = {
                      mediaId: t.mediaId,
                      source: t.source,
                      sendDttm: t.sendDttm,
                    };
                    if (t.localPathMapper) {
                      const e = await t.localPathMapper(t.source, t.type);
                      s.diskFetcherConfig = {
                        savePath: e,
                        downloadEntrySerial: t.downloadEntrySerial,
                        autoDownload: t.autoDownload,
                      };
                    }
                    return s;
                  });
              }
              async loadMedia(e, t) {
                const {
                    mediaId: s,
                    entry: i,
                    qualityFallback: n,
                    fetchStrategy: a,
                    canUseRemoteOnLocalFailure: r,
                  } = e,
                  { fetcher: o, diskCacheConfig: d } = a,
                  l = null == t ? void 0 : t.onFirstAvailable;
                let c = n;
                const h = new Set();
                let u = null;
                const g = new Set();
                for (; c; ) {
                  const t = c.data.url,
                    n = c.data.type;
                  if (!t) {
                    c = c.nextOR || c.next;
                    continue;
                  }
                  if (g.has(t)) {
                    c = c.nextOR || c.next;
                    continue;
                  }
                  let a;
                  if (this._runningTask.has(t))
                    (a = this._runningTask.get(t)), a.references.add(i);
                  else {
                    const r = Jo(
                      o,
                      await this._buildFetchConfig({
                        mediaId: s,
                        entry: i,
                        source: t,
                        type: _o.m[n],
                        localPathMapper: null == d ? void 0 : d.localPathMapper,
                        downloadEntrySerial:
                          null == d ? void 0 : d.downloadEntrySerial,
                        autoDownload: !!u,
                        sendDttm: e.sendDttm,
                      }),
                    );
                    (a = {
                      promise: r.promise,
                      abort: r.abort,
                      references: new Set([i]),
                    }),
                      this._runningTask.set(t, a);
                    const l = this._taskMapper.get(s) || new Set();
                    l.add(t), this._taskMapper.set(s, l);
                  }
                  const r = () => {
                      var e;
                      (this._runningTask.delete(t),
                      a.references.delete(i),
                      0 === a.references.size) &&
                        (null === (e = this._taskMapper.get(s)) ||
                          void 0 === e ||
                          e.delete(t));
                    },
                    m = await a.promise.finally(r);
                  "ERROR" != m.type
                    ? (u ||
                        ((u = { mediaURL: m.data.mediaURL, quality: _o.m[n] }),
                        null == l || l(_o.k.Success(u))),
                      h.add(n),
                      (c = c.next))
                    : (g.add(t), (c = c.nextOR || c.next));
                }
                return null === u
                  ? _o.k.Failure({ code: _o.d.FAILURE_BY_FETCH, error: s })
                  : _o.k.Success(u);
              }
              abort(e, t) {
                const s = this._taskMapper.get(e);
                if (!s) return;
                const i = Array.from(s);
                for (const n of i) {
                  const e = this._runningTask.get(n);
                  e
                    ? (e.references.delete(t),
                      0 === e.references.size &&
                        (e.abort(), this._runningTask.delete(n), s.delete(n)))
                    : s.delete(n);
                }
                0 === s.size && this._taskMapper.delete(e);
              }
            }),
          ) || Wo;
        i.ModuleContainer.registerSingleton(Ko.a, Qo);
        var Yo = s("UD1y"),
          Xo = s("Yvn0"),
          ed = s.n(Xo);
        const td = {
          FORWARD_MESSAGE: "FORWARD_MESSAGE",
          DOWNLOAD_MESSAGE: "DOWNLOAD_MESSAGE",
          ROTATE_LEFT: "ROTATE_LEFT",
          ROTATE_RIGHT: "ROTATE_RIGHT",
          ZOOM_IN: "ZOOM_IN",
          RESET_ZOOM: "RESET_ZOOM",
          MORE_MEDIA_ACTION: "MORE_MEDIA_ACTION",
          RELOAD_MEDIA: "RELOAD_MEDIA",
        };
        var sd,
          id = s("fB1t"),
          nd = s("Ms/M"),
          ad = s("c3KS");
        Object(i.injectable)()(
          (sd =
            Object($t.b)(Yo.b)(
              (sd =
                (function (e, t) {
                  return Object(i.inject)(Ko.a)(e, void 0, 0);
                })(
                  (sd =
                    (function (e, t) {
                      return Object(i.inject)(V.a)(e, void 0, 1);
                    })(
                      (sd =
                        (function (e, t) {
                          return Object(i.inject)(Eo.c)(e, void 0, 2);
                        })(
                          (sd =
                            Reflect.metadata(
                              "design:type",
                              Function,
                            )(
                              (sd =
                                Reflect.metadata("design:paramtypes", [
                                  Object,
                                  void 0 === V.a ? Object : V.a,
                                  Object,
                                ])(
                                  (sd = class {
                                    constructor(e, t, s) {
                                      (this.mediaPackageManager = e),
                                        (this.application = t),
                                        (this.mediaFetcher = s),
                                        (this._loadedTask = new Set()),
                                        (this._urlRefs = {}),
                                        (this._lastConvId = null),
                                        (this._revokedBlobURL = new Map()),
                                        (this._unmountInvoker = new Map()),
                                        (this._activeContextWindow = null),
                                        (this._eventEmitter = new ed.a()),
                                        (this.setActiveWindowContext = (e) => (
                                          "WeakRef" in globalThis
                                            ? (this._activeContextWindow =
                                                new WeakRef(e))
                                            : (this._activeContextWindow = e),
                                          this.removeActiveWindowContext
                                        )),
                                        (this.removeActiveWindowContext =
                                          () => {
                                            this._activeContextWindow = null;
                                          }),
                                        (this.getActiveWindowContext = () =>
                                          this._activeContextWindow instanceof
                                          WeakRef
                                            ? this._activeContextWindow.deref()
                                            : this._activeContextWindow),
                                        (this._signalRenderItem = function () {
                                          Object(nt.h)(...arguments);
                                        }),
                                        (this._triggerError = (e) => {
                                          0;
                                        }),
                                        (this._triggerExpired = (e) => {
                                          const t = id.a.get(e.mediaId);
                                          if (t) {
                                            const s = e.mediaId.split(".");
                                            "0" == s[1] &&
                                              (s[1] = Q.p.getSessionUserId()),
                                              "0" == s[2] &&
                                                (s[2] = Q.p.getSessionUserId());
                                            const i = s.join("_"),
                                              n = Object(f.a)({ metaId: i }, t);
                                            nd.a.dispatchEvent(
                                              new ad.a(ad.b.WriteDB, {
                                                message: n,
                                                result: {
                                                  isExpired: !0,
                                                  autoDownloadPath: "",
                                                },
                                              }),
                                            );
                                          }
                                        }),
                                        (this._handleRevokeURL = (e) => {
                                          const t =
                                            null == e ? void 0 : e.payload;
                                          Object(Mo.a)(
                                            !!t,
                                            "ImageLoaderController: revoke event payload undefined",
                                          );
                                          const { blobURL: s, mediaId: i } = t;
                                          if (!s) return;
                                          const n =
                                            this._revokedBlobURL.get(i) ||
                                            new Set();
                                          n.add(s),
                                            this._revokedBlobURL.set(i, n);
                                        }),
                                        (this.listenEvents = () => {
                                          this.application.addEventListener(
                                            V.b.Exit,
                                            this._cleanupEvents,
                                          ),
                                            this.mediaFetcher.addEventListener(
                                              _o.j.Revoke_BlobURL,
                                              this._handleRevokeURL,
                                            );
                                        }),
                                        (this._cleanupEvents = () => {
                                          this.application.removeEventListener(
                                            V.b.Exit,
                                            this._cleanupEvents,
                                          ),
                                            this.mediaFetcher.removeEventListener(
                                              _o.j.Revoke_BlobURL,
                                              this._handleRevokeURL,
                                            );
                                        }),
                                        (this.name = Yo.a),
                                        (this.data = new Map()),
                                        (this.key = "mediaId"),
                                        (this.init = () => {
                                          this.listenEvents();
                                        }),
                                        this.init();
                                    }
                                    on(e, t) {
                                      return (
                                        this._eventEmitter.on(e, t),
                                        () => this._eventEmitter.off(e, t)
                                      );
                                    }
                                    off(e, t) {
                                      this._eventEmitter.off(e, t);
                                    }
                                    emit(e, t) {
                                      this._eventEmitter &&
                                        e in td &&
                                        this._eventEmitter.emit(e, t);
                                    }
                                    async manualRetry(e, t) {
                                      this._loadedTask.delete(`${e}-${t}`);
                                      const s = this.data.get(e);
                                      s &&
                                        s.failure &&
                                        this.data.set(
                                          e,
                                          Object(f.a)(
                                            Object(f.a)({}, s),
                                            {},
                                            { failure: void 0 },
                                          ),
                                        ),
                                        this.emit(td.RELOAD_MEDIA, {
                                          mediaId: e,
                                          entry: t,
                                          hotSwapSource: !0,
                                        });
                                    }
                                    forceError(e) {
                                      const t = this.data.get(e) || {
                                        mediaId: e,
                                      };
                                      this.data.set(
                                        e,
                                        Object(f.a)(
                                          Object(f.a)({}, t),
                                          {},
                                          {
                                            failure: {
                                              code: _o.d.FAILURE_BY_FETCH,
                                              message: "Force error",
                                            },
                                            view: {},
                                          },
                                        ),
                                      ),
                                        this._signalRenderItem(this.name, e);
                                    }
                                    async loadMedia(e, t) {
                                      var s, i;
                                      void 0 === t && (t = {});
                                      const { forceLoad: n = !1 } = t,
                                        a = `${e.mediaId}-${e.entry}`,
                                        r = this.data.get(e.mediaId);
                                      if (globalThis.__alwaysForcePhotoExpired)
                                        return this.forceExpire(e.mediaId);
                                      if (
                                        !(
                                          (this._loadedTask.has(a) &&
                                            !1 === n) ||
                                          (null != r && r.failure && !1 === n)
                                        )
                                      )
                                        if (
                                          (this._mayInitState(e, !0),
                                          null !== (s = e.uploadSource) &&
                                            void 0 !== s &&
                                            null !== (i = s.oriUrl) &&
                                            void 0 !== i &&
                                            i.startsWith("blob:"))
                                        )
                                          this._updateViewUpload(
                                            e.mediaId,
                                            e.entry,
                                            e.uploadSource,
                                          );
                                        else
                                          try {
                                            let s = !1;
                                            const i = this.data.get(e.mediaId),
                                              n = Object(f.a)(
                                                Object(f.a)({}, t),
                                                {},
                                                { expiryCheck: e.expiryCheck },
                                              ),
                                              r =
                                                await this.mediaPackageManager.loadMedia(
                                                  e,
                                                  {
                                                    hasHd:
                                                      null == i
                                                        ? void 0
                                                        : i.hasHd,
                                                    skipHdCheck:
                                                      null == i
                                                        ? void 0
                                                        : i.hasHd,
                                                    onFirstAvailable: (t) => {
                                                      (s = !0),
                                                        this._handleLoadResponse(
                                                          e.mediaId,
                                                          e.entry,
                                                          t,
                                                          n,
                                                        );
                                                    },
                                                  },
                                                );
                                            s ||
                                              this._handleLoadResponse(
                                                e.mediaId,
                                                e.entry,
                                                r,
                                                n,
                                              ),
                                              this._loadedTask.add(a);
                                          } catch (o) {}
                                    }
                                    runFullflow(e, t) {
                                      this._loadedTask.delete(`${e}-${t}`),
                                        this.manualRetry(e, t);
                                    }
                                    getViewState(e, t) {
                                      var s, i;
                                      return null === (s = this.data.get(e)) ||
                                        void 0 === s ||
                                        null === (i = s.view) ||
                                        void 0 === i
                                        ? void 0
                                        : i[t];
                                    }
                                    allowOutviewUpdate(e, t) {
                                      const s = this.data.get(e),
                                        i = null == s ? void 0 : s.view[t];
                                      i
                                        ? i.actual !== i.expected &&
                                          Boolean(i.expected) &&
                                          (this.data.set(
                                            e,
                                            Object(f.a)(
                                              Object(f.a)({}, s),
                                              {},
                                              {
                                                view: Object(f.a)(
                                                  Object(f.a)(
                                                    {},
                                                    null == s ? void 0 : s.view,
                                                  ),
                                                  {},
                                                  {
                                                    [t]: Object(f.a)(
                                                      Object(f.a)({}, i),
                                                      {},
                                                      {
                                                        actual: i.expected,
                                                        dataSrcId:
                                                          _o.e.ZaloSource,
                                                      },
                                                    ),
                                                  },
                                                ),
                                              },
                                            ),
                                          ),
                                          this._signalRenderItem(this.name, e),
                                          this._runCleanup(e, i.actual))
                                        : this.emit("RELOAD_MEDIA", {
                                            mediaId: e,
                                            entry: t,
                                            hotSwapSource: !0,
                                          });
                                    }
                                    forceExpire(e) {
                                      const t = this.data.get(e) || {
                                        mediaId: e,
                                      };
                                      this.data.set(
                                        e,
                                        Object(f.a)(
                                          Object(f.a)({}, t),
                                          {},
                                          {
                                            failure: {
                                              code: _o.d.FORCE_EXPIRE,
                                              message: "Force expire",
                                            },
                                            view: {},
                                          },
                                        ),
                                      ),
                                        this._signalRenderItem(this.name, e);
                                    }
                                    abort(e, t) {
                                      const s = `${e}-${t}`;
                                      this.mediaPackageManager.abort(e, t),
                                        this._loadedTask.delete(s);
                                    }
                                    rotateMedia(e, t) {
                                      let s = this.data.get(e);
                                      if (!s)
                                        throw new Error(
                                          `rotateMedia failed with ${e}: ${t}`,
                                        );
                                      let i = s.rotateDeg || 0;
                                      (i += t),
                                        (s = Object(f.a)(
                                          Object(f.a)({}, s),
                                          {},
                                          { rotateDeg: i },
                                        )),
                                        this.data.set(e, s),
                                        this._signalRenderItem(this.name, e);
                                    }
                                    isBlobURLAlive(e, t) {
                                      const s = this._revokedBlobURL.get(e);
                                      return !s || !s.has(t);
                                    }
                                    abanbonMedia(e, t) {
                                      const s =
                                        this._revokedBlobURL.get(e) ||
                                        new Set();
                                      s.add(t), this._revokedBlobURL.set(e, s);
                                    }
                                    _runCleanup(e, t) {
                                      if (!t || !t.startsWith("blob:")) return;
                                      const s = this.data.get(e);
                                      if (!s)
                                        return void URL.revokeObjectURL(t);
                                      const i = s.view;
                                      Object.values(i).forEach((e) => {
                                        e.actual !== t && e.expected;
                                      }),
                                        URL.revokeObjectURL(t);
                                    }
                                    _mayInitState(e, t) {
                                      void 0 === t && (t = !0);
                                      let s = this.data.get(e.mediaId);
                                      s ||
                                        ((s = {
                                          mediaId: e.mediaId,
                                          view: {},
                                          rotateDeg: 90 * e.vOrient,
                                        }),
                                        this.data.set(e.mediaId, s)),
                                        t ||
                                          this._signalRenderItem(
                                            this.name,
                                            e.mediaId,
                                          );
                                    }
                                    _handleLoadResponse(e, t, s, i) {
                                      switch (s.type) {
                                        case "ERROR":
                                          this._handleLoadError(s, e, t, i);
                                          break;
                                        case "SUCCESS":
                                          this._handleLoadSuccess(s, e, t, i);
                                          break;
                                        default:
                                          throw new Error(
                                            `Unknown response type: ${e} ${t} got ${null == s ? void 0 : s.type}`,
                                          );
                                      }
                                    }
                                    _handleLoadError(e, t, s, i) {
                                      void 0 === i && (i = {});
                                      const n = e.data;
                                      switch (n.code) {
                                        case _o.d.FAILURE_BY_FETCH: {
                                          var a, r;
                                          const e = this.data.get(t);
                                          (e.failure = {
                                            code: n.code,
                                            message: n.error,
                                          }),
                                            this.data.set(t, e);
                                          !0 ===
                                          (null === (a = i) ||
                                          void 0 === a ||
                                          null === (r = a.expiryCheck) ||
                                          void 0 === r
                                            ? void 0
                                            : r.call(a))
                                            ? this._triggerExpired({
                                                mediaId: t,
                                              })
                                            : this._triggerError({
                                                mediaId: t,
                                              }),
                                            this._signalRenderItem(
                                              this.name,
                                              t,
                                            );
                                          break;
                                        }
                                        case _o.d.FAILURE_BY_PRELOAD: {
                                          const e = this.data.get(t);
                                          (e.failure = {
                                            code: n.code,
                                            message: n.error,
                                          }),
                                            this.data.set(t, e),
                                            this._signalRenderItem(
                                              this.name,
                                              t,
                                            );
                                          break;
                                        }
                                      }
                                    }
                                    async _updateViewUpload(e, t, s) {
                                      var n, a, r, o, d, l, c;
                                      if (null == s || !s.oriUrl) return;
                                      let h = this.data.get(e);
                                      const u = await i.ModuleContainer.resolve(
                                        yo.a,
                                      ).isBlobURLAlive(
                                        s.oriUrl,
                                        this.getActiveWindowContext(),
                                      );
                                      let g = s.oriUrl;
                                      if (
                                        u ||
                                        !s.file ||
                                        (null !== (n = h) &&
                                          void 0 !== n &&
                                          null !== (a = n.view) &&
                                          void 0 !== a &&
                                          null !== (r = a[t]) &&
                                          void 0 !== r &&
                                          r.actual)
                                      ) {
                                        if (
                                          null !== (o = h) &&
                                          void 0 !== o &&
                                          null !== (d = o.view) &&
                                          void 0 !== d &&
                                          null !== (l = d[t]) &&
                                          void 0 !== l &&
                                          l.actual
                                        )
                                          return;
                                      } else g = URL.createObjectURL(s.file);
                                      h
                                        ? (null === (c = h.view[t]) ||
                                          void 0 === c
                                            ? void 0
                                            : c.actual) !== g &&
                                          Boolean(g) &&
                                          (h = Object(f.a)(
                                            Object(f.a)({}, h),
                                            {},
                                            {
                                              view: Object(f.a)(
                                                Object(f.a)({}, h.view),
                                                {},
                                                {
                                                  [t]: {
                                                    actual: g,
                                                    expected: g,
                                                    dataSrcId: _o.e.Upload,
                                                    quality: _o.m.oriUrl,
                                                  },
                                                },
                                              ),
                                            },
                                          ))
                                        : (h = {
                                            mediaId: e,
                                            view: {
                                              [t]: {
                                                actual: g,
                                                expected: g,
                                                dataSrcId: _o.e.Upload,
                                                quality: _o.m.oriUrl,
                                              },
                                            },
                                          }),
                                        this.data.set(e, h),
                                        this._signalRenderItem(this.name, e);
                                    }
                                    _updateView(e, t, s, i, n) {
                                      if (!s) return;
                                      const a = this.data.get(e),
                                        r = a.view[t],
                                        o = this._revokedBlobURL.get(e);
                                      if (
                                        !r ||
                                        !Boolean(r.actual) ||
                                        (r.actual &&
                                          null != o &&
                                          o.has(r.actual))
                                      )
                                        (a.view = Object(f.a)(
                                          Object(f.a)({}, a.view),
                                          {},
                                          {
                                            [t]: {
                                              actual: s,
                                              expected: s,
                                              quality: i,
                                              dataSrcId: _o.e.ZaloSource,
                                            },
                                          },
                                        )),
                                          this.data.set(e, a);
                                      else if (
                                        Boolean(r.actual) &&
                                        r.actual !== s
                                      ) {
                                        const n = Object(f.a)(
                                          Object(f.a)({}, r),
                                          {},
                                          { expected: s, quality: i },
                                        );
                                        (a.view = Object(f.a)(
                                          Object(f.a)({}, a.view),
                                          {},
                                          { [t]: n },
                                        )),
                                          this.data.set(e, a);
                                      }
                                      if (null != n && n.hotSwapSource) {
                                        var d;
                                        const i = this.data.get(e);
                                        this.data.set(
                                          e,
                                          Object(f.a)(
                                            Object(f.a)({}, i),
                                            {},
                                            {
                                              view: Object(f.a)(
                                                Object(f.a)(
                                                  {},
                                                  null == i ? void 0 : i.view,
                                                ),
                                                {},
                                                {
                                                  [t]: Object(f.a)(
                                                    Object(f.a)(
                                                      {},
                                                      null == i ||
                                                        null === (d = i.view) ||
                                                        void 0 === d
                                                        ? void 0
                                                        : d[t],
                                                    ),
                                                    {},
                                                    {
                                                      actual: s,
                                                      expected: s,
                                                      dataSrcId:
                                                        _o.e.ZaloSource,
                                                    },
                                                  ),
                                                },
                                              ),
                                            },
                                          ),
                                        );
                                      }
                                      this._signalRenderItem(this.name, e);
                                    }
                                    _handleLoadSuccess(e, t, s, i) {
                                      const n = e.data;
                                      this._updateView(
                                        t,
                                        s,
                                        n.mediaURL,
                                        n.quality,
                                        i,
                                      );
                                    }
                                    getItem(e) {
                                      return this.data.get(e.key);
                                    }
                                    getList(e) {
                                      return "all" === e.key
                                        ? Array.from(this.data.keys())
                                        : [];
                                    }
                                    onGetItemFailure(e) {}
                                    onGetListFailure(e) {}
                                  }),
                                ) || sd),
                            ) || sd),
                        ) || sd),
                    ) || sd),
                ) || sd),
            ) || sd),
        );
        const rd = Object(i.define)("chat-box-list-controller");
        var od,
          dd = s("Ti+8");
        Object(V.h)()(
          (od =
            Object(V.g)()(
              (od =
                Object(i.singleton)(rd)(
                  (od =
                    Object(i.injectable)()(
                      (od =
                        (function (e, t) {
                          return Object(i.inject)(q.ZLoggerFactory)(
                            e,
                            void 0,
                            0,
                          );
                        })(
                          (od =
                            Reflect.metadata(
                              "design:type",
                              Function,
                            )(
                              (od =
                                Reflect.metadata("design:paramtypes", [
                                  void 0 === q.ZLoggerFactory
                                    ? Object
                                    : q.ZLoggerFactory,
                                ])(
                                  (od = class {
                                    constructor(e) {
                                      (this.logger = void 0),
                                        (this.handleMessageDelivered = (e) => {
                                          var t;
                                          Ct.default.log([
                                            "message delivered",
                                            null === (t = e.payload) ||
                                            void 0 === t
                                              ? void 0
                                              : t.length,
                                          ]);
                                        }),
                                        (this.logger = e.createZLogger("feat", [
                                          "chat-box-list-controller",
                                        ]));
                                    }
                                    onStart() {
                                      i.ModuleContainer.resolve(
                                        dd.a,
                                      ).addEventListener(
                                        Ma.MessageDelivered,
                                        this.handleMessageDelivered,
                                      );
                                    }
                                    onDispose() {
                                      i.ModuleContainer.resolve(
                                        dd.a,
                                      ).removeEventListener(
                                        Ma.MessageDelivered,
                                        this.handleMessageDelivered,
                                      );
                                    }
                                    openConversation(e) {
                                      return Promise.resolve(!0);
                                    }
                                  }),
                                ) || od),
                            ) || od),
                        ) || od),
                    ) || od),
                ) || od),
            ) || od),
        );
        var ld,
          cd = s("7nHs");
        const hd = {
          isShown: !1,
          modalTitle: "",
          guideTitle: "",
          errorCode: "",
          guideItems: [],
          showReloadBtn: !0,
          reloadBtnName: "STR_BU_CONFIRM_TEXT_4",
          showDeleteDataBtn: !0,
          deleteDataBtnName: "STR_BU_CANCEL_TEXT_4",
        };
        Object($t.b)(cd.a)(
          (ld = class {
            constructor() {
              (this.name = cd.b), (this.key = ""), (this.state = hd);
            }
            setState(e) {
              const t = Object(wr.a)(this.state, e);
              this.state !== t &&
                ((this.state = t), Object(nt.g)(this.name, ""));
            }
            showModal(e) {
              this.state.isShown ||
                this.setState((t) =>
                  Object(f.a)(
                    Object(f.a)(Object(f.a)({}, t), e),
                    {},
                    { isShown: !0 },
                  ),
                );
            }
            closeModal() {
              this.state.isShown &&
                this.setState((e) =>
                  Object(f.a)(
                    Object(f.a)(Object(f.a)({}, e), hd),
                    {},
                    { isShown: !1 },
                  ),
                );
            }
            init(e) {}
            getItem(e, t) {
              return this.state;
            }
            getList(e, t) {
              return [];
            }
            onGetItemFailure(e, t) {
              throw new Error("Method not implemented.");
            }
            onGetListFailure(e, t) {
              throw new Error("Method not implemented.");
            }
          }),
        );
        var ud,
          gd = s("Mf7h"),
          md = s("8c0e"),
          pd = s("alF8");
        const fd = new Ct.LocalId();
        Object(i.injectable)()(
          (ud =
            Object(i.singleton)(md.a)(
              (ud = class {
                constructor() {
                  (this._linkPreviewDatas = new Map()),
                    (this._lastCheckLinks = new Map()),
                    (this._listeners = new Map());
                }
                addListenerAtConv(e, t) {
                  if (e && "function" == typeof t) {
                    const s = this._listeners.get(e);
                    this._listeners.set(e, [...(s || []), t]);
                  }
                }
                removeListenerAtConv(e, t) {
                  let s = this._listeners.get(e);
                  s &&
                    s.length > 0 &&
                    ((s = s.filter((e) => e !== t)), this._listeners.set(e, s));
                }
                removeAllListenerAtConv(e) {
                  this._listeners.delete(e);
                }
                setLastCheckLinkByConvId(e, t) {
                  this._lastCheckLinks.set(e, t);
                }
                isLastCheckLinkOfConv(e, t) {
                  const s = this._lastCheckLinks.get(e);
                  return !!s && pd.a.isEqualUrl(s, t);
                }
                getLinkPreviewDataByConvId(e) {
                  return this._linkPreviewDatas.get(e) || null;
                }
                addLinkDataToConv(e, t) {
                  const s = this._prepareLinkPreviewData(e, t);
                  this._linkPreviewDatas.set(e, Object(f.a)({}, s));
                  const i = {
                    action: St.LinkPreviewActions.NEW_LINK_PREVIEW,
                    payload: { newLinkPreviewData: Object(f.a)({}, s) },
                  };
                  this._notifyLinkPreviewDataChangeToConv(e, i),
                    gd.a.emit(St.LinkPreviewActions.NEW_LINK_PREVIEW, {
                      newLinkPreviewData: Object(f.a)({}, s),
                    });
                }
                createLoadingLinkPreview(e, t) {
                  const s = {
                    id: fd.next(),
                    convId: e,
                    content: {
                      title: tt.default.str("STR_GETTING_LINK_INFO"),
                      src: t,
                      desc: "",
                      thumb: "",
                      loading: !0,
                    },
                    link: t,
                    shouldParseLinkOrContact: !0,
                  };
                  e && this._linkPreviewDatas.set(e, Object(f.a)({}, s));
                  const i = {
                    action: St.LinkPreviewActions.NEW_LINK_PREVIEW,
                    payload: { newLinkPreviewData: Object(f.a)({}, s) },
                  };
                  this._notifyLinkPreviewDataChangeToConv(e, i),
                    gd.a.emit(St.LinkPreviewActions.NEW_LINK_PREVIEW, {
                      newLinkPreviewData: Object(f.a)({}, s),
                    });
                }
                removeLinkPreviewData(e) {
                  if (!e) return;
                  this._linkPreviewDatas.delete(e);
                  const t = {
                    action: St.LinkPreviewActions.HIDE_LINK_PREVIEW,
                    payload: null,
                  };
                  this._notifyLinkPreviewDataChangeToConv(e, t),
                    gd.a.emit(St.LinkPreviewActions.HIDE_LINK_PREVIEW, null);
                }
                _notifyLinkPreviewDataChangeToConv(e, t) {
                  const s = this._listeners.get(e);
                  null == s ||
                    s.forEach((e) => {
                      "function" == typeof e &&
                        e({ action: t.action, payload: t.payload });
                    });
                }
                _prepareLinkPreviewData(e, t) {
                  return {
                    id: fd.next(),
                    convId: e,
                    link: t.link,
                    content: t.content,
                    shouldParseLinkOrContact: !1,
                  };
                }
              }),
            ) || ud),
        );
        var vd,
          bd = s("iy3m"),
          Id = s("twqL");
        Object(V.h)()(
          (vd =
            Object(i.singleton)(Id.a)(
              (vd =
                Reflect.metadata(
                  "design:type",
                  Function,
                )(
                  (vd =
                    Reflect.metadata(
                      "design:paramtypes",
                      [],
                    )(
                      (vd = class {
                        constructor() {
                          (this.changeTimeFlushNotiReactWhenResumeApp =
                            this.changeTimeFlushNotiReactWhenResumeApp.bind(
                              this,
                            )),
                            (this.changeTimeFlushNotiReactWhenDisNetwork =
                              this.changeTimeFlushNotiReactWhenDisNetwork.bind(
                                this,
                              )),
                            (this.changeTimeFlushNotiReactWhenStartApp =
                              this.changeTimeFlushNotiReactWhenStartApp.bind(
                                this,
                              ));
                        }
                        onStart(e) {
                          this.changeTimeFlushNotiReactWhenStartApp();
                        }
                        changeTimeFlushNotiReactWhenResumeApp() {
                          this.changeTimeFlushNotiReact(Object(bd.d)());
                        }
                        setupTimer(e) {
                          (sn.a.TimeFlushNotiReact = e),
                            (sn.a.TimeMaxWaiting = Object(bd.a)()),
                            sn.a.setupIntervalToFlushNotiReact(),
                            sn.a.setupTimeoutToGoBackNormalCondition();
                        }
                        changeTimeFlushNotiReactWhenDisNetwork(e) {
                          if (e === Dn.a.CONNECTED) {
                            const e = Dn.b.getPreStateNetwork();
                            e !== Dn.a.CONNECTED &&
                              e !== Dn.a.NOT_SET &&
                              this.changeTimeFlushNotiReact(Object(bd.b)());
                          }
                        }
                        changeTimeFlushNotiReactWhenStartApp() {
                          this.changeTimeFlushNotiReact(Object(bd.e)());
                        }
                        changeTimeFlushNotiReact(e) {
                          sn.a.notiReactTimeoutId
                            ? (sn.a.TimeFlushNotiReact !== e &&
                                ((sn.a.TimeFlushNotiReact = e),
                                sn.a.setupIntervalToFlushNotiReact()),
                              sn.a.TimeMaxWaiting !== Object(bd.a)() &&
                                ((sn.a.TimeMaxWaiting = Object(bd.a)()),
                                sn.a.setupTimeoutToGoBackNormalCondition()))
                            : this.setupTimer(e);
                        }
                      }),
                    ) || vd),
                ) || vd),
            ) || vd),
        );
        var yd,
          _d = s("K0f4"),
          Od = s("buT3"),
          Cd = s("wudS");
        Object(V.h)()(
          (yd =
            Object(V.e)()(
              (yd = class {
                onAuthenticated(e) {
                  const { userId: t } = e.getSession();
                  if (t) {
                    const e = Object(Cd.b)(t),
                      s = `${e}_${_d.m}`,
                      i = Od.a.getItem(s);
                    if (!(null !== i)) return;
                    const n = 97124,
                      a = "1" === i,
                      r = `${e}_${_d.g}`,
                      o = +(Od.a.getItem(r) || "-1"),
                      d = isNaN(o) ? -1 : o,
                      l = `${e}_${_d.i}`,
                      c = +(Od.a.getItem(l) || "-1"),
                      h = isNaN(c) ? -1 : c;
                    if (a) B.default.increaseSuccess(n, 0, d, [h]);
                    else {
                      const t = `${e}_${_d.c}`,
                        s = Od.a.getItem(t),
                        i = Number(s);
                      B.default.increaseFailed(n, 0, d, i, Date.now(), [h]);
                    }
                    Od.a.removeItem(s), Od.a.removeItem(r), Od.a.removeItem(l);
                  }
                }
                onStart() {
                  const e = _d.l,
                    t = Od.a.getItem(e);
                  if (!(null !== t)) return;
                  const s = "1" === t,
                    i = _d.f,
                    n = +(Od.a.getItem(i) || "-1"),
                    a = isNaN(n) ? -1 : n,
                    r = _d.h,
                    o = +(Od.a.getItem(r) || "-1"),
                    d = isNaN(o) ? -1 : o;
                  if (s) B.default.increaseSuccess(97123, 0, a, [d]);
                  else {
                    const e = Od.a.getItem(_d.b),
                      t = Number(e);
                    B.default.increaseFailed(97123, 0, a, t, Date.now(), [d]);
                  }
                  Od.a.removeItem(e), Od.a.removeItem(i), Od.a.removeItem(r);
                }
              }),
            ) || yd),
        );
        var Ed,
          Md = s("l9L4"),
          Sd = s("CDcE");
        Object(V.d)()(
          (Ed =
            Object(i.injectable)()(
              (Ed =
                Object(i.singleton)(Md.a)(
                  (Ed =
                    (function (e, t) {
                      return Object(i.inject)(q.ZLoggerFactory)(e, void 0, 0);
                    })(
                      (Ed =
                        Reflect.metadata(
                          "design:type",
                          Function,
                        )(
                          (Ed =
                            Reflect.metadata("design:paramtypes", [
                              void 0 === q.ZLoggerFactory
                                ? Object
                                : q.ZLoggerFactory,
                            ])(
                              (Ed = class {
                                constructor(e) {
                                  (this._isFirstLoginMap = new Map()),
                                    (this._firstLoginTimeMap = new Map()),
                                    (this._logger = void 0),
                                    (this._logger = e.createZLogger("utils", [
                                      "first-login-checker",
                                    ]));
                                }
                                getFirstLoginTime(e) {
                                  if (this.firstLoginTimeMap.has(e))
                                    return (
                                      this.firstLoginTimeMap.get(e) ||
                                      this.getDefaultFirstLoginTime()
                                    );
                                  try {
                                    const t = E.default
                                      .getInstance()
                                      .getItemForCurrentUser(
                                        R.FirstLoginLocalStorageKeys
                                          .FIRST_LOGIN_TIME,
                                      );
                                    null != t &&
                                      this.firstLoginTimeMap.set(
                                        e,
                                        parseInt(t),
                                      );
                                  } catch (t) {
                                    this.logger.zsymb(
                                      21,
                                      8183,
                                      3e4,
                                      "getFirstLoginTime error {} - {}",
                                      e,
                                      Object(Sd.f)(t, 2),
                                    );
                                  }
                                  return (
                                    this.firstLoginTimeMap.get(e) ||
                                    this.getDefaultFirstLoginTime()
                                  );
                                }
                                isFirstLogin(e) {
                                  return !!this._isFirstLoginMap.get(e);
                                }
                                onApplicationReady(e) {
                                  this.removeFirstLoginFlag();
                                }
                                setFirstLogin(e, t) {
                                  this._isFirstLoginMap.set(e, t);
                                }
                                setFirstLoginTime(e, t) {
                                  this.firstLoginTimeMap.set(e, t);
                                  try {
                                    E.default
                                      .getInstance()
                                      .setItemForCurrentUser(
                                        R.FirstLoginLocalStorageKeys
                                          .FIRST_LOGIN_TIME,
                                        (t && t.toString()) || "",
                                      );
                                  } catch (s) {
                                    this.logger.zsymb(
                                      21,
                                      8183,
                                      30001,
                                      "setFirstLoginTime error {} - {} - {}",
                                      e,
                                      t,
                                      Object(Sd.f)(s, 2),
                                    );
                                  }
                                }
                                removeFirstLoginFlag() {
                                  const e = Ye.default.getUidMe(),
                                    t = E.default.getInstance();
                                  t.getItem(
                                    R.FirstLoginLocalStorageKeys.IS_FIRST_LOGIN,
                                  ) === e &&
                                    t.removeItem(
                                      R.FirstLoginLocalStorageKeys
                                        .IS_FIRST_LOGIN,
                                    );
                                }
                                getDefaultFirstLoginTime() {
                                  return _t.default.getTimeNow();
                                }
                                get firstLoginTimeMap() {
                                  return this._firstLoginTimeMap;
                                }
                                get logger() {
                                  return this._logger;
                                }
                              }),
                            ) || Ed),
                        ) || Ed),
                    ) || Ed),
                ) || Ed),
            ) || Ed),
        );
        const Td = Object(i.define)("transfer-data-suggestion-loader");
        var wd = s("cgeJ"),
          Rd = s("XVri"),
          Ld = s("bAqL");
        var Dd = class {
          constructor(e) {
            (this._logger = void 0),
              (this._moduleName = void 0),
              (this._moduleName = e);
          }
          log() {
            this.Logger.zsymb(0, 8218, 3e4, this.moduleTagName, ...arguments);
          }
          logError(e, t) {
            const s = null == t ? "" : this.stringifyDepthLevel(t);
            this.Logger.zsymb(18, 8218, 30001, this.moduleTagName, e, s);
          }
          stringifyDepthLevel(e) {
            return Object(Ld.g)(e, Object(Ld.c)());
          }
          get Logger() {
            return (
              this._logger ||
                (this._logger = i.ModuleContainer.resolve(
                  q.ZLoggerFactory,
                ).createZLogger("msg-sync", [Rd.a])),
              this._logger
            );
          }
          get moduleTagName() {
            return this._moduleName + " - ";
          }
        };
        var Fd,
          Ad = class {
            constructor(e) {
              (this.moduleName = e),
                (this._logger = void 0),
                (this._logger = new Dd(this.moduleName));
            }
            get Logger() {
              return this._logger;
            }
          };
        function jd(e) {
          try {
            return JSON.stringify(e);
          } catch (t) {
            return "";
          }
        }
        function Pd(e) {
          return JSON.parse(e);
        }
        Object(i.injectable)()(
          (Fd =
            Object(i.singleton)(Td)(
              (Fd =
                Reflect.metadata(
                  "design:type",
                  Function,
                )(
                  (Fd =
                    Reflect.metadata(
                      "design:paramtypes",
                      [],
                    )(
                      (Fd = class extends Ad {
                        constructor() {
                          super(wd.e.LOADER),
                            (this._friendManager = void 0),
                            (this._groupManager = void 0);
                        }
                        async loadLastCloseBannerDownloadPC() {
                          const e = this.getSecureLocalStorageDB();
                          if (!e)
                            return (
                              this.Logger.logError(
                                "Load last close banner download pc failed cause invalid storage",
                              ),
                              Promise.reject()
                            );
                          try {
                            const t = await e.getItemForCurrentUserAsync(wd.b);
                            return null != t
                              ? Pd(t)
                              : (this.Logger.logError(
                                  "Load last close banner download pc failed null",
                                ),
                                null);
                          } catch (t) {
                            return (
                              this.Logger.logError(
                                "Load last close banner download pc failed",
                                t,
                              ),
                              t
                            );
                          }
                        }
                        async loadListConversationsFromDB() {
                          const e = this.getSecureLocalStorageDB();
                          if (!e)
                            return (
                              this.Logger.logError(
                                "Load list conversations from DB failed cause invalid storage",
                              ),
                              Promise.reject([])
                            );
                          try {
                            const t = await e.getItemForCurrentUserAsync(wd.d);
                            return null != t
                              ? Pd(t)
                              : (this.Logger.logError(
                                  "Load list conversations from DB failed null",
                                ),
                                []);
                          } catch (t) {
                            return (
                              this.Logger.logError(
                                "Load list conversations from DB failed",
                                t,
                              ),
                              []
                            );
                          }
                        }
                        async loadListFriends() {
                          const e = this.getFriendManagerModule();
                          if (e)
                            try {
                              return await e.getFriends();
                            } catch (t) {
                              return (
                                this.Logger.logError(
                                  "Load list friends failed",
                                  t,
                                ),
                                []
                              );
                            }
                          return this.Logger.log("Load list friends empty"), [];
                        }
                        async loadListGroups() {
                          const e = this.getGroupManagerModule();
                          if (e)
                            try {
                              return await e.getGroupsList();
                            } catch (t) {
                              return (
                                this.Logger.logError(
                                  "Load list groups failed",
                                  t,
                                ),
                                []
                              );
                            }
                          return this.Logger.log("Load list groups empty"), [];
                        }
                        async loadRegisteredData() {
                          const e = this.getSecureLocalStorageDB();
                          if (!e)
                            return (
                              this.Logger.logError(
                                "Load registered data failed cause invalid storage",
                              ),
                              Promise.reject()
                            );
                          try {
                            let t = e.getItemForCurrentUser(
                              R.RegisterLocalStorageKeys
                                .IS_REGISTERED_ON_THIS_DEVICE,
                            );
                            return null != t
                              ? { isRegisteredOnThisDevice: Pd(t) }
                              : (this.Logger.log("Load registered data null"),
                                null);
                          } catch (t) {
                            return (
                              this.Logger.logError(
                                "Load registered data failed",
                                t,
                              ),
                              t
                            );
                          }
                        }
                        async loadSyncMessagesData() {
                          const e = this.getSecureLocalStorageDB();
                          if (!e)
                            return (
                              this.Logger.logError(
                                "Load sync messages data failed cause invalid storage",
                              ),
                              Promise.reject()
                            );
                          try {
                            const t = e.getItemForCurrentUser(
                              "sync_cross_settings",
                            );
                            return t
                              ? Pd(t)
                              : (this.Logger.log(
                                  "Load sync messages data null",
                                ),
                                null);
                          } catch (t) {
                            return (
                              this.Logger.logError(
                                "Load sync messages data failed",
                                t,
                              ),
                              t
                            );
                          }
                        }
                        async loadTransferMessagesData() {
                          const e = this.getSecureLocalStorageDB();
                          if (!e)
                            return (
                              this.Logger.logError(
                                "Load transfer messages data failed cause invalid storage",
                              ),
                              Promise.reject()
                            );
                          try {
                            const t = await e.getItemForCurrentUserAsync(wd.l);
                            return t
                              ? Pd(t)
                              : (this.Logger.logError(
                                  "Load transfer messages data failed null",
                                ),
                                null);
                          } catch (t) {
                            return (
                              this.Logger.logError(
                                "Load transfer messages data failed",
                                t,
                              ),
                              t
                            );
                          }
                        }
                        async setLastCloseBannerDownloadPC(e) {
                          const t = this.getSecureLocalStorageDB();
                          return t
                            ? await t.setItemForCurrentUserAsync(wd.b, jd(e))
                            : Promise.reject("Invalid storage");
                        }
                        async setLastCloseFirstLoginTransferModal(e) {
                          const t = this.getSecureLocalStorageDB();
                          return t
                            ? await t.setItemForCurrentUserAsync(wd.c, jd(e))
                            : Promise.reject("Invalid storage");
                        }
                        async setListConversationsFirstLoginToDB(e) {
                          const t = this.getSecureLocalStorageDB();
                          return t
                            ? await t.setItemForCurrentUserAsync(wd.d, jd(e))
                            : Promise.reject("Invalid storage");
                        }
                        async updateTransferMessagesData(e) {
                          const t = {
                            lastTransferSuccessTime:
                              e.lastTransferSuccessTime || Date.now(),
                          };
                          try {
                            return await this.getSecureLocalStorageDB().setItemForCurrentUserAsync(
                              wd.l,
                              jd(t),
                            );
                          } catch (s) {
                            return s;
                          }
                        }
                        getFriendManagerModule() {
                          var e;
                          this._friendManager ||
                            (this._friendManager =
                              null === (e = s("UiPd")) || void 0 === e
                                ? void 0
                                : e.default);
                          return this._friendManager;
                        }
                        getGroupManagerModule() {
                          var e;
                          this._groupManager ||
                            (this._groupManager =
                              null === (e = s("Gm1y")) || void 0 === e
                                ? void 0
                                : e.default);
                          return this._groupManager;
                        }
                        getSecureLocalStorageDB() {
                          return E.default.getInstance();
                        }
                      }),
                    ) || Fd),
                ) || Fd),
            ) || Fd),
        );
        var Nd = s("n09q"),
          Ud = s("31cx"),
          kd = s("a1r1"),
          Bd = s("BO4k");
        var Gd,
          xd = class extends Ad {
            constructor(e, t) {
              super(Rd.c.MANAGER),
                (this._eventMap = new Map()),
                (this._fistLoginTime = void 0),
                (this._listConversationsBeforeLogin = []),
                (this._isTransferAfterLogin = void 0),
                (this._moduleLoader = void 0),
                (this._moduleUIManager = void 0),
                (this._moduleLoader = e),
                (this._moduleUIManager = t),
                (this._isTransferAfterLogin = !1),
                (this.handleUpdateConfigs =
                  this.handleUpdateConfigs.bind(this)),
                (this.isDisplayedBannerDownloadPCSuggestion =
                  this.isDisplayedBannerDownloadPCSuggestion.bind(this)),
                (this.isDisplayedBubbleInfoEcard =
                  this.isDisplayedBubbleInfoEcard.bind(this)),
                (this.isDisplayedCloseButtonBannerDownloadPC =
                  this.isDisplayedCloseButtonBannerDownloadPC.bind(this)),
                (this.isDisplayedConversationFooter =
                  this.isDisplayedConversationFooter.bind(this)),
                (this.isDisplayedGlobalSearchFooter =
                  this.isDisplayedGlobalSearchFooter.bind(this)),
                (this.isDisplayedSearchInConversationFooter =
                  this.isDisplayedSearchInConversationFooter.bind(this)),
                (this.isDisplayedMilestoneInPreviewMedia =
                  this.isDisplayedMilestoneInPreviewMedia.bind(this)),
                (this.isDisplayedSuggestionInMediaList =
                  this.isDisplayedSuggestionInMediaList.bind(this)),
                (this.isDisplayedTransferModal =
                  this.isDisplayedTransferModal.bind(this)),
                (this.isValidForTransferMessages =
                  this.isValidForTransferMessages.bind(this));
            }
            addEventListeners(e, t) {
              this.eventMap.set(e, [...(this.eventMap.get(e) || []), t]);
            }
            callTransferMessages(e) {}
            closeBannerDownloadPCSuggestion() {}
            getConversationFooterRendererHeight() {
              return this.isDisplayedConversationFooter()
                ? Rd.b.CONVERSATION
                : 0;
            }
            getFirstLoginTime() {
              return this.firstLoginTime;
            }
            getGlobalSearchFooterRendererHeight() {
              return this.isDisplayedConversationFooter()
                ? Rd.b.GLOBAL_SEARCH
                : 0;
            }
            getLogger() {
              return this.Logger;
            }
            getUrlDownloadPC() {
              return "";
            }
            getIsTransferAfterLogin() {
              return this.isTransferAfterLogin;
            }
            hasConversationBeforeFirstLogin(e) {
              return this._listConversationsBeforeLogin.includes(e);
            }
            hideTransferMessagesModal() {}
            async initialize() {
              (this.firstLoginTime = i.ModuleContainer.resolve(
                kd.a,
              ).getFirstLoginTime(this.getUserId())),
                this.handleUpdateConfigs(Bd.a()),
                this.registerSubscriptions(),
                await this.initializeListConversationsBeforeFirstLogin();
            }
            isDisplayedBannerDownloadPCSuggestion() {
              return !!this.isEnabledFeature() && Bd.g();
            }
            isDisplayedBubbleInfoEcard(e) {
              return (
                !!this.isEnabledFeature() &&
                !!Bd.h() &&
                this.hasConversationBeforeFirstLogin(e)
              );
            }
            isDisplayedCloseButtonBannerDownloadPC() {
              return !!this.isEnabledFeature() && Bd.k();
            }
            isDisplayedConversationFooter() {
              return !!this.isEnabledFeature() && Bd.l();
            }
            isDisplayedCTADownloadPC() {
              return !!this.isEnabledFeature() && Bd.i();
            }
            isDisplayedCTATransferMessages() {
              return !!this.isEnabledFeature() && Bd.j();
            }
            isDisplayedGlobalSearchFooter() {
              return !!this.isEnabledFeature() && Bd.m();
            }
            isDisplayedSearchInConversationFooter(e) {
              return (
                !!this.isEnabledFeature() &&
                !!Bd.p() &&
                this.hasConversationBeforeFirstLogin(e)
              );
            }
            isDisplayedMilestoneInPreviewMedia(e) {
              return (
                !!this.isEnabledFeature() &&
                !!Bd.o() &&
                this.hasConversationBeforeFirstLogin(e)
              );
            }
            isDisplayedSuggestionInMediaList(e) {
              return (
                !!this.isEnabledFeature() &&
                !!Bd.n() &&
                this.hasConversationBeforeFirstLogin(e)
              );
            }
            isDisplayedTransferModal() {
              return !!this.isEnabledFeature() && Bd.q();
            }
            isEnabledFeature() {
              return Bd.r();
            }
            isValidSupportDownloadPC() {
              return !1;
            }
            isValidForTransferMessages() {
              return this.isEnabledFeature();
            }
            needTransferMessages() {}
            removeEventListeners(e, t) {
              const s = this.eventMap.get(e);
              if (Array.isArray(s)) {
                const e = s.findIndex((e) => e === t);
                -1 !== e && s.splice(e, 1);
              }
            }
            setFirstLoginTime(e) {
              this.firstLoginTime = e;
            }
            setIsTransferAfterLogin(e) {
              this.isTransferAfterLogin = e;
            }
            shouldTransferMessages() {
              return !1;
            }
            showTransferMessagesModal() {}
            registerSubscriptions() {
              bt.$AppConfig.subscribe(this.handleUpdateConfigs);
            }
            isFirstLogin() {
              return i.ModuleContainer.resolve(kd.a).isFirstLogin(
                this.getUserId(),
              );
            }
            async initializeListConversationsBeforeFirstLogin() {
              this._listConversationsBeforeLogin =
                await this.loadListConversationsBeforeFirstLogin();
            }
            handleUpdateConfigs(e) {
              void 0 === e && (e = {});
              const { data_content: t } = Bd.b(e),
                { first_time_login_device: s } = e;
              t && this.UIManager.updateDataContent(Object(Ud.a)(t)),
                null != s && (this.firstLoginTime = s);
            }
            async loadListConversations() {
              const e = [],
                t = await this.loaderModule.loadListFriends();
              Array.isArray(t) &&
                t.forEach((t) => {
                  e.push(t.userId);
                });
              const s = await this.loaderModule.loadListGroups();
              return (
                Array.isArray(s) &&
                  s.forEach((t) => {
                    e.push(t.userId);
                  }),
                e
              );
            }
            async loadListConversationsBeforeFirstLogin() {
              let e;
              if (this.isFirstLogin())
                (e = await this.loadListConversations()),
                  this.loaderModule.setListConversationsFirstLoginToDB(e);
              else {
                const t = await this.loaderModule.loadListConversationsFromDB();
                (e = t),
                  (t || []).length ||
                    ((e = await this.loadListConversations()),
                    this.loaderModule.setListConversationsFirstLoginToDB(e));
              }
              return e;
            }
            notifyEvent(e) {
              for (
                var t = arguments.length,
                  s = new Array(t > 1 ? t - 1 : 0),
                  i = 1;
                i < t;
                i++
              )
                s[i - 1] = arguments[i];
              const n = this.eventMap.get(e);
              Array.isArray(n) &&
                n.forEach((e) => Promise.resolve(() => e(...s)));
            }
            get firstLoginTime() {
              return this._fistLoginTime;
            }
            set firstLoginTime(e) {
              this._fistLoginTime = e;
            }
            get isTransferAfterLogin() {
              return this._isTransferAfterLogin;
            }
            set isTransferAfterLogin(e) {
              this._isTransferAfterLogin = e;
            }
            get eventMap() {
              return this._eventMap;
            }
            get loaderModule() {
              return this._moduleLoader;
            }
            get UIManager() {
              return this._moduleUIManager;
            }
            getUserId() {
              const e = i.ModuleContainer.resolve(V.a),
                { userId: t } = e.getSession() || {};
              return t || "";
            }
          },
          zd = s("mgoj"),
          Vd = s("JCvM");
        Object(i.injectable)()(
          (Gd =
            Object(V.d)()(
              (Gd =
                Object(i.singleton)(Nd.a)(
                  (Gd =
                    (function (e, t) {
                      return Object(i.inject)(Td)(e, void 0, 0);
                    })(
                      (Gd =
                        (function (e, t) {
                          return Object(i.inject)(zd.a)(e, void 0, 1);
                        })(
                          (Gd =
                            Reflect.metadata(
                              "design:type",
                              Function,
                            )(
                              (Gd =
                                Reflect.metadata("design:paramtypes", [
                                  Object,
                                  void 0 === Vd.ITransferDataSuggestionUIManager
                                    ? Object
                                    : Vd.ITransferDataSuggestionUIManager,
                                ])(
                                  (Gd = class extends xd {
                                    constructor(e, t) {
                                      super(e, t),
                                        (this._lastCloseBannerTimestamp = 0),
                                        (this.handleBeforeUnload =
                                          this.handleBeforeUnload.bind(this));
                                    }
                                    closeBannerDownloadPCSuggestion() {
                                      const e = _t.default.getTimeNow();
                                      (this.lastCloseBannerTimestamp = e),
                                        this.UIManager.closeBannerDownloadPCSuggestion(),
                                        this.loaderModule.setLastCloseBannerDownloadPC(
                                          e,
                                        );
                                    }
                                    getUrlDownloadPC() {
                                      return Object(Bd.f)();
                                    }
                                    async initialize() {
                                      await super.initialize(),
                                        await this.loadLastCloseBannerTimestamp();
                                    }
                                    isDisplayedBannerDownloadPCSuggestion() {
                                      if (
                                        !super.isDisplayedBannerDownloadPCSuggestion()
                                      )
                                        return !1;
                                      if (!this.isValidSupportDownloadPC())
                                        return !1;
                                      const e = Object(Bd.e)();
                                      return (
                                        this.lastCloseBannerTimestamp + e <=
                                        _t.default.getTimeNow()
                                      );
                                    }
                                    isValidSupportDownloadPC() {
                                      const e = Object(Ld.d)().toLowerCase();
                                      return (
                                        null !=
                                        Object(Bd.d)().find(
                                          (t) => e.indexOf(t) > -1,
                                        )
                                      );
                                    }
                                    isValidForTransferMessages() {
                                      return !1;
                                    }
                                    onApplicationReady(e) {
                                      this.isDisplayedBannerDownloadPCSuggestion() &&
                                        Ld.a.logAction(
                                          Ld.a.BannerDownloadPC.DISPLAYED,
                                        ),
                                        this.isEnabledFeature() &&
                                          Ld.a.logAction(
                                            Ld.a.Common
                                              .DISPLAYED_NOT_ENOUGH_DATA_MESSAGE,
                                          );
                                    }
                                    handleBeforeUnload() {
                                      this.logActionBeforeUnload();
                                    }
                                    async loadLastCloseBannerTimestamp() {
                                      try {
                                        const e =
                                          await this.loaderModule.loadLastCloseBannerDownloadPC();
                                        e &&
                                          (this.lastCloseBannerTimestamp = e);
                                      } catch (e) {}
                                    }
                                    logActionBeforeUnload() {
                                      const e = Object(Ld.b)();
                                      Ld.a.logActionInfo(e, !0);
                                    }
                                    registerSubscriptions() {
                                      super.registerSubscriptions(),
                                        i.ModuleContainer.resolve(
                                          V.a,
                                        ).addEventListenerOnce(
                                          V.b.BeforeUnload,
                                          this.handleBeforeUnload,
                                        );
                                    }
                                    get lastCloseBannerTimestamp() {
                                      return this._lastCloseBannerTimestamp;
                                    }
                                    set lastCloseBannerTimestamp(e) {
                                      this._lastCloseBannerTimestamp = e;
                                    }
                                  }),
                                ) || Gd),
                            ) || Gd),
                        ) || Gd),
                    ) || Gd),
                ) || Gd),
            ) || Gd),
        );
        var Hd,
          $d = class extends Ad {
            constructor() {
              super(Rd.c.UI),
                (this.key = Vd.c),
                (this.name = Vd.c),
                (this.dataState = Object(f.a)({}, Rd.f)),
                (this.UIState = Object(f.a)({}, Rd.g));
            }
            closeBannerDownloadPCSuggestion() {}
            hideTransferMessagesModal() {}
            init(e) {}
            initialize() {
              const { data_content: e } = Object(Bd.b)(Object(Bd.a)());
              this.handleUpdateContent(e);
            }
            getItem(e, t) {
              return e.key === Rd.e
                ? this.dataState
                : e.key === Rd.h
                  ? this.UIState
                  : {};
            }
            getList(e, t) {
              return [];
            }
            turnOffDisplayingEntryPoints() {
              this.handleUpdateRenderer({ isDisplayedEntryPoints: !1 });
            }
            onGetItemFailure(e, t) {}
            onGetListFailure(e, t) {}
            showTransferMessagesModal() {}
            updateDataContent(e) {
              this.handleUpdateContent(e);
            }
            setDataState(e) {
              const t = Object(wr.a)(this.dataState, e);
              this.dataState !== t &&
                ((this.dataState = t), Object(nt.g)(this.name, Rd.e));
            }
            setUIState(e) {
              const t = Object(wr.a)(this.UIState, e);
              this.UIState !== t &&
                ((this.UIState = t), Object(nt.g)(this.name, Rd.h));
            }
            handleUpdateContent(e) {
              this.setDataState((t) => {
                (t.version = e.version), (t.content = e.content);
              });
            }
            handleUpdateRenderer(e) {
              this.setUIState((t) => {
                for (const s in e) t[s] = e[s];
              });
            }
          };
        Object($t.b)(Vd.b)(
          (Hd = class extends $d {
            closeBannerDownloadPCSuggestion() {
              this.setUIState((e) => {
                e[wd.k.BANNER_DOWNLOAD].isDisplayed = !1;
              });
            }
            getItem(e, t) {
              const s = super.getItem(e, t);
              if (!s) return;
              let i = {};
              if (e.key === wd.g) {
                const { content: e = {} } = s;
                for (const t in e) {
                  const s = e[t];
                  if (s)
                    for (const e in s) {
                      var n;
                      i[t] || (i[t] = {}),
                        (i[t][e] =
                          null === (n = s[e]) || void 0 === n ? void 0 : n.web);
                    }
                }
              } else i = s;
              return i;
            }
          }),
        );
        var Wd = Object(i.define)("forward-message"),
          Kd = s("oAAg");
        Kd.Pool;
        var qd,
          Zd,
          Jd,
          Qd,
          Yd,
          Xd = Object(i.define)("forward-message-pool");
        (qd = Object(i.singleton)(Wd)),
          (Zd = function (e, t) {
            return Object(i.inject)(Xd)(e, void 0, 0);
          }),
          (Jd = Reflect.metadata("design:type", Function)),
          (Qd = Reflect.metadata("design:paramtypes", [Object])),
          Object(i.injectable)(
            (Yd =
              qd(
                (Yd =
                  Zd(
                    (Yd =
                      Jd(
                        (Yd =
                          Qd(
                            (Yd = class {
                              constructor(e) {
                                (this._pool = void 0), (this.pool = e);
                              }
                              forward(e, t) {
                                const s = this.buildTask();
                                this.pool.use(s);
                              }
                              buildTask() {
                                return async () => {};
                              }
                              get pool() {
                                return this._pool;
                              }
                              set pool(e) {
                                this._pool = e;
                              }
                            }),
                          ) || Yd),
                      ) || Yd),
                  ) || Yd),
              ) || Yd),
          );
        var el = Object(i.define)("pin-topic-message-loader");
        var tl = Object(i.define)("pin-topic-storage"),
          sl = tl,
          il = s("UIHX"),
          nl = s("0URt"),
          al = s("DRpF");
        function rl(e) {
          return (
            !(-1 === Object(nl.g)().indexOf(e.msgType)) && !Object(al.a)(e)
          );
        }
        var ol = s("3ZdV");
        var dl = s("YYsv");
        function ll(e, t, s) {
          return s === e ? 1 : s < t ? 0 : -1;
        }
        function cl(e) {
          const t = { needFetch: !1, reason: "" };
          if (null == e || null == e || !e.lastFetch)
            return (t.needFetch = !0), (t.reason = "empty"), t;
          const { lastFetch: s } = e,
            i = (function (e) {
              return Nr.a.isOverflowAtTime(e);
            })(s);
          if (i) return (t.needFetch = !0), (t.reason = "overflow"), t;
          const n = (function (e) {
            return Date.now() - e > Object(ol.e)();
          })(s);
          if (n) return (t.needFetch = !0), (t.reason = "expired"), t;
          const a = (function (e) {
            const t = E.default
              .getInstance()
              .getItemForCurrentUser(dl.g.FORCE_FETCH_MILESTONE);
            return !(!t || isNaN(+t)) && e < +t;
          })(s);
          return a ? ((t.needFetch = !0), (t.reason = "forcedByServer"), t) : t;
        }
        function hl(e) {
          const t = [];
          return (
            e.forEach((e) => {
              t.push({ topicId: e.id, topicType: e.type });
            }),
            t
          );
        }
        function ul(e) {
          var t;
          return (
            (null === (t = e.params) || void 0 === t
              ? void 0
              : t.client_msg_id) || ""
          );
        }
        function gl(e) {
          var t;
          return (
            (null === (t = e.params) || void 0 === t
              ? void 0
              : t.global_msg_id) || ""
          );
        }
        function ml(e, t, s) {
          let i = t;
          const { topics: n } = s;
          if (!Array.isArray(n)) return i;
          switch (e) {
            case il.a.ADD: {
              const { index: e } = s;
              i =
                null == e
                  ? [...n, ...t]
                  : [...t.slice(0, e), ...n, ...t.slice(e)];
              break;
            }
            case il.a.REMOVE: {
              const e = {};
              n.forEach((t) => {
                e[t.id] = t.type;
              }),
                (i = []),
                t.forEach((t) => {
                  (!e.hasOwnProperty(t.id) ||
                    (e.hasOwnProperty(t.id) && e[t.id] !== t.type)) &&
                    i.push(t);
                });
              break;
            }
          }
          return i;
        }
        function pl(e) {
          const t = (e) => {
              if (!Array.isArray(e)) return e;
              const t = [];
              for (let s = 0; s < e.length; s++) {
                const i = e[s];
                i &&
                  (null != i.id && (i.id = i.id.toString()),
                  null != i.topicId && (i.topicId = i.topicId.toString()),
                  null != i.type && (i.type = parseInt(i.type)),
                  null != i.topicType && (i.topicType = parseInt(i.topicType)),
                  t.push(i));
              }
              return t;
            },
            s = Object(f.a)({}, e);
          return (
            null != s.oldTopic && (s.oldTopic = t([s.oldTopic])[0]),
            null != s.topic && (s.topic = t([s.topic])[0]),
            null != s.topics && (s.topics = t(s.topics)),
            s
          );
        }
        function fl(e) {
          let t = {};
          if (!e.params) return e;
          try {
            t = JSON.parse(e.params);
          } catch (s) {
            return;
          }
          if (t.extra && t.extra.constructor === String)
            try {
              t.extra = JSON.parse(t.extra);
            } catch (s) {
              return;
            }
          return (e.params = t), e;
        }
        var vl,
          bl = function () {
            const e = {};
            return {
              clear: () => {
                for (const t in e) delete e[t];
              },
              get: (t) => e[t],
              getCache: () => e,
              set: (t, s) => {
                e[t] = s;
              },
              has: (t) => e.hasOwnProperty(t),
              remove: (t) => {
                delete e[t];
              },
            };
          };
        let Il =
          Object(i.injectable)()(
            (vl =
              (function (e, t) {
                return Object(i.inject)(sl)(e, void 0, 0);
              })(
                (vl =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (vl =
                      Reflect.metadata("design:paramtypes", [Object])(
                        (vl = class {
                          constructor(e) {
                            (this.storage = e),
                              (this.clientMsgCache = void 0),
                              (this.globalMsgCache = void 0),
                              (this.globalMsgCache = bl()),
                              (this.clientMsgCache = bl());
                          }
                          clear(e) {
                            switch (e) {
                              case il.g.GLOBAL:
                                return void this.globalMsgCache.clear();
                              case il.g.CLIENT:
                                return void this.clientMsgCache.clear();
                              default:
                                return (
                                  this.globalMsgCache.clear(),
                                  void this.clientMsgCache.clear()
                                );
                            }
                          }
                          loadMessages(e) {
                            return new Promise((t, s) => {
                              (e && 0 !== e.length) || s("Invalid topics");
                              const i = e.length;
                              for (let n = 0; n < i; n++) {
                                const t = e[n];
                                if (!t) continue;
                                let i = gl(t);
                                if (i && "0" !== i)
                                  this.getMessage(il.g.GLOBAL, i)
                                    .then()
                                    .catch((e) => {
                                      s(e);
                                    });
                                else {
                                  let e = ul(t);
                                  if (e) {
                                    let i = t.params && t.params.senderUid;
                                    this.getMessage(il.g.CLIENT, e, {
                                      userId: i,
                                    })
                                      .then()
                                      .catch((e) => {
                                        s(e);
                                      });
                                  }
                                }
                              }
                              t();
                            });
                          }
                          getMessageFromTopic(e) {
                            if (e.type !== il.i.MESSAGE || !e.params) return {};
                            let t = gl(e);
                            if (
                              this.globalMsgCache &&
                              this.globalMsgCache.has(t)
                            )
                              return this.globalMsgCache.get(t) || {};
                            let s = ul(e);
                            return (
                              (this.clientMsgCache &&
                                this.clientMsgCache.has(s) &&
                                this.clientMsgCache.get(s)) ||
                              {}
                            );
                          }
                          removeMessages(e) {
                            Array.isArray(e) &&
                              e.forEach((e) => {
                                const t = gl(e),
                                  s = ul(e);
                                this.globalMsgCache.remove(t),
                                  this.clientMsgCache.remove(s);
                              });
                          }
                          getMessage(e, t, s) {
                            void 0 === s && (s = {});
                            return new Promise((i, n) => {
                              switch (e) {
                                case il.g.GLOBAL: {
                                  let s = this.globalMsgCache.get(t);
                                  s
                                    ? i(s)
                                    : this.storage
                                        .getMessagesByIds([t])
                                        .then((s) => {
                                          s
                                            ? (this.setMessage(e, t, s), i(s))
                                            : n("Not found");
                                        })
                                        .catch((e) => {
                                          n(e);
                                        });
                                  break;
                                }
                                case il.g.CLIENT: {
                                  const { userId: a } = s;
                                  let r = this.clientMsgCache.get(t);
                                  r
                                    ? i(r)
                                    : this.storage
                                        .getMessageByCliMsgId(t, {
                                          myUID: Ye.default.getUidMe(),
                                          userId: a,
                                        })
                                        .then((s) => {
                                          s
                                            ? (this.setMessage(e, t, s), i(s))
                                            : n("Not found");
                                        })
                                        .catch((e) => {
                                          n(e);
                                        });
                                  break;
                                }
                                default:
                                  n("Unknown");
                              }
                            });
                          }
                          setMessage(e, t, s) {
                            switch (e) {
                              case il.g.GLOBAL:
                                return void this.globalMsgCache.set(t, s);
                              case il.g.CLIENT:
                                return void this.clientMsgCache.set(t, s);
                              default:
                                return;
                            }
                          }
                        }),
                      ) || vl),
                  ) || vl),
              ) || vl),
          ) || vl;
        var yl = Il;
        i.ModuleContainer.register(el, yl);
        var _l = Object(i.define)("pin-topic-data-repository"),
          Ol = s("ZsEe");
        var Cl = function () {
          const e = {},
            t = (t) => e[t] || null;
          return {
            clear: () => {
              for (const t in e) delete e[t];
            },
            get: t,
            getAll: () => e,
            getLastFetch: (e) => {
              var s;
              return (
                (null === (s = t(e)) || void 0 === s ? void 0 : s.lastFetch) ||
                0
              );
            },
            getLastModified: (e) => {
              var s;
              return (
                (null === (s = t(e)) || void 0 === s
                  ? void 0
                  : s.lastModified) || 0
              );
            },
            getTopics: (e) => {
              var s;
              return (
                (null === (s = t(e)) || void 0 === s ? void 0 : s.topics) || []
              );
            },
            getVersion: (e) => {
              var s;
              return (
                (null === (s = t(e)) || void 0 === s ? void 0 : s.version) || 0
              );
            },
            has: (t) => !!e[t],
            remove: (t) => {
              delete e[t];
            },
            set: (t, s) => {
              e[t] = s;
            },
          };
        };
        var El = function (e) {
          const t = [];
          let s = !1;
          const i = e || (() => {}),
            n = () => t.length,
            a = (e) => {
              s = e;
            },
            r = () => {
              if (s) return;
              if (!n()) return void i();
              const e = t.shift();
              e &&
                (a(!0),
                e()
                  .then(() => {
                    a(!1), r();
                  })
                  .catch(() => {
                    a(!1), r();
                  }));
            };
          return {
            enqueue: (e) => {
              t.push(e), r();
            },
            dequeue: r,
            getLength: n,
          };
        };
        var Ml = function () {
            const e = [];
            let t;
            const s = () => e.length,
              i = (n, a) => {
                if ((a && (t = a), !s())) return t && t(n);
                const r = e.shift();
                r &&
                  ((e, t) => {
                    const { callback: s } = e;
                    let n;
                    "function" == typeof s && (n = s(e.data, t)), i(n);
                  })(r, n);
              };
            return {
              enqueue: (t) => {
                e.push(t);
              },
              dequeue: i,
              getLength: s,
            };
          },
          Sl = s("u+F0");
        var Tl = Object(i.define)("pin-topic-request-handler");
        function wl(e) {
          return new Promise((t) => {
            let s = 0,
              i = 0,
              n = {};
            for (let a in e)
              s++,
                e[a]
                  .then((e) => {
                    (n[a] = e), i++, i === s && t(n);
                  })
                  .catch(() => {
                    (n[a] = null), i++, i === s && t(n);
                  });
            0 === s && t({});
          });
        }
        function Rl(e, t) {
          return Object(Sd.f)(e, Number.isInteger(+t) ? t : 1 / 0);
        }
        var Ll,
          Dl = class {
            constructor(e, t) {
              (this.moduleName = e),
                (this.instanceNames = t),
                (this.instanceMap = new Map());
            }
            error(e) {
              const t = this.getLogger(e);
              if (void 0 !== t) {
                for (
                  var s = arguments.length,
                    i = new Array(s > 1 ? s - 1 : 0),
                    n = 1;
                  n < s;
                  n++
                )
                  i[n - 1] = arguments[n];
                t.zsymb(18, 9938, 3e4, ...i);
              }
            }
            info(e) {
              const t = this.getLogger(e);
              if (void 0 !== t) {
                for (
                  var s = arguments.length,
                    i = new Array(s > 1 ? s - 1 : 0),
                    n = 1;
                  n < s;
                  n++
                )
                  i[n - 1] = arguments[n];
                t.zsymb(0, 9938, 30001, ...i);
              }
            }
            getLogger(e) {
              if (
                this.instanceNames.includes(e) &&
                void 0 === this.instanceMap.get(e)
              ) {
                const t = this.LoggerFactory.createZLogger(
                  hs.ZLoggerNametags.pinTopic,
                  [this.moduleName, e],
                );
                this.instanceMap.set(e, t);
              }
              return this.instanceMap.get(e);
            }
            get LoggerFactory() {
              return i.ModuleContainer.resolve(q.ZLoggerFactory);
            }
          },
          Fl = Dl;
        !(function (e) {
          (e.CONTROL = "control"),
            (e.CREATE = "create"),
            (e.FETCH = "fetch"),
            (e.LOAD = "load"),
            (e.REORDER = "reorder"),
            (e.UNPIN = "unpin");
        })(Ll || (Ll = {}));
        var Al,
          jl = class extends Fl {
            constructor() {
              super(il.f.DataRepository, [
                Ll.CONTROL,
                Ll.CREATE,
                Ll.FETCH,
                Ll.LOAD,
                Ll.REORDER,
                Ll.UNPIN,
              ]);
            }
            infoControl() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logInfo(Ll.CONTROL, ...t);
            }
            infoCreate() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logInfo(Ll.CREATE, ...t);
            }
            infoFetch() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logInfo(Ll.FETCH, ...t);
            }
            infoLoad() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logInfo(Ll.LOAD, ...t);
            }
            infoReorder() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logInfo(Ll.REORDER, ...t);
            }
            infoUnpin() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logInfo(Ll.UNPIN, ...t);
            }
            errorControl() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logError(Ll.CONTROL, ...t);
            }
            errorCreate() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logError(Ll.CREATE, ...t);
            }
            errorFetch() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logError(Ll.FETCH, ...t);
            }
            errorLoad() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logError(Ll.LOAD, ...t);
            }
            errorReorder() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logError(Ll.REORDER, ...t);
            }
            errorUnpin() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logError(Ll.UNPIN, ...t);
            }
            logInfo(e) {
              if (this.isEnableLog()) {
                for (
                  var t = arguments.length,
                    s = new Array(t > 1 ? t - 1 : 0),
                    i = 1;
                  i < t;
                  i++
                )
                  s[i - 1] = arguments[i];
                super.info(e, ...s);
              }
            }
            logError(e) {
              if (this.isEnableLog()) {
                for (
                  var t = arguments.length,
                    s = new Array(t > 1 ? t - 1 : 0),
                    i = 1;
                  i < t;
                  i++
                )
                  s[i - 1] = arguments[i];
                super.error(e, ...s);
              }
            }
            isEnableLog() {
              return Object(ol.h)();
            }
          };
        var Pl =
          Object(i.injectable)()(
            (Al =
              (function (e, t) {
                return Object(i.inject)(sl)(e, void 0, 0);
              })(
                (Al =
                  (function (e, t) {
                    return Object(i.inject)(Tl)(e, void 0, 1);
                  })(
                    (Al =
                      Reflect.metadata(
                        "design:type",
                        Function,
                      )(
                        (Al =
                          Reflect.metadata("design:paramtypes", [
                            Object,
                            Object,
                          ])(
                            (Al = class {
                              constructor(e, t) {
                                (this.storage = e),
                                  (this.fetcher = t),
                                  (this.cache = void 0),
                                  (this.eventQueue = void 0),
                                  (this.logger = void 0),
                                  (this.pendingWhenLoadQueue = void 0),
                                  (this.requestID = void 0),
                                  (this.cache = Cl()),
                                  (this.eventQueue = {}),
                                  (this.pendingWhenLoadQueue = {}),
                                  (this.logger = new jl()),
                                  (this.requestID = new Ol.a());
                              }
                              clear() {
                                this.cache.clear();
                                for (const e in this.pendingWhenLoadQueue)
                                  delete this.pendingWhenLoadQueue[e];
                                for (const e in this.eventQueue)
                                  delete this.eventQueue[e];
                              }
                              clearPinTopicsForConversation(e, t) {
                                void 0 === t && (t = !1),
                                  this.cache.remove(e),
                                  delete this.pendingWhenLoadQueue[e],
                                  delete this.eventQueue[e],
                                  this.Storage.clearTopics(e, t);
                              }
                              createPinTopic(e, t, s) {
                                void 0 === s && (s = {});
                                return new Promise((i, n) => {
                                  const a = this.getRequestID();
                                  this.Logger.infoCreate(a, `call cId:${e}`),
                                    this.loadDataFromCacheOrDB(e).then((r) => {
                                      const { checkEnableToCreate: o } =
                                        s || {};
                                      let d = null;
                                      if (o) {
                                        const { enable: s, oldTopic: i } = o(
                                          e,
                                          t,
                                          r,
                                        );
                                        if (!s)
                                          return (
                                            this.Logger.infoCreate(
                                              a,
                                              `cId:${e} react limit`,
                                            ),
                                            n({
                                              code: Sl.a.PINBOARD_OVER_MAXIMUM,
                                              message: "",
                                              data: { cache: r },
                                            })
                                          );
                                        i && (d = i);
                                      }
                                      const { version: l } = r;
                                      this.Logger.infoCreate(a, `cId:${e}`, l),
                                        this.Fetcher.createTopic(e, t, l)
                                          .then((t) => {
                                            this.Logger.infoCreate(
                                              a,
                                              `cId:${e}, create topic success`,
                                            );
                                            let s = t.response.data;
                                            (s.oldVersion = l),
                                              d &&
                                                (s.oldTopic = {
                                                  topicId: d.id,
                                                  topicType: d.type,
                                                }),
                                              (s = pl(s)),
                                              this.enqueueEvent(
                                                e,
                                                this.addTopic.bind(
                                                  this,
                                                  e,
                                                  s,
                                                  (e) => i(e),
                                                ),
                                              );
                                          })
                                          .catch((t) => {
                                            const s = t.error;
                                            (s.data = Object(f.a)(
                                              Object(f.a)(
                                                {},
                                                null == s ? void 0 : s.data,
                                              ),
                                              {},
                                              { cache: r },
                                            )),
                                              this.Logger.errorCreate(
                                                a,
                                                `cId:${e}, create topic fail`,
                                                Rl(t, Object(ol.b)()),
                                              ),
                                              n(s);
                                          });
                                    });
                                });
                              }
                              getEntryPointPromotionalTooltipShowedStatus() {
                                return this.Storage.getEntryPointPromotionalTooltipShowedStatus();
                              }
                              handleReceivingEvent(e, t) {
                                return new Promise((s, i) => {
                                  if (
                                    (this.Logger.infoControl(
                                      `call ${e}`,
                                      Rl(t, Object(ol.b)()),
                                    ),
                                    e === il.c.FORCE_SYNC)
                                  ) {
                                    const { conversationIds: e } = t;
                                    if (!Array.isArray(e))
                                      return i(
                                        "Invalid conversationIds for force all",
                                      );
                                    if (0 === e.length)
                                      this.Storage.setForcedFetchMilestone(
                                        Date.now(),
                                      );
                                    else
                                      for (let t = 0; t < e.length; t++) {
                                        var n;
                                        const a =
                                          null === (n = e[t]) || void 0 === n
                                            ? void 0
                                            : n.toString();
                                        a &&
                                          (this.clearPinTopicsForConversation(
                                            a,
                                          ),
                                          this.fetchTopics(a)
                                            .then((e) => {
                                              s(e);
                                            })
                                            .catch(i));
                                      }
                                  } else {
                                    const { conversationId: n } = t;
                                    this.loadDataFromCacheOrDB(n).then((n) => {
                                      this.processEventControl(e, t, n, s, i);
                                    });
                                  }
                                });
                              }
                              loadPinTopics(e, t) {
                                return new Promise((s, i) => {
                                  e ||
                                    i({
                                      status: il.h.ERROR,
                                      error: {
                                        code: Sl.a.INVALID_PARAMETERS,
                                        message: "ConversationId not valid",
                                      },
                                    });
                                  const n = this.getRequestID();
                                  if (
                                    (this.Logger.infoLoad(n, `call cId:${e}`),
                                    t && t !== il.d.NONE)
                                  )
                                    return (
                                      this.Logger.infoLoad(
                                        n,
                                        `force fetch cId:${e}`,
                                        t,
                                      ),
                                      this.fetchTopics(e).then((e) => {
                                        s(e);
                                      })
                                    );
                                  this.loadDataFromCacheOrDB(e).then((a) => {
                                    if (
                                      (this.Logger.infoLoad(n, `cId:${e}`),
                                      t === il.d.NONE)
                                    )
                                      return s(a);
                                    this.doCheckAndFetchData(a)
                                      .then((e) => {
                                        s(e);
                                      })
                                      .catch(i);
                                  });
                                });
                              }
                              reorderPinTopics(e, t) {
                                return new Promise((s, i) => {
                                  const n = this.getRequestID();
                                  this.Logger.infoReorder(n, `call cId:${e}`),
                                    this.loadDataFromCacheOrDB(e).then((a) => {
                                      const { version: r } = a,
                                        o = hl(t);
                                      this.Logger.infoReorder(n, `cId:${e}`, r),
                                        this.Fetcher.reorderTopics(e, o, r)
                                          .then((i) => {
                                            this.Logger.infoReorder(
                                              n,
                                              `cId:${e}, reorder topic success`,
                                            );
                                            let a = i.response.data;
                                            (a.oldVersion = r),
                                              (a.topics = t),
                                              (a = pl(a)),
                                              this.enqueueEvent(
                                                e,
                                                this.setTopics.bind(
                                                  this,
                                                  e,
                                                  a,
                                                  (e) => s(e),
                                                ),
                                              );
                                          })
                                          .catch((t) => {
                                            this.Logger.errorReorder(
                                              n,
                                              `cId:${e}, reorder topic fail`,
                                              Rl(t, Object(ol.b)()),
                                            ),
                                              i(t.error);
                                          });
                                    });
                                });
                              }
                              setEntryPointPromotionalTooltipShowedStatus(e) {
                                this.Storage.setEntryPointPromotionalTooltipShowedStatus(
                                  e,
                                );
                              }
                              unpinTopics(e, t) {
                                return new Promise((s, i) => {
                                  const n = this.getRequestID();
                                  this.Logger.infoUnpin(n, `call cId:${e}`),
                                    this.loadDataFromCacheOrDB(e).then((a) => {
                                      const { version: r } = a,
                                        o = hl(t);
                                      this.Logger.infoUnpin(n, `cId:${e}`, r),
                                        this.Fetcher.unpinTopics(e, o, r)
                                          .then((i) => {
                                            this.Logger.infoUnpin(
                                              n,
                                              `cId:${e} unpin topic success`,
                                            );
                                            let a = i.response.data;
                                            (a.oldVersion = r),
                                              (a.topics = t),
                                              (a = pl(a)),
                                              this.enqueueEvent(
                                                e,
                                                this.removeTopics.bind(
                                                  this,
                                                  e,
                                                  a,
                                                  (e) => s(e),
                                                ),
                                              );
                                          })
                                          .catch((t) => {
                                            this.Logger.errorUnpin(
                                              n,
                                              `cId:${e}, unpin topic fail`,
                                              Rl(t, Object(ol.b)()),
                                            ),
                                              i(t.error);
                                          });
                                    });
                                });
                              }
                              setPendingQueue(e, t) {
                                t && !this.pendingWhenLoadQueue[e]
                                  ? (this.pendingWhenLoadQueue[e] = Ml())
                                  : delete this.pendingWhenLoadQueue[e];
                              }
                              isInPending(e) {
                                return !!this.pendingWhenLoadQueue[e];
                              }
                              openPendingQueue(e) {
                                this.setPendingQueue(e, !0);
                              }
                              closePendingQueue(e) {
                                this.setPendingQueue(e, !1);
                              }
                              enqueuePending(e, t) {
                                this.pendingWhenLoadQueue[e] &&
                                  this.pendingWhenLoadQueue[e].enqueue(t);
                              }
                              loadTopicsFromDB(e) {
                                this.openPendingQueue(e);
                                return new Promise((t) => {
                                  const s = this.getRequestID();
                                  this.Logger.infoLoad(s, `DB call cId:${e}`),
                                    this.Storage.loadTopics(e)
                                      .then((i) => {
                                        const n = this.handleLoadDBFinish(e, i);
                                        this.Logger.infoLoad(
                                          s,
                                          `DB cId:${e} success`,
                                        ),
                                          t({
                                            status: il.h.SUCCESS,
                                            response: { data: n },
                                          });
                                      })
                                      .catch((i) => {
                                        const n = this.handleLoadDBFinish(
                                          e,
                                          null,
                                        );
                                        this.Logger.errorLoad(
                                          s,
                                          `DB cId:${e} fail`,
                                          Rl(
                                            null == i ? void 0 : i.error,
                                            Object(ol.b)(),
                                          ),
                                        ),
                                          t({
                                            status: il.h.ERROR,
                                            response: { data: n },
                                          });
                                      });
                                });
                              }
                              getRequestID() {
                                return this.requestID.next();
                              }
                              handleLoadDBFinish(e, t) {
                                var s;
                                let i;
                                var n;
                                t &&
                                  (i = {
                                    conversationId: (n = t).conversationId,
                                    topics: n.topics,
                                    version: n.boardVersion,
                                    lastFetch: n.lastFetch,
                                    lastModified: Date.now(),
                                  }),
                                  (t &&
                                    (null === (s = i) || void 0 === s
                                      ? void 0
                                      : s.conversationId) === e) ||
                                    (i = (function (e) {
                                      return {
                                        conversationId: e,
                                        topics: [],
                                        version: 0,
                                        lastFetch: 0,
                                        lastModified: 0,
                                      };
                                    })(e));
                                let a = i;
                                if (!cl(a).needFetch && this.isInPending(e)) {
                                  const t = (e) => {
                                    e && (a = e);
                                  };
                                  this.pendingWhenLoadQueue[e].dequeue(i, t);
                                }
                                return this.closePendingQueue(e), a;
                              }
                              fetchTopics(e, t) {
                                void 0 === t && (t = 0),
                                  this.openPendingQueue(e);
                                return new Promise((s, i) => {
                                  const n = this.getRequestID();
                                  this.Logger.infoFetch(n, `call cId:${e}`, t),
                                    this.Fetcher.fetchTopics(e, t)
                                      .then((t) => {
                                        this.Logger.infoFetch(
                                          n,
                                          `cId:${e} success`,
                                        ),
                                          this.closePendingQueue(e);
                                        const { response: i } = t,
                                          a = i.data.topics;
                                        for (let e = 0; e < a.length; e++)
                                          a[e] = fl(a[e]);
                                        this.loadExtraDataForTopics(a).then(
                                          (t) => {
                                            const n = {
                                              conversationId: e,
                                              topics: t,
                                              version: i.data.version,
                                              lastFetch: Date.now(),
                                              lastModified: Date.now(),
                                            };
                                            this.setToCache(e, n),
                                              this.setTopicsToDB(n),
                                              s(n);
                                          },
                                        );
                                      })
                                      .catch((t) => {
                                        this.Logger.errorFetch(
                                          n,
                                          `cId:${e} fail`,
                                          Rl(t, Object(ol.b)()),
                                        ),
                                          this.closePendingQueue(e);
                                      });
                                });
                              }
                              doCheckAndFetchData(e) {
                                return new Promise((t, s) => {
                                  const i = cl(e);
                                  if (
                                    (this.Logger.infoFetch(
                                      `cId:${e.conversationId} needFetch:${i.needFetch} reason:${i.reason}`,
                                    ),
                                    !i.needFetch)
                                  )
                                    return t(e);
                                  this.fetchTopics(e.conversationId)
                                    .then((s) => {
                                      t(s || e);
                                    })
                                    .catch(s);
                                });
                              }
                              getDataInPendingQueueAfterMutation(e, t) {
                                if (e.conversationId !== t.conversationId)
                                  return t;
                                if (e.oldVersion != t.version) return t;
                                return {
                                  topics: ml(e.type, t.topics, {
                                    index: e.index,
                                    topics: e.topics,
                                  }),
                                  version: e.version,
                                  conversationId: e.conversationId,
                                  lastModified: Date.now(),
                                  lastFetch: t.lastFetch,
                                };
                              }
                              setToCache(e, t) {
                                return (
                                  null == t.lastModified &&
                                    (t.lastModified = Date.now()),
                                  this.cache.set(e, t),
                                  t
                                );
                              }
                              addToCache(e, t, s) {
                                void 0 === s && (s = 0);
                                const i = this.getCache(e),
                                  { topic: n, version: a } = t;
                                let r = Date.now(),
                                  o = [];
                                i
                                  ? ((o = ml(il.a.ADD, i.topics, {
                                      topics: [n],
                                      index: s,
                                    })),
                                    (r = i.lastFetch))
                                  : o.push(n),
                                  t.lastFetch && (r = t.lastFetch);
                                const d = {
                                  conversationId: e,
                                  topics: o,
                                  version: a,
                                  lastModified: Date.now(),
                                  lastFetch: r,
                                };
                                return this.setToCache(e, d);
                              }
                              removeInCache(e, t, s) {
                                if (
                                  (void 0 === s && (s = 0), !this.cache.has(e))
                                )
                                  return null;
                                const i = this.getCache(e),
                                  { topics: n } = i;
                                if (t.topic)
                                  for (let r = 0; r < n.length; r++) {
                                    const e = n[r];
                                    if (
                                      e.id === t.topic.id &&
                                      e.type === t.topic.type
                                    ) {
                                      n.splice(r, 1);
                                      break;
                                    }
                                  }
                                else n.splice(s, 1);
                                const a = {
                                  conversationId: e,
                                  topics: n,
                                  version: t.version,
                                  lastModified: Date.now(),
                                  lastFetch: i.lastFetch,
                                };
                                return this.setToCache(e, a);
                              }
                              enqueueEvent(e, t) {
                                if (!this.eventQueue[e]) {
                                  const t = () => {
                                    delete this.eventQueue[e];
                                  };
                                  this.eventQueue[e] = El(t);
                                }
                                this.eventQueue[e].enqueue(t);
                              }
                              addTopic(e, t, s) {
                                return new Promise((i, n) => {
                                  if (this.isInPending(e)) {
                                    const s = {
                                      data: {
                                        type: il.a.ADD,
                                        conversationId: e,
                                        oldTopic: t.oldTopic,
                                        topics: [t.topic],
                                        version: t.version,
                                        oldVersion: t.oldVersion,
                                        index: t.index,
                                      },
                                      callback:
                                        this.getDataInPendingQueueAfterMutation,
                                    };
                                    return this.enqueuePending(e, s), i();
                                  }
                                  const a = (n) => {
                                    const { oldVersion: a, version: r } = t,
                                      o = ll(a, r, n.version);
                                    if (
                                      (this.Logger.infoCreate(
                                        `add call cId:${e} actCode:${o}`,
                                        a,
                                        r,
                                        n.version,
                                      ),
                                      1 === o)
                                    ) {
                                      const {
                                        oldTopic: n,
                                        index: a,
                                        topic: o,
                                      } = t;
                                      n &&
                                        n.topicId &&
                                        this.removeInCache(e, {
                                          topic: {
                                            id: n.topicId,
                                            type: n.topicType,
                                          },
                                          version: r,
                                        }),
                                        fl(o),
                                        this.loadExtraDataForTopics([o])
                                          .then((n) => {
                                            const r = {
                                                topic: n[0],
                                                version: t.version,
                                              },
                                              o = this.addToCache(e, r, a);
                                            this.setTopicsToDB(o),
                                              i(),
                                              s && s(this.getCache(e));
                                          })
                                          .catch(() => {
                                            i();
                                          });
                                    } else
                                      0 === o
                                        ? this.fetchTopics(e)
                                            .then((e) => {
                                              s && s(e), i();
                                            })
                                            .catch(() => {
                                              s && s(this.getCache(e)), i();
                                            })
                                        : i();
                                  };
                                  this.loadDataFromCacheOrDB(e).then((e) => {
                                    a(e);
                                  });
                                });
                              }
                              removeTopics(e, t, s) {
                                return new Promise((i) => {
                                  if (this.isInPending(e)) {
                                    const s = {
                                      data: {
                                        type: il.a.REMOVE,
                                        conversationId: e,
                                        topics: t.topics,
                                        version: t.version,
                                        oldVersion: t.oldVersion,
                                      },
                                      callback:
                                        this.getDataInPendingQueueAfterMutation,
                                    };
                                    return this.enqueuePending(e, s), i();
                                  }
                                  const n = (n) => {
                                    const { oldVersion: a, version: r } = t,
                                      o = ll(a, r, n.version);
                                    if (
                                      (this.Logger.infoUnpin(
                                        `remove call cId:${e} actCode:${o}`,
                                        a,
                                        r,
                                        n.version,
                                      ),
                                      1 === o)
                                    ) {
                                      const { topics: a } = t;
                                      let o = n;
                                      for (let t = 0; t < a.length; t++)
                                        o = this.removeInCache(e, {
                                          topic: a[t],
                                          version: r,
                                        });
                                      return (
                                        this.setTopicsToDB(o),
                                        s && s(this.getCache(e)),
                                        i()
                                      );
                                    }
                                    0 === o
                                      ? this.fetchTopics(e)
                                          .then((e) => {
                                            s && s(e), i();
                                          })
                                          .catch(() => {
                                            s && s(this.getCache(e)), i();
                                          })
                                      : i();
                                  };
                                  this.loadDataFromCacheOrDB(e).then((e) => {
                                    n(e);
                                  });
                                });
                              }
                              setTopics(e, t, s) {
                                return new Promise((i) => {
                                  if (this.isInPending(e)) {
                                    const s = {
                                      data: {
                                        type: il.a.REORDER,
                                        conversationId: e,
                                        topics: t.topics,
                                        version: t.version,
                                        oldVersion: t.oldVersion,
                                      },
                                      callback:
                                        this.getDataInPendingQueueAfterMutation,
                                    };
                                    return this.enqueuePending(e, s), i();
                                  }
                                  const n = (n) => {
                                    const { oldVersion: a, version: r } = t,
                                      o = ll(a, r, n.version);
                                    if (
                                      (this.Logger.infoReorder(
                                        `set call cId:${e} actCode:${o}`,
                                        a,
                                        r,
                                        n.version,
                                      ),
                                      1 === o)
                                    ) {
                                      const a = n.topics,
                                        r = [];
                                      for (
                                        let e = 0;
                                        e < t.topics.length;
                                        e++
                                      ) {
                                        const s = t.topics[e],
                                          i = a.find(
                                            (e) =>
                                              e.id === s.id &&
                                              e.type === s.type,
                                          );
                                        i && r.push(i);
                                      }
                                      const o = {
                                        conversationId: e,
                                        topics: r,
                                        version: t.version,
                                        lastModified: Date.now(),
                                        lastFetch:
                                          (null == n ? void 0 : n.lastFetch) ||
                                          0,
                                      };
                                      return (
                                        this.setToCache(e, o),
                                        this.setTopicsToDB(o),
                                        s && s(this.getCache(e)),
                                        i()
                                      );
                                    }
                                    0 === o
                                      ? this.fetchTopics(e)
                                          .then((e) => {
                                            s && s(e), i();
                                          })
                                          .catch(() => {
                                            s && s(this.getCache(e)), i();
                                          })
                                      : i();
                                  };
                                  this.loadDataFromCacheOrDB(e).then((e) => {
                                    n(e);
                                  });
                                });
                              }
                              loadDataFromCacheOrDB(e) {
                                return new Promise((t) => {
                                  const s = this.getCache(e);
                                  s
                                    ? t(s)
                                    : this.loadTopicsFromDB(e).then((s) => {
                                        const i = s.response.data;
                                        this.setToCache(e, i), t(i);
                                      });
                                });
                              }
                              setTopicsToDB(e) {
                                return new Promise((t, s) => {
                                  const i = {
                                    conversationId: e.conversationId,
                                    boardVersion: e.version,
                                    topics: e.topics,
                                    lastFetch: e.lastFetch,
                                  };
                                  this.Storage.setTopics(i).then(t).catch(s);
                                });
                              }
                              processEventControl(e, t, s, i, n) {
                                const { conversationId: a } = t;
                                let r = {
                                  oldVersion: t.oldVersion,
                                  version: t.version,
                                };
                                const o = pl(t);
                                switch (e) {
                                  case il.c.CREATE:
                                    (r = Object(f.a)(
                                      Object(f.a)({}, r),
                                      {},
                                      {
                                        oldTopic: o.oldTopic,
                                        topic: o.topic,
                                        index: 0,
                                      },
                                    )),
                                      this.enqueueEvent(
                                        a,
                                        this.addTopic.bind(this, a, r, (e) =>
                                          i(e),
                                        ),
                                      );
                                    break;
                                  case il.c.UNPIN: {
                                    const e = o.topic,
                                      t = [];
                                    e &&
                                      null != e.topicId &&
                                      null != e.topicType &&
                                      t.push({
                                        id: e.topicId,
                                        type: e.topicType,
                                      }),
                                      (r = Object(f.a)(
                                        Object(f.a)({}, r),
                                        {},
                                        { topics: t },
                                      )),
                                      this.enqueueEvent(
                                        a,
                                        this.removeTopics.bind(
                                          this,
                                          a,
                                          r,
                                          (e) => i(e),
                                        ),
                                      );
                                    break;
                                  }
                                  case il.c.REORDER: {
                                    var d;
                                    const e = [],
                                      t =
                                        (null === (d = o.topics) || void 0 === d
                                          ? void 0
                                          : d.length) || 0;
                                    for (let i = 0; i < t; i++) {
                                      var l;
                                      const t =
                                        null === (l = o.topics) || void 0 === l
                                          ? void 0
                                          : l[i];
                                      if (
                                        t &&
                                        null != t.topicId &&
                                        null != t.topicType
                                      ) {
                                        const i = s.topics.find(
                                          (e) =>
                                            e.id === t.topicId &&
                                            e.type === t.topicType,
                                        );
                                        i && e.push(i);
                                      }
                                    }
                                    (r = Object(f.a)(
                                      Object(f.a)({}, r),
                                      {},
                                      { topics: e },
                                    )),
                                      this.enqueueEvent(
                                        a,
                                        this.setTopics.bind(this, a, r, (e) =>
                                          i(e),
                                        ),
                                      );
                                    break;
                                  }
                                }
                              }
                              loadStickerThumb(e) {
                                const t = (e) => `${e.id}_${e.type}`;
                                return new Promise((s) => {
                                  const i = {};
                                  for (let o = 0; o < e.length; o++) {
                                    var n, a;
                                    const s = e[o];
                                    if (
                                      (null === (n = s.params) || void 0 === n
                                        ? void 0
                                        : n.msg_type) === R.MSG_STICKER ||
                                      (null === (a = s.params) || void 0 === a
                                        ? void 0
                                        : a.msg_type) === R.CLI_MSG_TYPE_STICKER
                                    ) {
                                      var r;
                                      const e =
                                        null === (r = s.params) || void 0 === r
                                          ? void 0
                                          : r.extra;
                                      e &&
                                        null != e.catId &&
                                        null != e.id &&
                                        (i[t(s)] =
                                          this.StickerManager.getStickerIfNotExist(
                                            e.catId,
                                            e.id,
                                          ));
                                    }
                                  }
                                  Object.keys(i).length > 0
                                    ? wl(i).then((i) => {
                                        for (let s = 0; s < e.length; s++) {
                                          const n = e[s],
                                            a = i[t(n)];
                                          a &&
                                            a.id ===
                                              parseInt(n.params.extra.id) &&
                                            a.cateId ===
                                              parseInt(n.params.extra.catId) &&
                                            ((n.params.thumb =
                                              a.stickerUrl || ""),
                                            (e[s] = n));
                                        }
                                        s(e);
                                      })
                                    : s(e);
                                });
                              }
                              loadExtraDataForTopics(e) {
                                return new Promise((t) => {
                                  this.loadStickerThumb(e).then((e) => {
                                    t(e);
                                  });
                                });
                              }
                              getCache(e) {
                                return this.cache.get(e);
                              }
                              get Fetcher() {
                                return this.fetcher;
                              }
                              get Logger() {
                                return this.logger;
                              }
                              get StickerManager() {
                                return Et.g;
                              }
                              get Storage() {
                                return this.storage;
                              }
                            }),
                          ) || Al),
                      ) || Al),
                  ) || Al),
              ) || Al),
          ) || Al;
        i.ModuleContainer.register(_l, Pl);
        var Nl = class {
          createOneOnOneTopic(e, t, s, i) {
            void 0 === e && (e = ""),
              void 0 === s && (s = 0),
              void 0 === i && (i = "vi");
            let n = { conversationId: e, topic: t, version: s, lang: i };
            Ct.default.logCoreInfo(
              "[PinTopic] - createOneOnOneTopic params: ",
              n,
            );
            const a =
              mt.b.getFriendBoardDomain() +
              "/api/friendboard/create?" +
              this.getCommonParams() +
              "&params=" +
              this.getEncodedParams(n);
            return this.getRequest(a, null, 12067);
          }
          getListOneOnOnePinTopics(e, t) {
            void 0 === e && (e = ""), void 0 === t && (t = 0);
            let s = { conversationId: e, version: t };
            Ct.default.logCoreInfo(
              "[PinTopic] - getListOneOnOnePinTopics params: ",
              s,
            );
            const i =
              mt.b.getFriendBoardDomain() +
              "/api/friendboard/list?" +
              Ln.default._getCommonParams() +
              "&params=" +
              this.getEncodedParams(s);
            return this.getRequest(i, null, 12065);
          }
          reorderOneOnOnePinTopics(e, t, s, i) {
            void 0 === e && (e = ""),
              void 0 === s && (s = 0),
              void 0 === i && (i = "vi");
            let n = { conversationId: e, topics: t, version: s, lang: i };
            Ct.default.logCoreInfo(
              "[PinTopic] - reorderOneOnOnePinTopics params: ",
              n,
            );
            const a =
              mt.b.getFriendBoardDomain() +
              "/api/friendboard/reorder?" +
              this.getCommonParams() +
              "&params=" +
              this.getEncodedParams(n);
            return this.getRequest(a, null, 12068);
          }
          unpinOneOnOneTopics(e, t, s, i) {
            void 0 === e && (e = ""),
              void 0 === s && (s = 0),
              void 0 === i && (i = "vi");
            let n = { conversationId: e, topics: t, version: s, lang: i };
            Ct.default.logCoreInfo(
              "[PinTopic] - unpinOneOnOneTopics params: ",
              n,
            );
            const a =
              mt.b.getFriendBoardDomain() +
              "/api/friendboard/multi_unpin?" +
              this.getCommonParams() +
              "&params=" +
              this.getEncodedParams(n);
            return this.getRequest(a, null, 12069);
          }
          getCommonParams() {
            return Ln.default._getCommonParams();
          }
          getEncodedParams(e) {
            return Ln.default.getEncodedParams(e);
          }
          getRequest(e, t, s, i, n, a, r, o, d) {
            return Ln.default._get(e, t, s, i, n, a, r, o, d);
          }
        };
        var Ul,
          kl = function () {
            let e;
            function t() {
              return e || (e = new Nl()), e;
            }
            const s = (e) =>
              new Promise((t, s) => {
                e.then(wn.a).then(t).catch(s);
              });
            return {
              createOneOnOneTopic: function (e, i, n) {
                void 0 === n && (n = 0);
                const a = Object(f.a)({}, i),
                  { params: r } = a;
                r &&
                  r.extra &&
                  r.extra.constructor === Object &&
                  (r.extra = JSON.stringify(r.extra)),
                  r && (a.params = JSON.stringify(r)),
                  null == a.src && (a.src = -1),
                  null == a.pinAct && (a.pinAct = 1);
                const o = tt.default.getCurrentLanguageName();
                return s(t().createOneOnOneTopic(e, a, n, o));
              },
              getListOneOnOnePinTopics: function (e, i) {
                return (
                  void 0 === i && (i = 0), s(t().getListOneOnOnePinTopics(e, i))
                );
              },
              reorderOneOnOnePinTopics: function (e, i, n) {
                void 0 === n && (n = 0);
                const a = tt.default.getCurrentLanguageName();
                return s(t().reorderOneOnOnePinTopics(e, i, n, a));
              },
              unpinOneOnOneTopics: function (e, i, n) {
                void 0 === n && (n = 0);
                const a = tt.default.getCurrentLanguageName();
                return s(t().unpinOneOnOneTopics(e, i, n, a));
              },
            };
          };
        !(function (e) {
          (e.CREATE = "create"),
            (e.FETCH = "fetch"),
            (e.REORDER = "reorder"),
            (e.UNPIN = "unpin");
        })(Ul || (Ul = {}));
        var Bl = class extends Fl {
          constructor() {
            super(il.f.Network, [Ul.CREATE, Ul.FETCH, Ul.REORDER, Ul.UNPIN]);
          }
          infoCreate() {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
              t[s] = arguments[s];
            this.logInfo(Ul.CREATE, ...t);
          }
          infoFetch() {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
              t[s] = arguments[s];
            this.logInfo(Ul.FETCH, ...t);
          }
          infoReorder() {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
              t[s] = arguments[s];
            this.logInfo(Ul.REORDER, ...t);
          }
          infoUnpin() {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
              t[s] = arguments[s];
            this.logInfo(Ul.UNPIN, ...t);
          }
          errorCreate() {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
              t[s] = arguments[s];
            this.logError(Ul.CREATE, ...t);
          }
          errorFetch() {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
              t[s] = arguments[s];
            this.logError(Ul.FETCH, ...t);
          }
          errorReorder() {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
              t[s] = arguments[s];
            this.logError(Ul.REORDER, ...t);
          }
          errorUnpin() {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
              t[s] = arguments[s];
            this.logError(Ul.UNPIN, ...t);
          }
          logInfo(e) {
            if (this.isEnableLog()) {
              for (
                var t = arguments.length,
                  s = new Array(t > 1 ? t - 1 : 0),
                  i = 1;
                i < t;
                i++
              )
                s[i - 1] = arguments[i];
              super.info(e, ...s);
            }
          }
          logError(e) {
            if (this.isEnableLog()) {
              for (
                var t = arguments.length,
                  s = new Array(t > 1 ? t - 1 : 0),
                  i = 1;
                i < t;
                i++
              )
                s[i - 1] = arguments[i];
              super.error(e, ...s);
            }
          }
          isEnableLog() {
            return Object(ol.i)();
          }
        };
        var Gl,
          xl = class {
            constructor() {
              (this.apiClient = void 0),
                (this.logger = void 0),
                (this.requestID = void 0),
                (this.apiClient = kl()),
                (this.logger = new Bl()),
                (this.requestID = new Ol.a());
            }
            async fetchTopics(e, t) {
              void 0 === t && (t = 0);
              const s = this.getRequestId();
              this.Logger.infoFetch(s, `call cId:${e}`, t);
              try {
                const i = await this.apiClient.getListOneOnOnePinTopics(e, t);
                return (
                  this.Logger.infoFetch(s, `cId:${e} success`, i.version),
                  {
                    status: il.h.SUCCESS,
                    response: { data: { topics: i.data, version: i.version } },
                  }
                );
              } catch (i) {
                return (
                  this.Logger.errorFetch(
                    s,
                    `cId:${e} fail`,
                    Rl(i, Object(ol.d)()),
                  ),
                  Promise.reject({
                    status: il.h.ERROR,
                    error: {
                      code: i.code || i.error_code,
                      message: i.error_message,
                    },
                  })
                );
              }
            }
            async createTopic(e, t, s) {
              void 0 === s && (s = 0);
              const i = this.getRequestId();
              this.Logger.infoCreate(i, `call cId:${e}`, s);
              try {
                const n = await this.apiClient.createOneOnOneTopic(e, t, s);
                return (
                  this.Logger.infoCreate(i, `cId:${e} success`, n.version),
                  {
                    status: il.h.SUCCESS,
                    response: { data: { topic: n.data, version: n.version } },
                  }
                );
              } catch (n) {
                return (
                  this.Logger.errorCreate(
                    i,
                    `cId:${e} fail`,
                    Rl(n, Object(ol.d)()),
                  ),
                  Promise.reject({
                    status: il.h.ERROR,
                    error: {
                      code: n.code || n.error_code,
                      message: n.error_message,
                    },
                  })
                );
              }
            }
            async unpinTopics(e, t, s) {
              void 0 === s && (s = 0);
              const i = this.getRequestId();
              this.Logger.infoUnpin(i, `call cId:${e}`, s);
              try {
                const n = await this.apiClient.unpinOneOnOneTopics(e, t, s);
                return (
                  this.Logger.infoUnpin(i, `cId:${e} success`, n.version),
                  { status: il.h.SUCCESS, response: { data: n } }
                );
              } catch (n) {
                return (
                  this.Logger.errorUnpin(
                    i,
                    `cId:${e} fail`,
                    Rl(n, Object(ol.d)()),
                  ),
                  Promise.reject({
                    status: il.h.ERROR,
                    error: {
                      code: n.code || n.error_code,
                      message: n.error_message,
                    },
                  })
                );
              }
            }
            async reorderTopics(e, t, s) {
              void 0 === s && (s = 0);
              const i = this.getRequestId();
              this.Logger.infoReorder(i, `call cId:${e}`, s);
              try {
                const n = await this.apiClient.reorderOneOnOnePinTopics(
                  e,
                  t,
                  s,
                );
                return (
                  this.Logger.infoReorder(i, `cId:${e} success`, n.version),
                  { status: il.h.SUCCESS, response: { data: n } }
                );
              } catch (n) {
                return (
                  this.Logger.errorUnpin(
                    i,
                    `cId:${e} fail`,
                    Rl(n, Object(ol.d)()),
                  ),
                  Promise.reject({
                    status: il.h.ERROR,
                    error: {
                      code: n.code || n.error_code,
                      message: n.error_message,
                    },
                  })
                );
              }
            }
            getRequestId() {
              return this.requestID.next();
            }
            get Logger() {
              return this.logger;
            }
          };
        i.ModuleContainer.register(Tl, xl);
        let zl =
          Object(i.singleton)(tl)(
            (Gl = class {
              constructor() {
                this._storage = void 0;
              }
              async clearTopics(e, t) {
                void 0 === t && (t = !1);
                try {
                  let s;
                  if (t) s = this.storage.removeConversationTopics(e);
                  else {
                    const t = { conversationId: e, topics: [] },
                      i = ["topics"];
                    s = this.storage.updateGroupTopic(t, i);
                  }
                  return await s, e;
                } catch (s) {
                  return Promise.reject(s);
                }
              }
              async loadTopics(e) {
                try {
                  return (await this.loadTopicsFromDB(e)).response.data;
                } catch (t) {
                  return Promise.reject(t);
                }
              }
              async setTopics(e) {
                try {
                  return await this.setTopicsToDB(e);
                } catch (t) {
                  return Promise.reject(t);
                }
              }
              getEntryPointPromotionalTooltipShowedStatus() {
                const e = E.default
                  .getInstance()
                  .getItemForCurrentUser(
                    il.e.ONE_ON_ONE_ENTRY_POINT_PROMOTIONAL_TOOLTIP_SHOWED,
                  );
                if (null === e) return null;
                try {
                  return JSON.parse(e);
                } catch (t) {
                  return !1;
                }
              }
              async getMessagesByIds(e) {
                try {
                  const t = await this.storage.getMessagesByIds(e);
                  let s;
                  e && e.length > 0 && (s = e[0]);
                  let i = null;
                  return s && (i = t[s]), i || Promise.reject("Not found");
                } catch (t) {
                  return Promise.reject(t);
                }
              }
              async getMessageByCliMsgId(e, t) {
                void 0 === t && (t = {});
                try {
                  const { myUID: s, userId: i } = t;
                  if (i) {
                    let t = i;
                    s == i && (t = "0");
                    const n = await this.storage.getMessageByCliMsgIdOwnerId(
                      e,
                      t,
                    );
                    return n || Promise.reject("Not found");
                  }
                  const n = await this.storage.getMessageByCliMsgId(e);
                  if (!n || !n.length) return Promise.reject("Not found");
                  n.length;
                  const a = n && n[0];
                  return a || Promise.reject("Not found");
                } catch (s) {
                  return Promise.reject(s);
                }
              }
              setEntryPointPromotionalTooltipShowedStatus(e) {
                E.default
                  .getInstance()
                  .setItemForCurrentUser(
                    il.e.ONE_ON_ONE_ENTRY_POINT_PROMOTIONAL_TOOLTIP_SHOWED,
                    JSON.stringify(e),
                  );
              }
              setForcedFetchMilestone(e) {
                E.default
                  .getInstance()
                  .setItemForCurrentUser(
                    il.e.FORCE_FETCH_MILESTONE,
                    e.toString(),
                  );
              }
              async loadTopicsFromDB(e) {
                try {
                  const t = await this.storage.getGroupTopic(e);
                  return { status: il.h.SUCCESS, response: { data: t } };
                } catch (t) {
                  return Promise.reject({
                    status: il.h.ERROR,
                    error: {
                      code: null == t ? void 0 : t.code,
                      message:
                        (null == t ? void 0 : t.message) ||
                        (null == t ? void 0 : t.error_message),
                      data: t,
                    },
                  });
                }
              }
              async setTopicsToDB(e) {
                return await this.storage.setGroupTopic(e);
              }
              get storage() {
                return (
                  this._storage || (this._storage = s("XS0u").default),
                  this._storage
                );
              }
            }),
          ) || Gl;
        var Vl = zl;
        i.ModuleContainer.register(sl, Vl);
        var Hl = s("+3r3");
        var $l,
          Wl = Object(i.define)("pin-topic-one-on-one-controller");
        !(function (e) {
          (e.CONTROL = "control"),
            (e.CREATE = "create"),
            (e.LOAD = "load"),
            (e.REORDER = "reorder"),
            (e.UNPIN = "unpin");
        })($l || ($l = {}));
        var Kl,
          ql = class extends Fl {
            constructor() {
              super(il.f.OneOnOneController, [
                $l.CONTROL,
                $l.CREATE,
                $l.LOAD,
                $l.REORDER,
                $l.UNPIN,
              ]);
            }
            infoControl() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logInfo($l.CONTROL, ...t);
            }
            infoCreate() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logInfo($l.CREATE, ...t);
            }
            infoLoad() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logInfo($l.LOAD, ...t);
            }
            infoReorder() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logInfo($l.REORDER, ...t);
            }
            infoUnpin() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logInfo($l.UNPIN, ...t);
            }
            errorControl() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logError($l.CONTROL, ...t);
            }
            errorCreate() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logError($l.CREATE, ...t);
            }
            errorLoad() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logError($l.LOAD, ...t);
            }
            errorReorder() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logError($l.REORDER, ...t);
            }
            errorUnpin() {
              for (
                var e = arguments.length, t = new Array(e), s = 0;
                s < e;
                s++
              )
                t[s] = arguments[s];
              this.logError($l.UNPIN, ...t);
            }
            logInfo(e) {
              if (this.isEnableLog()) {
                for (
                  var t = arguments.length,
                    s = new Array(t > 1 ? t - 1 : 0),
                    i = 1;
                  i < t;
                  i++
                )
                  s[i - 1] = arguments[i];
                super.info(e, ...s);
              }
            }
            logError(e) {
              if (this.isEnableLog()) {
                for (
                  var t = arguments.length,
                    s = new Array(t > 1 ? t - 1 : 0),
                    i = 1;
                  i < t;
                  i++
                )
                  s[i - 1] = arguments[i];
                super.error(e, ...s);
              }
            }
            isEnableLog() {
              return Object(ol.g)();
            }
          };
        Object(i.injectable)()(
          (Kl =
            Object(i.singleton)(Wl)(
              (Kl =
                (function (e, t) {
                  return Object(i.inject)(_l)(e, void 0, 0);
                })(
                  (Kl =
                    (function (e, t) {
                      return Object(i.inject)(el)(e, void 0, 1);
                    })(
                      (Kl =
                        Reflect.metadata(
                          "design:type",
                          Function,
                        )(
                          (Kl =
                            Reflect.metadata("design:paramtypes", [
                              Object,
                              Object,
                            ])(
                              (Kl = class {
                                constructor(e, t) {
                                  (this.dataRepository = e),
                                    (this.messageLoader = t),
                                    (this.events = {}),
                                    (this.logger = void 0),
                                    (this.requestID = void 0),
                                    this.initialize(),
                                    (this.logger = new ql()),
                                    (this.requestID = new Ol.a());
                                }
                                getPinTopic(e, t, s) {
                                  return new Promise((i, n) => {
                                    this.loadPinTopics(e)
                                      .then((e) => {
                                        const { topics: a } = e,
                                          r = a.find(
                                            (e) =>
                                              e.id ===
                                                (null == t
                                                  ? void 0
                                                  : t.toString()) &&
                                              e.type === s,
                                          );
                                        r ? i(r) : n(null);
                                      })
                                      .catch(n);
                                  });
                                }
                                getMessageFromTopic(e) {
                                  return this.MessageLoader.getMessageFromTopic(
                                    e,
                                  );
                                }
                                displayEntryPointPromotionalTooltip() {
                                  this.DataRepository.setEntryPointPromotionalTooltipShowedStatus(
                                    !0,
                                  );
                                }
                                isDisplayedEntryPointPromotionalTooltip() {
                                  if (!Object(ol.l)()) return !0;
                                  const e =
                                    this.DataRepository.getEntryPointPromotionalTooltipShowedStatus();
                                  return null !== e && Boolean(e);
                                }
                                async loadPinTopics(e, t) {
                                  if (
                                    (void 0 === t && (t = !1), !Object(ol.k)())
                                  )
                                    return Promise.reject({
                                      code: dl.c.OFF_FEATURE,
                                      message: "",
                                    });
                                  const s = this.getRequestID();
                                  try {
                                    var i;
                                    let n;
                                    t && (n = dl.e.OPEN_DIALOG),
                                      this.Logger.infoLoad(
                                        s,
                                        `call cId:${e}`,
                                        t,
                                      );
                                    const a =
                                      await this.DataRepository.loadPinTopics(
                                        e,
                                        n,
                                      );
                                    return (
                                      this.Logger.infoLoad(
                                        s,
                                        `res cId:${e}`,
                                        !!a,
                                        a.conversationId,
                                        null === (i = a.topics) || void 0 === i
                                          ? void 0
                                          : i.length,
                                      ),
                                      {
                                        conversationId: a.conversationId,
                                        topics: a.topics,
                                      }
                                    );
                                  } catch (n) {
                                    return (
                                      this.Logger.errorLoad(
                                        s,
                                        `err cId:${e}`,
                                        Rl(n, Object(ol.a)()),
                                      ),
                                      Promise.reject(n)
                                    );
                                  }
                                }
                                addEventListener(e, t) {
                                  this.events[e] || (this.events[e] = []),
                                    this.events[e].push(t);
                                }
                                removeEventListener(e, t) {
                                  const s = this.events[e],
                                    i = (this.events[e] || []).length;
                                  for (let n = 0; n < i; n++)
                                    if (s[n] === t) {
                                      s.splice(n, 1);
                                      break;
                                    }
                                  0 === s.length && delete this.events[e];
                                }
                                removeEventListeners(e) {
                                  delete this.events[e];
                                }
                                handleEventControl(e) {
                                  if (!Object(ol.k)()) return;
                                  const t = this.getRequestID();
                                  this.Logger.infoControl(
                                    t,
                                    "recv",
                                    e.act,
                                    Rl(e.data, Object(ol.a)()),
                                  ),
                                    this.DataRepository.handleReceivingEvent(
                                      e.act,
                                      e.data,
                                    )
                                      .then((s) => {
                                        if (
                                          (this.Logger.infoControl(
                                            t,
                                            "res",
                                            e.act,
                                            Rl(s, Object(ol.a)()),
                                          ),
                                          e.act === dl.d.UNPIN)
                                        ) {
                                          let t = [];
                                          if (
                                            (Array.isArray(e.data.topics) &&
                                              e.data.topics.forEach((e) => {
                                                s.topics.find(
                                                  (t) =>
                                                    t.id === e.topicId &&
                                                    t.type === e.topicType,
                                                ) ||
                                                  t.push({
                                                    topicId: e.topicId,
                                                    topicType: e.topicType,
                                                  });
                                              }),
                                            t.length > 0)
                                          ) {
                                            const s = {};
                                            t.forEach((t) => {
                                              s[`${t.topicId}_${t.topicType}`] =
                                                this.getPinTopic(
                                                  e.data.conversationId,
                                                  t.topicId,
                                                  t.topicType,
                                                );
                                            }),
                                              wl(s).then((e) => {
                                                const t = Object.keys(e).map(
                                                  (t) => e[t],
                                                );
                                                this.MessageLoader.removeMessages(
                                                  t,
                                                );
                                              });
                                          }
                                        }
                                        this.MessageLoader.loadMessages(
                                          s.topics,
                                        ),
                                          this.notifyChangeEvent(
                                            s.conversationId,
                                            s.topics,
                                          );
                                      })
                                      .catch((s) => {
                                        this.Logger.errorControl(
                                          t,
                                          "err",
                                          e.act,
                                          Rl(s, Object(ol.a)()),
                                        );
                                      });
                                }
                                async createPinTopic(e, t, s) {
                                  if (
                                    (void 0 === s && (s = 2), !Object(ol.k)())
                                  )
                                    return Promise.reject({
                                      code: dl.c.OFF_FEATURE,
                                      message: "",
                                    });
                                  const i = this.getRequestID();
                                  try {
                                    var n;
                                    if (
                                      (this.Logger.infoCreate(
                                        i,
                                        `call cId:${e}`,
                                        !!t,
                                        s,
                                      ),
                                      !this.isValidNetwork())
                                    )
                                      return Promise.reject({
                                        code: dl.c.NO_NETWORK,
                                        message: "STR_CHECK_NET",
                                      });
                                    const a = await this.retryable(s, () =>
                                      this.processCreatePinTopic(e, t, s),
                                    );
                                    return (
                                      this.Logger.infoCreate(
                                        i,
                                        `res cId:${e}`,
                                        !!a,
                                        null == a ? void 0 : a.conversationId,
                                        null == a ||
                                          null === (n = a.topics) ||
                                          void 0 === n
                                          ? void 0
                                          : n.length,
                                      ),
                                      a
                                    );
                                  } catch (a) {
                                    return (
                                      this.Logger.errorCreate(
                                        i,
                                        `err cId:${e}`,
                                        Rl(a, Object(ol.a)()),
                                      ),
                                      Promise.reject(a)
                                    );
                                  }
                                }
                                async reorderPinTopics(e, t, s) {
                                  if (
                                    (void 0 === s && (s = 2), !Object(ol.k)())
                                  )
                                    return Promise.reject({
                                      code: dl.c.OFF_FEATURE,
                                      message: "",
                                    });
                                  const i = this.getRequestID();
                                  try {
                                    var n;
                                    if (
                                      (this.Logger.infoReorder(
                                        i,
                                        `call cId:${e}`,
                                        t.length,
                                        s,
                                      ),
                                      !this.isValidNetwork())
                                    )
                                      return Promise.reject({
                                        code: dl.c.NO_NETWORK,
                                        message: "STR_CHECK_NET",
                                      });
                                    const a = await this.retryable(s, () =>
                                      this.processReorderPinTopics(e, t, s),
                                    );
                                    return (
                                      this.Logger.infoReorder(
                                        i,
                                        `res cId:${e}`,
                                        !!a,
                                        null == a ? void 0 : a.conversationId,
                                        null == a ||
                                          null === (n = a.topics) ||
                                          void 0 === n
                                          ? void 0
                                          : n.length,
                                      ),
                                      a
                                    );
                                  } catch (a) {
                                    return (
                                      this.Logger.errorReorder(
                                        i,
                                        `err cId:${e}`,
                                        Rl(a, Object(ol.a)()),
                                      ),
                                      Promise.reject(a)
                                    );
                                  }
                                }
                                async unpinPinTopics(e, t, s) {
                                  if (
                                    (void 0 === s && (s = 2), !Object(ol.k)())
                                  )
                                    return Promise.reject({
                                      code: dl.c.OFF_FEATURE,
                                      message: "",
                                    });
                                  const i = this.getRequestID();
                                  try {
                                    var n;
                                    if (
                                      (this.Logger.infoUnpin(
                                        i,
                                        `call cId:${e}`,
                                        t.length,
                                        s,
                                      ),
                                      !this.isValidNetwork())
                                    )
                                      return Promise.reject({
                                        code: dl.c.NO_NETWORK,
                                        message: "STR_CHECK_NET",
                                      });
                                    const a = await this.retryable(s, () =>
                                      this.processUnpinPinTopics(e, t, s),
                                    );
                                    return (
                                      this.Logger.infoUnpin(
                                        i,
                                        `res cId:${e}`,
                                        !!a,
                                        null == a ? void 0 : a.conversationId,
                                        null == a ||
                                          null === (n = a.topics) ||
                                          void 0 === n
                                          ? void 0
                                          : n.length,
                                      ),
                                      a
                                    );
                                  } catch (a) {
                                    return (
                                      this.Logger.errorUnpin(
                                        i,
                                        `err cId:${e}`,
                                        Rl(a, Object(ol.a)()),
                                      ),
                                      Promise.reject(a)
                                    );
                                  }
                                }
                                isMessagePinnable(e) {
                                  return (function (e) {
                                    return rl(e);
                                  })(e);
                                }
                                initialize() {
                                  this.FriendManager.subscribeEventFriend(
                                    R.EventFriend.REMOVE_FRIEND,
                                    (e) => {
                                      const { userId: t } = e;
                                      t && this.clearTopics(t);
                                    },
                                  ),
                                    Object(Hl.b)(this.clear);
                                }
                                clear() {
                                  this.DataRepository.clear(),
                                    this.MessageLoader.clear();
                                }
                                checkEnableToCreate(e, t, s) {
                                  const i = (() => {
                                    if (t.type === dl.i.MESSAGE) {
                                      const i = s.topics,
                                        n = t.params.global_msg_id,
                                        a = t.params.client_msg_id,
                                        r = t.params.senderUid;
                                      for (let t = 0; t < i.length; t++) {
                                        const s = i[t];
                                        if (s.type === dl.i.MESSAGE) {
                                          const t =
                                            this.MessageLoader.getMessageFromTopic(
                                              s,
                                            );
                                          if (
                                            null != t &&
                                            null != n &&
                                            t.msgId === n
                                          )
                                            return s;
                                          if (
                                            null != t &&
                                            null != a &&
                                            t.cliMsgId === a &&
                                            t.fromUid === r &&
                                            t.toUid === e
                                          )
                                            return s;
                                        }
                                      }
                                    }
                                    return null;
                                  })();
                                  return s.topics.length < Object(ol.c)() || i
                                    ? { enable: !0, oldTopic: i }
                                    : { enable: !1, oldTopic: null };
                                }
                                clearTopics(e) {
                                  this.DataRepository.loadPinTopics(
                                    e,
                                    dl.e.NONE,
                                  )
                                    .then((t) => {
                                      this.DataRepository.clearPinTopicsForConversation(
                                        e,
                                        !0,
                                      ),
                                        this.MessageLoader.removeMessages(
                                          t.topics,
                                        ),
                                        this.notifyChangeEvent(e, []);
                                    })
                                    .catch();
                                }
                                getRequestID() {
                                  return this.requestID.next();
                                }
                                async fetchTopicsForHandleTopLevelErrors(e, t) {
                                  return await this.DataRepository.loadPinTopics(
                                    e,
                                    t,
                                  );
                                }
                                async handleTopLevelErrorInvalidBoardVersion(
                                  e,
                                  t,
                                  s,
                                ) {
                                  const { conversationId: i } = t;
                                  try {
                                    const e =
                                      await this.fetchTopicsForHandleTopLevelErrors(
                                        i,
                                        dl.e.OUT_OF_DATE,
                                      );
                                    return s ? await s() : e;
                                  } catch (n) {
                                    return Promise.reject(e);
                                  }
                                }
                                async handleTopLevelErrorRolledData(e, t) {
                                  const { conversationId: s } = t;
                                  try {
                                    const t =
                                      await this.fetchTopicsForHandleTopLevelErrors(
                                        s,
                                        dl.e.ROLLED_DATA,
                                      );
                                    return (
                                      this.notifyChangeEvent(
                                        t.conversationId,
                                        t.topics,
                                      ),
                                      Promise.reject({
                                        code: dl.c.TOPIC_NOT_IN_PIN_LIST,
                                        message:
                                          e.message || "STR_PIN_GENERAL_ERROR",
                                      })
                                    );
                                  } catch (i) {
                                    return Promise.reject(e);
                                  }
                                }
                                async handleTopLevelErrorUserBlockFriend(e) {
                                  return Promise.reject({
                                    code: dl.c.USER_BLOCK_FRIEND,
                                    message: e.message || "STR_TOAST_BLOCK",
                                  });
                                }
                                async handleTopLevelErrorUserNonFriend(e) {
                                  return Promise.reject({
                                    code: dl.c.USER_NON_FRIEND,
                                    message:
                                      e.message || "STR_PIN_NOT_ZALO_FRIEND",
                                  });
                                }
                                async handleTopLevelErrors(e, t, s) {
                                  return e.code === dl.c.INVALID_BOARD_VERSION
                                    ? await this.handleTopLevelErrorInvalidBoardVersion(
                                        e,
                                        t,
                                        s,
                                      )
                                    : e.code === dl.c.TOPIC_NOT_IN_PIN_LIST
                                      ? await this.handleTopLevelErrorRolledData(
                                          e,
                                          t,
                                        )
                                      : e.code === dl.c.USER_BLOCK_FRIEND
                                        ? await this.handleTopLevelErrorUserBlockFriend(
                                            e,
                                          )
                                        : e.code === dl.c.USER_NON_FRIEND
                                          ? await this.handleTopLevelErrorUserNonFriend(
                                              e,
                                            )
                                          : Promise.reject(e);
                                }
                                isValidNetwork() {
                                  return (
                                    Dn.b.getStateNetwork() === Dn.a.CONNECTED
                                  );
                                }
                                notifyEvent(e) {
                                  const t = this.events[e],
                                    s = (this.events[e] || []).length;
                                  for (
                                    var i = arguments.length,
                                      n = new Array(i > 1 ? i - 1 : 0),
                                      a = 1;
                                    a < i;
                                    a++
                                  )
                                    n[a - 1] = arguments[a];
                                  for (let r = 0; r < s; r++)
                                    "function" == typeof t[r] && t[r](...n);
                                }
                                notifyChangeEvent(e, t) {
                                  this.notifyEvent("onchange", e, t);
                                }
                                notifyExceedEvent(e, t, s) {
                                  this.notifyEvent("onexceed", e, t, s);
                                }
                                async processCreatePinTopic(e, t, s) {
                                  void 0 === s && (s = 2);
                                  if (!this.FriendManager.isFriend(e))
                                    return Promise.reject({
                                      code: dl.c.USER_NON_FRIEND,
                                      message: "STR_PIN_NOT_ZALO_FRIEND",
                                    });
                                  if (this.FriendManager.isBlocked(e))
                                    return Promise.reject({
                                      code: dl.c.USER_BLOCK_FRIEND,
                                      message: "STR_TOAST_BLOCK",
                                    });
                                  try {
                                    const s =
                                      await this.DataRepository.createPinTopic(
                                        e,
                                        t,
                                        {
                                          checkEnableToCreate:
                                            this.checkEnableToCreate.bind(this),
                                        },
                                      );
                                    return (
                                      this.MessageLoader.loadMessages(s.topics),
                                      this.notifyChangeEvent(
                                        s.conversationId,
                                        s.topics,
                                      ),
                                      {
                                        conversationId: s.conversationId,
                                        topics: s.topics,
                                      }
                                    );
                                  } catch (n) {
                                    try {
                                      const i = await this.handleTopLevelErrors(
                                        n,
                                        { conversationId: e },
                                        this.createPinTopic.bind(
                                          this,
                                          e,
                                          t,
                                          s - 1,
                                        ),
                                      );
                                      return {
                                        conversationId: i.conversationId,
                                        topics: i.topics,
                                      };
                                    } catch (a) {
                                      if (
                                        a.code === dl.c.PINBOARD_OVER_MAXIMUM
                                      ) {
                                        var i;
                                        const s =
                                          null == a ||
                                          null === (i = a.data) ||
                                          void 0 === i
                                            ? void 0
                                            : i.cache;
                                        this.notifyExceedEvent(
                                          e,
                                          (null == s ? void 0 : s.topics) || [],
                                          t,
                                        );
                                      }
                                      return Promise.reject(a);
                                    }
                                  }
                                }
                                async processReorderPinTopics(e, t, s) {
                                  void 0 === s && (s = 2);
                                  try {
                                    const s =
                                      await this.DataRepository.reorderPinTopics(
                                        e,
                                        t,
                                      );
                                    return (
                                      this.notifyChangeEvent(
                                        s.conversationId,
                                        s.topics,
                                      ),
                                      {
                                        conversationId: s.conversationId,
                                        topics: s.topics,
                                      }
                                    );
                                  } catch (i) {
                                    try {
                                      const n = await this.handleTopLevelErrors(
                                        i,
                                        { conversationId: e },
                                        this.reorderPinTopics.bind(
                                          this,
                                          e,
                                          t,
                                          s - 1,
                                        ),
                                      );
                                      return {
                                        conversationId: n.conversationId,
                                        topics: n.topics,
                                      };
                                    } catch (n) {
                                      return Promise.reject(n);
                                    }
                                  }
                                }
                                async processUnpinPinTopics(e, t, s) {
                                  void 0 === s && (s = 2);
                                  try {
                                    const s =
                                      await this.DataRepository.unpinTopics(
                                        e,
                                        t,
                                      );
                                    return (
                                      this.MessageLoader.removeMessages(t),
                                      this.notifyChangeEvent(
                                        s.conversationId,
                                        s.topics,
                                      ),
                                      {
                                        conversationId: s.conversationId,
                                        topics: s.topics,
                                      }
                                    );
                                  } catch (i) {
                                    try {
                                      const n = await this.handleTopLevelErrors(
                                        i,
                                        { conversationId: e },
                                        this.unpinPinTopics.bind(
                                          this,
                                          e,
                                          t,
                                          s - 1,
                                        ),
                                      );
                                      return {
                                        conversationId: n.conversationId,
                                        topics: n.topics,
                                      };
                                    } catch (n) {
                                      return Promise.reject(n);
                                    }
                                  }
                                }
                                async retryable(e, t) {
                                  return null != e && e < 0
                                    ? Promise.reject({
                                        code: dl.c.STOP_RETRY_CLIENT,
                                        message: "STR_PIN_GENERAL_ERROR",
                                      })
                                    : await t();
                                }
                                get DataRepository() {
                                  return this.dataRepository;
                                }
                                get FriendManager() {
                                  return Ye.default;
                                }
                                get Logger() {
                                  return this.logger;
                                }
                                get MessageLoader() {
                                  return this.messageLoader;
                                }
                              }),
                            ) || Kl),
                        ) || Kl),
                    ) || Kl),
                ) || Kl),
            ) || Kl),
        );
        var Zl,
          Jl = s("74m0");
        Object(i.injectable)()(
          (Zl =
            Object(i.singleton)(Jl.a)(
              (Zl =
                (function (e, t) {
                  return Object(i.inject)(Wl)(e, void 0, 0);
                })(
                  (Zl =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (Zl =
                        Reflect.metadata("design:paramtypes", [Object])(
                          (Zl = class {
                            constructor(e) {
                              this.oneOnOneController = e;
                            }
                            addEventListener(e, t) {
                              this.OneOnOneController.addEventListener(e, t);
                            }
                            createPinTopic(e, t) {
                              return Object(al.d)(e)
                                ? Promise.resolve()
                                : this.OneOnOneController.createPinTopic(e, t);
                            }
                            displayOneOnOneEntryPointPromotionalTooltip() {
                              return this.OneOnOneController.displayEntryPointPromotionalTooltip();
                            }
                            getPinTopic(e, t, s) {
                              return Object(al.d)(e)
                                ? Promise.resolve()
                                : this.OneOnOneController.getPinTopic(e, t, s);
                            }
                            getMessageFromTopic(e, t) {
                              if (!Object(al.d)(e))
                                return this.OneOnOneController.getMessageFromTopic(
                                  t,
                                );
                            }
                            handleEventControl(e) {}
                            handleOneOnOneEventsControl(e) {
                              this.OneOnOneController.handleEventControl(e);
                            }
                            isDisplayedOneOnOneEntryPointPromotionalTooltip() {
                              return this.OneOnOneController.isDisplayedEntryPointPromotionalTooltip();
                            }
                            isEnablePinTopicOneOnOneFeature() {
                              return ol.k();
                            }
                            isEnablePinTopicOneOnOneEntryPoint() {
                              return ol.j();
                            }
                            isMessagePinnable(e, t) {
                              return (
                                !!this.isMessagePinnableForAllConversations(
                                  e,
                                ) &&
                                (t !== R.CONVERSATION_TYPE.FRIEND ||
                                  this.OneOnOneController.isMessagePinnable(e))
                              );
                            }
                            loadPinTopics(e, t) {
                              return Object(al.d)(e)
                                ? Promise.resolve()
                                : this.OneOnOneController.loadPinTopics(e, t);
                            }
                            removeEventListener(e, t) {
                              this.OneOnOneController.removeEventListener(e, t);
                            }
                            removeEventListeners(e) {
                              this.OneOnOneController.removeEventListeners(e);
                            }
                            reorderPinTopics(e, t) {
                              return Object(al.d)(e)
                                ? Promise.resolve()
                                : this.OneOnOneController.reorderPinTopics(
                                    e,
                                    t,
                                  );
                            }
                            unpinPinTopics(e, t) {
                              return Object(al.d)(e)
                                ? Promise.resolve()
                                : this.OneOnOneController.unpinPinTopics(e, t);
                            }
                            isMessagePinnableForAllConversations(e) {
                              return rl(e);
                            }
                            get OneOnOneController() {
                              return this.oneOnOneController;
                            }
                          }),
                        ) || Zl),
                    ) || Zl),
                ) || Zl),
            ) || Zl),
        );
        var Ql = s("t5n0"),
          Yl = s("aQZC");
        var Xl,
          ec = new (class {
            constructor() {
              (this.focusManager = void 0),
                (this.focusStatus = void 0),
                (this.focusService = void 0);
            }
            get FSV() {
              return (
                this.focusService ||
                  (this.focusService = i.ModuleContainer.resolve(
                    q.ZLoggerFactory,
                  ).createZLogger(hs.ZLoggerNametags.appStatus, [
                    hs.ZLoggerNametags.focusDetectorManager,
                  ])),
                this.focusService
              );
            }
            get FM() {
              return (
                this.focusManager ||
                  (this.focusManager = i.ModuleContainer.resolve(
                    q.ZLoggerFactory,
                  ).createZLogger(hs.ZLoggerNametags.appStatus, [
                    hs.ZLoggerNametags.focusDetectorManager,
                  ])),
                this.focusManager
              );
            }
            get FSTT() {
              return (
                this.focusStatus ||
                  (this.focusStatus = i.ModuleContainer.resolve(
                    q.ZLoggerFactory,
                  ).createZLogger(hs.ZLoggerNametags.appStatus, [
                    hs.ZLoggerNametags.focusStatus,
                  ])),
                this.focusStatus
              );
            }
          })();
        let tc =
          Object(i.injectable)()(
            (Xl =
              Object(V.e)()(
                (Xl =
                  (function (e, t) {
                    return Object(i.inject)(_.a)(e, void 0, 0);
                  })(
                    (Xl =
                      Reflect.metadata(
                        "design:type",
                        Function,
                      )(
                        (Xl =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === _.a ? Object : _.a,
                          ])(
                            (Xl = class extends te.b {
                              constructor(e) {
                                super(),
                                  (this.config = e),
                                  (this.detectors = void 0),
                                  (this.lostFocusHandler = void 0),
                                  (this.reFocusHandler = void 0),
                                  (this.lastFirer = void 0),
                                  (this.enableLog = void 0),
                                  (this.listenDetector = (e, t) => {
                                    t &&
                                      (this.detectors.set(e, t),
                                      this.lostFocusHandler.set(e, () => {
                                        this.onLostFocus(e);
                                      }),
                                      this.reFocusHandler.set(e, () => {
                                        this.onRefocus(e);
                                      }),
                                      t.idle(this.lostFocusHandler.get(e)),
                                      t.wakeup(this.reFocusHandler.get(e)));
                                  }),
                                  (this.disposeDetector = (e) => {
                                    const t = this.detectors.get(e);
                                    this.enableLog &&
                                      ec.FM.zsymb(
                                        0,
                                        11677,
                                        30003,
                                        "disposeDetector",
                                        e,
                                        !!t,
                                      ),
                                      t &&
                                        (t.removeIdle(
                                          this.lostFocusHandler.get(e),
                                        ),
                                        t.removeWakeup(
                                          this.reFocusHandler.get(e),
                                        ),
                                        (t.ifvisible = null),
                                        (t._window = null),
                                        t.removeAllIpc(),
                                        this.lostFocusHandler.delete(e),
                                        this.reFocusHandler.delete(e),
                                        this.detectors.delete(e));
                                  }),
                                  (this.onLostFocus = (e) => {
                                    this.lastFirer &&
                                      (clearTimeout(this.lastFirer),
                                      (this.lastFirer = null)),
                                      (this.lastFirer = setTimeout(() => {
                                        this.enableLog &&
                                          ec.FM.zsymb(
                                            0,
                                            11677,
                                            30004,
                                            "onlostFocus",
                                            e,
                                          );
                                        let t = !0,
                                          s = Number.MAX_SAFE_INTEGER,
                                          i = "unknown";
                                        this.detectors.forEach((e) => {
                                          if (e.isActive()) t = !1;
                                          else {
                                            const t = e.getIdleInfo();
                                            t.idleFor < s &&
                                              ((s = t.idleFor),
                                              (i = t.idleByTimeout
                                                ? "no-action-timeout"
                                                : "unknown"));
                                          }
                                        }),
                                          t &&
                                            this.dispatchEvent(
                                              new Ql.a(Ql.b.LostFocus, {
                                                scope: "app",
                                                reason: i,
                                              }),
                                            ),
                                          (this.lastFirer = null);
                                      }, 200));
                                  }),
                                  (this.onRefocus = (e) => {
                                    this.lastFirer &&
                                      (clearTimeout(this.lastFirer),
                                      (this.lastFirer = null)),
                                      (this.lastFirer = setTimeout(() => {
                                        this.enableLog &&
                                          ec.FM.zsymb(
                                            0,
                                            11677,
                                            30005,
                                            "onRefocus",
                                            e,
                                          ),
                                          this.dispatchEvent(
                                            new Ql.a(Ql.b.Focus, e),
                                          ),
                                          (this.lastFirer = null);
                                      }, 200));
                                  }),
                                  (this.detectors = new Map()),
                                  (this.lostFocusHandler = new Map()),
                                  (this.reFocusHandler = new Map()),
                                  (this.enableLog = !0);
                              }
                              onAuthenticated(e) {
                                const { userId: t } = e.getSession();
                                this.enableLog &&
                                  ec.FM.zsymb(
                                    0,
                                    11677,
                                    3e4,
                                    "onAuthenticated",
                                    t,
                                  ),
                                  this.init();
                              }
                              acquire(e, t, s) {
                                if (!e || e == Qt.c) return Yl.b;
                                if (this.detectors.has(e))
                                  return (
                                    ec.FM.zsymb(
                                      0,
                                      11677,
                                      30001,
                                      "acquire exists",
                                      e,
                                    ),
                                    this.detectors.get(e)
                                  );
                                this.enableLog &&
                                  ec.FM.zsymb(
                                    0,
                                    11677,
                                    30002,
                                    "acquire new",
                                    e,
                                  );
                                const i = new Yl.a(e, t, s);
                                return this.listenDetector(e, i), i;
                              }
                              release(e) {
                                this.disposeDetector(e);
                              }
                              getAppIdleTime() {
                                let e = Number.MAX_SAFE_INTEGER;
                                return (
                                  this.detectors.forEach((t) => {
                                    const s = t.getIdleInfo();
                                    s.idleFor < e && (e = s.idleFor);
                                  }),
                                  e
                                );
                              }
                              updateIdleTimeout(e) {
                                this.detectors.forEach((t) => {
                                  t.setIdleTimeout(e);
                                });
                              }
                              isAppFocus() {
                                let e = !1;
                                return (
                                  this.detectors.forEach((t) => {
                                    t.isActive() && (e = !0);
                                  }),
                                  e
                                );
                              }
                              init() {
                                this.listenDetector(Qt.c, Yl.b);
                              }
                            }),
                          ) || Xl),
                      ) || Xl),
                  ) || Xl),
              ) || Xl),
          ) || Xl;
        const sc = Object(i.define)("lost-focus-service"),
          ic = Object(i.define)("active-service");
        var nc,
          ac,
          rc = s("cHDa");
        !(function (e) {
          (e[(e.Focus = 0)] = "Focus"), (e[(e.LostFocus = 1)] = "LostFocus");
        })(ac || (ac = {}));
        let oc =
          Object(i.injectable)()(
            (nc =
              Object(V.e)()(
                (nc =
                  (function (e, t) {
                    return Object(i.inject)(_.a)(e, void 0, 0);
                  })(
                    (nc =
                      (function (e, t) {
                        return Object(i.inject)(sc)(e, void 0, 1);
                      })(
                        (nc =
                          Reflect.metadata(
                            "design:type",
                            Function,
                          )(
                            (nc =
                              Reflect.metadata("design:paramtypes", [
                                void 0 === _.a ? Object : _.a,
                                void 0 === sc ? Object : sc,
                              ])(
                                (nc = class {
                                  constructor(e, t) {
                                    (this.config = e),
                                      (this.service = t),
                                      (this.enableLog = void 0),
                                      (this.currentState = void 0),
                                      (this.enableLog = !0),
                                      (this.currentState = ac.LostFocus);
                                  }
                                  onAuthenticated(e) {
                                    const { userId: t } = e.getSession();
                                    this.enableLog &&
                                      ec.FSTT.zsymb(
                                        0,
                                        9656,
                                        3e4,
                                        "onAuthenticated",
                                        t,
                                      ),
                                      this.init();
                                  }
                                  init() {
                                    const e = i.ModuleContainer.resolve(Ql.c);
                                    e.addEventListener(Ql.b.LostFocus, (e) => {
                                      const { scope: t, reason: s } = e.payload;
                                      this.currentState == ac.Focus &&
                                        "app" === t &&
                                        (this.service.notiLostFocus(),
                                        this.config.get(
                                          "online_configs.enable_focus_manager",
                                        ) && rc.b.setAppStatus(rc.a.BACKGROUND),
                                        (this.currentState = ac.LostFocus));
                                    }),
                                      e.addEventListener(Ql.b.Focus, (e) => {
                                        this.currentState == ac.LostFocus &&
                                          this.config.get(
                                            "online_configs.enable_focus_manager",
                                          ) &&
                                          rc.b.setAppStatus(rc.a.FOREGROUND),
                                          (this.currentState = ac.Focus);
                                      });
                                  }
                                }),
                              ) || nc),
                          ) || nc),
                      ) || nc),
                  ) || nc),
              ) || nc),
          ) || nc;
        var dc;
        let lc =
          Object(i.injectable)()(
            (dc =
              (function (e, t) {
                return Object(i.inject)(_.a)(e, void 0, 0);
              })(
                (dc =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (dc =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === _.a ? Object : _.a,
                      ])(
                        (dc = class {
                          constructor(e) {
                            this.config = e;
                          }
                          notiLostFocus() {
                            this.config.get("online_configs.enable_lost_focus")
                              ? Ln.default
                                  .lostFocus()
                                  .then(wn.a)
                                  .then(() => {
                                    ec.FSV.zsymb(
                                      0,
                                      8612,
                                      30001,
                                      "send noti lost success",
                                    );
                                  })
                                  .catch((e) => {
                                    ec.FSV.zsymb(
                                      0,
                                      8612,
                                      30002,
                                      "send noti lost fail",
                                      JSON.stringify(e),
                                    );
                                  })
                              : ec.FSV.zsymb(
                                  0,
                                  8612,
                                  3e4,
                                  "call send noti lost but feat disable",
                                );
                          }
                        }),
                      ) || dc),
                  ) || dc),
              ) || dc),
          ) || dc;
        var cc = s("a8HX"),
          hc = s("LLK0");
        class uc {
          constructor() {
            this.interpreter = void 0;
          }
          create(e) {
            this.interpreter = new hc.a(this.createMachine(e), e);
          }
          get status() {
            var e;
            return (
              (null === (e = this.interpreter) || void 0 === e
                ? void 0
                : e.status) || hc.b.NotStarted
            );
          }
          start() {
            var e;
            null === (e = this.interpreter) || void 0 === e || e.start();
          }
          stop() {
            var e;
            null === (e = this.interpreter) || void 0 === e || e.stop();
          }
          send(e) {
            return this.interpreter.send(e);
          }
          onChange(e) {
            this.interpreter.onChange(e);
          }
          onTransition(e) {
            this.interpreter.onTransition(e);
          }
          onStop(e) {
            this.interpreter.onStop(e);
          }
          onDone(e) {
            this.interpreter.onDone(e);
          }
          off(e) {
            var t, s;
            null === (t = this.interpreter) ||
              void 0 === t ||
              null === (s = t.off) ||
              void 0 === s ||
              s.call(t, e);
          }
        }
        var gc,
          mc = s("G15u");
        let pc =
          Object(i.injectable)()(
            (gc =
              (function (e, t) {
                return Object(i.inject)(q.ZLoggerFactory)(e, void 0, 0);
              })(
                (gc =
                  (function (e, t) {
                    return Object(i.inject)(ic)(e, void 0, 1);
                  })(
                    (gc =
                      Reflect.metadata(
                        "design:type",
                        Function,
                      )(
                        (gc =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === q.ZLoggerFactory
                              ? Object
                              : q.ZLoggerFactory,
                            void 0 === ic ? Object : ic,
                          ])(
                            (gc = class extends uc {
                              constructor(e, t) {
                                super(),
                                  (this.loggerFactory = e),
                                  (this.service = t);
                              }
                              createMachine() {
                                return (
                                  (e = this.loggerFactory.createZLogger(
                                    hs.ZLoggerNametags.activeDeactive,
                                    [hs.ZLoggerNametags.stateMachine],
                                  )),
                                  (t = this.service),
                                  Object(mc.a)({
                                    strict: !0,
                                    id: "active-deactive",
                                    context: {},
                                    initial: "unset",
                                    states: {
                                      unset: {
                                        entry: () =>
                                          e.zsymb(3, 9805, 3e4, "unset"),
                                        on: {
                                          FOCUS: {
                                            actions: () => {
                                              e.zsymb(
                                                3,
                                                9805,
                                                30001,
                                                "start life cycle normal case!",
                                              );
                                            },
                                            target: "foreground_active",
                                          },
                                          APP_UNLOCK: {
                                            actions: () => {
                                              e.zsymb(
                                                3,
                                                9805,
                                                30002,
                                                "start life cycle app auto lock case!",
                                              );
                                            },
                                            target: "foreground_active",
                                          },
                                          LOST_FOCUS: {
                                            actions: () => {
                                              e.zsymb(
                                                3,
                                                9805,
                                                30003,
                                                "start life cycle lost focus case!",
                                              );
                                            },
                                            target: "background_active",
                                          },
                                        },
                                      },
                                      foreground_active: {
                                        entry: (s) => {
                                          e.zsymb(
                                            3,
                                            9805,
                                            30004,
                                            "state: foreground_active",
                                          ),
                                            t.startForegroundMode();
                                        },
                                        on: {
                                          IDLE: {
                                            actions: () => {},
                                            target: "background_deactive",
                                          },
                                          LOST_FOCUS: {
                                            actions: () => {},
                                            target: "background_active",
                                          },
                                          INAPP_INTERACT: {
                                            actions: () => {
                                              t.keepForegroundMode();
                                            },
                                          },
                                          OUTAPP_INTERACT: {
                                            actions: (e, s) => {
                                              t.activeInBackground(s.isOsEvt);
                                            },
                                          },
                                          APP_LOCK: {
                                            target: "background_deactive",
                                          },
                                          APP_UNLOCK: {
                                            actions: () => {
                                              t.startForegroundMode();
                                            },
                                          },
                                          LOG_OFF: {
                                            target: "background_deactive",
                                          },
                                          OUTAPP_IDLE: {
                                            target: "background_deactive",
                                          },
                                        },
                                      },
                                      background_active: {
                                        entry: (s) => {
                                          e.zsymb(
                                            3,
                                            9805,
                                            30005,
                                            "state: background_active",
                                          ),
                                            t.startBackgroundMode();
                                        },
                                        on: {
                                          FOCUS: {
                                            target: "foreground_active",
                                          },
                                          OUTAPP_INTERACT: {
                                            actions: (e, s) => {
                                              t.activeInBackground(s.isOsEvt);
                                            },
                                          },
                                          OUTAPP_IDLE: {
                                            target: "background_deactive",
                                          },
                                          APP_LOCK: {
                                            target: "background_deactive",
                                          },
                                          LOG_OFF: {
                                            target: "background_deactive",
                                          },
                                        },
                                      },
                                      background_deactive: {
                                        entry: (s, i) => {
                                          e.zsymb(
                                            3,
                                            9805,
                                            30006,
                                            "state: background_deactive",
                                            i.status,
                                          ),
                                            t.startDeactive(i.status);
                                        },
                                        on: {
                                          FOCUS: {
                                            actions: () => {},
                                            target: "foreground_active",
                                          },
                                          OUTAPP_INTERACT: {
                                            actions: (e, s) => {
                                              t.activeInBackground(s.isOsEvt);
                                            },
                                            target: "background_active",
                                          },
                                          APP_UNLOCK: {
                                            target: "foreground_active",
                                          },
                                        },
                                      },
                                    },
                                    on: {
                                      RESET: {
                                        target: "unset",
                                        actions: () => {},
                                      },
                                    },
                                  })
                                );
                                var e, t;
                              }
                              isUnset() {
                                var e;
                                return (
                                  "unset" ===
                                  (null === (e = this.interpreter) ||
                                  void 0 === e
                                    ? void 0
                                    : e.state.value)
                                );
                              }
                              onceDeactive(e) {
                                var t;
                                if (
                                  "background_deactive" ===
                                  (null === (t = this.interpreter) ||
                                  void 0 === t
                                    ? void 0
                                    : t.state.value)
                                )
                                  e();
                                else {
                                  let t = () => {
                                    var s, i;
                                    "background_deactive" ===
                                      (null === (s = this.interpreter) ||
                                      void 0 === s
                                        ? void 0
                                        : s.state.value) &&
                                      (null === (i = this.interpreter) ||
                                        void 0 === i ||
                                        i.off(t),
                                      e());
                                  };
                                  this.onChange(t);
                                }
                              }
                            }),
                          ) || gc),
                      ) || gc),
                  ) || gc),
              ) || gc),
          ) || gc;
        var fc,
          vc = s("4zJP");
        const bc = new Map([
          ["0", "LOCK_SCREEN"],
          ["1", "UNLOCK_SCREEN"],
          ["2", "LOG_ON"],
          ["3", "LOG_OFF"],
          ["4", "SLEEP"],
          ["5", "RESUME"],
        ]);
        let Ic =
          Object(i.injectable)()(
            (fc =
              Object(V.h)()(
                (fc =
                  Object(V.g)()(
                    (fc =
                      Object(i.singleton)(cc.a)(
                        (fc =
                          (function (e, t) {
                            return Object(i.inject)(_.a)(e, void 0, 0);
                          })(
                            (fc =
                              (function (e, t) {
                                return Object(i.inject)(q.ZLoggerFactory)(
                                  e,
                                  void 0,
                                  1,
                                );
                              })(
                                (fc =
                                  (function (e, t) {
                                    return Object(i.inject)(ic)(e, void 0, 2);
                                  })(
                                    (fc =
                                      Reflect.metadata(
                                        "design:type",
                                        Function,
                                      )(
                                        (fc =
                                          Reflect.metadata(
                                            "design:paramtypes",
                                            [
                                              void 0 === _.a ? Object : _.a,
                                              void 0 === q.ZLoggerFactory
                                                ? Object
                                                : q.ZLoggerFactory,
                                              void 0 === ic ? Object : ic,
                                            ],
                                          )(
                                            (fc = class {
                                              constructor(e, t, s) {
                                                (this.config = e),
                                                  (this.service = s),
                                                  (this.logger = void 0),
                                                  (this.machine = void 0),
                                                  (this.authenticated = void 0),
                                                  (this.appLocked = void 0),
                                                  (this.isRunning = void 0),
                                                  (this.lastConfig = void 0),
                                                  (this.onAppLock = () => {
                                                    this.logger.zsymb(
                                                      0,
                                                      16232,
                                                      30003,
                                                      "app locked",
                                                      this.authenticated,
                                                    ),
                                                      (this.appLocked = !0),
                                                      this.authenticated &&
                                                        (this.machine.send({
                                                          type: "APP_LOCK",
                                                          status: 2,
                                                        }),
                                                        $zInAppPayment.closeInAppPayment());
                                                  }),
                                                  (this.onAppUnLock = () => {
                                                    this.logger.zsymb(
                                                      0,
                                                      16232,
                                                      30004,
                                                      "app unlocked",
                                                      this.authenticated,
                                                    ),
                                                      (this.appLocked = !1),
                                                      this.authenticated &&
                                                        this.machine.send({
                                                          type: "APP_UNLOCK",
                                                          status: 0,
                                                        });
                                                  }),
                                                  (this.onConfigChanged = (
                                                    e,
                                                  ) => {
                                                    bt.default.stagingAccount &&
                                                      (window._activeController =
                                                        this),
                                                      e &&
                                                        this.config.set(
                                                          "online_configs",
                                                          e,
                                                        );
                                                    const t =
                                                      this.isConfigsReallyChanged();
                                                    if (
                                                      (this.logger.zsymb(
                                                        0,
                                                        16232,
                                                        30005,
                                                        "onConfigChanged",
                                                        t,
                                                      ),
                                                      !t)
                                                    )
                                                      return;
                                                    this.lastConfig =
                                                      this.config.get(
                                                        "online_configs",
                                                      );
                                                    const s = this.config.get(
                                                      "online_configs.idle_time",
                                                    );
                                                    i.ModuleContainer.resolve(
                                                      Ql.c,
                                                    ).updateIdleTimeout(
                                                      s / 1e3,
                                                    ),
                                                      this.service.onConfigUpdated(),
                                                      this.isEnable()
                                                        ? this.setup()
                                                        : this.onDispose();
                                                  }),
                                                  (this.onLostFocus = async (
                                                    e,
                                                  ) => {
                                                    const {
                                                      scope: t,
                                                      reason: s,
                                                    } = e.payload;
                                                    "app" === t &&
                                                      (this.logger.zsymb(
                                                        0,
                                                        16232,
                                                        30006,
                                                        "lost focus",
                                                        s,
                                                      ),
                                                      "no-action-timeout" !=
                                                        s ||
                                                      (await this.service.isUserHasAction(
                                                        this.idleTime,
                                                      ))
                                                        ? this.machine.send({
                                                            type: "LOST_FOCUS",
                                                          })
                                                        : this.machine.send({
                                                            type: "IDLE",
                                                            status: 0,
                                                          }));
                                                  }),
                                                  (this.onFocus = (e) => {
                                                    this.isUsingApp() &&
                                                      (this.logger.zsymb(
                                                        0,
                                                        16232,
                                                        30007,
                                                        "active-deactive focus",
                                                      ),
                                                      this.machine.send({
                                                        type: "FOCUS",
                                                      }));
                                                  }),
                                                  (this.onActiveFromBackground =
                                                    (e, t) => {
                                                      this.logger.zsymb(
                                                        0,
                                                        16232,
                                                        30008,
                                                        "onActiveFromBackground",
                                                        t,
                                                      ),
                                                        this.isUsingApp() &&
                                                          this.machine.send({
                                                            type: "OUTAPP_INTERACT",
                                                            isOsEvt: t,
                                                          });
                                                    }),
                                                  (this.onDeactiveFromBackground =
                                                    (e, t) => {
                                                      this.logger.zsymb(
                                                        0,
                                                        16232,
                                                        30009,
                                                        "onDeactiveFromBackground",
                                                        t,
                                                      ),
                                                        this.isUsingApp() &&
                                                          this.machine.send({
                                                            type: "OUTAPP_IDLE",
                                                            status: t,
                                                          });
                                                    }),
                                                  (this.machine =
                                                    i.ModuleContainer.resolveToken(
                                                      pc,
                                                    )),
                                                  (this.logger =
                                                    t.createZLogger(
                                                      hs.ZLoggerNametags
                                                        .activeDeactive,
                                                      [
                                                        hs.ZLoggerNametags
                                                          .controller,
                                                      ],
                                                    )),
                                                  (this.config = e),
                                                  (this.service = s),
                                                  (this.authenticated = !1),
                                                  (this.appLocked = !1),
                                                  (this.isRunning = !1),
                                                  (this.lastConfig = {}),
                                                  Q.p.listenEvent(
                                                    Q.m,
                                                    this.onConfigChanged,
                                                  );
                                                try {
                                                  this.machine.create();
                                                } catch (n) {
                                                  return void this.logger.zsymb(
                                                    18,
                                                    16232,
                                                    3e4,
                                                    () => [
                                                      "create error",
                                                      { error: n },
                                                    ],
                                                  );
                                                }
                                              }
                                              createMachine() {}
                                              onStart() {
                                                this.isEnable() ||
                                                  this.logger.zsymb(
                                                    0,
                                                    16232,
                                                    30001,
                                                    "feature is not enable",
                                                  );
                                              }
                                              setup() {
                                                if (
                                                  (this.logger.zsymb(
                                                    0,
                                                    16232,
                                                    30002,
                                                    "setup",
                                                    this.isRunning,
                                                  ),
                                                  this.clearBackgroundTracking(),
                                                  this.isEnableBackgroundTrack() &&
                                                    this.setupBackgroundTracking(),
                                                  this.isRunning)
                                                )
                                                  return;
                                                (this.isRunning = !0),
                                                  this.machine.start();
                                                const e =
                                                  i.ModuleContainer.resolve(
                                                    Ql.c,
                                                  );
                                                this.machine.isUnset() &&
                                                  (e.isAppFocus()
                                                    ? this.machine.send({
                                                        type: "FOCUS",
                                                      })
                                                    : this.machine.send({
                                                        type: "LOST_FOCUS",
                                                      })),
                                                  e.addEventListener(
                                                    Ql.b.LostFocus,
                                                    this.onLostFocus,
                                                  ),
                                                  e.addEventListener(
                                                    Ql.b.Focus,
                                                    this.onFocus,
                                                  ),
                                                  (this.appLocked =
                                                    Q.p.getAppLock()),
                                                  vc.b.on(
                                                    vc.a.APP_LOCKED,
                                                    this.onAppLock,
                                                  ),
                                                  vc.b.on(
                                                    vc.a.APP_UNLOCKED,
                                                    this.onAppUnLock,
                                                  );
                                              }
                                              onAuthenticated() {
                                                (this.authenticated = !0),
                                                  this.isEnable() &&
                                                    this.service.onLogin();
                                              }
                                              onDispose() {
                                                if (!this.isRunning) return;
                                                (this.isRunning = !1),
                                                  this.machine.stop();
                                                const e =
                                                  i.ModuleContainer.resolve(
                                                    Ql.c,
                                                  );
                                                e.removeEventListener(
                                                  Ql.b.LostFocus,
                                                  this.onLostFocus,
                                                ),
                                                  e.removeEventListener(
                                                    Ql.b.Focus,
                                                    this.onFocus,
                                                  ),
                                                  vc.b.off(
                                                    vc.a.APP_LOCKED,
                                                    this.onAppLock,
                                                  ),
                                                  vc.b.off(
                                                    vc.a.APP_UNLOCKED,
                                                    this.onAppUnLock,
                                                  ),
                                                  this.clearBackgroundTracking();
                                              }
                                              isConfigsReallyChanged() {
                                                for (const e in this.config.get(
                                                  "online_configs",
                                                ))
                                                  if (
                                                    e &&
                                                    this.lastConfig[e] !==
                                                      this.config.get(
                                                        `online_configs.${e}`,
                                                      )
                                                  )
                                                    return !0;
                                                return !1;
                                              }
                                              setupBackgroundTracking() {}
                                              clearBackgroundTracking() {}
                                              onUserSendMessage() {
                                                this.isEnable() &&
                                                  this.machine.send(
                                                    "INAPP_INTERACT",
                                                  );
                                              }
                                              onUserLogOff() {
                                                return new Promise((e) => {
                                                  if (
                                                    !this.isEnable() ||
                                                    !this.isUsingApp()
                                                  )
                                                    return e(!1);
                                                  this.machine.onceDeactive(
                                                    () => {
                                                      e(!0);
                                                    },
                                                  ),
                                                    this.machine.send({
                                                      type: "LOG_OFF",
                                                      status: 3,
                                                    }),
                                                    this.onDispose(),
                                                    setTimeout(() => {
                                                      e(!0);
                                                    }, 1e3);
                                                });
                                              }
                                              onOSEvent(e) {
                                                if (!this.isEnable()) return;
                                                const t = bc.get(e);
                                                Mt.default.send(
                                                  St.GeneralActions
                                                    .USER_ACTIVE_CHANGED,
                                                  t,
                                                ),
                                                  this.logger.zsymb(
                                                    3,
                                                    16232,
                                                    30010,
                                                    "handle event os ",
                                                    t,
                                                  );
                                              }
                                              isUsingApp() {
                                                const e =
                                                  this.appLocked ||
                                                  Q.p.getWaitRestart();
                                                return this.authenticated && !e;
                                              }
                                              isEnable() {
                                                return this.config.get(
                                                  "online_configs.enable_active_deactive_v2",
                                                );
                                              }
                                              isEnableBackgroundTrack() {
                                                return !1;
                                              }
                                              isEnableFullBackgroundTrack() {
                                                return !1;
                                              }
                                              get pingInterval() {
                                                return this.config.get(
                                                  "online_configs.update_action_interval",
                                                );
                                              }
                                              get idleTime() {
                                                return this.config.get(
                                                  "online_configs.idle_time",
                                                );
                                              }
                                            }),
                                          ) || fc),
                                      ) || fc),
                                  ) || fc),
                              ) || fc),
                          ) || fc),
                      ) || fc),
                  ) || fc),
              ) || fc),
          ) || fc;
        var yc,
          _c,
          Oc,
          Cc,
          Ec = s("8RMw"),
          Mc = s("UkBb"),
          Sc = s("oQzU");
        !(function (e) {
          (e[(e.ActiveBackground = 0)] = "ActiveBackground"),
            (e[(e.KeepActiveForeground = 1)] = "KeepActiveForeground"),
            (e[(e.FirstActiveForeground = 2)] = "FirstActiveForeground"),
            (e[(e.ToBackground = 3)] = "ToBackground"),
            (e[(e.KeepActiveBackground = 4)] = "KeepActiveBackground");
        })(_c || (_c = {})),
          (function (e) {
            (e[(e.Idle = 0)] = "Idle"),
              (e[(e.ComputerLock = 1)] = "ComputerLock"),
              (e[(e.AppLock = 2)] = "AppLock"),
              (e[(e.LogOff = 3)] = "LogOff");
          })(Oc || (Oc = {})),
          (function (e) {
            (e[(e.Foreground = 0)] = "Foreground"),
              (e[(e.BackgroundActive = 1)] = "BackgroundActive"),
              (e[(e.BackgroundDeactive = 2)] = "BackgroundDeactive");
          })(Cc || (Cc = {}));
        const Tc = {
          [Cc.Foreground]: _c.KeepActiveForeground,
          [Cc.BackgroundActive]: _c.KeepActiveBackground,
        };
        let wc =
          Object(i.injectable)()(
            (yc =
              (function (e, t) {
                return Object(i.inject)(_.a)(e, void 0, 0);
              })(
                (yc =
                  (function (e, t) {
                    return Object(i.inject)(q.ZLoggerFactory)(e, void 0, 1);
                  })(
                    (yc =
                      (function (e, t) {
                        return Object(i.inject)(Ql.c)(e, void 0, 2);
                      })(
                        (yc =
                          Reflect.metadata(
                            "design:type",
                            Function,
                          )(
                            (yc =
                              Reflect.metadata("design:paramtypes", [
                                void 0 === _.a ? Object : _.a,
                                void 0 === q.ZLoggerFactory
                                  ? Object
                                  : q.ZLoggerFactory,
                                void 0 === Ql.c ? Object : Ql.c,
                              ])(
                                (yc = class {
                                  constructor(e, t, s) {
                                    (this.config = e),
                                      (this.focusManager = s),
                                      (this.logger = void 0),
                                      (this.pingTimer = void 0),
                                      (this.deactiveTimer = void 0),
                                      (this.status = void 0),
                                      (this.configChanged = void 0),
                                      (this.countPingWssFail = 0),
                                      (this.logger = t.createZLogger(
                                        hs.ZLoggerNametags.activeDeactive,
                                        [hs.ZLoggerNametags.service],
                                      )),
                                      (this.status = Cc.Foreground),
                                      (this.configChanged = !1);
                                  }
                                  get pingInterval() {
                                    return this.config.get(
                                      "online_configs.update_action_interval",
                                    );
                                  }
                                  get deactiveTimeout() {
                                    return this.config.get(
                                      "online_configs.idleTime",
                                    );
                                  }
                                  get enableSendDeactiveOnBgIdle() {
                                    return this.config.get(
                                      "online_configs.enable_deact_on_bg_idle",
                                    );
                                  }
                                  get enableSendDeactiveOnFgIdle() {
                                    return this.config.get(
                                      "online_configs.enable_deact_on_fg_idle",
                                    );
                                  }
                                  get enSendActiveToKeepAlive() {
                                    return this.config.get(
                                      "online_configs.send_active_to_keep_live",
                                    );
                                  }
                                  get enActiveUsingSocket() {
                                    return this.config.get(
                                      "online_configs.send_active_using_socket",
                                    );
                                  }
                                  get enableBackgroundTracking() {
                                    return this.config.get(
                                      "online_configs.enable_background_tracking",
                                    );
                                  }
                                  get enableFeature() {
                                    return this.config.get(
                                      "online_configs.enable_active_deactive_v2",
                                    );
                                  }
                                  get enableFullBackgroundTrack() {
                                    return !1;
                                  }
                                  onLogin() {
                                    this.sendActiveToServer(
                                      _c.ActiveBackground,
                                    );
                                  }
                                  startTrackIdle(e) {
                                    void 0 === e && (e = !0),
                                      this.enableBackgroundTracking
                                        ? this.logger.zsymb(
                                            0,
                                            13781,
                                            30001,
                                            "startTrackIdle",
                                          )
                                        : this.logger.zsymb(
                                            0,
                                            13781,
                                            3e4,
                                            "in startTrackIdle but flag off",
                                          );
                                  }
                                  stopTrackIdle() {
                                    this.logger.zsymb(
                                      0,
                                      13781,
                                      30002,
                                      "stopTrackIdle",
                                    );
                                  }
                                  startForegroundMode() {
                                    (this.status = Cc.Foreground),
                                      this.sendActiveToServer(
                                        _c.FirstActiveForeground,
                                      ),
                                      this.clearPingTimer(),
                                      this.createPingTimer(),
                                      this.enableFullBackgroundTrack ||
                                        this.stopTrackIdle();
                                  }
                                  keepForegroundMode() {
                                    this.sendActiveToServer(
                                      _c.KeepActiveForeground,
                                      { additionText: "[Send Msg] " },
                                    );
                                  }
                                  startBackgroundMode() {
                                    (this.status = Cc.BackgroundActive),
                                      this.clearPingTimer(),
                                      this.startTrackIdle();
                                  }
                                  activeInBackground(e) {
                                    const t = e
                                      ? _c.ActiveBackground
                                      : _c.KeepActiveBackground;
                                    this.pingTimer
                                      ? this.logger.zsymb(
                                          0,
                                          13781,
                                          30003,
                                          "user action bg but dont need ping because in ping interval",
                                        )
                                      : this.sendActiveToServer(t);
                                  }
                                  startDeactive(e) {
                                    let t = -1;
                                    switch (e) {
                                      case 0:
                                        t = Oc.Idle;
                                        break;
                                      case 1:
                                        t = Oc.ComputerLock;
                                        break;
                                      case 2:
                                        t = Oc.AppLock;
                                        break;
                                      case 3:
                                        t = Oc.LogOff;
                                    }
                                    this.clearPingTimer(),
                                      -1 !== t &&
                                        this.canSendDeactive(t) &&
                                        this.sendDeactiveToServer(t),
                                      this.status === Cc.Foreground &&
                                        t == Oc.Idle &&
                                        this.startTrackIdle(!1),
                                      (t != Oc.ComputerLock &&
                                        t != Oc.AppLock) ||
                                        this.stopTrackIdle(),
                                      (this.status = Cc.BackgroundDeactive);
                                  }
                                  onConfigUpdated() {
                                    (this.configChanged = !0),
                                      this.enableFeature ||
                                        this.clearPingTimer();
                                  }
                                  getStatus() {
                                    return this.status;
                                  }
                                  createPingTimer() {
                                    !this.pingTimer &&
                                      this.enableFeature &&
                                      (this.logger.zsymb(
                                        0,
                                        13781,
                                        30004,
                                        "createPingTimer",
                                      ),
                                      (this.configChanged = !1),
                                      (this.pingTimer = setInterval(() => {
                                        const e = Tc[this.status];
                                        e
                                          ? this.sendPingActive(e)
                                          : this.logger.zsymb(
                                              0,
                                              13781,
                                              30005,
                                              "call ping invalid state!",
                                            ),
                                          this.configChanged &&
                                            (this.clearPingTimer(),
                                            this.createPingTimer());
                                      }, this.pingInterval)));
                                  }
                                  clearPingTimer() {
                                    this.logger.zsymb(
                                      0,
                                      13781,
                                      30006,
                                      "clearPingTimer",
                                    ),
                                      clearInterval(this.pingTimer),
                                      (this.pingTimer = null);
                                  }
                                  async isUserHasAction(e) {
                                    return (
                                      this.focusManager.getAppIdleTime() < e
                                    );
                                  }
                                  canSendDeactive(e) {
                                    return (
                                      e !== Oc.Idle ||
                                      (this.status === Cc.Foreground &&
                                        this.enableSendDeactiveOnFgIdle) ||
                                      (this.status === Cc.BackgroundActive &&
                                        this.enableSendDeactiveOnBgIdle)
                                    );
                                  }
                                  async sendPingActive(e) {
                                    (await this.isUserHasAction(
                                      this.pingInterval,
                                    ))
                                      ? this.sendActiveToServer(e)
                                      : this.logger.zsymb(
                                          3,
                                          13781,
                                          30007,
                                          "call ping but discard, because the user don't have action!",
                                        );
                                  }
                                  sendActiveToServer(e, t) {
                                    void 0 === t && (t = { additionText: "" });
                                    const { additionText: s } = t;
                                    if (
                                      !this.enActiveUsingSocket ||
                                      Mc.default.getMsgSrcType() !==
                                        R.MsgSources.SOCKET
                                    )
                                      return (
                                        B.default.increaseFailed(
                                          88888,
                                          0,
                                          0,
                                          e,
                                          Date.now(),
                                        ),
                                        this.sendActiveViaHttp(e, s).then(
                                          (e) => (
                                            e && (this.countPingWssFail = 0), e
                                          ),
                                        )
                                      );
                                    let i = null;
                                    return (
                                      (i = this.enSendActiveToKeepAlive
                                        ? Ec.default.pingActiveViaKeepAlive(e)
                                        : Sc.a.instance().pingActive(e)),
                                      i
                                        .then(
                                          () => (
                                            (this.countPingWssFail = 0),
                                            this.logger.zsymb(
                                              3,
                                              13781,
                                              30008,
                                              "{}Call active app SUCCESS: socket - {}",
                                              s,
                                              e,
                                            ),
                                            !0
                                          ),
                                        )
                                        .catch(
                                          (t) => (
                                            this.logger.zsymb(
                                              21,
                                              13781,
                                              30009,
                                              "{}Call active fail: socket - {} - {}",
                                              s,
                                              e,
                                              JSON.stringify(t),
                                            ),
                                            this.countPingWssFail++,
                                            B.default.increaseFailed(
                                              88888,
                                              1,
                                              0,
                                              e,
                                              Date.now(),
                                            ),
                                            this.sendActiveViaHttp(e).then(
                                              (t) => (
                                                t &&
                                                  this.countPingWssFail >= 3 &&
                                                  ((this.countPingWssFail = 0),
                                                  B.default.increaseFailed(
                                                    88888,
                                                    2,
                                                    0,
                                                    e,
                                                    Date.now(),
                                                  )),
                                                t
                                              ),
                                            )
                                          ),
                                        )
                                    );
                                  }
                                  sendActiveViaHttp(e, t) {
                                    return (
                                      void 0 === t && (t = ""),
                                      new Promise((s) => {
                                        Ln.default
                                          .active(e)
                                          .then(wn.a)
                                          .then(() => {
                                            this.logger.zsymb(
                                              3,
                                              13781,
                                              30010,
                                              "{}Call active app SUCCESS: http - {}",
                                              t,
                                              e,
                                            ),
                                              s(!0);
                                          })
                                          .catch((i) => {
                                            this.logger.zsymb(
                                              21,
                                              13781,
                                              30011,
                                              "{}Call active fail: http - {} - {}",
                                              t,
                                              e,
                                              JSON.stringify(i),
                                            ),
                                              s(!1);
                                          });
                                      })
                                    );
                                  }
                                  sendDeactiveToServer(e) {
                                    return Ln.default
                                      .deactiveV2()
                                      .then(wn.a)
                                      .then(
                                        () => (
                                          this.logger.zsymb(
                                            3,
                                            13781,
                                            30012,
                                            "Call deactive app SUCCESS {}",
                                            e,
                                          ),
                                          !0
                                        ),
                                      )
                                      .catch(
                                        (e) => (
                                          this.logger.zsymb(
                                            21,
                                            13781,
                                            30013,
                                            "Call deactive fail: ",
                                            JSON.stringify(e),
                                          ),
                                          !1
                                        ),
                                      );
                                  }
                                }),
                              ) || yc),
                          ) || yc),
                      ) || yc),
                  ) || yc),
              ) || yc),
          ) || yc;
        i.ModuleContainer.registerSingleton(sc, lc),
          i.ModuleContainer.registerSingleton(Ql.c, tc),
          i.ModuleContainer.registerSingleton(ic, wc),
          i.ModuleContainer.resolve(Ql.c),
          i.ModuleContainer.resolveToken(oc),
          i.ModuleContainer.resolveToken(Ic);
        var Rc,
          Lc = s("Vp9m"),
          Dc = s("CPou"),
          Fc = s("MnxE"),
          Ac = s("NDwn");
        Object($t.b)(Si.b)(
          (Rc =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (Rc =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (Rc = class {
                    get Logger() {
                      return (
                        this._Logger ||
                          (this._Logger = i.ModuleContainer.resolve(
                            q.ZLoggerFactory,
                          ).createZLogger(
                            hs.ZLoggerNametags.onlyAdminChatSettings,
                            [this.name],
                          )),
                        this._Logger
                      );
                    }
                    constructor() {
                      (this.type = void 0),
                        (this.name = void 0),
                        (this.key = void 0),
                        (this.settings = new Map()),
                        (this.me = ""),
                        (this._Logger = void 0),
                        (this.name = Si.a),
                        (this.key = Si.a),
                        1 ===
                          bt.default.only_admin_chat_setting
                            .enable_only_admin_chat_setting &&
                          this._addPublicGroupSettingEventListener(),
                        this._addPublicFriendEventListener(),
                        Ac.a ||
                          Fc.a.signalCallback(this.onSettingsUpdate.bind(this));
                    }
                    _filterSettingKeys(e, t, s) {
                      let i = { lockSendMsg: !1 };
                      for (let n in e)
                        Object.keys(Dc.a).includes(n) &&
                          n === Dc.a.lockSendMsg &&
                          (i[Dc.a.lockSendMsg] =
                            !t && !s && Boolean(e[Dc.a.lockSendMsg]));
                      return i;
                    }
                    _onUpdateSettings(e, t, s, i) {
                      this.me || (this.me = Ye.default.getUidMe());
                      const n = this.me === t,
                        a = this._filterSettingKeys(i, n, s);
                      return (
                        this.settings.set(e, a), Object(nt.g)(this.name, e), a
                      );
                    }
                    showNoti(e) {
                      if ("TOAST" === e.type)
                        Lc.ZToastManagerHolder.getZToastManagerByWindowId(
                          e.windowId || Qt.c,
                        ).show(Object(f.a)({}, e.config));
                    }
                    verifySetting(e) {
                      const { convId: t, field: s, showNoti: i } = e,
                        n = this.settings.get(t);
                      return n
                        ? (i && i.triggerValue === n[s] && this.showNoti(i),
                          n && n[s])
                        : null;
                    }
                    onSettingsUpdate(e, t) {
                      let s = this.settings.get(e) || { lockSendMsg: !1 };
                      for (let i in t)
                        Object.keys(Dc.a).includes(i) && (s[i] = t[i]);
                      this.settings.set(e, s), Object(nt.g)(this.name, e);
                    }
                    _addPublicGroupSettingEventListener() {
                      ds.default.subscribeEventGroup(
                        R.EventGroup.CHANGE_OWNER,
                        (e) => {
                          const { groupId: t } = e;
                          t && this.onLoadGroupSetting(t);
                        },
                      ),
                        ds.default.subscribeEventGroup(
                          R.EventGroup.ADD_ADMIN,
                          (e) => {
                            const { groupId: t } = e;
                            t && this.onLoadGroupSetting(t);
                          },
                        ),
                        ds.default.subscribeEventGroup(
                          R.EventGroup.REMOVE_ADMIN,
                          (e) => {
                            const { groupId: t } = e;
                            t && this.onLoadGroupSetting(t);
                          },
                        ),
                        ds.default.subscribeEventGroup(
                          R.EventGroup.GROUP_INFO_CHANGED,
                          (e) => {
                            if (null != e && e.length)
                              for (let t = 0; t < e.length; t++)
                                this.onLoadGroupSetting(e[t]);
                          },
                        ),
                        Ks.default.subscribe(Qt.a.CHILD_WINDOW_ALIVE, (e) => {
                          null != e &&
                            e.windowId &&
                            this.onLoadSetting(e.windowId);
                        }),
                        Mt.default.subscribe((e, t) => {
                          switch (e) {
                            case St.FetchActions.UPDATE_GROUP_SETTING: {
                              var s, i;
                              const e =
                                null != t &&
                                null !== (s = t.data) &&
                                void 0 !== s &&
                                null !== (i = s.groupId) &&
                                void 0 !== i &&
                                i.startsWith("g")
                                  ? t.data.groupId
                                  : "g" + t.data.groupId;
                              e && this.onLoadGroupSetting(e);
                              break;
                            }
                          }
                        });
                    }
                    updateFriendBLockSetting(e, t) {
                      const s = t || Ye.default.isBlocked(e),
                        i =
                          1 ===
                          bt.default.block_msg_call_setting
                            .enable_block_msg_call_setting;
                      this.onSettingsUpdate(e, {
                        [Dc.a.lockSendMsg]: Boolean(s) && i,
                      });
                    }
                    _addPublicFriendEventListener() {
                      Ye.default.subscribeEventFriend(
                        R.EventFriend.BLOCK_FRIEND,
                        (e) => {
                          this.updateFriendBLockSetting(e.userId, !0);
                        },
                      ),
                        Ye.default.subscribeEventFriend(
                          R.EventFriend.UNBLOCK_FRIEND,
                          (e) => {
                            this.updateFriendBLockSetting(e.userId, !1);
                          },
                        ),
                        Mt.default.subscribe((e, t) => {
                          if (e === St.FriendsAction.FRIENDS_CHANGE_INFO)
                            t &&
                              Array.isArray(t) &&
                              t.forEach((e) => {
                                let { userId: t } = e;
                                this.updateFriendBLockSetting(t);
                              });
                        });
                    }
                    _checkGroupAdmin(e) {
                      var t;
                      return (
                        this.me || (this.me = Ye.default.getUidMe()),
                        (null == e || null === (t = e.topMember) || void 0 === t
                          ? void 0
                          : t.filter((e) => e.id === this.me && e.isAdmin)
                              .length) > 0
                      );
                    }
                    onLoadGroupSetting(e) {
                      return new Promise((t, s) => {
                        ds.default
                          .getFullInfoGroupById(e)
                          .then((s) => {
                            if (!s)
                              return (
                                this.Logger.zsymb(
                                  18,
                                  11223,
                                  3e4,
                                  "[GroupSetting]: Load GroupInfo from manager faily " +
                                    s +
                                    ", GroupId: " +
                                    e,
                                ),
                                t(null)
                              );
                            const i = s.setting,
                              n = s.creatorId,
                              a = this._checkGroupAdmin(s),
                              r = this._onUpdateSettings(e, n, a, i);
                            i &&
                              !i.hasOwnProperty("lockSendMsg") &&
                              this.Logger.zsymb(
                                18,
                                11223,
                                30001,
                                "[GroupSetting]: Dont have field lockSendMsg in setting data",
                              ),
                              t(r);
                          })
                          .catch((s) => {
                            this.Logger.zsymb(
                              18,
                              11223,
                              30002,
                              "[GroupSetting]: Have error in loadiing GroupInfo from manager: " +
                                JSON.stringify(s) +
                                ", GroupId: " +
                                e,
                            ),
                              t(null);
                          });
                      });
                    }
                    async onLoadSetting(e) {
                      return e.startsWith("g")
                        ? 1 !==
                          bt.default.only_admin_chat_setting
                            .enable_only_admin_chat_setting
                          ? null
                          : await this.onLoadGroupSetting(e)
                        : (this.updateFriendBLockSetting(e),
                          Ac.a ? null : void Fc.a.signalIfUnlock(e));
                    }
                    init(e) {
                      throw new Error("Method not  .");
                    }
                    getCurrentItem(e) {
                      return this.settings.get(e);
                    }
                    getItem(e, t) {
                      return this.settings.get(e.key);
                    }
                    getList(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    onGetItemFailure(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    onGetListFailure(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    getDefaultItem() {
                      throw new Error("Method not implemented.");
                    }
                    getDefaultList() {
                      throw new Error("Method not implemented.");
                    }
                  }),
                ) || Rc),
            ) || Rc),
        );
        const jc = Object(i.define)("media-primary-key-convertor");
        var Pc;
        let Nc =
          Object(i.injectable)()(
            (Pc = class {
              async toMediaPKFromMessagePK(e) {
                if (!e) return "";
                const t = await K.default.getInstance().Core.Message.get(e);
                return t && (t.cliMsgId || t.fromUid || t.toUid)
                  ? `${t.cliMsgId}_${t.fromUid}_${t.toUid}`
                  : "";
              }
              async toMessagePKFromMediaPK(e) {
                const [t, s, i] = this._getThreePartsFromMediaPK(e);
                if (!t || !s || !i) return "";
                const n = await this._getMessagesByCliMsgIdRange(t, i);
                let a = "";
                return (
                  n.forEach((e) => {
                    e.fromUid === s && e.toUid === i && (a = e.msgId);
                  }),
                  a
                );
              }
              _getMessagesByCliMsgIdRange(e, t) {
                const s = { from: e, to: e, excludeFrom: !1, excludeTo: !1 },
                  i = { index: "cliMsgIdIndex", partition: t };
                return K.default.getInstance().Core.Message.getAll(s, i);
              }
              _getThreePartsFromMediaPK(e) {
                if ("string" != typeof e || !e) return [];
                const [t, s, i] = e.split("_");
                return [t, s, i];
              }
            }),
          ) || Pc;
        i.ModuleContainer.register(jc, Nc);
        const Uc = Object(i.define)("utils-media-mapper"),
          kc = Object(i.define)("file-media-mapper"),
          Bc = Object(i.define)("image-media-mapper"),
          Gc = Object(i.define)("link-media-mapper");
        var xc;
        let zc =
          Object(i.injectable)()(
            (xc = class {
              toUtilsMediaDTOFromDomain(e) {
                return {
                  id: e.id,
                  convId: e.convId,
                  mediaType: e.mediaType,
                  senderIds: e.senderIds,
                  fileTypes: e.fileTypes,
                };
              }
            }),
          ) || xc;
        i.ModuleContainer.register(Uc, zc);
        var Vc,
          Hc = s("v6qY"),
          $c = s("IZCB");
        function Wc(e) {
          try {
            const t = JSON.parse(e),
              { fileExt: s, fType: i } = t;
            return "zip" === s && 2 === i;
          } catch (t) {
            return !1;
          }
        }
        function Kc(e) {
          try {
            if (Wc(e)) return "folder";
            const t = JSON.parse(e);
            if (!t) return "";
            const { fileExt: s } = t;
            return s.toLowerCase();
          } catch (t) {
            return "";
          }
        }
        function qc(e) {
          try {
            const t = JSON.parse(e);
            if (!t) return { width: null, height: null };
            const { width: s, height: i } = t;
            return { width: s, height: i };
          } catch (t) {
            return { width: null, height: null };
          }
        }
        let Zc =
          Object(i.injectable)()(
            (Vc = class {
              toDomainFromOldDomain(e, t) {
                if (
                  (void 0 === t && (t = `${Hc.c.UNKNOWN}${Hc.d.FROM_OLD_DB}`),
                  !e || !e.message)
                )
                  throw Error("This oldImageEntity isn't valid!");
                if (!(e.cliMsgId && e.fromUid && e.userId))
                  throw Error(
                    "This oldImageEntity doesn't have key_from_to valid!",
                  );
                const s =
                  "string" == typeof e.sendDttm
                    ? parseInt(e.sendDttm)
                    : e.sendDttm;
                return {
                  mediaId: `${e.cliMsgId}_${e.fromUid}_${e.userId}`,
                  convId: e.userId,
                  cliMsgId:
                    "number" == typeof e.cliMsgId
                      ? e.cliMsgId.toString()
                      : e.cliMsgId,
                  fromUid: e.fromUid,
                  content: {
                    title: e.message.title || null,
                    thumbUrl: e.message.thumbUrl || "",
                    hdUrl: e.message.hdUrl || "",
                    normalUrl: e.message.normalUrl || "",
                    oriUrl: e.message.oriUrl,
                    params: e.message.params,
                    duration: e.message.duration || null,
                  },
                  type: "number" == typeof e.subType ? e.subType : -1,
                  src: t,
                  sendDttm: s,
                  ttl: e.ttl,
                  localPath: e.localPath || "",
                  previewThumb: e.previewThumb || "",
                  modifiedTime: e.updateTime || s,
                  metadata: Object(f.a)(
                    Object(f.a)({}, qc(e.message.params)),
                    {},
                    { vOrient: $c.a.None },
                  ),
                };
              }
              toDomainFromDTO(e) {
                if (!e || !e.message) throw Error("This imageDTO isn't valid!");
                if (!(e.cliMsgId && e.fromUid && e.userId))
                  throw Error("This imageDTO doesn't have key_from_to valid!");
                const t =
                  "string" == typeof e.sendDttm
                    ? parseInt(e.sendDttm)
                    : e.sendDttm;
                return {
                  mediaId: e.mediaId,
                  convId: e.userId,
                  cliMsgId:
                    "number" == typeof e.cliMsgId
                      ? e.cliMsgId.toString()
                      : e.cliMsgId,
                  fromUid: e.fromUid,
                  content: {
                    title: e.message.title || null,
                    thumbUrl: e.message.thumbUrl || "",
                    hdUrl: e.message.hdUrl || "",
                    normalUrl: e.message.normalUrl || "",
                    oriUrl: e.message.oriUrl,
                    params: e.message.params,
                    duration: e.message.duration || null,
                  },
                  type: "number" == typeof e.subType ? e.subType : -1,
                  sendDttm: t,
                  src: e.src,
                  ttl: "number" == typeof e.ttl ? e.ttl : 0,
                  localPath: e.localPath || "",
                  previewThumb: e.previewThumb || "",
                  modifiedTime:
                    "number" == typeof e.updateTime ? e.updateTime : t,
                  metadata: Object(f.a)(
                    Object(f.a)({}, qc(e.message.params)),
                    {},
                    { vOrient: e.vOrient || $c.a.None },
                  ),
                };
              }
              toDomainFromTMessage(e, t, s) {
                if (
                  (void 0 === s && (s = `${Hc.c.UNKNOWN}${Hc.d.FROM_MSG}`),
                  !e || !e.message)
                )
                  throw Error("This messageEntity isn't valid!");
                if (!(e.cliMsgId && e.fromUid && e.toUid))
                  throw Error(
                    "This messageEntity doesn't have key_from_to valid!",
                  );
                const i =
                  "string" == typeof e.sendDttm
                    ? parseInt(e.sendDttm)
                    : e.sendDttm;
                return {
                  mediaId: `${e.cliMsgId}_${e.fromUid}_${e.toUid}`,
                  convId: e.toUid,
                  cliMsgId:
                    "number" == typeof e.cliMsgId
                      ? e.cliMsgId.toString()
                      : e.cliMsgId,
                  fromUid: e.fromUid,
                  content: {
                    title: e.message.title || null,
                    thumbUrl: e.message.thumbUrl || "",
                    hdUrl: e.message.hdUrl || "",
                    normalUrl: e.message.normalUrl || "",
                    oriUrl: e.message.oriUrl,
                    params: e.message.params,
                    duration: e.message.duration || null,
                  },
                  src: s,
                  type: t,
                  sendDttm: i,
                  ttl: e.ttl || 0,
                  localPath: e.localPath || "",
                  previewThumb: e.previewThumb || "",
                  modifiedTime: i,
                  metadata: Object(f.a)(
                    Object(f.a)({}, qc(e.message.params)),
                    {},
                    { vOrient: $c.a.None },
                  ),
                };
              }
              async toDTO(e) {
                if (!e || !e.mediaId)
                  throw Error("This imageEntity isn't valid!");
                const t = e.msgId
                  ? e.msgId
                  : await i.ModuleContainer.resolve(jc).toMessagePKFromMediaPK(
                      e.mediaId,
                    );
                return {
                  mediaId: e.mediaId,
                  msgId: t,
                  cliMsgId: e.cliMsgId,
                  fromUid: e.fromUid,
                  userId: e.convId,
                  message: {
                    title: e.content.title,
                    description: "",
                    childnumber: 0,
                    action: "",
                    params: e.content.params,
                    type: "",
                    thumbUrl: e.content.thumbUrl,
                    oriUrl: e.content.oriUrl,
                    hdUrl: e.content.hdUrl,
                    normalUrl: e.content.normalUrl,
                    duration: e.content.duration || null,
                    thumb: "",
                    href: "",
                  },
                  sendDttm: e.sendDttm,
                  src: e.src,
                  ttl: e.ttl,
                  type: "image",
                  subType: e.type,
                  id: 0,
                  localPath: e.localPath,
                  previewThumb: e.previewThumb,
                  updateTime: e.modifiedTime,
                  width: e.metadata.width,
                  height: e.metadata.height,
                  vOrient: e.metadata.vOrient,
                };
              }
              toMediaToCreateOrUpdateUtilsMediaDTOFromDomain(e) {
                return {
                  convId: e.convId,
                  fromUid: e.fromUid,
                  mediaType: "image",
                  content: { params: e.content.params },
                };
              }
              toOldEAttsFromNewEAtts(e) {
                if (!e || "object" != typeof e)
                  throw Error("newEAtts is undefined or not valid!");
                const t = {};
                var s, i;
                (e.hasOwnProperty("message") &&
                  "object" == typeof e.content &&
                  (t.message = {
                    title: e.content.title,
                    description: "",
                    childnumber: 0,
                    action: "",
                    params: e.content.params,
                    type: "",
                    thumbUrl: e.content.thumbUrl,
                    oriUrl: e.content.oriUrl,
                    hdUrl: e.content.hdUrl,
                    normalUrl: e.content.normalUrl,
                    duration: e.content.duration || null,
                    thumb: "",
                    href: "",
                  }),
                e.hasOwnProperty("subType") && (t.subType = e.type),
                e.hasOwnProperty("sendDttm") &&
                  (t.sendDttm =
                    "string" == typeof e.sendDttm ? +e.sendDttm : e.sendDttm),
                e.hasOwnProperty("ttl") && (t.ttl = e.ttl || 0),
                e.hasOwnProperty("localPath") &&
                  (t.localPath = e.localPath || ""),
                e.hasOwnProperty("previewThumb") &&
                  (t.previewThumb = e.previewThumb || ""),
                e.hasOwnProperty("updateTime") &&
                  (t.updateTime = e.modifiedTime || Date.now()),
                e.hasOwnProperty("metadata")) &&
                  ((t.width =
                    null === (s = e.metadata) || void 0 === s
                      ? void 0
                      : s.width),
                  (t.height =
                    null === (i = e.metadata) || void 0 === i
                      ? void 0
                      : i.height));
                return t;
              }
              toNewEAttsFromDTOAtts(e) {
                if (!e || "object" != typeof e)
                  throw Error("dtoAtts is undefined or not valid!");
                const t = {};
                return (
                  e.hasOwnProperty("message") &&
                    "object" == typeof e.message &&
                    (t.content = {
                      title: e.message.title || null,
                      thumbUrl: e.message.thumbUrl || "",
                      hdUrl: e.message.hdUrl || "",
                      normalUrl: e.message.normalUrl || "",
                      oriUrl: e.message.oriUrl,
                      params: e.message.params,
                      duration: e.message.duration || null,
                    }),
                  e.hasOwnProperty("subType") && (t.type = e.subType),
                  e.hasOwnProperty("sendDttm") &&
                    (t.sendDttm =
                      "string" == typeof e.sendDttm ? +e.sendDttm : e.sendDttm),
                  e.hasOwnProperty("ttl") && (t.ttl = e.ttl || 0),
                  e.hasOwnProperty("localPath") &&
                    (t.localPath = e.localPath || ""),
                  e.hasOwnProperty("previewThumb") &&
                    (t.previewThumb = e.previewThumb || ""),
                  e.hasOwnProperty("updateTime") &&
                    (t.modifiedTime = e.updateTime || Date.now()),
                  e.hasOwnProperty("width") &&
                    e.hasOwnProperty("height") &&
                    e.hasOwnProperty("vOrient") &&
                    (t.metadata = {
                      width: e.width,
                      height: e.height,
                      vOrient: e.vOrient || 0,
                    }),
                  t
                );
              }
            }),
          ) || Vc;
        var Jc;
        i.ModuleContainer.register(Bc, Zc);
        let Qc =
          Object(i.injectable)()(
            (Jc = class {
              toDomainFromOldDomain(e, t) {
                if (
                  (void 0 === t && (t = `${Hc.c.UNKNOWN}${Hc.d.FROM_OLD_DB}`),
                  !e || !e.message)
                )
                  throw Error("This oldFileEntity isn't valid!");
                if (!(e.cliMsgId && e.fromUid && e.userId))
                  throw Error(
                    "This oldFileEntity doesn't have key_from_to valid!",
                  );
                const s =
                  "string" == typeof e.sendDttm
                    ? parseInt(e.sendDttm)
                    : e.sendDttm;
                return {
                  mediaId: `${e.cliMsgId}_${e.fromUid}_${e.userId}`,
                  convId: e.userId,
                  cliMsgId:
                    "number" == typeof e.cliMsgId
                      ? e.cliMsgId.toString()
                      : e.cliMsgId,
                  fromUid: e.fromUid,
                  content: {
                    title: e.message.title,
                    href: e.message.href,
                    params: e.message.params,
                    thumb: e.message.thumb || "",
                  },
                  type: Wc(e.message.params) ? Hc.a.FOLDER : Hc.a.FILE,
                  src: t,
                  extType: Kc(e.message.params),
                  sendDttm: s,
                  ttl: "number" == typeof e.ttl ? e.ttl : 0,
                  modifiedTime: e.updateTime || s,
                  localPath: e.localPath || "",
                  folderPath: e.folderPath || "",
                  thumbMetadata: e.dimension
                    ? {
                        width: e.dimension.width,
                        height: e.dimension.height,
                        type: e.dimension.type,
                        orientation: Object(f.a)({}, e.dimension.orientation),
                        bigRes: e.dimension.bigRes,
                      }
                    : null,
                };
              }
              toDomainFromDTO(e) {
                if (!e || !e.message) throw Error("This fileDTO isn't valid!");
                if (!(e.cliMsgId && e.fromUid && e.userId))
                  throw Error("This fileDTO doesn't have key_from_to valid!");
                const t =
                  "string" == typeof e.sendDttm
                    ? parseInt(e.sendDttm)
                    : e.sendDttm;
                return {
                  mediaId: e.mediaId,
                  convId: e.userId,
                  cliMsgId:
                    "number" == typeof e.cliMsgId
                      ? e.cliMsgId.toString()
                      : e.cliMsgId,
                  fromUid: e.fromUid,
                  msgId: e.msgId,
                  content: {
                    title: e.message.title,
                    href: e.message.href,
                    params: e.message.params,
                    thumb: e.message.thumb || "",
                  },
                  type:
                    e.fileType || Wc(e.message.params)
                      ? Hc.a.FOLDER
                      : Hc.a.FILE,
                  src: e.src,
                  extType: e.extType || Kc(e.message.params),
                  sendDttm: t,
                  ttl: "number" == typeof e.ttl ? e.ttl : 0,
                  modifiedTime: e.updateTime || t,
                  localPath: e.localPath || "",
                  folderPath: e.folderPath || "",
                  thumbMetadata: e.dimension
                    ? {
                        width: e.dimension.width,
                        height: e.dimension.height,
                        type: e.dimension.type,
                        orientation: Object(f.a)({}, e.dimension.orientation),
                        bigRes: e.dimension.bigRes,
                      }
                    : null,
                };
              }
              async toDTO(e) {
                if (!e || !e.mediaId || !e.content)
                  throw Error("This fileEntity isn't valid!");
                const t = e.msgId
                  ? e.msgId
                  : await i.ModuleContainer.resolve(jc).toMessagePKFromMediaPK(
                      e.mediaId,
                    );
                return {
                  mediaId: e.mediaId,
                  msgId: t,
                  cliMsgId: e.cliMsgId,
                  fromUid: e.fromUid,
                  userId: e.convId,
                  message: {
                    title: e.content.title,
                    href: e.content.href,
                    params: e.content.params,
                    thumb: e.content.thumb,
                    childnumber: 0,
                    action: "",
                    description: "",
                    type: "",
                    thumbUrl: "",
                    oriUrl: "",
                  },
                  sendDttm: e.sendDttm,
                  ttl: e.ttl,
                  src: e.src,
                  type: "file",
                  fileType: e.type,
                  extType: e.extType,
                  id: 0,
                  updateTime: e.modifiedTime,
                  localPath: e.localPath || "",
                  folderPath: e.folderPath || "",
                  downloadError: !1,
                  dimension:
                    "object" == typeof e.thumbMetadata ? e.thumbMetadata : null,
                  previewThumb: "",
                };
              }
              toDomainFromMessage(e, t) {
                if (
                  (void 0 === t && (t = `${Hc.c.UNKNOWN}${Hc.d.FROM_MSG}`),
                  !e || !e.msgId || !e.message)
                )
                  throw Error("This messageEntity isn't valid!");
                if (!(e.cliMsgId && e.fromUid && e.toUid))
                  throw Error(
                    "This messageEntity doesn't have key_from_to valid!",
                  );
                const s =
                  "string" == typeof e.sendDttm
                    ? parseInt(e.sendDttm)
                    : e.sendDttm;
                return {
                  mediaId: `${e.cliMsgId}_${e.fromUid}_${e.toUid}`,
                  convId: e.toUid,
                  cliMsgId:
                    "number" == typeof e.cliMsgId
                      ? e.cliMsgId.toString()
                      : e.cliMsgId,
                  fromUid: e.fromUid,
                  content: {
                    title: e.message.title,
                    href: e.message.href,
                    params: e.message.params,
                    thumb: e.message.thumb || "",
                  },
                  type: Wc(e.message.params) ? Hc.a.FOLDER : Hc.a.FILE,
                  src: t,
                  extType: Kc(e.message.params),
                  sendDttm: s,
                  ttl: e.ttl || 0,
                  modifiedTime: s,
                  localPath: e.localPath || "",
                  folderPath: e.folderPath || "",
                  thumbMetadata: null,
                };
              }
              toMediaToCreateOrUpdateUtilsMediaDTOFromDomain(e) {
                return {
                  convId: e.convId,
                  fromUid: e.fromUid,
                  mediaType: "file",
                  content: { params: e.content.params },
                };
              }
              toOldEAttsFromNewEAtts(e) {
                if (!e || "object" != typeof e)
                  throw Error("newEAtts isn't valid!");
                const t = {};
                return (
                  e.hasOwnProperty("message") &&
                    "object" == typeof e.content &&
                    (t.message = {
                      title: e.content.title,
                      href: e.content.href,
                      params: e.content.params,
                      thumb: e.content.thumb,
                      childnumber: 0,
                      action: "",
                      description: "",
                      type: "",
                      thumbUrl: "",
                      oriUrl: "",
                    }),
                  e.hasOwnProperty("sendDttm") && (t.sendDttm = e.sendDttm),
                  e.hasOwnProperty("ttl") && (t.ttl = e.ttl || 0),
                  e.hasOwnProperty("localPath") &&
                    (t.localPath = e.localPath || ""),
                  e.hasOwnProperty("folderPath") &&
                    (t.folderPath = e.folderPath || ""),
                  e.hasOwnProperty("updateTime") &&
                    (t.updateTime = e.modifiedTime || Date.now()),
                  e.hasOwnProperty("dimension") &&
                    (t.dimension = e.thumbMetadata
                      ? {
                          width: e.thumbMetadata.width,
                          height: e.thumbMetadata.height,
                          type: e.thumbMetadata.type,
                          orientation: e.thumbMetadata.orientation,
                          bigRes: e.thumbMetadata.bigRes,
                        }
                      : null),
                  t
                );
              }
              toNewEAttsFromDTOAtts(e) {
                if (!e || "object" != typeof e)
                  throw Error("dtoAtts isn't valid!");
                const t = {};
                return (
                  e.hasOwnProperty("message") &&
                    "object" == typeof e.message &&
                    (t.content = {
                      title: e.message.title,
                      href: e.message.href,
                      params: e.message.params,
                      thumb: e.message.thumb || "",
                    }),
                  e.hasOwnProperty("fileType") && (t.type = e.fileType),
                  e.hasOwnProperty("extType") && (t.extType = e.extType || ""),
                  e.hasOwnProperty("sendDttm") &&
                    (t.sendDttm =
                      "string" == typeof e.sendDttm ? +e.sendDttm : e.sendDttm),
                  e.hasOwnProperty("ttl") && (t.ttl = e.ttl || 0),
                  e.hasOwnProperty("localPath") &&
                    (t.localPath = e.localPath || ""),
                  e.hasOwnProperty("folderPath") &&
                    (t.folderPath = e.folderPath || ""),
                  e.hasOwnProperty("updateTime") &&
                    (t.modifiedTime = e.updateTime || Date.now()),
                  e.hasOwnProperty("dimension") &&
                    (t.thumbMetadata = e.dimension
                      ? {
                          width: e.dimension.width,
                          height: e.dimension.height,
                          type: e.dimension.type,
                          orientation: e.dimension.orientation,
                          bigRes: e.dimension.bigRes,
                        }
                      : null),
                  t
                );
              }
            }),
          ) || Jc;
        var Yc;
        i.ModuleContainer.register(kc, Qc);
        let Xc =
          Object(i.injectable)()(
            (Yc = class {
              toDomainFromOldDomain(e, t) {
                if (
                  (void 0 === t && (t = `${Hc.c.UNKNOWN}${Hc.d.FROM_OLD_DB}`),
                  !e || !e.message)
                )
                  throw Error("This oldLinkEntity isn't valid!");
                if (!(e.cliMsgId && e.fromUid && e.userId))
                  throw Error(
                    "This oldLinkEntity doesn't have key_from_to valid!",
                  );
                const s =
                  "string" == typeof e.sendDttm
                    ? parseInt(e.sendDttm)
                    : e.sendDttm;
                return {
                  mediaId: `${e.cliMsgId}_${e.fromUid}_${e.userId}`,
                  convId: e.userId,
                  cliMsgId:
                    "number" == typeof e.cliMsgId
                      ? e.cliMsgId.toString()
                      : e.cliMsgId,
                  fromUid: e.fromUid,
                  content: {
                    title:
                      "object" == typeof e.message.title
                        ? e.message.title.title || ""
                        : e.message.title,
                    params: e.message.params || "",
                    href: e.message.href || "",
                    thumb: e.message.thumb || "",
                    description: e.message.description || "",
                    type: e.message.type || "",
                  },
                  type: -1,
                  src: t,
                  sendDttm: s,
                  ttl: e.ttl,
                  modifiedTime: e.updateTime || s,
                  parsedInfo: null,
                };
              }
              toDomainFromDTO(e) {
                if (!e || !e.message) throw Error("This linkDTO isn't valid!");
                if (!(e.cliMsgId && e.fromUid && e.userId))
                  throw Error("This linkDTO doesn't have key_from_to valid!");
                const t =
                  "string" == typeof e.sendDttm
                    ? parseInt(e.sendDttm)
                    : e.sendDttm;
                return {
                  mediaId: e.mediaId,
                  convId: e.userId,
                  cliMsgId:
                    "number" == typeof e.cliMsgId
                      ? e.cliMsgId.toString()
                      : e.cliMsgId,
                  fromUid: e.fromUid,
                  content: {
                    title:
                      "object" == typeof e.message.title
                        ? e.message.title.title
                        : e.message.title || "",
                    params: e.message.params || "",
                    href: e.message.href || "",
                    thumb: e.message.thumb || "",
                    description: e.message.description || "",
                    type: e.message.type,
                  },
                  src: e.src,
                  type: "number" == typeof e.linkType ? e.linkType : -1,
                  sendDttm: t,
                  ttl: "number" == typeof e.ttl ? e.ttl : 0,
                  modifiedTime: e.updateTime || t,
                  parsedInfo: null,
                };
              }
              async toDTO(e) {
                if (!e || !e.mediaId)
                  throw Error("This linkEntity isn't valid!");
                const t = e.msgId
                  ? e.msgId
                  : await i.ModuleContainer.resolve(jc).toMessagePKFromMediaPK(
                      e.mediaId,
                    );
                return {
                  mediaId: e.mediaId,
                  msgId: t,
                  cliMsgId: parseInt(e.cliMsgId),
                  fromUid: e.fromUid,
                  userId: e.convId,
                  message: {
                    title: e.content.title,
                    params: e.content.params,
                    href: e.content.href,
                    thumb: e.content.thumb,
                    description: e.content.description,
                    type: e.content.type,
                    action: "",
                    childnumber: 0,
                    oriUrl: "",
                    thumbUrl: "",
                  },
                  sendDttm: e.sendDttm,
                  type: "link",
                  ttl: e.ttl,
                  src: e.src,
                  linkType: e.type,
                  id: 0,
                  updateTime: e.modifiedTime,
                  previewThumb: "",
                  parsedInfo:
                    "object" == typeof e.parsedInfo
                      ? Object(f.a)({}, e.parsedInfo)
                      : null,
                };
              }
              toDomainFromMessage(e, t) {
                if (
                  (void 0 === t && (t = `${Hc.c.UNKNOWN}${Hc.d.FROM_MSG}`), !e)
                )
                  throw Error("This messageEntity isn't valid!");
                if (!(e.cliMsgId && e.fromUid && e.toUid))
                  throw Error(
                    "This messageEntity doesn't have key_from_to valid!",
                  );
                const s =
                  "string" == typeof e.sendDttm
                    ? parseInt(e.sendDttm)
                    : e.sendDttm;
                return {
                  mediaId: `${e.cliMsgId}_${e.fromUid}_${e.toUid}`,
                  convId: e.toUid,
                  cliMsgId:
                    "number" == typeof e.cliMsgId
                      ? e.cliMsgId.toString()
                      : e.cliMsgId,
                  fromUid: e.fromUid,
                  content: {
                    title:
                      "object" === e.message.title
                        ? e.message.title.title
                        : e.message.title || "",
                    params: e.message.params || "",
                    href: e.message.href || "",
                    thumb: e.message.thumb || "",
                    description: e.message.description || "",
                    type: e.message.type,
                  },
                  type: -1,
                  src: t,
                  sendDttm: s,
                  ttl: e.ttl || 0,
                  modifiedTime: s,
                  parsedInfo: null,
                };
              }
              toMediaToCreateOrUpdateUtilsMediaDTOFromDomain(e) {
                return {
                  convId: e.convId,
                  fromUid: e.fromUid,
                  mediaType: "link",
                  content: { params: e.content.params },
                };
              }
              toOldEAttsFromNewEAtts(e) {
                if (!e || "object" != typeof e)
                  throw Error("newEAtts isn't valid!");
                const t = {};
                return (
                  e.hasOwnProperty("content") &&
                    "object" == typeof e.content &&
                    (t.message = {
                      title: e.content.title,
                      params: e.content.params,
                      href: e.content.href,
                      thumb: e.content.thumb,
                      description: e.content.description,
                      type: e.content.type,
                      action: "",
                      childnumber: 0,
                      oriUrl: "",
                      thumbUrl: "",
                    }),
                  e.hasOwnProperty("sendDttm") && (t.sendDttm = e.sendDttm),
                  e.hasOwnProperty("ttl") && (t.ttl = e.ttl || 0),
                  e.hasOwnProperty("updateTime") &&
                    (t.updateTime = e.modifiedTime || Date.now()),
                  t
                );
              }
              toNewEAttsFromDTOAtts(e) {
                if (!e || "object" != typeof e)
                  throw Error("dtoAtts isn't valid!");
                const t = {};
                var s;
                e.hasOwnProperty("message") &&
                  "object" == typeof e.message &&
                  (t.content = {
                    title:
                      "object" == typeof e.message.title
                        ? (null === (s = e.message.title) || void 0 === s
                            ? void 0
                            : s.title) || ""
                        : e.message.title || "",
                    params: e.message.params || "",
                    href: e.message.href || "",
                    thumb: e.message.thumb || "",
                    description: e.message.description || "",
                    type: e.message.type || "",
                  });
                return (
                  e.hasOwnProperty("sendDttm") &&
                    (t.sendDttm =
                      "string" == typeof e.sendDttm ? +e.sendDttm : e.sendDttm),
                  e.hasOwnProperty("ttl") && (t.ttl = e.ttl || 0),
                  e.hasOwnProperty("linkType") && (t.type = e.linkType),
                  e.hasOwnProperty("updateTime") &&
                    (t.modifiedTime = e.updateTime || Date.now()),
                  e.hasOwnProperty("parsedInfo") &&
                    (t.parsedInfo = e.parsedInfo
                      ? {
                          protocol: e.parsedInfo.protocol || "",
                          host: e.parsedInfo.domain || "",
                        }
                      : null),
                  t
                );
              }
            }),
          ) || Yc;
        i.ModuleContainer.register(Gc, Xc);
        var eh = s("GbHB");
        let th, sh, ih;
        !(function (e) {
          (e[(e.OLD = 0)] = "OLD"),
            (e[(e.NEW = 1)] = "NEW"),
            (e[(e.UNKNOWN = 2)] = "UNKNOWN");
        })(th || (th = {})),
          (function (e) {
            (e[(e.OLD = 0)] = "OLD"),
              (e[(e.NEW = 1)] = "NEW"),
              (e[(e.UNKNOWN = 2)] = "UNKNOWN");
          })(sh || (sh = {})),
          (function (e) {
            (e[(e.OLD = 0)] = "OLD"),
              (e[(e.NEW = 1)] = "NEW"),
              (e[(e.UNKNOWN = 2)] = "UNKNOWN");
          })(ih || (ih = {}));
        const nh = "DONE",
          ah = "NOT_DONE",
          rh = "UNKNOWN",
          oh = "GET_FROM_OLD_DB",
          dh = "ADD_TO_NEW_DB",
          lh = "DELETE_FROM_OLD_DB",
          ch = "DONE",
          hh = "FAILED",
          uh = "NEW",
          gh = "RUNNING",
          mh = "FAILED",
          ph = "persisted_job_desc_summaries",
          fh = "migration_state";
        class vh {
          constructor(e, t, s, i, n, a) {
            (this._dbInstance = void 0),
              (this._mediaMigrationManager = void 0),
              (this._dalInstance = K.default.getInstance()),
              (this.dbTable = void 0),
              (this.logger = void 0),
              (this.mediaType = void 0),
              (this.dbTable = this._dalInstance[e][t]),
              (this._dbInstance = this._dalInstance[e]),
              (this.mediaType = s),
              (this._mediaMigrationManager = n),
              (this.logger = a.createZLogger(`${e}-${t}-repository`, [i]));
          }
          async insert(e, t) {
            if (!e) throw Error("[insert]: item is undefined!");
            if (!e.cliMsgId || !e.fromUid || !e.convId)
              throw Error(
                `[insert]: item doesn't have valid key_from_to: ${e.cliMsgId}_${e.fromUid}_${e.convId}`,
              );
            return (
              (e.mediaId = `${e.cliMsgId}_${e.fromUid}_${e.convId}`),
              !!(await this.dbTable.insert(e, t))
            );
          }
          insertMulti(e, t) {
            if (!e || !e.length)
              throw Error("[insertMulti]: items is undefined or empty!");
            const s = [];
            return (
              e.forEach((e) => {
                e.cliMsgId && e.fromUid && e.convId
                  ? ((e.mediaId = `${e.cliMsgId}_${e.fromUid}_${e.convId}`),
                    s.push(e))
                  : this.logger.zsymb(
                      21,
                      11049,
                      3e4,
                      "[insertMulti]: media doesn't have valid key_from_to: {}_{}_{}",
                      e.cliMsgId,
                      e.fromUid,
                      e.convId,
                    );
              }),
              this.dbTable.insertMulti(s, t)
            );
          }
          async update(e, t) {
            if (!vh.isNewMediaIdFormat(e))
              throw Error(
                "[update]: mediaId doesn't have new media id format!",
              );
            return !!(await this.dbTable.update(e, t));
          }
          async updateMedia(e, t, s) {
            if ((void 0 === s && (s = th.UNKNOWN), !e))
              throw Error("[updateMedia]: mediaIdObj is undefined!");
            const { newId: i, oldId: n } = e;
            if ((s === th.NEW || (await this._isMigrationDone())) && i)
              return !!(await this.dbTable.update(i, t));
            if (s === th.OLD && n) {
              let e;
              if (t) {
                const s = this.getMediaMapper().toOldEAttsFromNewEAtts(
                  t.value || {},
                );
                return (
                  (e = Object(f.a)(
                    Object(f.a)({}, t),
                    {},
                    { attributes: Object.keys(s), value: s },
                  )),
                  !!(await this.getOldDBTable().update(n, e))
                );
              }
              throw Error("options is undefined!");
            }
            try {
              if (i) {
                if (await this.dbTable.get(i))
                  return !!(await this.dbTable.update(i, t));
              }
              if (n) {
                let e;
                if (t) {
                  const s = this.getMediaMapper().toOldEAttsFromNewEAtts(
                    t.value || {},
                  );
                  return (
                    (e = Object(f.a)(
                      Object(f.a)({}, t),
                      {},
                      { attributes: Object.keys(s), value: s },
                    )),
                    !!(await this.getOldDBTable().update(n, e))
                  );
                }
                throw Error("options is undefined!");
              }
              throw Error(`${i} or ${n} isn't valid!`);
            } catch (a) {
              throw Error(`[updateMedia] - err: ${a.message}`);
            }
          }
          async updateMulti(e) {
            const t = await this.dbTable.updateMulti(e);
            return {
              success: t.success.map((e) => e.mediaId),
              fail: t.fail.map((e) => e.mediaId),
            };
          }
          async updateMultiMedias(e) {
            throw Error("This updateMultiMedias isn't implemented!");
          }
          delete(e, t) {
            if (!vh.isNewMediaIdFormat(e))
              throw Error(
                "[delete]: mediaId doesn't have new media id format!",
              );
            return this.dbTable.delete(e, t);
          }
          deleteMulti(e, t) {
            if (!e || !e.length)
              throw Error("[deleteMulti]: mediaIds is undefined or empty!");
            if (e.some((e) => !vh.isNewMediaIdFormat(e)))
              throw Error(
                "[deleteMulti]: mediaIds contains an id which doesn't have new media id format!",
              );
            return this.dbTable.deleteMulti(e, t);
          }
          async deleteMedia(e, t, s) {
            if ((void 0 === s && (s = ih.UNKNOWN), !e))
              throw Error("[deleteMedia]: mediaObj is undefined!");
            const { newId: i, oldId: n } = e;
            if ((s === ih.NEW || (await this._isMigrationDone())) && i)
              return this.dbTable.delete(i);
            if (s === ih.OLD && n) return this.getOldDBTable().delete(n, t);
            {
              const e = [];
              i && e.push(this.dbTable.delete(i, t)),
                n && e.push(this.getOldDBTable().delete(n, t));
              return (await Promise.allSettled(e)).every(
                (e) => "fulfilled" === e.status && e.value,
              );
            }
          }
          async deleteMultiMedias(e, t) {
            if (!e || !e.length)
              throw Error(
                "[deleteMultiMedias]: mediaIdObjs is undefined or empty!",
              );
            const s = { success: [], fail: [] },
              i = [];
            for (const { newId: n, oldId: a, deleteTo: r } of e) {
              const e =
                  (r === ih.NEW ? n : r === ih.OLD ? a : n || a || "") || "",
                o = async () => {
                  try {
                    (await this.deleteMedia({ newId: n, oldId: a }, t, r)) &&
                      s.success.push(e);
                  } catch (i) {
                    this.logger.zsymb(18, 11049, 30001, i), s.fail.push(e);
                  }
                };
              i.push(o);
            }
            return await Promise.allSettled(i.map((e) => e())), s;
          }
          async get(e, t) {
            if (!vh.isNewMediaIdFormat(e))
              throw Error("[get]: mediaId doesn't have new media id format!");
            return this.dbTable.get(e, t);
          }
          async getMulti(e, t) {
            const { newIdFormats: s, oldIdFormats: i } = e.reduce(
              (e, t) => (vh.isNewMediaIdFormat(t) && e.newIdFormats.push(t), e),
              { newIdFormats: [], oldIdFormats: [] },
            );
            let n = [];
            if (s.length) {
              const e = await this.dbTable.getMulti(s, t);
              e.length && n.push(...e);
            }
            return n;
          }
          async getMedia(e, t, s) {
            if ((void 0 === s && (s = sh.UNKNOWN), !e))
              throw Error("[getMedia]: mediaIdObj params is undefined!");
            const { newId: i, oldId: n } = e;
            if ((s === sh.NEW || (await this._isMigrationDone())) && i)
              return this.dbTable.get(i, t);
            if (s === sh.NEW && n) {
              const e = await this.getOldDBTable().get(n, t);
              if (e) return this.getMediaMapper().toDomainFromOldDomain(e);
            } else {
              if (i) {
                const e = await this.dbTable.get(i, t);
                if (e) return e;
              }
              if (n) {
                const e = await this.getOldDBTable().get(n, t);
                if (e) return this.getMediaMapper().toDomainFromOldDomain(e);
              }
            }
          }
          async getMultiMedias(e, t) {
            if (!e || !e.length)
              throw Error(
                "[getMultiMedias]: mediaIdObjs is undefined or empty!",
              );
            let s = [];
            const i = [];
            for (const { newId: n, oldId: a, getFrom: r } of e)
              i.push(
                this.getMedia(
                  { newId: n, oldId: a },
                  t,
                  "number" == typeof r ? r : sh.UNKNOWN,
                ),
              );
            return (
              (s = (await Promise.allSettled(i)).map((e) =>
                "fulfilled" === e.status ? e.value : void 0,
              )),
              s
            );
          }
          getAll(e, t) {
            if (!e) throw Error("[getAll]: keyRange is undefined!");
            return this.dbTable.getAll(e, t);
          }
          async getAllInOldDB(e, t) {
            if (await this._isMigrationDone()) return [];
            if (!e) throw Error("[getAllInOldDB]: keyRange is undefined!");
            const s = await this.getOldDBTable().getAll(e, t);
            return null != s && s.length
              ? s.map((e) => this.getMediaMapper().toDomainFromOldDomain(e))
              : [];
          }
          static isNewMediaIdFormat(e) {
            if (!e) return !1;
            return 3 === e.split("_").length;
          }
          static filterMedia(e, t) {
            if (
              !(
                t &&
                (t.member ||
                  (t.date && (t.date.start || t.date.end)) ||
                  t.name ||
                  t.ext)
              )
            )
              return !0;
            if (!t.member || (e.fromUid && e.fromUid === t.member)) {
              let i, n, a;
              if (t.name) {
                if (e.message.params && e.message.href)
                  try {
                    let t = JSON.parse(e.message.params);
                    (i = t.mediaTitle
                      ? Ct.default.simpleStripVietnamese(t.mediaTitle)
                      : Ct.default.simpleStripVietnamese(e.message.title)),
                      (n = t.src);
                  } catch (s) {
                    return Ct.default.logCoreError(s), !1;
                  }
                a = Ct.default.simpleStripVietnamese(t.name);
              }
              if (
                !t.name ||
                (a.length <= i.length && Ct.default.searchContent(i, a))
              ) {
                let i = !1;
                if (
                  (t.ext &&
                    (i = R.fileExt[t.ext].some((t) => {
                      if (!e.message.title) {
                        const t = eh.a.decrypt(e.message, Ee.default.UIN, !1);
                        try {
                          e.message = JSON.parse(t);
                        } catch (s) {
                          e.message = { title: "" };
                        }
                      }
                      return e.message.title.endsWith(t);
                    })),
                  !t.ext || i)
                )
                  return (
                    (null == t.date.start && null == t.date.end) ||
                    (e.sendDttm >= t.date.start ? e.sendDttm <= t.date.end : 0)
                  );
              }
            }
            return !1;
          }
          async isExistedMedia(e) {
            let t = !1;
            if (e) {
              const { newId: s, oldId: i } = e;
              s && (t = !!(await this.dbTable.get(s))),
                i && !t && (t = !!(await this.getOldDBTable().get(i)));
            }
            return t;
          }
          async getLastMediasOfConv(e, t, s) {
            if ((void 0 === s && (s = 100), !e || !t))
              throw Error(
                `[getLastMediasOfConv]: convId: ${e}, lastItemOptions:${JSON.stringify(t)} isn't valid!`,
              );
            const { sendDttm: i, cliMsgId: n, msgId: a } = t,
              r = await this.getLastMediasOfConvInNewDB(
                e,
                { sendDttm: i, cliMsgId: n },
                s,
              );
            return (
              r.length < s &&
                !(await this._isMigrationDone()) &&
                r.push(
                  ...(await this.getLastMediasOfConvInOldDB(
                    e,
                    { msgId: a },
                    s - r.length,
                  )),
                ),
              r
            );
          }
          async countMediaOfConv(e, t) {
            let s = 0;
            if (!(e && t && t.from && t.to))
              throw Error(
                `[countMediaOfConv]: convId: ${e}, options: ${JSON.stringify(t)} isn't valid!`,
              );
            const { from: i, to: n } = t;
            return (
              (s = await this.countMediaOfConvInNewDB(e, {
                from: { sendDttm: i.sendDttm, cliMsgId: i.cliMsgId },
                to: { sendDttm: n.sendDttm, cliMsgId: n.cliMsgId },
              })),
              (await this._isMigrationDone()) ||
                (s += await this.countMediaOfConvInOldDB(e, {
                  from: { msgId: i.msgId },
                  to: { msgId: n.msgId },
                })),
              s
            );
          }
          countMediaOfConvInNewDB(e, t) {
            const { from: s, to: i } = t,
              n = {
                from: [e, s.sendDttm, s.cliMsgId],
                to: [e, i.sendDttm, i.cliMsgId],
                excludeFrom: !1,
                excludeTo: !1,
              };
            return this.dbTable.count(n, { index: "convId_sendDttm_cliMsgId" });
          }
          async countMediaOfConvInOldDB(e, t) {
            if (await this._isMigrationDone()) return 0;
            const { from: s, to: i } = t,
              n = {
                from: [e, s.msgId.length, s.msgId],
                to: [e, i.msgId.length, i.msgId],
                excludeFrom: !1,
                excludeTo: !1,
              };
            return this.getOldDBTable().count(n, {
              index: "userId_sendDttm_msgId",
            });
          }
          async getMediasOfConv(e, t, s, i) {
            if (!e || !t || !s) return Promise.resolve([]);
            let n = [];
            if (
              (bt.default.load_media.optimize_mode &&
                (n = (await this._isMigrationDone())
                  ? await this.getMediasOfConvOptimizeMode(e, t, s, i)
                  : await this.getMediasOfConvOptimizeModeInMixedDB(
                      e,
                      t,
                      s,
                      i,
                    )),
              null != i && i.deletePointOfConv)
            ) {
              const {
                lastId: e,
                lastSendDttm: t,
                lastCliMsgId: s,
              } = i.deletePointOfConv;
              return n.filter(
                (i) =>
                  !(e && i.msgId && i.msgId <= e) &&
                  !(t && i.sendDttm <= t) &&
                  !(s && i.cliMsgId <= s),
              );
            }
            return n;
          }
          async getMediasOfConvOptimizeModeInMixedDB(e, t, s, i) {
            let n = !1,
              a = !1;
            i &&
              i.date &&
              (null !== i.date.start || null !== i.date.end) &&
              (n = !0);
            const r = [],
              { sendDttm: o, cliMsgId: d } =
                await this.getSendDttmOfLatestMediaInOldDB(e),
              { sendDttm: l, cliMsgId: c, msgId: h } = t,
              u = {
                from: [e, 0, ""],
                to: [e, l, c],
                excludeFrom: !0,
                excludeTo: !0,
              },
              g = {
                index: "convId_sendDttm_cliMsgId",
                limit: s,
                direction: Aa.CursorDirection.PREV,
                predicate: (e) => {
                  if (!e) return !1;
                  if (!Ct.default.mapHasItem(e.content)) return !1;
                  if (!pn.a.instance.filterDBMessage(e)) return !1;
                  let t = vh.filterMedia(
                    {
                      message: e.content,
                      fromUid: e.fromUid,
                      sendDttm: e.sendDttm,
                    },
                    i,
                  );
                  return (
                    0 === t && (a = !0),
                    !!t &&
                      ((e.sendDttm > o && e.cliMsgId > d) || (r.push(e), !1))
                  );
                },
                aborted: n ? () => a : void 0,
              };
            try {
              let t = await this.dbTable.getAll(u, g);
              if (t.length < s) {
                const n = await this.getMediasOfConvOptimizeModeInOldDB(
                    e,
                    { msgId: h },
                    s - t.length,
                    i,
                  ),
                  a = [];
                n.length > 0
                  ? r.length > 0
                    ? (n.forEach((e) => {
                        const t = r[0];
                        t &&
                        e.sendDttm <= t.sendDttm &&
                        e.cliMsgId <= t.cliMsgId
                          ? (a.push(t), r.shift())
                          : a.push(e);
                      }),
                      r.length > 0 && a.push(...r),
                      t.push(...a.slice(0, s - t.length)))
                    : t.push(...n)
                  : r.length > 0 && t.push(...r);
              }
              return t;
            } catch (m) {
              const t = [e, this.mediaType, s, l, c, !!i].join("_");
              throw (this.logger.zsymb(18, 11049, 30002, t, m), m);
            }
          }
          async getSendDttmOfLatestMediaInOldDB(e) {
            const t = {
                from: [e, 0, ""],
                to: [
                  e,
                  R.MessageConstants.MAX_SENDDTTM,
                  R.MessageConstants.MAX_MSG_ID,
                ],
                excludeFrom: !1,
                excludeTo: !1,
              },
              s = {
                index: "userId_sendDttm_msgId",
                limit: 1,
                direction: Aa.CursorDirection.PREV,
              },
              i = await this.getOldDBTable().getAll(t, s);
            if (!i || !i[0]) return { sendDttm: 0, cliMsgId: "0" };
            return {
              sendDttm:
                "string" == typeof i[0].sendDttm
                  ? parseInt(i[0].sendDttm)
                  : i[0].sendDttm,
              cliMsgId: "" + (i[0].cliMsgId || 0),
            };
          }
          async getMediasOfConvOptimizeMode(e, t, s, i) {
            if (!e || !t || !s)
              throw Error(
                `[getMediasOfConvOptimizeMode]: convId: ${e}, lastItemOptions: ${JSON.stringify(t)}, limit: ${s} isn't valid!`,
              );
            const { sendDttm: n, cliMsgId: a, msgId: r } = t,
              o = await this.getMediasOfConvOptimizeModeInNewDB(
                e,
                { sendDttm: n, cliMsgId: a },
                s,
                i,
              );
            return (
              o.length < s &&
                !(await this._isMigrationDone()) &&
                o.push(
                  ...(await this.getMediasOfConvOptimizeModeInOldDB(
                    e,
                    { msgId: r },
                    s - o.length,
                    i,
                  )),
                ),
              o
            );
          }
          getMediasOfConvOptimizeModeInNewDB(e, t, s, i) {
            let n = !1,
              a = !1;
            i &&
              i.date &&
              (null !== i.date.start || null !== i.date.end) &&
              (n = !0);
            const { sendDttm: r, cliMsgId: o } = t,
              d = {
                from: [e, 0, ""],
                to: [e, r, o],
                excludeFrom: !0,
                excludeTo: !0,
              },
              l = {
                index: "convId_sendDttm_cliMsgId",
                limit: s,
                direction: Aa.CursorDirection.PREV,
                predicate: (e) => {
                  if (!e) return !1;
                  if (!Ct.default.mapHasItem(e.content)) return !1;
                  if (!pn.a.instance.filterDBMessage(e)) return !1;
                  let t = vh.filterMedia(
                    {
                      message: e.content,
                      fromUid: e.fromUid,
                      sendDttm: e.sendDttm,
                    },
                    i,
                  );
                  return 0 === t && (a = !0), !!t;
                },
                aborted: n ? () => a : void 0,
              };
            try {
              return this.dbTable.getAll(d, l);
            } catch (c) {
              const t = [e, this.mediaType, s, r, o, !!i].join("_");
              throw (this.logger.zsymb(18, 11049, 30003, t, c), c);
            }
          }
          async getMediasOfConvOptimizeModeInOldDB(e, t, s, i) {
            if (await this._isMigrationDone()) return [];
            let n = !1,
              a = !1;
            i &&
              i.date &&
              (null != i.date.start || null != i.date.end) &&
              (n = !0);
            const { msgId: r } = t,
              o = {
                from: [e, 0, ""],
                to: [e, r.length, r],
                excludeFrom: !0,
                excludeTo: !0,
              },
              d = {
                index: "userId_sendDttm_msgId",
                limit: s,
                direction: Aa.CursorDirection.PREV,
                predicate: (e) => {
                  if (e) {
                    if (e.msgId && e.msgId.includes("_")) return !1;
                    if (!Ct.default.mapHasItem(e.message)) return !1;
                  }
                  if (!pn.a.instance.filterDBMessage(e)) return !1;
                  let t = vh.filterMedia(e, i);
                  return 0 === t && (a = !0), !!t;
                },
                aborted: n ? () => a : void 0,
              };
            try {
              const e = await this.getOldDBTable().getAll(o, d);
              return (await this.correctMediasInOldDB(e)).map((e) =>
                this.getMediaMapper().toDomainFromOldDomain(e),
              );
            } catch (l) {
              const t = [e, this.mediaType, s, r, !!i].join("_");
              throw (this.logger.zsymb(18, 11049, 30004, t, l), l);
            }
          }
          getLastMediasOfConvInNewDB(e, t, s) {
            const { sendDttm: i, cliMsgId: n } = t,
              a = {
                from: [e, 0, ""],
                to: [e, i, n],
                excludeFrom: !1,
                excludeTo: !1,
              },
              r = {
                index: "convId_sendDttm_cliMsgId",
                limit: s,
                direction: Aa.CursorDirection.PREV,
              };
            return this.dbTable.getAll(a, r);
          }
          async getLastMediasOfConvInOldDB(e, t, s) {
            if (await this._isMigrationDone()) return [];
            const { msgId: i } = t,
              n = {
                from: [e, 0, ""],
                to: [e, i.length, i],
                excludeFrom: !1,
                excludeTo: !1,
              },
              a = {
                index: "userId_sendDttm_msgId",
                limit: s,
                direction: Aa.CursorDirection.PREV,
              },
              r = await this.getOldDBTable().getAll(n, a);
            return r.length > 0
              ? r.map((e) =>
                  Object(f.a)(
                    Object(f.a)(
                      {},
                      this.getMediaMapper().toDomainFromOldDomain(e),
                    ),
                    {},
                    { msgId: e.msgId },
                  ),
                )
              : [];
          }
          correctMediasInOldDB(e, t) {
            return (
              void 0 === t && (t = { saveBack: !0 }),
              e && e.length
                ? new Promise((s) => {
                    let i = [],
                      n = {},
                      a = [];
                    if (
                      (e.forEach((e) => {
                        e &&
                          e.msgId &&
                          e.sendDttm &&
                          (e.type && e.cliMsgId
                            ? a.push(e)
                            : (i.push(e.msgId), (n[e.msgId] = e)));
                      }),
                      !i.length)
                    )
                      return s(a);
                    {
                      let e = "";
                      const r = (t, s) => {
                        switch (s.msgType) {
                          case R.MSG_PHOTO:
                          case R.MSG_PHOTO_2:
                            (e = "image"), (t.subType = R.MSG_SUBTYPE_PHOTO);
                            break;
                          case R.MSG_VIDEO:
                            (e = "image"),
                              (t.subType = R.MSG_SUBTYPE_MEDIA_VIDEO);
                            break;
                          case R.MSG_FILE:
                            e = "file";
                            break;
                          case R.MSG_CONTACT:
                            "object" == typeof s.message &&
                              "recommened.link" === s.message.action &&
                              (e = "link");
                        }
                        return (t.cliMsgId = s.cliMsgId), (t.type = e), t;
                      };
                      Ee.default
                        .getMessagesByIdsInQueue(i)
                        .then((e) => {
                          const i = [];
                          if (e) for (let t in e) e[t] && i.push(r(n[t], e[t]));
                          let o = a.concat(i);
                          return (
                            o.sort(
                              (e, t) =>
                                parseInt(t.sendDttm) - parseInt(e.sendDttm),
                            ),
                            i.length &&
                              t.saveBack &&
                              this.deleteAndInsertInOldDB(i),
                            s(o)
                          );
                        })
                        .catch((e) => s(a));
                    }
                  })
                : Promise.resolve([])
            );
          }
          async deleteAndInsertInOldDB(e) {
            if (!e || !e.length)
              throw Error(
                `[deleteAndInsertInOldDB]: oldItems: ${JSON.stringify(e)} isn't valid!`,
              );
            return this.getOldDBTable().insertMulti(e, { replace: !0 });
          }
          async _isMigrationDone() {
            return (
              (await this._mediaMigrationManager.getMediaMigrationState())
                .stateName === nh
            );
          }
        }
        class bh extends vh {
          constructor(e, t, s, i, n, a) {
            super(e, t, s, i, n, a);
          }
          async getImageMessagesForPhotoViewer(e, t, s, i, n, a) {
            const r = await this.getMsgIdsOfImageMediaForPhotoViewer(
              e,
              s,
              t,
              i,
              n,
              a,
            );
            if (null == r || !r.length) return [];
            const o = await Promise.all(
                r.map((e) => this.getMediaMapper().toDTO(e)),
              ),
              d = [];
            let l = [];
            for (const c of o)
              d.push(
                K.default
                  .getInstance()
                  .Core.Message.get(c.msgId, { partition: e })
                  .then((e) => {
                    e
                      ? l.push(Object(f.a)(Object(f.a)({}, c), e))
                      : c.message && l.push(c);
                  }),
              );
            return (
              await Promise.all(d),
              l.reverse(),
              Ee.default._fillExifBeforeShow(l),
              l
            );
          }
          async getMsgIdsOfImageMediaForPhotoViewer(e, t, s, i, n, a) {
            const { cliMsgId: r, sendDttm: o, msgId: d } = t,
              l = !i && !n;
            let c = !1;
            const h = () => c,
              u = (e) => {
                if (
                  !(
                    a &&
                    (a.member ||
                      (a.date && (a.date.start || a.date.end)) ||
                      a.name ||
                      a.ext)
                  )
                )
                  return !0;
                if (!a.member || (e.fromUid && e.fromUid === a.member)) {
                  let s, i, n;
                  if (a.name) {
                    if (e.message.params && e.message.href)
                      try {
                        let t = JSON.parse(e.message.params);
                        (s = t.mediaTitle
                          ? Ct.default.simpleStripVietnamese(t.mediaTitle)
                          : Ct.default.simpleStripVietnamese(e.message.title)),
                          (i = t.src);
                      } catch (t) {
                        return this.logger.zsymb(18, 11029, 3e4, t), !1;
                      }
                    n = Ct.default.simpleStripVietnamese(a.name);
                  }
                  if (
                    !a.name ||
                    Ct.default.searchContent(s, n) ||
                    Ct.default.searchContent(i, n)
                  ) {
                    let t = !1;
                    if (
                      (a.ext &&
                        (t = R.fileExt[a.ext].some((t) =>
                          e.message.title.endsWith(t),
                        )),
                      !a.ext || t)
                    )
                      return (
                        !a.date.start ||
                        !a.date.end ||
                        (a.date.end < e.sendDttm
                          ? e.sendDttm < a.date.start + 864e5
                          : ((c = !0), !1))
                      );
                  }
                }
                return !1;
              };
            let g = [];
            if (i) {
              const t = async () => {
                let t = [];
                if (!(await this._isMigrationDone())) {
                  const i = {
                      from: [e, d.length, d],
                      to: [
                        e,
                        R.MessageConstants.MAX_MSG_ID.length,
                        R.MessageConstants.MAX_MSG_ID,
                      ],
                      excludeFrom: !l,
                      excludeTo: !l,
                    },
                    n = {
                      limit: s,
                      index: "userId_sendDttm_msgId",
                      direction: Aa.CursorDirection.NEXT,
                      predicate: (e) =>
                        u({
                          fromUid: e.fromUid,
                          message: e.message,
                          sendDttm:
                            "string" == typeof e.sendDttm
                              ? parseInt(e.sendDttm)
                              : e.sendDttm,
                        }),
                      aborted: h,
                    };
                  t = await this.getAllInOldDB(i, n);
                }
                if (t.length < s) {
                  const i = {
                      from: [e, o, r],
                      to: [
                        e,
                        parseInt(R.MessageConstants.MAX_SENDDTTM),
                        R.MessageConstants.MAX_MSG_ID,
                      ],
                      excludeFrom: !l,
                      excludeTo: !l,
                    },
                    n = {
                      limit: s - t.length,
                      index: "convId_sendDttm_cliMsgId",
                      direction: Aa.CursorDirection.NEXT,
                      predicate: (e) =>
                        u({
                          fromUid: e.fromUid,
                          message: e.content,
                          sendDttm: e.sendDttm,
                        }),
                      aborted: h,
                    };
                  t.push(...(await this.getAll(i, n)));
                }
                return t;
              };
              g.push(t());
            }
            if (n) {
              const t = async () => {
                let t = [];
                const i = {
                    from: [e, 0, ""],
                    to: [e, o, r],
                    excludeFrom: !l,
                    excludeTo: !l,
                  },
                  n = {
                    limit: s,
                    index: "convId_sendDttm_cliMsgId",
                    direction: Aa.CursorDirection.PREV,
                    predicate: (e) =>
                      u({
                        fromUid: e.fromUid,
                        message: e.content,
                        sendDttm: e.sendDttm,
                      }),
                    aborted: h,
                  };
                if (
                  ((t = await this.getAll(i, n)),
                  t.length < s && !(await this._isMigrationDone()))
                ) {
                  const i = {
                      from: [e, 0, ""],
                      to: [e, d.length, d],
                      excludeFrom: !l,
                      excludeTo: !l,
                    },
                    n = {
                      limit: t ? s - t.length : s,
                      index: "userId_sendDttm_msgId",
                      direction: Aa.CursorDirection.PREV,
                      predicate: (e) =>
                        u({
                          fromUid: e.fromUid,
                          message: e.message,
                          sendDttm:
                            "string" == typeof e.sendDttm
                              ? parseInt(e.sendDttm)
                              : e.sendDttm,
                        }),
                      aborted: h,
                    };
                  t.push(...(await this.getAllInOldDB(i, n)));
                }
                return t;
              };
              g.push(t());
            }
            try {
              const e = await Promise.all(g);
              if (2 === e.length) {
                let t = e[0].reverse();
                return t.pop(), (t = t.concat(e[1])), t;
              }
              return n ? e[0] : e[0].reverse();
            } catch (m) {
              return this.logger.zsymb(18, 11029, 30001, m), [];
            }
          }
        }
        const Ih = Object(i.define)("image-media-repository");
        var yh,
          _h = s("H8Z7");
        Object(i.injectable)()(
          (yh =
            Object(i.singleton)(Ih)(
              (yh =
                (function (e, t) {
                  return Object(i.inject)(Bc)(e, void 0, 0);
                })(
                  (yh =
                    (function (e, t) {
                      return Object(i.inject)(_h.c)(e, void 0, 1);
                    })(
                      (yh =
                        (function (e, t) {
                          return Object(i.inject)(q.ZLoggerFactory)(
                            e,
                            void 0,
                            2,
                          );
                        })(
                          (yh =
                            Reflect.metadata(
                              "design:type",
                              Function,
                            )(
                              (yh =
                                Reflect.metadata("design:paramtypes", [
                                  Object,
                                  void 0 === _h.IMediaMigrationManager
                                    ? Object
                                    : _h.IMediaMigrationManager,
                                  void 0 === q.ZLoggerFactory
                                    ? Object
                                    : q.ZLoggerFactory,
                                ])(
                                  (yh = class extends bh {
                                    constructor(e, t, s) {
                                      super(
                                        "Media",
                                        "Image",
                                        "image",
                                        "crud-image-media",
                                        t,
                                        s,
                                      ),
                                        (this.imageMediaMapper = void 0),
                                        (this.oldDBTable = void 0),
                                        (this.imageMediaMapper = e),
                                        (this.oldDBTable =
                                          this._dalInstance.Core.Image);
                                    }
                                    getOldDBTable() {
                                      return (
                                        this.oldDBTable ||
                                          (this.oldDBTable =
                                            K.default.getInstance().Core.Image),
                                        this.oldDBTable
                                      );
                                    }
                                    getMediaMapper() {
                                      return this.imageMediaMapper;
                                    }
                                    deleteMatch(e, t) {
                                      throw Error(
                                        "Currently, this method isn't supported!",
                                      );
                                    }
                                    getAllKey(e, t) {
                                      throw Error(
                                        "Currently, this method isn't supported!",
                                      );
                                    }
                                    put(e, t) {
                                      throw Error(
                                        "Currently, this method isn't supported!",
                                      );
                                    }
                                    runTransaction(e, t, s) {
                                      throw Error(
                                        "Currently, this method isn't supported!",
                                      );
                                    }
                                  }),
                                ) || yh),
                            ) || yh),
                        ) || yh),
                    ) || yh),
                ) || yh),
            ) || yh),
        );
        class Oh extends vh {
          constructor(e, t, s, i, n, a) {
            super(e, t, s, i, n, a);
          }
          async getLastestAddedFiles(e, t) {
            if (!e || "number" != typeof t)
              throw Error(
                `[getLastestAddedFiles]: ${JSON.stringify(e)} or ${t} isn't valid!`,
              );
            const s = await this.getLastestAddedFilesInNewDB(e, t);
            return (
              s.length < t &&
                !(await this._isMigrationDone()) &&
                s.push(
                  ...(await this.getLastestAddedFilesInOldDB(
                    { sendDttm: e.sendDttm },
                    t - s.length,
                  )),
                ),
              s
            );
          }
          async getLastestAddedFilesInNewDB(e, t) {
            const { convId: s, sendDttm: i, cliMsgId: n } = e;
            return this.dbTable.getAll(
              {
                from: ["", 0, 0],
                to: [s, i, n],
                excludeFrom: !0,
                excludeTo: !0,
              },
              {
                index: "convId_sendDttm_cliMsgId",
                limit: t,
                direction: Aa.CursorDirection.PREV,
              },
            );
          }
          async getLastestAddedFilesInOldDB(e, t) {
            if (await this._isMigrationDone()) return [];
            const s = await this.getOldDBTable().getAll(
              { from: 0, to: e.sendDttm, excludeFrom: !0, excludeTo: !0 },
              {
                index: "sendDttm",
                limit: t,
                direction: Aa.CursorDirection.PREV,
              },
            );
            return s.length > 0
              ? s.map((e) => this.getMediaMapper().toDomainFromOldDomain(e))
              : [];
          }
        }
        const Ch = Object(i.define)("file-media-repository");
        var Eh;
        Object(i.injectable)()(
          (Eh =
            Object(i.singleton)(Ch)(
              (Eh =
                (function (e, t) {
                  return Object(i.inject)(kc)(e, void 0, 0);
                })(
                  (Eh =
                    (function (e, t) {
                      return Object(i.inject)(_h.c)(e, void 0, 1);
                    })(
                      (Eh =
                        (function (e, t) {
                          return Object(i.inject)(q.ZLoggerFactory)(
                            e,
                            void 0,
                            2,
                          );
                        })(
                          (Eh =
                            Reflect.metadata(
                              "design:type",
                              Function,
                            )(
                              (Eh =
                                Reflect.metadata("design:paramtypes", [
                                  Object,
                                  void 0 === _h.IMediaMigrationManager
                                    ? Object
                                    : _h.IMediaMigrationManager,
                                  void 0 === q.ZLoggerFactory
                                    ? Object
                                    : q.ZLoggerFactory,
                                ])(
                                  (Eh = class extends Oh {
                                    constructor(e, t, s) {
                                      super(
                                        "Media",
                                        "File",
                                        "file",
                                        "crud-file-media",
                                        t,
                                        s,
                                      ),
                                        (this.fileMediaMapper = void 0),
                                        (this.oldDBTable = void 0),
                                        (this.fileMediaMapper = e),
                                        (this.oldDBTable =
                                          this._dalInstance.Core.File);
                                    }
                                    getOldDBTable() {
                                      return (
                                        this.oldDBTable ||
                                          (this.oldDBTable =
                                            K.default.getInstance().Core.File),
                                        this.oldDBTable
                                      );
                                    }
                                    getMediaMapper() {
                                      return this.fileMediaMapper;
                                    }
                                    deleteMatch(e, t) {
                                      throw Error(
                                        "Currently, this method isn't supported!",
                                      );
                                    }
                                    getAllKey(e, t) {
                                      throw Error(
                                        "Currently, this method isn't supported!",
                                      );
                                    }
                                    put(e, t) {
                                      throw Error(
                                        "Currently, this method isn't supported!",
                                      );
                                    }
                                    runTransaction(e, t, s) {
                                      throw Error(
                                        "Currently, this method isn't supported!",
                                      );
                                    }
                                  }),
                                ) || Eh),
                            ) || Eh),
                        ) || Eh),
                    ) || Eh),
                ) || Eh),
            ) || Eh),
        );
        class Mh extends vh {
          constructor(e, t, s, i, n, a) {
            super(e, t, s, i, n, a);
          }
        }
        const Sh = Object(i.define)("link-media-repository");
        var Th;
        Object(i.injectable)()(
          (Th =
            Object(i.singleton)(Sh)(
              (Th =
                (function (e, t) {
                  return Object(i.inject)(Gc)(e, void 0, 0);
                })(
                  (Th =
                    (function (e, t) {
                      return Object(i.inject)(_h.c)(e, void 0, 1);
                    })(
                      (Th =
                        (function (e, t) {
                          return Object(i.inject)(q.ZLoggerFactory)(
                            e,
                            void 0,
                            2,
                          );
                        })(
                          (Th =
                            Reflect.metadata(
                              "design:type",
                              Function,
                            )(
                              (Th =
                                Reflect.metadata("design:paramtypes", [
                                  Object,
                                  void 0 === _h.IMediaMigrationManager
                                    ? Object
                                    : _h.IMediaMigrationManager,
                                  void 0 === q.ZLoggerFactory
                                    ? Object
                                    : q.ZLoggerFactory,
                                ])(
                                  (Th = class extends Mh {
                                    constructor(e, t, s) {
                                      super(
                                        "Media",
                                        "Link",
                                        "link",
                                        "crud-link-media",
                                        t,
                                        s,
                                      ),
                                        (this.linkMediaMapper = void 0),
                                        (this.oldDBTable = void 0),
                                        (this.linkMediaMapper = e),
                                        (this.oldDBTable =
                                          this._dalInstance.Core.Link);
                                    }
                                    getOldDBTable() {
                                      return (
                                        this.oldDBTable ||
                                          (this.oldDBTable =
                                            K.default.getInstance().Core.Link),
                                        this.oldDBTable
                                      );
                                    }
                                    getMediaMapper() {
                                      return this.linkMediaMapper;
                                    }
                                    deleteMatch(e, t) {
                                      throw Error(
                                        "Currently, this method isn't supported!",
                                      );
                                    }
                                    getAllKey(e, t) {
                                      throw Error(
                                        "Currently, this method isn't supported!",
                                      );
                                    }
                                    put(e, t) {
                                      throw Error(
                                        "Currently, this method isn't supported!",
                                      );
                                    }
                                    runTransaction(e, t, s) {
                                      throw Error(
                                        "Currently, this method isn't supported!",
                                      );
                                    }
                                  }),
                                ) || Th),
                            ) || Th),
                        ) || Th),
                    ) || Th),
                ) || Th),
            ) || Th),
        );
        const wh = Object(i.define)("utils-media-repository");
        class Rh {
          constructor(e) {
            (this._lruCache = void 0), (this._lruCache = new U.default(e));
          }
          get(e) {
            return this._lruCache.get(e);
          }
          getAll(e) {
            void 0 === e && (e = "ASC");
            const t =
              "ASC" === e
                ? this._lruCache.entriesAscending()
                : this._lruCache.entriesDescending();
            return Object.values(t);
          }
          getAllKey(e) {
            void 0 === e && (e = "ASC");
            const t =
              "ASC" === e
                ? this._lruCache.entriesAscending()
                : this._lruCache.entriesDescending();
            return Object.keys(t);
          }
          set(e, t) {
            this._lruCache.set(e, t);
          }
          delete(e) {
            return this._lruCache.delete(e);
          }
          clear() {
            this._lruCache.clear();
          }
        }
        var Lh;
        Object(i.injectable)()(
          (Lh =
            Object(i.singleton)(wh)(
              (Lh =
                (function (e, t) {
                  return Object(i.inject)(q.ZLoggerFactory)(e, void 0, 0);
                })(
                  (Lh =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (Lh =
                        Reflect.metadata("design:paramtypes", [
                          void 0 === q.ZLoggerFactory
                            ? Object
                            : q.ZLoggerFactory,
                        ])(
                          (Lh = class extends ja.b {
                            constructor(e) {
                              super(
                                "Media",
                                "UtilsMedia",
                                "utils-media-repo",
                                e,
                                "id",
                                Hc.b,
                              ),
                                (this._cache = new Rh({ maxSize: Hc.b }));
                            }
                            async isExisted(e) {
                              if (!e) return !1;
                              const t = this._cache.get(e);
                              if (!t) {
                                const t = await this._dbCollection.get(e);
                                return t && this._cache.set(e, t), !!t;
                              }
                              return !!t;
                            }
                            async update(e, t) {
                              const s = await this._dbCollection.update(e, t);
                              return s && this._cache.set(e, s), s;
                            }
                            async updateMulti(e) {
                              const t = await this._dbCollection.updateMulti(e);
                              return (
                                t.success.forEach((e) =>
                                  this._cache.set(e.id, e),
                                ),
                                t
                              );
                            }
                            getAllSenderIds(e, t) {
                              if ((void 0 === t && (t = !0), !e))
                                throw Error(
                                  `[getAllSenderIds]: id: ${e} isn't valid!`,
                                );
                              return this._getItemListByField(
                                e,
                                "senderIds",
                                t,
                              );
                            }
                            getAllFileTypes(e, t) {
                              if (!e)
                                throw Error(
                                  `[getAllFileTypes]: id: ${e} isn't valid!`,
                                );
                              return this._getItemListByField(
                                e,
                                "fileTypes",
                                t,
                              );
                            }
                            saveSender(e, t) {
                              if (!e)
                                throw Error(
                                  `[saveSender]: id: ${e} isn't valid!`,
                                );
                              return this._saveValueOnField(e, "senderIds", t);
                            }
                            saveFileType(e, t) {
                              if (!e)
                                throw Error(
                                  `[saveFileType]: id: ${e} isn't valid!`,
                                );
                              return this._saveValueOnField(e, "fileTypes", t);
                            }
                            saveSenders(e, t) {
                              if (!e)
                                throw Error(
                                  `[saveSenders]: id: ${e} isn't valid!`,
                                );
                              return this._saveValuesOnField(e, "senderIds", t);
                            }
                            saveFileTypes(e, t) {
                              if (!e)
                                throw Error(
                                  `[saveSenders]: id: ${e} isn't valid!`,
                                );
                              return this._saveValuesOnField(e, "fileTypes", t);
                            }
                            deleteSender(e, t) {
                              if (!e)
                                throw Error(
                                  `[deleteSender]: id: ${e} isn't valid!`,
                                );
                              return this._deleteValueOnField(
                                e,
                                "senderIds",
                                t,
                              );
                            }
                            deleteFileType(e, t) {
                              if (!e)
                                throw Error(
                                  `[deleteFileType]: id: ${e} isn't valid!`,
                                );
                              return this._deleteValueOnField(
                                e,
                                "fileTypes",
                                t,
                              );
                            }
                            deleteSenders(e, t) {
                              if (!e)
                                throw Error(
                                  `[deleteSenders]: id: ${e} isn't valid!`,
                                );
                              return this._deleteValuesByField(
                                e,
                                "senderIds",
                                t,
                              );
                            }
                            deleteFileTypes(e, t) {
                              if (!e)
                                throw Error(
                                  `[deleteFileTypes]: id: ${e} isn't valid!`,
                                );
                              return this._deleteValuesByField(
                                e,
                                "fileTypes",
                                t,
                              );
                            }
                            async _saveValueOnField(e, t, s) {
                              const i =
                                this._cache.get(e) ||
                                (await this._dbCollection.get(e));
                              if (i) {
                                i[t].some((e) => e === s) ||
                                  (i[t].push(s),
                                  await this.update(e, {
                                    value: { [t]: i[t] },
                                    attributes: [t],
                                  }));
                              }
                              return !0;
                            }
                            async _saveValuesOnField(e, t, s) {
                              const i =
                                this._cache.get(e) ||
                                (await this._dbCollection.get(e));
                              if (i) {
                                const n = s.filter((e) => !i[t].includes(e));
                                n.length &&
                                  (i[t].push(...n),
                                  await this.update(e, {
                                    value: { [t]: i[t] },
                                    attributes: [t],
                                  }));
                              }
                              return !0;
                            }
                            async _deleteValueOnField(e, t, s) {
                              const i =
                                this._cache.get(e) ||
                                (await this._dbCollection.get(e));
                              if (i) {
                                const n = i[t].indexOf(s);
                                -1 !== n &&
                                  (i[t].splice(n, 1),
                                  await this.update(e, {
                                    value: { [t]: i[t] },
                                    attributes: [t],
                                  }));
                              }
                              return !0;
                            }
                            async _deleteValuesByField(e, t, s) {
                              const i =
                                this._cache.get(e) ||
                                (await this._dbCollection.get(e));
                              if (i) {
                                const n = i[t].filter((e) => !s.includes(e));
                                n.length < i[t].length &&
                                  ((i[t] = n),
                                  await this.update(e, {
                                    value: { [t]: n },
                                    attributes: [t],
                                  }));
                              }
                              return !0;
                            }
                            async _getItemListByField(e, t, s) {
                              var i;
                              void 0 === s && (s = !0);
                              const n = this._cache.get(e);
                              var a;
                              if (s)
                                return n &&
                                  null !== (a = n[t]) &&
                                  void 0 !== a &&
                                  a.length
                                  ? n[t].slice()
                                  : [];
                              const r = await this._dbCollection.get(e);
                              return (
                                r &&
                                  !n &&
                                  this._cache.set(e, Object(f.a)({}, r)),
                                r &&
                                null !== (i = r[t]) &&
                                void 0 !== i &&
                                i.length
                                  ? r[t].slice()
                                  : []
                              );
                            }
                          }),
                        ) || Lh),
                    ) || Lh),
                ) || Lh),
            ) || Lh),
        );
        const Dh = Object(i.define)("media-mapper-factory");
        var Fh;
        Object(i.injectable)()(
          (Fh =
            Object(i.singleton)(Dh)(
              (Fh = class {
                getMediaMapper(e) {
                  switch (e) {
                    case "image":
                      return i.ModuleContainer.resolve(Bc);
                    case "file":
                      return i.ModuleContainer.resolve(kc);
                    case "link":
                      return i.ModuleContainer.resolve(Gc);
                    default:
                      return;
                  }
                }
              }),
            ) || Fh),
        );
        const Ah = Object(i.define)("media-repository-factory");
        var jh;
        Object(i.injectable)()(
          (jh =
            Object(i.singleton)(Ah)(
              (jh = class {
                getMediaRepository(e) {
                  switch (e) {
                    case "image":
                      return i.ModuleContainer.resolve(Ih);
                    case "link":
                      return i.ModuleContainer.resolve(Sh);
                    case "file":
                      return i.ModuleContainer.resolve(Ch);
                    default:
                      return;
                  }
                }
              }),
            ) || jh),
        );
        const Ph = "utils-media-domain-service",
          Nh = Object(i.define)(Ph);
        function Uh(e) {
          const t = e;
          return function (e, s, i) {
            void 0 === i && (i = "error");
            const n = `${e} ${i}: ${s}`;
            switch (i) {
              case "error":
                t.zsymb(18, 11026, 3e4, n);
                break;
              case "debug":
                t.zsymb(12, 11026, 30001, n);
                break;
              case "info":
                t.zsymb(0, 11026, 30002, n);
            }
          };
        }
        var kh;
        Object(i.injectable)()(
          (kh =
            Object(i.singleton)(Nh)(
              (kh =
                (function (e, t) {
                  return Object(i.inject)(wh)(e, void 0, 0);
                })(
                  (kh =
                    (function (e, t) {
                      return Object(i.inject)(q.ZLoggerFactory)(e, void 0, 1);
                    })(
                      (kh =
                        Reflect.metadata(
                          "design:type",
                          Function,
                        )(
                          (kh =
                            Reflect.metadata("design:paramtypes", [
                              Object,
                              void 0 === q.ZLoggerFactory
                                ? Object
                                : q.ZLoggerFactory,
                            ])(
                              (kh = class {
                                constructor(e, t) {
                                  (this._log = void 0),
                                    (this._logger = void 0),
                                    (this._utilsMediaRepository = void 0),
                                    (this._utilsMediaRepository = e),
                                    (this._logger = t.createZLogger(
                                      "utils-media-domain-service",
                                      ["mn-utils-media-de"],
                                    )),
                                    (this._log = Uh(this._logger));
                                }
                                async create(e) {
                                  if (!e)
                                    throw Error(
                                      `utilsMedia(${e}) isn't existed!`,
                                    );
                                  if (!e.convId || !e.mediaType)
                                    throw Error(
                                      `cannot create utilsMedia with convId(${e.convId}) and mediaType(${e.mediaType})`,
                                    );
                                  if (
                                    await this._utilsMediaRepository.isExisted(
                                      `${e.convId}_${e.mediaType}`,
                                    )
                                  )
                                    throw (
                                      (this._log(
                                        "[create]",
                                        `existed utilsMedia have convId(${e.convId}) and mediaType(${e.mediaType})`,
                                        "info",
                                      ),
                                      Error(
                                        `existed utilsMedia have convId(${e.convId}) and mediaType(${e.mediaType})`,
                                      ))
                                    );
                                  return {
                                    id: `${e.convId}_${e.mediaType}`,
                                    convId: e.convId,
                                    mediaType: e.mediaType,
                                    senderIds: e.senderIds || [],
                                    fileTypes: e.fileTypes || [],
                                  };
                                }
                                addSenders(e, t) {
                                  if (!e)
                                    throw Error(
                                      "[addFileTypes] utilsMediaEntity isn't existed!",
                                    );
                                  if (!t || !t.length)
                                    return Object(f.a)({}, e);
                                  return Object(f.a)(
                                    Object(f.a)({}, e),
                                    {},
                                    {
                                      senderIds: t.reduce(
                                        (e, t) => (
                                          e.includes(t) || e.push(t), e
                                        ),
                                        [...e.senderIds] || !1,
                                      ),
                                    },
                                  );
                                }
                                addFileTypes(e, t) {
                                  if (!e)
                                    throw Error(
                                      "[addFileTypes] utilsMediaEntity isn't existed!",
                                    );
                                  if (!t || !t.length)
                                    return Object(f.a)({}, e);
                                  const s = Object(f.a)(
                                    Object(f.a)({}, e),
                                    {},
                                    {
                                      fileTypes: t.reduce(
                                        (e, t) => (
                                          e.includes(t) || e.push(t), e
                                        ),
                                        [...e.fileTypes] || !1,
                                      ),
                                    },
                                  );
                                  return s;
                                }
                              }),
                            ) || kh),
                        ) || kh),
                    ) || kh),
                ) || kh),
            ) || kh),
        );
        const Bh = "utils-media-app-service",
          Gh = Object(i.define)(Bh);
        var xh;
        Object(i.injectable)()(
          (xh =
            Object(i.singleton)(Gh)(
              (xh =
                (function (e, t) {
                  return Object(i.inject)(Nh)(e, void 0, 0);
                })(
                  (xh =
                    (function (e, t) {
                      return Object(i.inject)(wh)(e, void 0, 1);
                    })(
                      (xh =
                        (function (e, t) {
                          return Object(i.inject)(Uc)(e, void 0, 2);
                        })(
                          (xh =
                            (function (e, t) {
                              return Object(i.inject)(q.ZLoggerFactory)(
                                e,
                                void 0,
                                3,
                              );
                            })(
                              (xh =
                                Reflect.metadata(
                                  "design:type",
                                  Function,
                                )(
                                  (xh =
                                    Reflect.metadata("design:paramtypes", [
                                      Object,
                                      Object,
                                      Object,
                                      void 0 === q.ZLoggerFactory
                                        ? Object
                                        : q.ZLoggerFactory,
                                    ])(
                                      (xh = class {
                                        constructor(e, t, s, i) {
                                          (this._utilsMediaDomainService =
                                            void 0),
                                            (this._utilsMediaRepository =
                                              void 0),
                                            (this._mapper = void 0),
                                            (this._logger = void 0),
                                            (this._log = void 0),
                                            (this._utilsMediaDomainService = e),
                                            (this._utilsMediaRepository = t),
                                            (this._mapper = s),
                                            (this._logger = i.createZLogger(
                                              Bh,
                                              ["manage-utils-media-in-app"],
                                            )),
                                            (this._log = Uh(this._logger));
                                        }
                                        async create(e) {
                                          try {
                                            const t =
                                              await this._utilsMediaDomainService.create(
                                                e,
                                              );
                                            return this._mapper.toUtilsMediaDTOFromDomain(
                                              await this._utilsMediaRepository.insert(
                                                t,
                                              ),
                                            );
                                          } catch (t) {
                                            return void this._log(
                                              "[create]",
                                              t.message,
                                            );
                                          }
                                        }
                                        async createOrUpdate(e) {
                                          try {
                                            const t = `${e.convId}_${e.mediaType}`;
                                            let s =
                                              await this._utilsMediaRepository.get(
                                                t,
                                              );
                                            if (s) {
                                              const {
                                                senderIds: i,
                                                fileTypes: n,
                                              } = e;
                                              let a = s.senderIds,
                                                r = s.fileTypes;
                                              if (
                                                (i &&
                                                  i.length &&
                                                  (a =
                                                    this._utilsMediaDomainService.addSenders(
                                                      s,
                                                      i,
                                                    ).senderIds),
                                                n &&
                                                  n.length &&
                                                  (r =
                                                    this._utilsMediaDomainService.addFileTypes(
                                                      s,
                                                      n,
                                                    ).fileTypes),
                                                a.length !==
                                                  s.senderIds.length ||
                                                  r.length !==
                                                    s.fileTypes.length)
                                              ) {
                                                const e =
                                                  await this._utilsMediaRepository.update(
                                                    t,
                                                    {
                                                      value: {
                                                        senderIds: a,
                                                        fileTypes: r,
                                                      },
                                                      attributes: [
                                                        "senderIds",
                                                        "fileTypes",
                                                      ],
                                                    },
                                                  );
                                                return this._mapper.toUtilsMediaDTOFromDomain(
                                                  e,
                                                );
                                              }
                                              return this._mapper.toUtilsMediaDTOFromDomain(
                                                s,
                                              );
                                            }
                                            return this.create(e);
                                          } catch (t) {
                                            return void this._log(
                                              "[createOrUpdate]",
                                              t.message,
                                            );
                                          }
                                        }
                                        async deleteUtilsMediasByConvId(e) {
                                          try {
                                            if (!e) return [];
                                            const t = Object.values(Hc.e).map(
                                              (t) => `${e}_${t}`,
                                            );
                                            return (
                                              await this._utilsMediaRepository.deleteMulti(
                                                t,
                                              )
                                            ).success;
                                          } catch (t) {
                                            return (
                                              this._log(
                                                "[deleteUtilsMediasByConvId]",
                                                t.message,
                                              ),
                                              []
                                            );
                                          }
                                        }
                                        async createOrUpdateFromMedias(e) {
                                          try {
                                            if (!e || !e.length) return [];
                                            const t = new Map();
                                            e.forEach((e) => {
                                              let s = t.get(e.convId);
                                              if (
                                                "image" === e.mediaType ||
                                                "link" === e.mediaType
                                              )
                                                if (s) {
                                                  -1 ===
                                                    s.senderIds.indexOf(
                                                      e.fromUid,
                                                    ) &&
                                                    (s.senderIds.push(
                                                      e.fromUid,
                                                    ),
                                                    t.set(e.convId, s));
                                                } else
                                                  (s = {
                                                    convId: e.convId,
                                                    mediaType: e.mediaType,
                                                    senderIds: [e.fromUid],
                                                    fileTypes: [],
                                                  }),
                                                    t.set(e.convId, s);
                                              else if ("file" === e.mediaType) {
                                                const i = this._getFileType(
                                                  e.content.params,
                                                );
                                                if (s) {
                                                  -1 ===
                                                    s.fileTypes.indexOf(i) &&
                                                    (s.fileTypes.push(i),
                                                    t.set(e.convId, s));
                                                } else
                                                  (s = {
                                                    convId: e.convId,
                                                    mediaType: e.mediaType,
                                                    senderIds: [e.fromUid],
                                                    fileTypes: [i],
                                                  }),
                                                    t.set(e.convId, s);
                                              }
                                            });
                                            const s = Array.from(t.values());
                                            return (
                                              await Promise.all(
                                                s.map((e) =>
                                                  this.createOrUpdate(e),
                                                ),
                                              )
                                            ).filter(Boolean);
                                          } catch (t) {
                                            return (
                                              this._log(
                                                "[createOrUpdateFromMedias]",
                                                t.message,
                                              ),
                                              []
                                            );
                                          }
                                        }
                                        _getFileType(e) {
                                          try {
                                            const t = JSON.parse(e);
                                            if (!t)
                                              throw Error(`paramsObj is ${t}!`);
                                            const { fileExt: s, fType: i } = t;
                                            return "zip" === s && 2 === i
                                              ? "folder"
                                              : s.toLowerCase();
                                          } catch (t) {
                                            return (
                                              this._log(
                                                "[_getFileType]",
                                                t.message,
                                              ),
                                              ""
                                            );
                                          }
                                        }
                                      }),
                                    ) || xh),
                                ) || xh),
                            ) || xh),
                        ) || xh),
                    ) || xh),
                ) || xh),
            ) || xh),
        );
        const zh = Object(i.define)("media-migration-state-persist");
        var Vh;
        Object(i.injectable)()(
          (Vh =
            Object(i.singleton)(zh)(
              (Vh = class {
                constructor() {
                  this._localStorage = E.default.getInstance();
                }
                async saveMigrationState(e) {
                  e &&
                    (await this._localStorage.setItemForCurrentUserAsync(
                      fh,
                      JSON.stringify(e),
                    ));
                }
                async getMigrationState() {
                  try {
                    const e =
                      await this._localStorage.getItemForCurrentUserAsync(fh);
                    return e
                      ? JSON.parse(e)
                      : { stateName: rh, mediaTableNamesToMigrate: [] };
                  } catch (e) {
                    return { stateName: rh, mediaTableNamesToMigrate: [] };
                  }
                }
                async saveJobDescSummaries(e) {
                  Array.isArray(e) &&
                    (await this._localStorage.setItemForCurrentUserAsync(
                      ph,
                      JSON.stringify(e),
                    ));
                }
                async getSavedJobDescSummaries() {
                  try {
                    const e =
                      await this._localStorage.getItemForCurrentUserAsync(ph);
                    if (!e) return [];
                    return JSON.parse(e);
                  } catch (e) {
                    return [];
                  }
                }
                async clearPersistedJobDescSummaries() {
                  await this._localStorage.removeItemForCurrentUserAsync(ph);
                }
              }),
            ) || Vh),
        );
        var Hh = s("mH7l"),
          $h = s.n(Hh);
        const Wh = (e) => "GET_FROM_OLD_DB" === e.name,
          Kh = (e) => "ADD_TO_NEW_DB" === e.name,
          qh = (e) => "DELETE_FROM_OLD_DB" === e.name;
        function Zh() {
          return bt.default.media_migration_db.should_stop_migration;
        }
        function Jh() {
          return bt.default.media_migration_db.max_running_concurrency_job;
        }
        function Qh() {
          return bt.default.media_migration_db.delay_time_per_job;
        }
        function Yh() {
          return bt.default.media_migration_db.delay_time_each_k_jobs;
        }
        function Xh() {
          return bt.default.media_migration_db.media_limit_per_job;
        }
        function eu() {
          return bt.default.media_migration_db.min_retry_after;
        }
        function tu() {
          return bt.default.media_migration_db.max_retry_after;
        }
        var su = s("1erv");
        const iu = 0,
          nu = 1,
          au = 2,
          ru = 4;
        class ou extends Error {
          constructor(e) {
            super(`ExpBackoff error:${e}`), (this.code = e);
          }
        }
        function* du(e) {
          var t, s, i, n, a;
          const r =
              null !== (t = null == e ? void 0 : e.retries) && void 0 !== t
                ? t
                : 3,
            o =
              null !== (s = null == e ? void 0 : e.min) && void 0 !== s
                ? s
                : 100,
            d =
              null !== (i = null == e ? void 0 : e.max) && void 0 !== i
                ? i
                : 1e4,
            l =
              null !== (n = null == e ? void 0 : e.step) && void 0 !== n
                ? n
                : 2,
            c =
              null !== (a = null == e ? void 0 : e.jitter) && void 0 !== a
                ? a
                : 0;
          if (o <= 0) throw new ou(au);
          if (c < 0 || c > 1) throw new ou(nu);
          let h = 0;
          for (; h <= r; ) {
            const e = lu({ nTry: h, step: l, jitter: c, min: o, max: d });
            yield {
              nTry: h,
              duration: e,
              sleep: () =>
                new Promise((t) => {
                  setTimeout(t, e);
                }),
            },
              h++;
          }
        }
        function lu(e) {
          let { step: t, nTry: s, jitter: i, min: n, max: a } = e,
            r = n * Math.pow(t, s);
          if (i) {
            const e = Math.random(),
              t = Math.floor(e * i * r);
            r = 0 == (1 & Math.floor(10 * e)) ? r - t : r + t;
          }
          return 0 | Math.min(r, a);
        }
        var cu;
        const hu = new Ol.a(),
          uu = 999999;
        Object(V.d)()(
          (cu =
            Object(i.injectable)()(
              (cu =
                Object(i.singleton)(_h.c)(
                  (cu =
                    (function (e, t) {
                      return Object(i.inject)(zh)(e, void 0, 0);
                    })(
                      (cu =
                        (function (e, t) {
                          return Object(i.inject)(V.a)(e, void 0, 1);
                        })(
                          (cu =
                            (function (e, t) {
                              return Object(i.inject)(q.ZLoggerFactory)(
                                e,
                                void 0,
                                2,
                              );
                            })(
                              (cu =
                                Reflect.metadata(
                                  "design:type",
                                  Function,
                                )(
                                  (cu =
                                    Reflect.metadata("design:paramtypes", [
                                      Object,
                                      void 0 === V.a ? Object : V.a,
                                      void 0 === q.ZLoggerFactory
                                        ? Object
                                        : q.ZLoggerFactory,
                                    ])(
                                      (cu = class {
                                        constructor(e, t, s) {
                                          (this._isLoadData = !1),
                                            (this._forceStop = !1),
                                            (this._mediaMigrationStatePersist =
                                              void 0),
                                            (this._maxWorkerPoolNum = Jh()),
                                            (this._worker = new $h.a({
                                              concurrency:
                                                this._maxWorkerPoolNum,
                                              autoStart: !1,
                                            })),
                                            (this._delayTimePerJob = Qh()),
                                            (this._delayTimeEachKJobs = Yh()),
                                            (this._mediaNumLimitPerJob = Xh()),
                                            (this._minRetryAfter = eu()),
                                            (this._maxRetryAfter = tu()),
                                            (this._currentJobDescs = []),
                                            (this._currentJobHolders = []),
                                            (this._currentMsgIdCursor =
                                              R.MessageConstants.MAX_MSG_ID),
                                            (this._mediaMigrationState =
                                              void 0),
                                            (this._failedGetJob = !1),
                                            (this._failedAddJob = !1),
                                            (this._failedDeleteJob = !1),
                                            (this._hasDBError = !1),
                                            (this._logger = void 0),
                                            (this._application = void 0),
                                            (this._mediaMigrationStatePersist =
                                              e),
                                            (this._onApplicationIdle =
                                              this._onApplicationIdle.bind(
                                                this,
                                              )),
                                            (this._onApplicationActive =
                                              this._onApplicationActive.bind(
                                                this,
                                              )),
                                            (this._onApplicationExit =
                                              this._onApplicationExit.bind(
                                                this,
                                              )),
                                            (this._application = t),
                                            (this._logger = s.createZLogger(
                                              _h.b,
                                              ["manage-media-migration"],
                                            ));
                                        }
                                        onApplicationReady(e) {
                                          this._listenEvents(),
                                            this._isLoadData ||
                                              this._loadData().then(() => {
                                                this._runMigration();
                                              }),
                                            this.toggleDBError(
                                              this._getTestMediaMigrationFlag(
                                                "[mm]:db_error",
                                              ),
                                            ),
                                            this.toggleGetJobFailed(
                                              this._getTestMediaMigrationFlag(
                                                "[mm]:get_failed",
                                              ),
                                            ),
                                            this.toggleAddJobFailed(
                                              this._getTestMediaMigrationFlag(
                                                "[mm]:add_failed",
                                              ),
                                            ),
                                            this.toggleDeleteJobFailed(
                                              this._getTestMediaMigrationFlag(
                                                "[mm]:delete_failed",
                                              ),
                                            );
                                        }
                                        async getMediaMigrationState() {
                                          if (!Object(su.a)() || Zh())
                                            return {
                                              stateName: rh,
                                              mediaTableNamesToMigrate: [],
                                            };
                                          if (!this._mediaMigrationState) {
                                            const {
                                              stateName: e,
                                              remainingTableNames: t,
                                            } =
                                              await this._statsMediaMigration();
                                            this._mediaMigrationState = {
                                              stateName: e,
                                              mediaTableNamesToMigrate: t,
                                            };
                                          }
                                          return this._mediaMigrationState;
                                        }
                                        pauseMigration(e) {
                                          this._logger.zsymb(
                                            3,
                                            10719,
                                            3e4,
                                            "[mm] pause migration - reason: {}",
                                            e,
                                          ),
                                            this.flushHoldingJobs(),
                                            (this._forceStop = !0),
                                            this._worker.pause();
                                        }
                                        async resumeMigration(e) {
                                          this._logger.zsymb(
                                            3,
                                            10719,
                                            30001,
                                            "[mm] resume migration - reason: {}",
                                            e,
                                          ),
                                            (this._forceStop = !1),
                                            Object(su.a)() &&
                                              !Zh() &&
                                              (this._isLoadData ||
                                                (await this._loadData()),
                                              this._currentJobDescs.forEach(
                                                (e) => {
                                                  if (e.state === mh) {
                                                    e.state = uh;
                                                    const t =
                                                      this._createJob(e);
                                                    if (t) {
                                                      const s =
                                                        this._scheduleJob(
                                                          e.id,
                                                          t,
                                                        );
                                                      this._worker.add(s, {
                                                        priority: uu,
                                                      });
                                                    }
                                                  }
                                                },
                                              ),
                                              this._worker.size > 0
                                                ? this._worker.isPaused &&
                                                  this._worker.start()
                                                : this._runMigration());
                                        }
                                        flushHoldingJobs() {
                                          this._currentJobHolders.forEach(
                                            (e) => {
                                              clearTimeout(e.timeoutId),
                                                e.resolver();
                                            },
                                          ),
                                            (this._currentJobHolders = []);
                                        }
                                        toggleGetJobFailed(e) {
                                          this._failedGetJob = e;
                                        }
                                        toggleAddJobFailed(e) {
                                          this._failedAddJob = e;
                                        }
                                        toggleDeleteJobFailed(e) {
                                          this._failedDeleteJob = e;
                                        }
                                        toggleDBError(e) {
                                          this._hasDBError = e;
                                        }
                                        _createJob(e) {
                                          const { id: t, currentStep: s } = e;
                                          return (
                                            this._updateStateOfCurrentJobByJobId(
                                              t,
                                              gh,
                                            ),
                                            Wh(s)
                                              ? this._createJobFromGetFromOldDBCurrentStep(
                                                  t,
                                                  s,
                                                )
                                              : Kh(s)
                                                ? this._createJobFromAddToNewDBCurrentStep(
                                                    t,
                                                    s,
                                                  )
                                                : qh(s)
                                                  ? this._createJobFromDeleteFromOldDBCurrentStep(
                                                      t,
                                                      s,
                                                    )
                                                  : void 0
                                          );
                                        }
                                        _createJobFromGetFromOldDBCurrentStep(
                                          e,
                                          t,
                                        ) {
                                          const s = Object(f.a)({}, t),
                                            {
                                              mediaTableName: i,
                                              amount: n,
                                              lastMsgId: a,
                                            } = s.dataToRun;
                                          return async () => {
                                            try {
                                              await this._withRetry(
                                                async () => {
                                                  const t = this._createStep(s);
                                                  if (!t)
                                                    return void this._logger.zsymb(
                                                      21,
                                                      10719,
                                                      30002,
                                                      "[mm] getFromOldDBStep is undefined!",
                                                    );
                                                  let r = await t();
                                                  if (r.state === hh)
                                                    throw (
                                                      ((r.data.jobId = e),
                                                      (r.data.jobType =
                                                        "GET_FROM_OLD_DB"),
                                                      r.data)
                                                    );
                                                  const { data: o } = r;
                                                  if (
                                                    (this._logger.zsymb(
                                                      3,
                                                      10719,
                                                      30003,
                                                      "[mm] getFromOldDBStep - DONE - jobId: {}, {}",
                                                      e,
                                                      o.length,
                                                    ),
                                                    o.length >= n
                                                      ? (this._currentMsgIdCursor =
                                                          o[o.length - 1].msgId)
                                                      : this
                                                          ._mediaMigrationState &&
                                                        this
                                                          ._mediaMigrationState
                                                          .mediaTableNamesToMigrate
                                                          .length &&
                                                        (this._mediaMigrationState.mediaTableNamesToMigrate.shift(),
                                                        (this._currentMsgIdCursor =
                                                          R.MessageConstants.MAX_MSG_ID)),
                                                    this._runMigration(),
                                                    o.length)
                                                  ) {
                                                    const t = {
                                                      name: dh,
                                                      dataToRun: {
                                                        mediaTableName: i,
                                                        amount: n,
                                                        lastMsgId: a,
                                                        data: o,
                                                      },
                                                    };
                                                    this._updateCurrentStepByJobId(
                                                      e,
                                                      t,
                                                    );
                                                    const s =
                                                      this._createJobFromAddToNewDBCurrentStep(
                                                        e,
                                                        t,
                                                      );
                                                    await s();
                                                  }
                                                },
                                              )();
                                            } catch (t) {
                                              this._logger.zsymb(
                                                3,
                                                10719,
                                                30004,
                                                "[mm] throw error from get from old DB step - jobId: {}, {}",
                                                e,
                                                null == t ? void 0 : t.message,
                                              );
                                            }
                                          };
                                        }
                                        _createJobFromAddToNewDBCurrentStep(
                                          e,
                                          t,
                                        ) {
                                          const s = Object(f.a)({}, t),
                                            {
                                              mediaTableName: i,
                                              amount: n,
                                              lastMsgId: a,
                                            } = s.dataToRun;
                                          return async () => {
                                            try {
                                              await this._withRetry(
                                                async () => {
                                                  await this._persistCurrentJobDescs();
                                                  const s = this._createStep(t);
                                                  if (!s)
                                                    return void this._logger.zsymb(
                                                      18,
                                                      10719,
                                                      30005,
                                                      "[mm] addToNewDBStep is undefined!",
                                                    );
                                                  const r = await s();
                                                  if (r.state === hh)
                                                    throw (
                                                      ((r.data.jobId = e),
                                                      (r.data.jobType =
                                                        "ADD_TO_NEW_DB"),
                                                      r.data)
                                                    );
                                                  const { data: o } = r;
                                                  if (
                                                    (this._logger.zsymb(
                                                      3,
                                                      10719,
                                                      30006,
                                                      "[mm] addToNewDBStep - jobId: {}, {}",
                                                      e,
                                                      o.length,
                                                    ),
                                                    o.length)
                                                  ) {
                                                    const t = {
                                                      name: lh,
                                                      dataToRun: {
                                                        mediaTableName: i,
                                                        amount: n,
                                                        lastMsgId: a,
                                                        data: o,
                                                      },
                                                    };
                                                    this._updateCurrentStepByJobId(
                                                      e,
                                                      t,
                                                    );
                                                    const s =
                                                      this._createJobFromDeleteFromOldDBCurrentStep(
                                                        e,
                                                        t,
                                                      );
                                                    await s();
                                                  }
                                                },
                                              )();
                                            } catch (s) {
                                              this._logger.zsymb(
                                                3,
                                                10719,
                                                30007,
                                                "[mm] throw error from add to new DB step - jobId: {}, {}",
                                                e,
                                                null == s ? void 0 : s.message,
                                              );
                                            }
                                          };
                                        }
                                        _createJobFromDeleteFromOldDBCurrentStep(
                                          e,
                                          t,
                                        ) {
                                          const s = Object(f.a)({}, t);
                                          return async () => {
                                            try {
                                              await this._withRetry(
                                                async () => {
                                                  await this._persistCurrentJobDescs();
                                                  const t = this._createStep(s);
                                                  if (!t)
                                                    return void this._logger.zsymb(
                                                      21,
                                                      10719,
                                                      30008,
                                                      "[mm] deleteFromOldDBStep is undefined!",
                                                    );
                                                  const i = await t();
                                                  if (i.state === hh)
                                                    throw (
                                                      ((i.data.jobId = e),
                                                      (i.data.jobType =
                                                        "DELETE_FROM_OLD_DB"),
                                                      i.data)
                                                    );
                                                  this._logger.zsymb(
                                                    3,
                                                    10719,
                                                    30009,
                                                    "[mm] deleteFromOldDBStep - DONE - jobId: {}",
                                                    e,
                                                  ),
                                                    (this._currentJobDescs =
                                                      this._currentJobDescs.filter(
                                                        (t) => t.id !== e,
                                                      )),
                                                    (this._currentJobHolders =
                                                      this._currentJobHolders.filter(
                                                        (t) => t.jobId !== e,
                                                      )),
                                                    this._persistCurrentJobDescs();
                                                },
                                              )();
                                            } catch (t) {
                                              this._logger.zsymb(
                                                3,
                                                10719,
                                                30010,
                                                "[mm] throw error from delete from old DB step - jobId: {} - err: {}",
                                                e,
                                                null == t ? void 0 : t.message,
                                              );
                                            }
                                          };
                                        }
                                        _updateCurrentStepByJobId(e, t) {
                                          const s = this._currentJobDescs.find(
                                            (t) => t.id === e,
                                          );
                                          s && (s.currentStep = t);
                                        }
                                        _updateStateOfCurrentJobByJobId(e, t) {
                                          const s = this._currentJobDescs.find(
                                            (t) => t.id === e,
                                          );
                                          s && (s.state = t);
                                        }
                                        async _persistCurrentJobDescs() {
                                          await this._mediaMigrationStatePersist.saveJobDescSummaries(
                                            this._currentJobDescs.reduce(
                                              (e, t) => (
                                                t.currentStep.name !== oh &&
                                                  e.push(
                                                    this._toJobDescSummary(t),
                                                  ),
                                                e
                                              ),
                                              [],
                                            ),
                                          );
                                        }
                                        _createStep(e) {
                                          return Wh(e)
                                            ? async () => {
                                                try {
                                                  if (this._hasDBError)
                                                    this._throwDBError();
                                                  else if (this._failedGetJob)
                                                    throw Error(
                                                      "[SIMULATE]: Failed to get job from old DB!",
                                                    );
                                                  const {
                                                      mediaTableName: t,
                                                      amount: s,
                                                      lastMsgId: n,
                                                    } = e.dataToRun,
                                                    a = t,
                                                    r =
                                                      i.ModuleContainer.resolve(
                                                        ps.a,
                                                      ),
                                                    o =
                                                      await r.getMediasFromOldDB(
                                                        a,
                                                        s,
                                                        n,
                                                      );
                                                  return { state: ch, data: o };
                                                } catch (t) {
                                                  return (
                                                    this._logger.zsymb(
                                                      21,
                                                      10719,
                                                      30011,
                                                      "[mm] get from old db step err: {}",
                                                      null == t
                                                        ? void 0
                                                        : t.message,
                                                    ),
                                                    { state: hh, data: t }
                                                  );
                                                }
                                              }
                                            : Kh(e)
                                              ? async () => {
                                                  try {
                                                    if (this._hasDBError)
                                                      this._throwDBError();
                                                    else if (this._failedAddJob)
                                                      throw Error(
                                                        "[SIMULATE]: Failed to add job to new DB!",
                                                      );
                                                    let {
                                                      mediaTableName: t,
                                                      data: s,
                                                      lastMsgId: n,
                                                      amount: a,
                                                    } = e.dataToRun;
                                                    const r = t,
                                                      o =
                                                        i.ModuleContainer.resolve(
                                                          ps.a,
                                                        );
                                                    let d = s;
                                                    d ||
                                                      (d =
                                                        await o.getMediasFromOldDB(
                                                          r,
                                                          a,
                                                          n,
                                                        ));
                                                    const l =
                                                      await o.addMediasFromOldDB(
                                                        r,
                                                        d,
                                                      );
                                                    return {
                                                      state: ch,
                                                      data: l,
                                                    };
                                                  } catch (t) {
                                                    return (
                                                      this._logger.zsymb(
                                                        21,
                                                        10719,
                                                        30012,
                                                        "[mm] add to new db step err: {}",
                                                        null == t
                                                          ? void 0
                                                          : t.message,
                                                      ),
                                                      { state: hh, data: t }
                                                    );
                                                  }
                                                }
                                              : qh(e)
                                                ? async () => {
                                                    try {
                                                      if (this._hasDBError)
                                                        this._throwDBError();
                                                      else if (
                                                        this._failedDeleteJob
                                                      )
                                                        throw Error(
                                                          "[SIMULATE]: Failed to delete job from old DB!",
                                                        );
                                                      const {
                                                          mediaTableName: t,
                                                          data: s,
                                                          lastMsgId: n,
                                                          amount: a,
                                                        } = e.dataToRun,
                                                        r = t,
                                                        o =
                                                          i.ModuleContainer.resolve(
                                                            ps.a,
                                                          );
                                                      return s
                                                        ? {
                                                            state: ch,
                                                            data: await o.deleteMediasFromOldDB(
                                                              r,
                                                              s,
                                                            ),
                                                          }
                                                        : {
                                                            state: ch,
                                                            data: await o.deleteMediasFromOldDBByRange(
                                                              r,
                                                              a,
                                                              n,
                                                            ),
                                                          };
                                                    } catch (t) {
                                                      return (
                                                        this._logger.zsymb(
                                                          21,
                                                          10719,
                                                          30013,
                                                          "[mm] delete from old db step err: {}",
                                                          null == t
                                                            ? void 0
                                                            : t.message,
                                                        ),
                                                        { state: hh, data: t }
                                                      );
                                                    }
                                                  }
                                                : void 0;
                                        }
                                        async _loadData() {
                                          if (Zh() || !Object(su.a)()) return;
                                          const e =
                                            await this.getMediaMigrationState();
                                          this._logger.zsymb(
                                            3,
                                            10719,
                                            30014,
                                            "[mm] MEDIA MIGRATION STATE after load data: {}",
                                            e.stateName,
                                          ),
                                            (this._mediaMigrationState = e);
                                          const t =
                                            await this._mediaMigrationStatePersist.getSavedJobDescSummaries();
                                          t.length > 0 &&
                                            t.forEach((e) => {
                                              const t = this._toJobDesc(e);
                                              this._currentJobDescs.push(t);
                                              const s = this._createJob(t);
                                              if (s) {
                                                const e = this._scheduleJob(
                                                  t.id,
                                                  s,
                                                );
                                                this._worker.add(e, {
                                                  priority: uu,
                                                });
                                              }
                                            }),
                                            (this._isLoadData = !0);
                                        }
                                        async _statsMediaMigration() {
                                          const e = i.ModuleContainer.resolve(
                                              ps.a,
                                            ),
                                            t = await Promise.all([
                                              e.countTotalMediaInOldDB("image"),
                                              e.countTotalMediaInOldDB("file"),
                                              e.countTotalMediaInOldDB("link"),
                                            ]);
                                          let s = ah,
                                            n = [];
                                          return (
                                            (s =
                                              t.reduce(
                                                (e, t, s) => (
                                                  0 === s && t > 0
                                                    ? n.push("image")
                                                    : 1 === s && t > 0
                                                      ? n.push("file")
                                                      : 2 === s &&
                                                        t > 0 &&
                                                        n.push("link"),
                                                  e + t
                                                ),
                                                0,
                                              ) > 0
                                                ? ah
                                                : nh),
                                            {
                                              stateName: s,
                                              remainingTableNames: n,
                                            }
                                          );
                                        }
                                        async _runMigration() {
                                          if (
                                            (this._logger.zsymb(
                                              0,
                                              10719,
                                              30015,
                                              "[mm] ====================RUN MIGRATION====================",
                                            ),
                                            !Object(su.a)())
                                          )
                                            return void this._logger.zsymb(
                                              0,
                                              10719,
                                              30016,
                                              "[mm] ==========STOP MIGRATION: not use new media DB flow (cfsv)==========",
                                            );
                                          if (Zh())
                                            return void this._logger.zsymb(
                                              0,
                                              10719,
                                              30017,
                                              "[mm] ==========STOP MIGRATION: stop migration (cfsv)==========",
                                            );
                                          if (this._forceStop)
                                            return void this._logger.zsymb(
                                              0,
                                              10719,
                                              30018,
                                              "[mm] ==========STOP MIGRATION: force stop (in app)==========",
                                            );
                                          if (
                                            !this._isLoadData &&
                                            (await this._loadData(),
                                            !this._isLoadData)
                                          )
                                            return;
                                          if (
                                            this._mediaMigrationState
                                              .stateName === nh
                                          )
                                            return void this._logger.zsymb(
                                              0,
                                              10719,
                                              30019,
                                              "[mm] ==========STOP MIGRATION: migration done==========",
                                            );
                                          const e =
                                            this._mediaMigrationState
                                              .mediaTableNamesToMigrate.length >
                                            0
                                              ? this._mediaMigrationState
                                                  .mediaTableNamesToMigrate[0]
                                              : "";
                                          if (!e) {
                                            if (!this._currentJobDescs.length)
                                              return (
                                                this._logger.zsymb(
                                                  0,
                                                  10719,
                                                  30020,
                                                  "[mm] ==========STOP MIGRATION: no media table to migrate==========",
                                                ),
                                                this._stopListenEvents(),
                                                void (await this._mediaMigrationStatePersist.clearPersistedJobDescSummaries())
                                              );
                                            this._logger.zsymb(
                                              0,
                                              10719,
                                              30021,
                                              "[mm] ==========STOP MIGRATION: no media table to migrate, but still have running jobs==========",
                                            );
                                          }
                                          if (
                                            (this._logger.zsymb(
                                              3,
                                              10719,
                                              30022,
                                              "[mm] worker pending: ",
                                              this._worker.pending,
                                            ),
                                            this._logger.zsymb(
                                              3,
                                              10719,
                                              30023,
                                              "[mm] worker size: ",
                                              this._worker.size,
                                            ),
                                            e)
                                          ) {
                                            if (
                                              hu.value %
                                                this._maxWorkerPoolNum ==
                                                0 &&
                                              (await this._waitIn(
                                                this._delayTimeEachKJobs,
                                              ),
                                              this._forceStop ||
                                                !Object(su.a)() ||
                                                Zh())
                                            )
                                              return;
                                            const t = {
                                                id: hu.next(),
                                                state: uh,
                                                currentStep: {
                                                  name: oh,
                                                  dataToRun: {
                                                    mediaTableName: e,
                                                    amount:
                                                      this._mediaNumLimitPerJob,
                                                    lastMsgId:
                                                      this._currentMsgIdCursor,
                                                  },
                                                },
                                              },
                                              s = this._createJob(t);
                                            if (s) {
                                              this._currentJobDescs.push(t);
                                              const e = this._scheduleJob(
                                                t.id,
                                                s,
                                              );
                                              this._worker.add(e);
                                            }
                                          } else if (
                                            !this._currentJobDescs.length
                                          )
                                            return;
                                          this._worker.isPaused &&
                                            this._worker.start();
                                        }
                                        _listenEvents() {
                                          this._application.addEventListener(
                                            V.b.Idle,
                                            this._onApplicationIdle,
                                          ),
                                            this._application.addEventListener(
                                              V.b.Active,
                                              this._onApplicationActive,
                                            ),
                                            this._application.addEventListener(
                                              V.b.Exit,
                                              this._onApplicationExit,
                                            );
                                        }
                                        _stopListenEvents() {
                                          this._application.removeEventListener(
                                            V.b.Idle,
                                            this._onApplicationIdle,
                                          ),
                                            this._application.removeEventListener(
                                              V.b.Active,
                                              this._onApplicationActive,
                                            ),
                                            this._application.removeEventListener(
                                              V.b.Exit,
                                              this._onApplicationExit,
                                            );
                                        }
                                        _onApplicationIdle() {
                                          this._setupMigrationConfig({
                                            maxWorkerPoolNum: Jh(),
                                            mediaNumLimitPerJob: Xh(),
                                            delayTimePerJob: Qh(),
                                            delayTimeEachKJobs: Yh(),
                                            minRetryAfter: eu(),
                                            maxRetryAfter: tu(),
                                          });
                                        }
                                        _onApplicationActive() {
                                          this._setupMigrationConfig({
                                            maxWorkerPoolNum: Jh(),
                                            mediaNumLimitPerJob: Xh(),
                                            delayTimePerJob: Qh(),
                                            delayTimeEachKJobs: Yh(),
                                            minRetryAfter: eu(),
                                            maxRetryAfter: tu(),
                                          });
                                        }
                                        _onApplicationExit() {
                                          this.pauseMigration("EXIT_APP");
                                        }
                                        _toJobDescSummary(e) {
                                          const { currentStep: t } = e;
                                          return {
                                            currentStep: {
                                              name: t.name,
                                              summaryData: {
                                                mediaTableName:
                                                  t.dataToRun.mediaTableName,
                                                amount: t.dataToRun.amount,
                                                lastMsgId:
                                                  t.dataToRun.lastMsgId,
                                              },
                                            },
                                          };
                                        }
                                        _toJobDesc(e) {
                                          let { currentStep: t } = e;
                                          return {
                                            id: hu.next(),
                                            state: uh,
                                            currentStep: {
                                              name: t.name,
                                              dataToRun: Object(f.a)(
                                                Object(f.a)({}, t.summaryData),
                                                {},
                                                { data: void 0 },
                                              ),
                                            },
                                          };
                                        }
                                        _setupMigrationConfig(e) {
                                          "number" ==
                                            typeof e.maxWorkerPoolNum &&
                                            (this._worker.concurrency =
                                              e.maxWorkerPoolNum),
                                            "number" ==
                                              typeof e.mediaNumLimitPerJob &&
                                              (this._mediaNumLimitPerJob =
                                                e.mediaNumLimitPerJob),
                                            "number" ==
                                              typeof e.delayTimePerJob &&
                                              (this._delayTimePerJob =
                                                e.delayTimePerJob),
                                            "number" ==
                                              typeof e.delayTimeEachKJobs &&
                                              (this._delayTimeEachKJobs =
                                                e.delayTimeEachKJobs),
                                            "number" ==
                                              typeof e.minRetryAfter &&
                                              (this._minRetryAfter =
                                                e.minRetryAfter),
                                            "number" ==
                                              typeof e.maxRetryAfter &&
                                              (this._maxRetryAfter =
                                                e.maxRetryAfter);
                                        }
                                        _scheduleJob(e, t) {
                                          return async () =>
                                            new Promise((t) => {
                                              const s = setTimeout(() => {
                                                (this._currentJobHolders =
                                                  this._currentJobHolders.filter(
                                                    (t) => t.jobId !== e,
                                                  )),
                                                  t();
                                              }, 1e3 * this._delayTimePerJob);
                                              this._currentJobHolders.push({
                                                jobId: e,
                                                timeoutId: s,
                                                resolver: t,
                                              });
                                            }).then(() => t());
                                        }
                                        _withRetry(e) {
                                          return (
                                            (t = e),
                                            (s = {
                                              retries: 1 / 0,
                                              min: 1e3 * this._minRetryAfter,
                                              max: 1e3 * this._maxRetryAfter,
                                              shouldRetryOnError: async (e) => {
                                                let {
                                                  error: t,
                                                  currentState: s,
                                                } = e;
                                                return this._forceStop ||
                                                  Zh() ||
                                                  !Object(su.a)()
                                                  ? (this._updateStateOfCurrentJobByJobId(
                                                      t.jobId,
                                                      mh,
                                                    ),
                                                    !1)
                                                  : "UnknownError" === t.name ||
                                                      "QuotaExceededError" ===
                                                        t.name ||
                                                      22 === t.code
                                                    ? (this._updateStateOfCurrentJobByJobId(
                                                        t.jobId,
                                                        mh,
                                                      ),
                                                      this.pauseMigration(
                                                        "DB_ERROR",
                                                      ),
                                                      !1)
                                                    : (this._logger.zsymb(
                                                        21,
                                                        10719,
                                                        30024,
                                                        "[mm]: Retry - jobId: {} - jobType: {} - error: {}",
                                                        t.jobId,
                                                        t.jobType,
                                                        t.message,
                                                      ),
                                                      !0);
                                              },
                                            }),
                                            async function () {
                                              for (
                                                var e = arguments.length,
                                                  i = new Array(e),
                                                  n = 0;
                                                n < e;
                                                n++
                                              )
                                                i[n] = arguments[n];
                                              for await (const {
                                                sleep: r,
                                                duration: o,
                                                nTry: d,
                                              } of du(s))
                                                try {
                                                  const e = await t(...i);
                                                  return (
                                                    null != s &&
                                                      s.afterRetry &&
                                                      (null == s ||
                                                        s.afterRetry({
                                                          nTry: d,
                                                          duration: o,
                                                          sleep: r,
                                                          success: !0,
                                                          shouldRetry: !1,
                                                        })),
                                                    e
                                                  );
                                                } catch (a) {
                                                  const e =
                                                      null != s &&
                                                      s.shouldRetryOnError
                                                        ? null == s
                                                          ? void 0
                                                          : s.shouldRetryOnError
                                                        : () =>
                                                            Promise.resolve(!0),
                                                    t = await e({
                                                      error: a,
                                                      currentState: {
                                                        nTry: d,
                                                        duration: o,
                                                        sleep: r,
                                                      },
                                                      input: i,
                                                    });
                                                  if (
                                                    (null != s &&
                                                      s.afterRetry &&
                                                      (null == s ||
                                                        s.afterRetry({
                                                          nTry: d,
                                                          duration: o,
                                                          sleep: r,
                                                          shouldRetry: t,
                                                          success: !1,
                                                        })),
                                                    !t)
                                                  )
                                                    throw new ou(ru);
                                                  await r();
                                                }
                                              throw new ou(iu);
                                            }
                                          );
                                          var t, s;
                                        }
                                        async _waitIn(e) {
                                          return (
                                            this._logger.zsymb(
                                              3,
                                              10719,
                                              30025,
                                              "[mm]: waiting in {} seconds",
                                              e,
                                            ),
                                            new Promise((t) => {
                                              setTimeout(t, 1e3 * e);
                                            })
                                          );
                                        }
                                        _getTestMediaMigrationFlag(e) {
                                          const t = E.default
                                            .getInstance()
                                            .getItemForCurrentUser(e);
                                          try {
                                            return !!t && JSON.parse(t);
                                          } catch (s) {
                                            return !1;
                                          }
                                        }
                                        _throwDBError() {
                                          const e = new Error(
                                            "[SIMULATE]: DB is corrupted or quota is exceeded!",
                                          );
                                          throw (
                                            ((e.name = "UnknownError"),
                                            (e.code = 22),
                                            e)
                                          );
                                        }
                                      }),
                                    ) || cu),
                                ) || cu),
                            ) || cu),
                        ) || cu),
                    ) || cu),
                ) || cu),
            ) || cu),
        );
        var gu,
          mu = s("zLd2");
        Object(i.injectable)()(
          (gu =
            Object(i.singleton)(mu.c)(
              (gu =
                (function (e, t) {
                  return Object(i.inject)(Gh)(e, void 0, 0);
                })(
                  (gu =
                    (function (e, t) {
                      return Object(i.inject)(q.ZLoggerFactory)(e, void 0, 1);
                    })(
                      (gu =
                        Reflect.metadata(
                          "design:type",
                          Function,
                        )(
                          (gu =
                            Reflect.metadata("design:paramtypes", [
                              Object,
                              void 0 === q.ZLoggerFactory
                                ? Object
                                : q.ZLoggerFactory,
                            ])(
                              (gu = class {
                                constructor(e, t) {
                                  (this._utilsMediaAppService = void 0),
                                    (this._logger = void 0),
                                    (this._log = void 0),
                                    (this._utilsMediaAppService = e),
                                    Pt.a.ConvInfoDataManager.addEventListener(
                                      Zt.b.DeleteConv,
                                      this._onDeleteConversation.bind(this),
                                    ),
                                    Pt.a.ConvInfoDataManager.addEventListener(
                                      Zt.b.EmptyConv,
                                      this._onEmptyConversation.bind(this),
                                    ),
                                    (this._logger = t.createZLogger(mu.b, [
                                      "manage-utils-media-in-ui",
                                    ])),
                                    (this._log = Uh(this._logger));
                                }
                                create(e) {
                                  return this._utilsMediaAppService.create(e);
                                }
                                createOrUpdate(e) {
                                  return this._utilsMediaAppService.createOrUpdate(
                                    e,
                                  );
                                }
                                async createOrUpdateFromMedias(e) {
                                  return this._utilsMediaAppService.createOrUpdateFromMedias(
                                    e,
                                  );
                                }
                                _onDeleteConversation(e) {
                                  const { convId: t } = e;
                                  this._utilsMediaAppService.deleteUtilsMediasByConvId(
                                    t,
                                  );
                                }
                                _onEmptyConversation(e) {
                                  const { convId: t } = e;
                                  this._utilsMediaAppService.deleteUtilsMediasByConvId(
                                    t,
                                  );
                                }
                              }),
                            ) || gu),
                        ) || gu),
                    ) || gu),
                ) || gu),
            ) || gu),
        );
        var pu = s("Mlp7"),
          fu = s("ycTR");
        const vu = (function () {
          const e = new Map();
          return function (t, s, i) {
            const n = `${s}_${i}`;
            if (e.has(n)) return e.get(n);
            const a = Object(fu.a)(s, Aa.AdapterType.IDB),
              r = (
                null == a
                  ? void 0
                  : a.partitionsMap.default.tables.filter(
                      (e) => e.tableName === i,
                    )[0]
              ).getTransformConfigs(Aa.AdapterType.IDB);
            return (
              r.forEach((e) => {
                e.init(t);
              }),
              e.set(n, r),
              r
            );
          };
        })();
        class bu extends class {
          constructor(e, t) {
            (this.dbName = e),
              (this.dbIdentity = t),
              (this.db = void 0),
              (this.logger = void 0),
              (this.db = null),
              (this.dbName = e);
            const s = i.ModuleContainer.resolve(q.ZLoggerFactory);
            this.logger = s.createZLogger(hs.ZLoggerNametags.liteIDB, [
              hs.ZLoggerNametags.liteIDB,
            ]);
          }
          acquireDB() {
            return new Promise(async (e, t) => {
              if (this.db) return e(this.db);
              const s = window.indexedDB.open(this.dbName);
              (s.onsuccess = () => {
                (this.db = s.result), e(this.db);
              }),
                (s.onerror = (e) => {
                  this.logger.zsymb(
                    18,
                    12155,
                    3e4,
                    "open db error",
                    this.dbName,
                    e,
                  ),
                    t(e);
                }),
                (s.onupgradeneeded = (e) => {
                  this.logger.zsymb(0, 12155, 30001, "on db upgrade");
                  const t = Object(fu.a)(this.dbIdentity, Aa.AdapterType.IDB);
                  null == t ||
                    t.partitionsMap.default.tables.map((t) => {
                      let s = {};
                      if (t.isNonFieldlikeEntity) s = { autoIncrement: !0 };
                      else {
                        const e = t.primaryIndex;
                        s = {
                          keyPath: Object(Aa.firstOrArray)(e.getRealFields()),
                          autoIncrement: e.autoIncrement,
                        };
                      }
                      e.target.result.createObjectStore(t.tableName, s);
                    });
                });
            });
          }
          writeTrans(e) {
            return new Promise((t, s) => {
              this.acquireDB().then((i) => {
                const n = i.transaction([e], "readwrite");
                (n.oncomplete = t), (n.onerror = s), t(n);
              });
            });
          }
          async writeStore(e) {
            return (await this.writeTrans(e)).objectStore(e);
          }
        } {
          constructor(e, t, s) {
            super(s, t),
              (this.uin = e),
              (this.transforms = void 0),
              (this.transforms = []);
          }
          toDBTransform(e) {
            if ((Array.isArray(e) || (e = [e]), 0 === this.transforms.length))
              return e;
            return e.map((e) => {
              const t = Object(f.a)({}, e);
              return (
                this.transforms.forEach((e) => {
                  e.toDB(t);
                }),
                t
              );
            });
          }
          add(e, t, s) {
            return new Promise((i) => {
              try {
                const n = e.add(t);
                (n.onsuccess = (e) => {
                  i(s);
                }),
                  (n.onerror = (e) => {
                    var s, n;
                    i(void 0),
                      e.preventDefault(),
                      e.stopPropagation(),
                      0 !==
                        (null === (s = e.target) ||
                        void 0 === s ||
                        null === (n = s.error) ||
                        void 0 === n
                          ? void 0
                          : n.code) &&
                        this.logger.zsymb(
                          18,
                          12155,
                          30002,
                          "import err: ",
                          e,
                          t,
                        );
                  });
              } catch (n) {
                this.logger.zsymb(18, 12155, 30003, "add err", n, t), i(void 0);
              }
            });
          }
          async import(e, t) {
            this.transforms = vu(this.uin, this.dbIdentity, e);
            const s = await this.writeStore(e),
              i = this.toDBTransform(t).reduce(
                (e, i, n) => (e.push(this.add(s, i, t[n])), e),
                [],
              );
            return Promise.all(i).then((e) => ({
              success: e.filter((e) => !!e),
              fail: [],
            }));
          }
          clear() {}
        }
        var Iu,
          yu = new (class {
            constructor() {
              (this.dbInstances = void 0),
                (this.uin = void 0),
                (this.uid = void 0),
                (this.uin = ""),
                (this.uid = ""),
                (this.dbInstances = new Map());
            }
            init(e, t) {
              (this.uid = e), (this.uin = t);
            }
            getDB(e, t) {
              if (!this.dbInstances.has(t)) {
                this.uin;
                const s = new bu(this.uin, e, t);
                this.dbInstances.set(t, s);
              }
              return this.dbInstances.get(t);
            }
            getDBName(e) {
              switch (e) {
                case "Core":
                  return "zdb_" + this.uid;
                case "Res":
                  return "zres_" + this.uid;
                default:
                  return "";
              }
            }
            insert(e, t, s) {
              const i = this.getDB(e, this.getDBName(e));
              return i
                ? i.import(t, s).then((e) => e)
                : Promise.resolve({ success: [], fail: [] });
            }
          })(),
          _u = s("dm9D");
        Object(i.injectable)()(
          (Iu =
            Object(i.singleton)(ps.a)(
              (Iu =
                (function (e, t) {
                  return Object(i.inject)(mu.c)(e, void 0, 0);
                })(
                  (Iu =
                    (function (e, t) {
                      return Object(i.inject)(Ah)(e, void 0, 1);
                    })(
                      (Iu =
                        (function (e, t) {
                          return Object(i.inject)(Dh)(e, void 0, 2);
                        })(
                          (Iu =
                            (function (e, t) {
                              return Object(i.inject)(jc)(e, void 0, 3);
                            })(
                              (Iu =
                                (function (e, t) {
                                  return Object(i.inject)(q.ZLoggerFactory)(
                                    e,
                                    void 0,
                                    4,
                                  );
                                })(
                                  (Iu =
                                    Reflect.metadata(
                                      "design:type",
                                      Function,
                                    )(
                                      (Iu =
                                        Reflect.metadata("design:paramtypes", [
                                          void 0 === mu.IUtilsMediaManager
                                            ? Object
                                            : mu.IUtilsMediaManager,
                                          Object,
                                          Object,
                                          Object,
                                          void 0 === q.ZLoggerFactory
                                            ? Object
                                            : q.ZLoggerFactory,
                                        ])(
                                          (Iu = class {
                                            constructor(e, t, s, i, n) {
                                              (this._utilsMediaManager =
                                                void 0),
                                                (this._mediaMapperFactory =
                                                  void 0),
                                                (this._mediaRepositoryFactory =
                                                  void 0),
                                                (this._mediaPrimaryKeyConvertor =
                                                  void 0),
                                                (this._logger = void 0),
                                                (this._utilsMediaManager = e),
                                                (this._mediaRepositoryFactory =
                                                  t),
                                                (this._mediaMapperFactory = s),
                                                (this._mediaPrimaryKeyConvertor =
                                                  i),
                                                (this._logger = n.createZLogger(
                                                  "media-manager",
                                                  [""],
                                                ));
                                            }
                                            filter(e, t) {
                                              return Object(su.a)()
                                                ? vh.filterMedia(e, t)
                                                : pu.a.filter(e, t);
                                            }
                                            getMediaRepository(e, t) {
                                              void 0 === t && (t = !0);
                                              const s =
                                                this._mediaRepositoryFactory.getMediaRepository(
                                                  e,
                                                );
                                              if (!s && t)
                                                throw Error(
                                                  `[getMediaRepository]: can't get mediaRepository has mediaType: ${e}!`,
                                                );
                                              return s;
                                            }
                                            getMediaMapper(e, t) {
                                              void 0 === t && (t = !0);
                                              const s =
                                                this._mediaMapperFactory.getMediaMapper(
                                                  e,
                                                );
                                              if (!s && t)
                                                throw Error(
                                                  `[getMediaMapper]: can't get mediaMapper has mediaType: ${e}!`,
                                                );
                                              return s;
                                            }
                                            async _isMigrationDone() {
                                              return (
                                                (
                                                  await i.ModuleContainer.resolve(
                                                    _h.c,
                                                  ).getMediaMigrationState()
                                                ).stateName === nh
                                              );
                                            }
                                            async isExistedMedia(e, t) {
                                              try {
                                                if (!e)
                                                  throw Error(
                                                    "mediaType is invalid!",
                                                  );
                                                if (!t)
                                                  throw Error(
                                                    "mediaIdObj is invalid!",
                                                  );
                                                const s =
                                                  this.getMediaRepository(e);
                                                return await s.isExistedMedia({
                                                  newId: t.newId || "",
                                                  oldId: t.oldId || "",
                                                });
                                              } catch (s) {
                                                return (
                                                  this._logger.zsymb(
                                                    18,
                                                    16198,
                                                    3e4,
                                                    `[isExistedMedia]: error: ${s.message}`,
                                                  ),
                                                  !1
                                                );
                                              }
                                            }
                                            async addMedias(e, t, s) {
                                              void 0 === s &&
                                                (s = `${Hc.c.UNKNOWN}${Hc.d.UNKNOWN}`);
                                              try {
                                                if (!e)
                                                  throw Error(
                                                    "mediaType is undefined!",
                                                  );
                                                if (!t || !t.length) return;
                                                const i =
                                                    this.getMediaRepository(e),
                                                  n = this.getMediaMapper(e),
                                                  a = t.map(
                                                    (t) => (
                                                      (t.src = s),
                                                      "image" === e &&
                                                        (t.subType =
                                                          R.MSG_SUBTYPE_MEDIA_DOODLE),
                                                      n.toDomainFromDTO(t)
                                                    ),
                                                  ),
                                                  r = (
                                                    await i.insertMulti(a)
                                                  ).success.map((t) =>
                                                    this.getMediaMapper(
                                                      e,
                                                    ).toMediaToCreateOrUpdateUtilsMediaDTOFromDomain(
                                                      t,
                                                    ),
                                                  );
                                                await this._utilsMediaManager.createOrUpdateFromMedias(
                                                  r,
                                                );
                                              } catch (i) {
                                                this._logger.zsymb(
                                                  21,
                                                  16198,
                                                  30001,
                                                  "[addMedias] - err: {}",
                                                  i.message,
                                                );
                                              }
                                            }
                                            addMediaToConvOnly(e, t) {
                                              var s, i, n;
                                              if (
                                                (void 0 === t &&
                                                  (t = `${Hc.c.UNKNOWN}${Hc.d.UNKNOWN}`),
                                                !Object(su.a)())
                                              )
                                                return pu.a.addMediaToConversationOnly(
                                                  e,
                                                );
                                              let a = [];
                                              if (
                                                null != e &&
                                                null !== (s = e.image) &&
                                                void 0 !== s &&
                                                s.length
                                              ) {
                                                const s =
                                                    this.getMediaRepository(
                                                      "image",
                                                    ),
                                                  i =
                                                    this.getMediaMapper(
                                                      "image",
                                                    );
                                                a.push(
                                                  null == s
                                                    ? void 0
                                                    : s
                                                        .insertMulti(
                                                          e.image.map(
                                                            (e) => (
                                                              (e.src = t),
                                                              i.toDomainFromDTO(
                                                                e,
                                                              )
                                                            ),
                                                          ),
                                                        )
                                                        .then((e) => {
                                                          if (
                                                            e.success.length
                                                          ) {
                                                            const t =
                                                              e.success.map(
                                                                (e) =>
                                                                  this.getMediaMapper(
                                                                    "image",
                                                                  ).toMediaToCreateOrUpdateUtilsMediaDTOFromDomain(
                                                                    e,
                                                                  ),
                                                              );
                                                            this._utilsMediaManager.createOrUpdateFromMedias(
                                                              t,
                                                            );
                                                          }
                                                        }),
                                                );
                                              }
                                              if (
                                                null != e &&
                                                null !== (i = e.link) &&
                                                void 0 !== i &&
                                                i.length
                                              ) {
                                                const s =
                                                    this.getMediaRepository(
                                                      "link",
                                                    ),
                                                  i =
                                                    this.getMediaMapper("link");
                                                a.push(
                                                  null == s
                                                    ? void 0
                                                    : s
                                                        .insertMulti(
                                                          e.link.map((e) => {
                                                            e.src = t;
                                                            return i.toDomainFromDTO(
                                                              e,
                                                            );
                                                          }),
                                                        )
                                                        .then((e) => {
                                                          if (
                                                            e.success.length
                                                          ) {
                                                            const t =
                                                              e.success.map(
                                                                (e) =>
                                                                  this.getMediaMapper(
                                                                    "link",
                                                                  ).toMediaToCreateOrUpdateUtilsMediaDTOFromDomain(
                                                                    e,
                                                                  ),
                                                              );
                                                            this._utilsMediaManager.createOrUpdateFromMedias(
                                                              t,
                                                            );
                                                          }
                                                        }),
                                                );
                                              }
                                              if (
                                                null != e &&
                                                null !== (n = e.file) &&
                                                void 0 !== n &&
                                                n.length
                                              ) {
                                                const s =
                                                    this.getMediaRepository(
                                                      "file",
                                                    ),
                                                  i =
                                                    this.getMediaMapper("file");
                                                a.push(
                                                  s
                                                    .insertMulti(
                                                      e.file.map(
                                                        (e) => (
                                                          (e.src = t),
                                                          i.toDomainFromDTO(e)
                                                        ),
                                                      ),
                                                    )
                                                    .then((e) => {
                                                      if (e.success.length) {
                                                        const t = e.success.map(
                                                          (e) =>
                                                            this.getMediaMapper(
                                                              "file",
                                                            ).toMediaToCreateOrUpdateUtilsMediaDTOFromDomain(
                                                              e,
                                                            ),
                                                        );
                                                        this._utilsMediaManager.createOrUpdateFromMedias(
                                                          t,
                                                        );
                                                      }
                                                    }),
                                                );
                                              }
                                              return Promise.all(a);
                                            }
                                            async deleteMediasById(e, t) {
                                              try {
                                                if (!t)
                                                  throw Error(
                                                    "mediaIdObjs is undefined!",
                                                  );
                                                const r = Array.isArray(t)
                                                  ? [...t]
                                                  : [t];
                                                for (const e of r) {
                                                  const { newId: t, oldId: s } =
                                                    e;
                                                  if (!t && s) {
                                                    const t =
                                                      await this.getMediaFieldsByMsgId(
                                                        s,
                                                      );
                                                    e.newId = t
                                                      ? `${t.cliMsgId}_${t.fromUid}_${t.toUid}`
                                                      : "";
                                                  }
                                                }
                                                const o =
                                                    this.getMediaRepository(
                                                      e,
                                                      !1,
                                                    ),
                                                  d = [];
                                                for (const e of r)
                                                  d.push(
                                                    Object(f.a)(
                                                      Object(f.a)({}, e),
                                                      {},
                                                      {
                                                        deleteTo:
                                                          (await this._isMigrationDone())
                                                            ? ih.NEW
                                                            : ih.UNKNOWN,
                                                      },
                                                    ),
                                                  );
                                                if (o)
                                                  await o.deleteMultiMedias(d);
                                                else {
                                                  var s, n, a;
                                                  const e = [];
                                                  e.push(
                                                    null ===
                                                      (s =
                                                        i.ModuleContainer.resolve(
                                                          Ih,
                                                        )) || void 0 === s
                                                      ? void 0
                                                      : s.deleteMultiMedias(d),
                                                    null ===
                                                      (n =
                                                        i.ModuleContainer.resolve(
                                                          Ch,
                                                        )) || void 0 === n
                                                      ? void 0
                                                      : n.deleteMultiMedias(d),
                                                    null ===
                                                      (a =
                                                        i.ModuleContainer.resolve(
                                                          Sh,
                                                        )) || void 0 === a
                                                      ? void 0
                                                      : a.deleteMultiMedias(d),
                                                  ),
                                                    await Promise.all(e);
                                                }
                                              } catch (r) {
                                                this._logger.zsymb(
                                                  18,
                                                  16198,
                                                  30002,
                                                  r,
                                                );
                                              }
                                            }
                                            async getValidMediasOfConv(
                                              e,
                                              t,
                                              s,
                                              i,
                                              n,
                                            ) {
                                              try {
                                                if (!t)
                                                  return Promise.resolve([]);
                                                const a = {
                                                  cliMsgId:
                                                    R.MessageConstants
                                                      .MAX_MSG_ID,
                                                  sendDttm: parseInt(
                                                    R.MessageConstants
                                                      .MAX_SENDDTTM,
                                                  ),
                                                  msgId:
                                                    i ||
                                                    R.MessageConstants
                                                      .MAX_MSG_ID,
                                                };
                                                if (i) {
                                                  const e =
                                                    await this.getMediaFieldsByMsgId(
                                                      i,
                                                    );
                                                  e &&
                                                    ((a.cliMsgId = e.cliMsgId),
                                                    (a.sendDttm = e.sendDttm));
                                                }
                                                const r =
                                                    pu.a.getLastDeleteConv(
                                                      t,
                                                      e,
                                                    ),
                                                  o =
                                                    this.getMediaRepository(e),
                                                  d = await o.getMediasOfConv(
                                                    t,
                                                    a,
                                                    s,
                                                    Object(f.a)(
                                                      Object(f.a)({}, n),
                                                      {},
                                                      { deletePointOfConv: r },
                                                    ),
                                                  );
                                                if (!d.length) return [];
                                                const l =
                                                  this.getMediaMapper(e);
                                                return await Promise.all(
                                                  d.map((e) => l.toDTO(e)),
                                                );
                                              } catch (a) {
                                                return (
                                                  this._logger.zsymb(
                                                    18,
                                                    16198,
                                                    30003,
                                                    a,
                                                  ),
                                                  Promise.resolve([])
                                                );
                                              }
                                            }
                                            async getLastMediasOfConvWithoutCorrectData(
                                              e,
                                              t,
                                              s,
                                              i,
                                              n,
                                            ) {
                                              if (
                                                (void 0 === i && (i = 100),
                                                !Object(su.a)())
                                              )
                                                return pu.a.getLastMediaFromConversation(
                                                  t,
                                                  e,
                                                  i,
                                                  s,
                                                );
                                              try {
                                                if (!t)
                                                  return Promise.resolve([
                                                    null,
                                                    Error(
                                                      "convId is undefined!",
                                                    ),
                                                  ]);
                                                const a = {
                                                  cliMsgId:
                                                    R.MessageConstants
                                                      .MAX_MSG_ID,
                                                  sendDttm: parseInt(
                                                    R.MessageConstants
                                                      .MAX_SENDDTTM,
                                                  ),
                                                  msgId:
                                                    s ||
                                                    bt.default.load_media
                                                      .use_max_id ||
                                                    R.MessageConstants
                                                      .MAX_MSG_ID,
                                                };
                                                if (null != n && n.lastItemOpts)
                                                  (a.cliMsgId =
                                                    n.lastItemOpts.cliMsgId),
                                                    (a.sendDttm =
                                                      n.lastItemOpts.sendDttm);
                                                else if (s) {
                                                  const e =
                                                    await this.getMediaFieldsByMsgId(
                                                      s,
                                                    );
                                                  e &&
                                                    ((a.cliMsgId = e.cliMsgId),
                                                    (a.sendDttm = e.sendDttm));
                                                }
                                                const r =
                                                    this.getMediaRepository(e),
                                                  o =
                                                    await r.getLastMediasOfConv(
                                                      t,
                                                      a,
                                                      i,
                                                    );
                                                return [
                                                  await Promise.all(
                                                    o.map((t) =>
                                                      this.getMediaMapper(
                                                        e,
                                                      ).toDTO(t),
                                                    ),
                                                  ),
                                                  null,
                                                ];
                                              } catch (a) {
                                                return (
                                                  this._logger.zsymb(
                                                    18,
                                                    16198,
                                                    30004,
                                                    a,
                                                  ),
                                                  [null, a]
                                                );
                                              }
                                            }
                                            async updateMedia(e, t, s, i) {
                                              if (!Object(su.a)()) {
                                                const n = Object(f.a)(
                                                  Object(f.a)({}, s),
                                                  {},
                                                  { msgId: t },
                                                );
                                                return pu.a.updateMedia(
                                                  n,
                                                  e,
                                                  i,
                                                );
                                              }
                                              return this._updateMedia(
                                                e,
                                                t,
                                                s,
                                                i,
                                              );
                                            }
                                            loadingPendingMedias() {
                                              return Object(su.a)()
                                                ? new Promise((e, t) => {
                                                    let s =
                                                      Ee.default.getAllPendingMediaIds();
                                                    if (
                                                      (this._logger.zsymb(
                                                        3,
                                                        16198,
                                                        30005,
                                                        "[loadingPendingMedias]: {}",
                                                        JSON.stringify(s),
                                                      ),
                                                      s &&
                                                        Ct.default.mapHasItem(
                                                          s,
                                                        ))
                                                    ) {
                                                      let t = {};
                                                      for (let e in s)
                                                        t[e] =
                                                          this.getMultiMedias(
                                                            e,
                                                            s[e],
                                                          );
                                                      Ct.default
                                                        .join(t)
                                                        .then(e)
                                                        .catch((t) => {
                                                          e(null);
                                                        });
                                                    } else e(null);
                                                  })
                                                : pu.a.loadAllPendingMedia();
                                            }
                                            async countMediaOfConv(e, t, s) {
                                              try {
                                                t ||
                                                  Promise.resolve({
                                                    ok: !0,
                                                    result: 0,
                                                    error: null,
                                                  });
                                                const { from: i, to: n } = s;
                                                (i.cliMsgId = i.cliMsgId
                                                  ? i.cliMsgId
                                                  : ""),
                                                  (i.sendDttm = i.sendDttm
                                                    ? i.sendDttm
                                                    : 0),
                                                  (i.msgId = i.msgId
                                                    ? i.msgId
                                                    : ""),
                                                  (n.cliMsgId = n.cliMsgId
                                                    ? n.cliMsgId
                                                    : R.MessageConstants
                                                        .MAX_MSG_ID),
                                                  (n.sendDttm = n.sendDttm
                                                    ? n.sendDttm
                                                    : parseInt(
                                                        R.MessageConstants
                                                          .MAX_SENDDTTM,
                                                      )),
                                                  (n.msgId = n.msgId
                                                    ? n.msgId
                                                    : R.MessageConstants
                                                        .MAX_MSG_ID);
                                                const a =
                                                  this.getMediaRepository(e);
                                                return {
                                                  ok: !0,
                                                  result:
                                                    await a.countMediaOfConv(
                                                      t,
                                                      {
                                                        from: Object(f.a)(
                                                          {},
                                                          i,
                                                        ),
                                                        to: Object(f.a)({}, n),
                                                      },
                                                    ),
                                                  error: null,
                                                };
                                              } catch (i) {
                                                return (
                                                  this._logger.zsymb(
                                                    18,
                                                    16198,
                                                    30006,
                                                    i,
                                                  ),
                                                  {
                                                    ok: !1,
                                                    result: 0,
                                                    error: i,
                                                  }
                                                );
                                              }
                                            }
                                            async getMediaFieldsByMsgId(e) {
                                              if (!e)
                                                return Promise.resolve(void 0);
                                              const t = await K.default
                                                .getInstance()
                                                .Core.Message.get(e);
                                              return t
                                                ? {
                                                    cliMsgId:
                                                      "number" ==
                                                      typeof t.cliMsgId
                                                        ? t.cliMsgId.toString()
                                                        : t.cliMsgId,
                                                    fromUid: t.fromUid,
                                                    toUid: t.toUid,
                                                    sendDttm:
                                                      "string" ==
                                                      typeof t.sendDttm
                                                        ? parseInt(t.sendDttm)
                                                        : t.sendDttm,
                                                  }
                                                : Promise.resolve(void 0);
                                            }
                                            async getAllValidPhotoAndVideosOfConv(
                                              e,
                                            ) {
                                              if (!Object(su.a)())
                                                return pu.a.getAllMediaFromConv(
                                                  e,
                                                );
                                              let t = !0,
                                                s = {
                                                  cliMsgId:
                                                    R.MessageConstants
                                                      .MAX_MSG_ID,
                                                  sendDttm: parseInt(
                                                    R.MessageConstants
                                                      .MAX_SENDDTTM,
                                                  ),
                                                  msgId:
                                                    R.MessageConstants
                                                      .MAX_MSG_ID,
                                                },
                                                i = [],
                                                n = [];
                                              for (; t; ) {
                                                const a =
                                                  await this.getValidMediasOfConv(
                                                    "image",
                                                    e,
                                                    50,
                                                    s.msgId,
                                                  );
                                                t = a.length >= 50;
                                                let r = s;
                                                if (a.length) {
                                                  if (
                                                    (a.forEach((e) => {
                                                      e &&
                                                      e.subType ==
                                                        R.MSG_SUBTYPE_MEDIA_VIDEO
                                                        ? i.push(e)
                                                        : !e ||
                                                          (e.subType !=
                                                            R.MSG_SUBTYPE_PHOTO &&
                                                            e.subType !==
                                                              R.MSG_SUBTYPE_MEDIA_DOODLE) ||
                                                          n.push(e);
                                                    }),
                                                    (r = {
                                                      cliMsgId:
                                                        a[a.length - 1]
                                                          .cliMsgId,
                                                      sendDttm:
                                                        a[a.length - 1]
                                                          .sendDttm,
                                                      msgId:
                                                        a[a.length - 1].msgId,
                                                    }),
                                                    r.msgId == s.msgId)
                                                  )
                                                    break;
                                                  s = r;
                                                }
                                              }
                                              return { photos: n, videos: i };
                                            }
                                            async getImageMessagesForPhotoViewer(
                                              e,
                                              t,
                                              s,
                                              n,
                                              a,
                                              r,
                                            ) {
                                              if (!Object(su.a)())
                                                return Ee.default.getImagesForPhotoViewer(
                                                  { userId: e },
                                                  t,
                                                  s,
                                                  n,
                                                  a,
                                                  r,
                                                );
                                              try {
                                                var o;
                                                if (!e || !t)
                                                  throw Error(
                                                    "convId or lastMsgId is undefined!",
                                                  );
                                                const d =
                                                  await this.getMediaFieldsByMsgId(
                                                    t,
                                                  );
                                                return await (null ===
                                                  (o =
                                                    i.ModuleContainer.resolve(
                                                      Ih,
                                                    )) || void 0 === o
                                                  ? void 0
                                                  : o.getImageMessagesForPhotoViewer(
                                                      e,
                                                      s,
                                                      {
                                                        sendDttm:
                                                          (null == d
                                                            ? void 0
                                                            : d.sendDttm) ||
                                                          parseInt(
                                                            R.MessageConstants
                                                              .MAX_SENDDTTM,
                                                          ),
                                                        cliMsgId:
                                                          (null == d
                                                            ? void 0
                                                            : d.cliMsgId) ||
                                                          R.MessageConstants
                                                            .MAX_MSG_ID,
                                                        msgId: t,
                                                      },
                                                      n,
                                                      a,
                                                      r,
                                                    ));
                                              } catch (d) {
                                                return (
                                                  this._logger.zsymb(
                                                    18,
                                                    16198,
                                                    30007,
                                                    d,
                                                  ),
                                                  []
                                                );
                                              }
                                            }
                                            async getLastestAddedFiles(e, t) {
                                              if (
                                                (void 0 === t && (t = 40),
                                                !Object(su.a)())
                                              )
                                                return Ee.default.getLatestFiles(
                                                  e,
                                                  t,
                                                );
                                              try {
                                                if (!e) {
                                                  e = Date.now();
                                                  let t =
                                                    _t.default.getTimeNow();
                                                  e = e > t ? e : t;
                                                }
                                                const s =
                                                    R.MessageConstants
                                                      .MAX_CONVERSATION_ID,
                                                  n = parseInt(
                                                    R.MessageConstants
                                                      .MAX_MSG_ID,
                                                  ),
                                                  a =
                                                    i.ModuleContainer.resolve(
                                                      Ch,
                                                    ),
                                                  r =
                                                    await a.getLastestAddedFiles(
                                                      {
                                                        convId: s,
                                                        sendDttm: e,
                                                        cliMsgId: n,
                                                      },
                                                      t,
                                                    );
                                                if (r.length > 0) {
                                                  const e =
                                                    this.getMediaMapper("file");
                                                  return await Promise.all(
                                                    r.map((t) => e.toDTO(t)),
                                                  );
                                                }
                                                return [];
                                              } catch (s) {
                                                return (
                                                  this._logger.zsymb(
                                                    18,
                                                    16198,
                                                    30008,
                                                    "[getLastestAddedFiles] - err: ",
                                                    s,
                                                  ),
                                                  Promise.resolve([])
                                                );
                                              }
                                            }
                                            async getMultiMedias(e, t) {
                                              if (!Object(su.a)())
                                                return Ee.default.getMediaByIds(
                                                  e,
                                                  t,
                                                );
                                              try {
                                                if (!t || t.length < 0)
                                                  throw Error(
                                                    "msgIds is undefined or empty!",
                                                  );
                                                const s = [],
                                                  i = t.map((e) =>
                                                    this.getMediaFieldsByMsgId(
                                                      e,
                                                    ).then(async (t) => {
                                                      s.push({
                                                        newId: t
                                                          ? `${t.cliMsgId}_${t.fromUid}_${t.toUid}`
                                                          : "",
                                                        oldId: e,
                                                        getFrom:
                                                          (await this._isMigrationDone())
                                                            ? sh.NEW
                                                            : sh.UNKNOWN,
                                                      });
                                                    }),
                                                  );
                                                if (
                                                  (await Promise.all(i),
                                                  !s.length)
                                                )
                                                  return [];
                                                const n = (
                                                  await this.getMediaRepository(
                                                    e,
                                                  ).getMultiMedias(s)
                                                ).filter(Boolean);
                                                return n.length > 0
                                                  ? await Promise.all(
                                                      n.map((t) =>
                                                        this.getMediaMapper(
                                                          e,
                                                        ).toDTO(t),
                                                      ),
                                                    )
                                                  : [];
                                              } catch (s) {
                                                return (
                                                  this._logger.zsymb(
                                                    18,
                                                    16198,
                                                    30009,
                                                    "[getMultiMedias] - err: ",
                                                    s,
                                                  ),
                                                  []
                                                );
                                              }
                                            }
                                            async getMediaById(e, t) {
                                              try {
                                                if (!t)
                                                  throw Error(
                                                    "mediaId is undefined!",
                                                  );
                                                const s =
                                                    await this.getMediaFieldsByMsgId(
                                                      t,
                                                    ),
                                                  i =
                                                    this.getMediaRepository(e),
                                                  n = await i.getMedia(
                                                    {
                                                      newId: s
                                                        ? `${s.cliMsgId}_${s.fromUid}_${s.toUid}`
                                                        : "",
                                                      oldId: t,
                                                    },
                                                    void 0,
                                                    (await this._isMigrationDone())
                                                      ? sh.NEW
                                                      : sh.UNKNOWN,
                                                  );
                                                return n
                                                  ? await this.getMediaMapper(
                                                      e,
                                                    ).toDTO(n)
                                                  : void 0;
                                              } catch (s) {
                                                return (
                                                  this._logger.zsymb(
                                                    18,
                                                    16198,
                                                    30010,
                                                    "[getMediaById] - err: ",
                                                    s,
                                                  ),
                                                  Promise.resolve(void 0)
                                                );
                                              }
                                            }
                                            async _updateMedia(e, t, s, i) {
                                              try {
                                                if (!t)
                                                  throw Error(
                                                    "mediaId isn't valid!",
                                                  );
                                                if (!s)
                                                  throw Error(
                                                    "mediaValue isn't valid!",
                                                  );
                                                const i =
                                                    this.getMediaRepository(e),
                                                  n =
                                                    await this._mediaPrimaryKeyConvertor.toMediaPKFromMessagePK(
                                                      t,
                                                    ),
                                                  a =
                                                    this.getMediaMapper(
                                                      e,
                                                    ).toNewEAttsFromDTOAtts(s);
                                                return await i.updateMedia(
                                                  { newId: n, oldId: t },
                                                  {
                                                    attributes: Object.keys(a),
                                                    value: a,
                                                    ignoreNotFound: !0,
                                                  },
                                                  (await this._isMigrationDone())
                                                    ? th.NEW
                                                    : th.UNKNOWN,
                                                );
                                              } catch (n) {
                                                return (
                                                  this._logger.zsymb(
                                                    21,
                                                    16198,
                                                    30011,
                                                    "[_updateMedia] - err: {}",
                                                    n.message,
                                                  ),
                                                  !1
                                                );
                                              }
                                            }
                                            async _addMediasWhenTransferMessageOldFlow(
                                              e,
                                            ) {
                                              try {
                                                const t = [],
                                                  s = [],
                                                  i = [];
                                                for (
                                                  let a = 0;
                                                  a < e.length;
                                                  a++
                                                ) {
                                                  const n = e[a],
                                                    r = n.msgType;
                                                  switch (r) {
                                                    case R.MSG_PHOTO:
                                                    case R.MSG_PHOTO_2:
                                                    case R.MSG_DOODLE:
                                                      r == R.MSG_DOODLE &&
                                                        n.message &&
                                                        (n.message.thumbUrl =
                                                          n.message.oriUrl),
                                                        Object(_u.a)(n) ||
                                                          Ct.default.isPhotoStickerMessage(
                                                            n,
                                                          ) ||
                                                          s.push({
                                                            msgId: n.msgId,
                                                            userId: n.toUid,
                                                            message: n.message,
                                                            sendDttm:
                                                              n.sendDttm,
                                                            fromUid: n.fromUid,
                                                            subType:
                                                              R.MSG_SUBTYPE_PHOTO,
                                                            type: "image",
                                                            ttl: n.ttl,
                                                            cliMsgId:
                                                              n.cliMsgId,
                                                          });
                                                      break;
                                                    case R.MSG_FILE:
                                                      t.push({
                                                        msgId: n.msgId,
                                                        userId: n.toUid,
                                                        message: n.message,
                                                        sendDttm: n.sendDttm,
                                                        fromUid: n.fromUid,
                                                        type: "file",
                                                        ttl: n.ttl,
                                                        cliMsgId: n.cliMsgId,
                                                      });
                                                      break;
                                                    case R.MSG_CONTACT:
                                                      "recommened.link" ===
                                                        n.message.action &&
                                                        i.push({
                                                          msgId: n.msgId,
                                                          userId: n.toUid,
                                                          message: n.message,
                                                          sendDttm: n.sendDttm,
                                                          fromUid: n.fromUid,
                                                          type: "link",
                                                          ttl: n.ttl,
                                                          cliMsgId: n.cliMsgId,
                                                        });
                                                      break;
                                                    case R.MSG_VIDEO:
                                                      s.push({
                                                        msgId: n.msgId,
                                                        userId: n.toUid,
                                                        message: n.message,
                                                        sendDttm: n.sendDttm,
                                                        fromUid: n.fromUid,
                                                        subType:
                                                          R.MSG_SUBTYPE_MEDIA_VIDEO,
                                                        type: "image",
                                                        ttl: n.ttl,
                                                        cliMsgId: n.cliMsgId,
                                                      });
                                                  }
                                                }
                                                let n = [];
                                                return (
                                                  s.length > 0 &&
                                                    n.push(
                                                      yu.insert(
                                                        "Core",
                                                        "image",
                                                        s,
                                                      ),
                                                    ),
                                                  i.length > 0 &&
                                                    n.push(
                                                      yu.insert(
                                                        "Core",
                                                        "link",
                                                        i,
                                                      ),
                                                    ),
                                                  t.length > 0 &&
                                                    n.push(
                                                      yu.insert(
                                                        "Core",
                                                        "file",
                                                        t,
                                                      ),
                                                    ),
                                                  await Promise.all(n)
                                                );
                                              } catch (t) {
                                                this._logger.zsymb(
                                                  18,
                                                  16198,
                                                  30012,
                                                  "[_addMediasWhenTransferMessageOldFlow] - err: ",
                                                  t.message,
                                                );
                                              }
                                            }
                                            async _addMediasFromMessages(e, t) {
                                              try {
                                                if (!e || !e.length) return;
                                                t =
                                                  t ||
                                                  `${Hc.c.UNKNOWN}${Hc.d.FROM_MSG}`;
                                                const s = [],
                                                  i = [],
                                                  n = [],
                                                  a =
                                                    this.getMediaMapper(
                                                      "image",
                                                    ),
                                                  r =
                                                    this.getMediaMapper("file"),
                                                  o =
                                                    this.getMediaMapper("link");
                                                e.forEach((e) => {
                                                  const d = e.msgType;
                                                  switch (d) {
                                                    case R.MSG_PHOTO:
                                                    case R.MSG_PHOTO_2:
                                                    case R.MSG_DOODLE:
                                                      d === R.MSG_DOODLE
                                                        ? (e.message &&
                                                            (e.message.thumbUrl =
                                                              e.message.oriUrl),
                                                          s.push(
                                                            a.toDomainFromTMessage(
                                                              e,
                                                              R.MSG_SUBTYPE_MEDIA_DOODLE,
                                                              t,
                                                            ),
                                                          ))
                                                        : Object(_u.a)(e) ||
                                                          Ct.default.isPhotoStickerMessage(
                                                            e,
                                                          ) ||
                                                          s.push(
                                                            a.toDomainFromTMessage(
                                                              e,
                                                              R.MSG_SUBTYPE_PHOTO,
                                                              t,
                                                            ),
                                                          );
                                                      break;
                                                    case R.MSG_FILE:
                                                      i.push(
                                                        r.toDomainFromMessage(
                                                          e,
                                                          t,
                                                        ),
                                                      );
                                                      break;
                                                    case R.MSG_CONTACT:
                                                      "recommened.link" ===
                                                        e.message.action &&
                                                        n.push(
                                                          o.toDomainFromMessage(
                                                            e,
                                                            t,
                                                          ),
                                                        );
                                                      break;
                                                    case R.MSG_VIDEO:
                                                      s.push(
                                                        a.toDomainFromTMessage(
                                                          e,
                                                          R.MSG_SUBTYPE_MEDIA_VIDEO,
                                                          t,
                                                        ),
                                                      );
                                                  }
                                                });
                                                let d = [];
                                                return (
                                                  s.length > 0 &&
                                                    d.push(
                                                      this.getMediaRepository(
                                                        "image",
                                                      )
                                                        .insertMulti(s)
                                                        .then((e) => {
                                                          if (
                                                            e.success.length
                                                          ) {
                                                            const t =
                                                              e.success.map(
                                                                (e) =>
                                                                  this.getMediaMapper(
                                                                    "image",
                                                                  ).toMediaToCreateOrUpdateUtilsMediaDTOFromDomain(
                                                                    e,
                                                                  ),
                                                              );
                                                            this._utilsMediaManager.createOrUpdateFromMedias(
                                                              t,
                                                            );
                                                          }
                                                        }),
                                                    ),
                                                  i.length > 0 &&
                                                    d.push(
                                                      this.getMediaRepository(
                                                        "file",
                                                      )
                                                        .insertMulti(i)
                                                        .then((e) => {
                                                          if (
                                                            e.success.length
                                                          ) {
                                                            const t =
                                                              e.success.map(
                                                                (e) =>
                                                                  this.getMediaMapper(
                                                                    "file",
                                                                  ).toMediaToCreateOrUpdateUtilsMediaDTOFromDomain(
                                                                    e,
                                                                  ),
                                                              );
                                                            this._utilsMediaManager.createOrUpdateFromMedias(
                                                              t,
                                                            );
                                                          }
                                                        }),
                                                    ),
                                                  n.length > 0 &&
                                                    d.push(
                                                      this.getMediaRepository(
                                                        "link",
                                                      )
                                                        .insertMulti(n)
                                                        .then((e) => {
                                                          if (
                                                            e.success.length
                                                          ) {
                                                            const t =
                                                              e.success.map(
                                                                (e) =>
                                                                  this.getMediaMapper(
                                                                    "link",
                                                                  ).toMediaToCreateOrUpdateUtilsMediaDTOFromDomain(
                                                                    e,
                                                                  ),
                                                              );
                                                            this._utilsMediaManager.createOrUpdateFromMedias(
                                                              t,
                                                            );
                                                          }
                                                        }),
                                                    ),
                                                  await Promise.all(d)
                                                );
                                              } catch (s) {
                                                this._logger.zsymb(
                                                  21,
                                                  16198,
                                                  30013,
                                                  "[addMediasFromMessages] - err: {}",
                                                  JSON.stringify(s),
                                                );
                                              }
                                            }
                                            async _addMediasAtExportImportFlowOldFlow(
                                              e,
                                            ) {
                                              if (!e || !e.length) return;
                                              const t = [],
                                                s = [],
                                                i = [];
                                              e.forEach((e) => {
                                                if (e.msgType === R.MSG_FILE)
                                                  s.push({
                                                    msgId: e.msgId,
                                                    userId: e.toUid,
                                                    message: e.message,
                                                    sendDttm: e.sendDttm,
                                                    localPath: e.localPath,
                                                    fromUid: e.fromUid,
                                                    type: "file",
                                                    ttl: e.ttl,
                                                  });
                                                else if (
                                                  e.msgType === R.MSG_CONTACT
                                                )
                                                  "recommened.link" ===
                                                    e.message.action &&
                                                    i.push({
                                                      msgId: e.msgId,
                                                      userId: e.toUid,
                                                      message: e.message,
                                                      sendDttm: e.sendDttm,
                                                      fromUid: e.fromUid,
                                                      type: "link",
                                                      ttl: e.ttl,
                                                    });
                                                else if (
                                                  (e.msgType !== R.MSG_PHOTO &&
                                                    e.msgType !==
                                                      R.MSG_PHOTO_2 &&
                                                    e.msgType !==
                                                      R.MSG_DOODLE) ||
                                                  Object(_u.a)(e) ||
                                                  Ct.default.isPhotoStickerMessage(
                                                    e,
                                                  )
                                                )
                                                  e.msgType === R.MSG_VIDEO &&
                                                    t.push({
                                                      msgId: e.msgId,
                                                      userId: e.toUid,
                                                      message: e.message,
                                                      sendDttm: e.sendDttm,
                                                      fromUid: e.fromUid,
                                                      type: "image",
                                                      subType:
                                                        R.MSG_SUBTYPE_MEDIA_VIDEO,
                                                      ttl: e.ttl,
                                                    });
                                                else {
                                                  const s = {
                                                    msgId: e.msgId,
                                                    userId: e.toUid,
                                                    message: e.message,
                                                    sendDttm: e.sendDttm,
                                                    fromUid: e.fromUid,
                                                    type: "image",
                                                    subType:
                                                      R.MSG_SUBTYPE_PHOTO,
                                                    ttl: e.ttl,
                                                  };
                                                  e.msgType === R.MSG_DOODLE &&
                                                    ((s.subType =
                                                      R.MSG_SUBTYPE_MEDIA_DOODLE),
                                                    (s.message.thumbUrl =
                                                      s.message.oriUrl)),
                                                    t.push(s);
                                                }
                                              }),
                                                s.length &&
                                                  Ee.default.addFilesToConversation(
                                                    s,
                                                  ),
                                                i.length &&
                                                  Ee.default.addLinksToConversation(
                                                    i,
                                                  ),
                                                t.length &&
                                                  Ee.default.addOrUpdateImagesToConversation(
                                                    t,
                                                  );
                                            }
                                            async _addMediasFromMessagesWhenBackupOldFlow(
                                              e,
                                            ) {
                                              if (!e || !e.length) return;
                                              const t = [],
                                                s = [],
                                                i = [];
                                              e.forEach((e) => {
                                                e.msgType === R.MSG_FILE
                                                  ? s.push({
                                                      msgId: e.msgId,
                                                      userId: e.toUid,
                                                      message: e.message,
                                                      sendDttm: e.sendDttm,
                                                      localPath: e.localPath,
                                                      fromUid: e.fromUid,
                                                      ttl: e.ttl,
                                                    })
                                                  : e.msgType ===
                                                        R.MSG_CONTACT &&
                                                      "recommened.link" ===
                                                        e.message.action
                                                    ? i.push({
                                                        msgId: e.msgId,
                                                        userId: e.toUid,
                                                        message: e.message,
                                                        sendDttm: e.sendDttm,
                                                        fromUid: e.fromUid,
                                                        ttl: e.ttl,
                                                      })
                                                    : (e.msgType !==
                                                        R.MSG_PHOTO &&
                                                        e.msgType !==
                                                          R.MSG_PHOTO_2 &&
                                                        e.msgType !==
                                                          R.MSG_DOODLE) ||
                                                      Object(_u.a)(e) ||
                                                      Ct.default.isPhotoStickerMessage(
                                                        e,
                                                      ) ||
                                                      t.push({
                                                        msgId: e.msgId,
                                                        userId: e.toUid,
                                                        message: e.message,
                                                        sendDttm: e.sendDttm,
                                                        fromUid: e.fromUid,
                                                        ttl: e.ttl,
                                                      });
                                              }),
                                                s.length &&
                                                  Ee.default.addFilesToConversation(
                                                    s,
                                                  ),
                                                i.length &&
                                                  Ee.default.addLinksToConversation(
                                                    i,
                                                  ),
                                                t.length &&
                                                  Ee.default.addOrUpdateImagesToConversation(
                                                    t,
                                                  );
                                            }
                                            async _emptyOldMediaStore(e, t) {
                                              const s = {
                                                  from: [t, 0, ""],
                                                  to: [
                                                    t,
                                                    R.MessageConstants
                                                      .MAX_MSG_ID.length,
                                                    R.MessageConstants
                                                      .MAX_MSG_ID,
                                                  ],
                                                  excludeFrom: !1,
                                                  excludeTo: !1,
                                                },
                                                i = {
                                                  index:
                                                    "userId_sendDttm_msgId",
                                                  direction:
                                                    Aa.CursorDirection.PREV,
                                                },
                                                n = await e.getAllKey(s, i);
                                              null != n &&
                                                n.length &&
                                                (await e.deleteMulti(n));
                                            }
                                            async _emptyNewMediaStore(e, t) {
                                              const s = {
                                                  from: [t, 0, ""],
                                                  to: [
                                                    t,
                                                    parseInt(
                                                      R.MessageConstants
                                                        .MAX_SENDDTTM,
                                                    ),
                                                    R.MessageConstants
                                                      .MAX_MSG_ID,
                                                  ],
                                                  excludeFrom: !1,
                                                  excludeTo: !1,
                                                },
                                                i = {
                                                  index:
                                                    "convId_sendDttm_cliMsgId",
                                                  direction:
                                                    Aa.CursorDirection.PREV,
                                                },
                                                n = await e.getAllKey(s, i);
                                              null != n &&
                                                n.length &&
                                                (await e.deleteMulti(n));
                                            }
                                            async updateFile(e, t, s) {
                                              return Object(su.a)()
                                                ? this._updateMedia(
                                                    "file",
                                                    e,
                                                    t,
                                                    s,
                                                  )
                                                : !!(await Ee.default.updateFile(
                                                    e,
                                                    t,
                                                    s,
                                                  ));
                                            }
                                            async getMediaFromConversationWhenDownloadOldMedia(
                                              e,
                                              t,
                                              s,
                                              i,
                                            ) {
                                              if (!Object(su.a)())
                                                return pu.a.getMediaFromConversation(
                                                  { userId: e },
                                                  i,
                                                  t,
                                                  s,
                                                );
                                              const n = i.substring(
                                                  0,
                                                  i.length - 1,
                                                ),
                                                a =
                                                  await this.getValidMediasOfConv(
                                                    n,
                                                    e,
                                                    t,
                                                    s,
                                                    null,
                                                  );
                                              return a.length > 0
                                                ? a.map((e) => ({
                                                    userId: e.userId,
                                                    sendDttm: e.sendDttm,
                                                    msgId: e.msgId,
                                                    message: {
                                                      href: e.message.href,
                                                      params:
                                                        e.message.params || "",
                                                    },
                                                    type: e.type,
                                                    subType:
                                                      "image" === e.type
                                                        ? e.subType
                                                        : -1,
                                                  }))
                                                : [];
                                            }
                                            getMediaFromConversation(
                                              e,
                                              t,
                                              s,
                                              i,
                                              n,
                                            ) {
                                              if (!Object(su.a)())
                                                return pu.a.getMediaFromConversation(
                                                  { userId: t },
                                                  e,
                                                  s,
                                                  i,
                                                  n,
                                                );
                                              const a = e.substring(
                                                0,
                                                e.length - 1,
                                              );
                                              return this.getValidMediasOfConv(
                                                a,
                                                t,
                                                s,
                                                i,
                                                n,
                                              );
                                            }
                                            async deleteMediaWhenDeleteMsg(
                                              e,
                                              t,
                                            ) {
                                              if (!Object(su.a)())
                                                return void Ee.default.deleteMediaItem(
                                                  e,
                                                );
                                              let s = "";
                                              if (null != t && t.mediaIdKeys) {
                                                const {
                                                  cliMsgId: e,
                                                  fromUid: i,
                                                  convId: n,
                                                } = t.mediaIdKeys;
                                                s = `${e}_${i}_${n}`;
                                              } else
                                                s =
                                                  await this._mediaPrimaryKeyConvertor.toMediaPKFromMessagePK(
                                                    e,
                                                  );
                                              this.deleteMediasById("", {
                                                newId: s,
                                                oldId: e,
                                              });
                                            }
                                            async deleteMediaItems(e, t, s) {
                                              if (!t) return [];
                                              if (!Object(su.a)())
                                                return pu.a.deleteMediaItem(
                                                  t,
                                                  e,
                                                );
                                              let i = [];
                                              i =
                                                null != s &&
                                                s.mediaIdKeysArr &&
                                                s.mediaIdKeysArr.length
                                                  ? s.mediaIdKeysArr.map(
                                                      (e) =>
                                                        `${e.cliMsgId}_${e.fromUid}_${e.convId}`,
                                                    )
                                                  : await Promise.all(
                                                      t.map((e) =>
                                                        this._mediaPrimaryKeyConvertor.toMediaPKFromMessagePK(
                                                          e,
                                                        ),
                                                      ),
                                                    );
                                              const n = t.map((e, t) => ({
                                                oldId: e,
                                                newId: i[t],
                                              }));
                                              return this.deleteMediasById(
                                                e,
                                                n,
                                              );
                                            }
                                            async addLinksToConversation(e) {
                                              Object(su.a)()
                                                ? this.addMedias("link", e)
                                                : Ee.default.addLinksToConversation(
                                                    e,
                                                  );
                                            }
                                            async getFilesFromConversation(
                                              e,
                                              t,
                                              s,
                                            ) {
                                              return Object(su.a)()
                                                ? this.getValidMediasOfConv(
                                                    "file",
                                                    e,
                                                    t,
                                                    s,
                                                    null,
                                                  )
                                                : Ee.default.getFilesFromConversation(
                                                    { userId: e },
                                                    t,
                                                    s,
                                                  );
                                            }
                                            async addMediasWhenTransferMessage(
                                              e,
                                              t,
                                              s,
                                            ) {
                                              return s
                                                ? this._addMediasFromMessages(
                                                    e,
                                                    t,
                                                  )
                                                : this._addMediasWhenTransferMessageOldFlow(
                                                    e,
                                                  );
                                            }
                                            async addMediasAtExportImportFlow(
                                              e,
                                              t,
                                            ) {
                                              return Object(su.a)()
                                                ? this._addMediasFromMessages(
                                                    e,
                                                    t,
                                                  )
                                                : this._addMediasAtExportImportFlowOldFlow(
                                                    e,
                                                  );
                                            }
                                            async addMediasFromMessagesWhenBackup(
                                              e,
                                              t,
                                            ) {
                                              return Object(su.a)()
                                                ? this._addMediasFromMessages(
                                                    e,
                                                    t,
                                                  )
                                                : this._addMediasFromMessagesWhenBackupOldFlow(
                                                    e,
                                                  );
                                            }
                                            async deleteImageByMsgId(e, t) {
                                              if (!Object(su.a)())
                                                return Ee.default.deleteImageByMsgId(
                                                  e,
                                                );
                                              let s = "";
                                              return (
                                                (s =
                                                  null != t && t.mediaIdKeys
                                                    ? `${t.mediaIdKeys.cliMsgId}_${t.mediaIdKeys.fromUid}_${t.mediaIdKeys.convId}`
                                                    : await this._mediaPrimaryKeyConvertor.toMediaPKFromMessagePK(
                                                        e,
                                                      )),
                                                await this.deleteMediasById(
                                                  "image",
                                                  { newId: s, oldId: e },
                                                ),
                                                !0
                                              );
                                            }
                                            async doAddMediaToConversation(
                                              e,
                                              t,
                                            ) {
                                              return Object(su.a)()
                                                ? this.addMedias(e, t)
                                                : pu.a.doAddMediaToConversation(
                                                    t,
                                                    e,
                                                  );
                                            }
                                            async updateMsgIdForRelativeMedia(
                                              e,
                                              t,
                                              s,
                                            ) {
                                              const {
                                                imageStore: i,
                                                fileStore: n,
                                                linkStore: a,
                                              } = e;
                                              if (Object(su.a)()) {
                                                const e = (e, t, s) => {
                                                  this.getMediaById(e, s).then(
                                                    (i) => {
                                                      i &&
                                                        ((i.msgId = t),
                                                        this.deleteMediasById(
                                                          e,
                                                          {
                                                            newId: void 0,
                                                            oldId: s,
                                                          },
                                                        ).then(() => {
                                                          this.addMedias(e, [
                                                            i,
                                                          ]);
                                                        }));
                                                    },
                                                  );
                                                };
                                                e("file", t, s),
                                                  e("image", t, s),
                                                  e("link", t, s);
                                              } else {
                                                const e = (e, t, s) => {
                                                  e.get(s).then((i) => {
                                                    i &&
                                                      ((i.msgId = t),
                                                      e.delete(s).then(() => {
                                                        e.insert(i);
                                                      }));
                                                  });
                                                };
                                                n && e(n, t, s),
                                                  i && e(i, t, s),
                                                  a && e(a, t, s);
                                              }
                                            }
                                            async emptyMediaStores(e, t) {
                                              e &&
                                                t &&
                                                t.length &&
                                                (Object(su.a)()
                                                  ? t.forEach((t) => {
                                                      "file" === t
                                                        ? this._emptyNewMediaStore(
                                                            K.default.getInstance()
                                                              .Media.File,
                                                            e,
                                                          )
                                                        : "image" === t
                                                          ? this._emptyNewMediaStore(
                                                              K.default.getInstance()
                                                                .Media.Image,
                                                              e,
                                                            )
                                                          : "link" === t &&
                                                            this._emptyNewMediaStore(
                                                              K.default.getInstance()
                                                                .Media.Link,
                                                              e,
                                                            );
                                                    })
                                                  : t.forEach((t) => {
                                                      "file" === t
                                                        ? this._emptyOldMediaStore(
                                                            K.default.getInstance()
                                                              .Core.File,
                                                            e,
                                                          )
                                                        : "image" === t
                                                          ? this._emptyOldMediaStore(
                                                              K.default.getInstance()
                                                                .Core.Image,
                                                              e,
                                                            )
                                                          : "link" === t &&
                                                            this._emptyOldMediaStore(
                                                              K.default.getInstance()
                                                                .Core.Link,
                                                              e,
                                                            );
                                                    }));
                                            }
                                            async addMediasFromOldDB(e, t) {
                                              if (!t || !t.length) return [];
                                              const s =
                                                  this.getMediaRepository(e),
                                                i = pu.a.getAllDeleteConv();
                                              let n = t,
                                                a = t.map((e) => e.msgId);
                                              if (i) {
                                                const s = t.reduce(
                                                  (t, s) => {
                                                    var n;
                                                    const { userId: a } = s;
                                                    if (
                                                      null !== (n = i[a]) &&
                                                      void 0 !== n &&
                                                      n[e]
                                                    ) {
                                                      const n = s.msgId,
                                                        r = i[a][e].lastId;
                                                      r &&
                                                        n &&
                                                        r < n &&
                                                        t.oldMediaEntitiesShouldAddToNewDB.push(
                                                          s,
                                                        );
                                                    } else
                                                      t.oldMediaEntitiesShouldAddToNewDB.push(
                                                        s,
                                                      );
                                                    return (
                                                      t.oldMediaIdsShouldDeleteFromOldDB.push(
                                                        s.msgId,
                                                      ),
                                                      t
                                                    );
                                                  },
                                                  {
                                                    oldMediaEntitiesShouldAddToNewDB:
                                                      [],
                                                    oldMediaIdsShouldDeleteFromOldDB:
                                                      [],
                                                  },
                                                );
                                                (n =
                                                  s.oldMediaEntitiesShouldAddToNewDB),
                                                  (a =
                                                    s.oldMediaIdsShouldDeleteFromOldDB);
                                              }
                                              const r =
                                                  await s.correctMediasInOldDB(
                                                    n,
                                                    { saveBack: !1 },
                                                  ),
                                                o = this.getMediaMapper(e),
                                                d = r.map((e) =>
                                                  o.toDomainFromOldDomain(e),
                                                ),
                                                l = await s.insertMulti(d);
                                              if (l.success.length) {
                                                const e = l.success.map((e) =>
                                                  o.toMediaToCreateOrUpdateUtilsMediaDTOFromDomain(
                                                    e,
                                                  ),
                                                );
                                                return (
                                                  this._utilsMediaManager.createOrUpdateFromMedias(
                                                    e,
                                                  ),
                                                  a
                                                );
                                              }
                                              return [];
                                            }
                                            async getMediasFromOldDB(e, t, s) {
                                              if (await this._isMigrationDone())
                                                return [];
                                              const i = {
                                                  from: "",
                                                  to: s,
                                                  excludeFrom: !0,
                                                  excludeTo: !0,
                                                },
                                                n = {
                                                  index: "primary",
                                                  direction:
                                                    Aa.CursorDirection.PREV,
                                                  limit: t,
                                                };
                                              return this.getMediaRepository(e)
                                                .getOldDBTable()
                                                .getAll(i, n);
                                            }
                                            async deleteMediasFromOldDB(e, t) {
                                              const s =
                                                this.getMediaRepository(e);
                                              return (
                                                await s
                                                  .getOldDBTable()
                                                  .deleteMulti(t)
                                              ).success;
                                            }
                                            async deleteMediasFromOldDBByRange(
                                              e,
                                              t,
                                              s,
                                            ) {
                                              const i = {
                                                  from: "",
                                                  to: s,
                                                  excludeFrom: !0,
                                                  excludeTo: !0,
                                                },
                                                n = {
                                                  index: "primary",
                                                  direction:
                                                    Aa.CursorDirection.PREV,
                                                  limit: t,
                                                },
                                                a = this.getMediaRepository(e),
                                                r = await a
                                                  .getOldDBTable()
                                                  .getAllKey(i, n);
                                              return (
                                                await a
                                                  .getOldDBTable()
                                                  .deleteMulti(r)
                                              ).success;
                                            }
                                            async countTotalMediaInOldDB(e) {
                                              try {
                                                return this.getMediaRepository(
                                                  e,
                                                )
                                                  .getOldDBTable()
                                                  .count();
                                              } catch (t) {
                                                return (
                                                  this._logger.zsymb(
                                                    18,
                                                    16198,
                                                    30014,
                                                    "[countTotalMediaInOldDB] - err: ",
                                                    t,
                                                  ),
                                                  0
                                                );
                                              }
                                            }
                                            async _testAddMedias(e, t) {
                                              void 0 === t && (t = 50);
                                              let s = [];
                                              const i =
                                                  2 * Date.now() +
                                                  Math.round(
                                                    1e5 * Math.random(),
                                                  ) +
                                                  1e3,
                                                n =
                                                  5 * Date.now() +
                                                  Math.round(
                                                    1e7 * Math.random(),
                                                  ) +
                                                  1e3,
                                                a = [
                                                  "0",
                                                  "123456123111111456",
                                                  "12345111111345",
                                                  "111111111111111",
                                                  "12345111111167890",
                                                  "2121212121112222121",
                                                  "1231231231232222123",
                                                  "22222222222222222",
                                                  "2111111111111222111",
                                                  "322222222222222222",
                                                  "12341234212341123",
                                                  "9753434346787646",
                                                  "1234123412341234",
                                                  "987651235545454545",
                                                  "123123455432123432",
                                                  "21212123443434545",
                                                  "5454544531321323",
                                                  "98909087567564545645",
                                                ],
                                                r = [
                                                  "4037840159631073270",
                                                  ...JSON.parse(
                                                    '["101598415","124139871","147333052","169079931","194945127","200868372","225822710","276214855","355712826","361879215","910825795994501468","g100588026","g112969450","g1149397433596350988","g1352476194718464059","g147262698","g149205131","g158719108","g158754949","g160924468","g164283274","g175572981","g194334627","g230291933","g2426404535463764819","g245533229","g25193586","g257364624","g263690118","g285979907","g285992315","g28757702","g288999008","g289367881","g293290840","g301757910","g302249930","g302577276","g309222362","g312505929","g317894641","g318028102","g320951866","g321466298","g322706780","g325920125","g325933426","g328827910","g331912501","g34509241","g47431271","g5355130437069108654","g55402697","g6911969691454201107","g85951308"]',
                                                  ),
                                                ];
                                              switch (e) {
                                                case "image":
                                                  for (let e = 0; e < t; e++) {
                                                    const t =
                                                        a[
                                                          Math.round(
                                                            Math.random() *
                                                              (a.length - 1),
                                                          )
                                                        ],
                                                      o =
                                                        r[
                                                          Math.round(
                                                            Math.random() *
                                                              (r.length - 1),
                                                          )
                                                        ],
                                                      d = i + e,
                                                      l = n + e;
                                                    s.push({
                                                      userId: o,
                                                      cliMsgId: d,
                                                      fromUid: t,
                                                      msgId: l.toString(),
                                                      message: {
                                                        hdUrl:
                                                          "https://b-f62-zpg-r.zdn.vn/8236607293085145247/0d5e94a8fc3726697f26.jpg?e2esession=QIqxr2vdpiBkZh0yizDjKzJIO2LACOAaSb+KBDlUkbwlil6lySe5/p1RncUJJLfTJj1Co/AkPZAOh6ln",
                                                        oriUrl:
                                                          "https://b-f62-zpg-r.zdn.vn/8236607293085145247/0d5e94a8fc3726697f26.jpg?e2esession=QIqxr2vdpiBkZh0yizDjKzJIO2LACOAaSb+KBDlUkbwlil6lySe5/p1RncUJJLfTJj1Co/AkPZAOh6ln",
                                                        params:
                                                          '{"width":800,"height":800,"hd":"https://b-f62-zpg-r.zdn.vn/8236607293085145247/0d5e94a8fc3726697f26.jpg?e2esession=QIqxr2vdpiBkZh0yizDjKzJIO2LACOAaSb+KBDlUkbwlil6lySe5/p1RncUJJLfTJj1Co/AkPZAOh6ln","rawThumbUrl":"https://b-f62-zpg-r.zdn.vn/8236607293085145247/0d5e94a8fc3726697f26.jpg"}',
                                                        thumbUrl:
                                                          "https://f62-zpg-r.zdn.vn/1518777612491889561/5571c987a1187b462209.jpg?e2esession=YBl+XgC1U90bnMk4yPcU519rhnRW4KoItoeNXLpRsl/secNpaT3Nxkal57Nj3UZhy2rUFgxhf8Pcjwah",
                                                        title: void 0,
                                                      },
                                                      type: "image",
                                                      isExpired: !1,
                                                      isExpiredAll: !1,
                                                      subType: Math.round(
                                                        Math.random(),
                                                      )
                                                        ? R.MSG_SUBTYPE_PHOTO
                                                        : R.MSG_SUBTYPE_MEDIA_VIDEO,
                                                      sendDttm: Date.now() + e,
                                                      ttl: 0,
                                                      localPath: null,
                                                      previewThumb: void 0,
                                                      updateTime: Date.now(),
                                                      width: 0,
                                                      height: 0,
                                                    });
                                                  }
                                                  break;
                                                case "file":
                                                  for (let e = 0; e < t; e++) {
                                                    const t =
                                                        a[
                                                          Math.round(
                                                            Math.random() *
                                                              (a.length - 1),
                                                          )
                                                        ],
                                                      o =
                                                        r[
                                                          Math.round(
                                                            Math.random() *
                                                              (r.length - 1),
                                                          )
                                                        ],
                                                      d = i + e,
                                                      l = n + e;
                                                    s.push({
                                                      userId: o,
                                                      cliMsgId: d,
                                                      fromUid: t,
                                                      msgId: l.toString(),
                                                      message: {
                                                        href: "https://f27-group-zfr.zdn.vn/7f8b522a54e0babee3f1/117090926800068678?e2esession=RSHmz0Kj28vN9gMz6oFilBjFxVFqisUPnj3XpjlolXXpTo3bwJ0hqlUl5uR6Sr/wtHrtcyXqXj/mLYl3",
                                                        params:
                                                          '{"fileSize":8178,"checksum":"78c2c03eeab27abbdf28b0fe25088e30","checksumSha":"","fileExt":"xlsx","fdata":"{}","fType":1}',
                                                        title:
                                                          "program_matrix_laP5chSikftFYc_LmERud.xlsx",
                                                      },
                                                      type: "file",
                                                      fileType: -1,
                                                      extType: "",
                                                      sendDttm: Date.now() + e,
                                                      ttl: 0,
                                                      updateTime: Date.now(),
                                                      localPath: null,
                                                      folderPath: null,
                                                      previewThumb: "",
                                                      dimension: null,
                                                      downloadError: !1,
                                                      isExpired: !1,
                                                      isExpiredAll: !1,
                                                    });
                                                  }
                                                  break;
                                                case "link":
                                                  for (let e = 0; e < t; e++) {
                                                    const t =
                                                        a[
                                                          Math.round(
                                                            Math.random() *
                                                              (a.length - 1),
                                                          )
                                                        ],
                                                      o =
                                                        r[
                                                          Math.round(
                                                            Math.random() *
                                                              (r.length - 1),
                                                          )
                                                        ],
                                                      d = i + e,
                                                      l = n + e;
                                                    s.push({
                                                      userId: o,
                                                      cliMsgId: d,
                                                      fromUid: t,
                                                      msgId: l.toString(),
                                                      message: {
                                                        action:
                                                          "recommened.link",
                                                        childnumber: 0,
                                                        description:
                                                          "http://tinhte.vn",
                                                        href: "http://tinhte.vn",
                                                        oriUrl:
                                                          "http://tinhte.vn",
                                                        params:
                                                          '{"mediaTitle":"http://tinhte.vn","artist":"","src":"tinhte.vn","stream_icon":"","streamUrl":"","type":0,"subType":3}',
                                                        thumb: "",
                                                        thumbUrl: "",
                                                        title: "tinhte.vn",
                                                        type: "",
                                                      },
                                                      type: "link",
                                                      sendDttm: Date.now() + e,
                                                      ttl: 0,
                                                      updateTime: Date.now(),
                                                      previewThumb: "",
                                                    });
                                                  }
                                              }
                                              const o = this._getMediaDB(e, !1);
                                              await (null == o
                                                ? void 0
                                                : o.insertMulti(s));
                                            }
                                            _getMediaDB(e, t) {
                                              const s = K.default.getInstance();
                                              switch (e) {
                                                case "image":
                                                  return t
                                                    ? s.Media.Image
                                                    : s.Core.Image;
                                                case "file":
                                                  return t
                                                    ? s.Media.File
                                                    : s.Core.File;
                                                case "link":
                                                  return t
                                                    ? s.Media.Link
                                                    : s.Core.Link;
                                              }
                                            }
                                          }),
                                        ) || Iu),
                                    ) || Iu),
                                ) || Iu),
                            ) || Iu),
                        ) || Iu),
                    ) || Iu),
                ) || Iu),
            ) || Iu),
        );
        var Ou,
          Cu = s("lT2C"),
          Eu = s("C8zZ"),
          Mu = s("wmCV");
        let Su =
          Object($t.b)(Eu.GroupPollManager)(
            (Ou =
              (function (e, t) {
                return i.ModuleContainer.inject(zt.b)(e, void 0, 0);
              })(
                (Ou =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (Ou =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === zt.b ? Object : zt.b,
                      ])(
                        (Ou = class {
                          constructor(e) {
                            (this.convDataManager = e),
                              (this._Logger = void 0),
                              (this.pollCache = void 0),
                              (this.pollCache = new U.default({
                                maxSize: 1e4,
                              })),
                              this.setUpEvent();
                          }
                          get Logger() {
                            return (
                              this._Logger ||
                                (this._Logger = i.ModuleContainer.resolve(
                                  q.ZLoggerFactory,
                                ).createZLogger(hs.ZLoggerNametags.pollV3, [
                                  hs.ZLoggerNametags.groupPollManager,
                                ])),
                              this._Logger
                            );
                          }
                          updatePollCache(e, t) {
                            this.pollCache.set(e, t);
                          }
                          removePollCacheBelongsToConv(e) {
                            Array.from(
                              this.pollCache.entriesAscending(),
                            ).forEach((t) => {
                              let [s, i] = t;
                              i.group_id ===
                                Ct.default.getGroupIdFromConversationId(e) &&
                                this.pollCache.delete(s);
                            });
                          }
                          setUpEvent() {
                            this.convDataManager.addEventListener(
                              Zt.b.DeleteConv,
                              (e) => {
                                this.removePollCacheBelongsToConv(e.convId);
                              },
                            ),
                              this.convDataManager.addEventListener(
                                Zt.b.EmptyConv,
                                (e) => {
                                  this.removePollCacheBelongsToConv(e.convId);
                                },
                              ),
                              this.convDataManager.addEventListener(
                                Zt.b.LeaveGroup,
                                (e) => {
                                  this.removePollCacheBelongsToConv(e.convId);
                                },
                              );
                          }
                          isAdmin(e, t) {
                            var s;
                            const i = ds.default.getGroupByIdSync(e);
                            if (!i) return !1;
                            if (t === i.creatorId) return !0;
                            let n = !1;
                            return (
                              null === (s = i.topMember) ||
                                void 0 === s ||
                                s.forEach((e) => {
                                  e.id === t && e.isAdmin && (n = !0);
                                }),
                              n
                            );
                          }
                          isAllowSetTopic(e) {
                            var t;
                            const s = ds.default.getGroupByIdSync(e);
                            return (
                              !!s &&
                              !(
                                !bt.default.group_topics.enable ||
                                (null !== (t = s.setting) &&
                                  void 0 !== t &&
                                  t.setTopicOnly)
                              )
                            );
                          }
                          isEnablePin(e) {
                            return (
                              this.isAdmin(e, Ye.default.getUidMe()) ||
                              this.isAllowSetTopic(e)
                            );
                          }
                          isEnableClose(e, t) {
                            const s = Ye.default.getUidMe();
                            return this.isAdmin(e, s) || s === t;
                          }
                          createPollRequestData(e) {
                            const { pollData: t, groupId: s, src: i } = e,
                              n = {
                                question: t.question,
                                options: t.options,
                                expired_time: t.expiredTime,
                                pinAct: t.pinAct,
                                allow_multi_choices: t.allowMultiChoices,
                                allow_add_new_option: t.allowAddNewOption,
                                is_hide_vote_preview: t.isHideVotePreview,
                                is_anonymous: t.isAnonymous,
                                poll_type: t.pollType,
                              };
                            return {
                              groupId:
                                Ct.default.getGroupIdFromConversationId(s),
                              pollData: n,
                              src: i,
                            };
                          }
                          async createPoll(e) {
                            const t = e.pollData.pinAct,
                              {
                                groupId: s,
                                pollData: i,
                                src: n,
                              } = this.createPollRequestData(e);
                            try {
                              const a = await Ot.default.createPoll(s, i, n);
                              t &&
                                this.pinPoll(a.poll_id, e.groupId, a.question);
                            } catch (a) {
                              throw (this.Logger.zsymb(18, 10716, 3e4, a), a);
                            }
                          }
                          getPollDetailSync(e) {
                            return this.pollCache.get(e);
                          }
                          async getPollDetail(e, t) {
                            let s = this.getPollDetailSync(e);
                            if (s) return s;
                            if (((s = await Ee.default.getPollInfo(e)), !s)) {
                              if (t) return this.getPollDetailFromServer(e);
                              throw Error("Poll isn't existed in DB");
                            }
                            return this.pollCache.set(e, s), s;
                          }
                          async getPollDetailFromServer(e, t) {
                            const s = await Ot.default.getPollDetail(t, e, !1);
                            if (!s) throw Error("Poll isn't existed in Server");
                            return this.pollCache.set(e, s), s;
                          }
                          async pinPoll(e, t, s) {
                            let i = s;
                            if (!i) {
                              let t = this.getPollDetailSync(e);
                              if ((t || (t = await this.getPollDetail(e)), !t))
                                throw Error("Poll isn't existed");
                              i = t.question;
                            }
                            Mu.a.pinFromBoard(
                              { userId: t },
                              { poll_id: e, isPoll: !0, question: i },
                              null,
                              null,
                              Fa.a.getWinIdByConvId(t),
                            );
                          }
                          unpinPoll(e, t) {
                            Mu.a.unpinFromBoard(t, { poll_id: e, isPoll: !0 });
                          }
                          async lockPoll(e) {
                            const t = this.getPollDetailSync(e);
                            if (!t || !t.closed)
                              try {
                                Ot.default.lockPoll(e);
                              } catch (s) {
                                this.Logger.zsymb(
                                  18,
                                  10716,
                                  30001,
                                  "[lockPoll] ",
                                  e,
                                  s,
                                );
                              }
                          }
                          async sharePollInGroup(e) {
                            try {
                              Ot.default.sharePoll(e);
                            } catch (t) {
                              this.Logger.zsymb(
                                18,
                                10716,
                                30002,
                                "[sharePollInGroup] ",
                                e,
                                t,
                              );
                            }
                          }
                          async votePoll(e) {
                            const {
                                newOptions: t,
                                pollId: s,
                                votedOptionIds: i,
                              } = e,
                              n = Ct.default.getGroupIdFromConversationId(
                                e.groupId,
                              );
                            try {
                              t.length > 0
                                ? await Ot.default.addNewOptionPoll(
                                    n,
                                    s,
                                    JSON.stringify(t),
                                    i,
                                  )
                                : await Ot.default.vote(n, s, i);
                            } catch (a) {
                              throw (
                                (this.Logger.zsymb(
                                  18,
                                  10716,
                                  30003,
                                  "[votePoll] ",
                                  a,
                                  s,
                                ),
                                a)
                              );
                            }
                          }
                        }),
                      ) || Ou),
                  ) || Ou),
              ) || Ou),
          ) || Ou;
        var Tu,
          wu = s("ILDi");
        let Ru =
          Object($t.b)(Eu.GroupPollInfoManager)(
            (Tu =
              Reflect.metadata(
                "design:type",
                Function,
              )(
                (Tu =
                  Reflect.metadata(
                    "design:paramtypes",
                    [],
                  )(
                    (Tu = class {
                      constructor() {
                        (this.updateEmitter = void 0),
                          (this.viewedMoreFromMsgIds = void 0),
                          (this.updateEmitter = new xr.a()),
                          (this.viewedMoreFromMsgIds = new Set());
                      }
                      getPollParams(e) {
                        let t = null;
                        try {
                          var s;
                          t = JSON.parse(
                            null == e ||
                              null === (s = e.message) ||
                              void 0 === s
                              ? void 0
                              : s.params,
                          );
                        } catch (i) {
                          t = {};
                        }
                        return t;
                      }
                      getLastMessagePoll(e, t, s) {
                        let i = t;
                        return (
                          s.forEach((s) => {
                            s.msgType !== t.msgType ||
                              this.getPollParams(s).pollId !== e ||
                              (i = s);
                          }),
                          i
                        );
                      }
                      getContinuosPollInfoSection(e, t) {
                        const s = [];
                        let i = 0;
                        return (
                          t.forEach((t) => {
                            var n;
                            t.msgType === R.MSG_POLL &&
                            this.getPollParams(t).pollId === e
                              ? (s[i] || (s[i] = []), s[i].push(t))
                              : null !== (n = s[i]) &&
                                void 0 !== n &&
                                n[0] &&
                                (i += 1);
                          }),
                          s.filter(
                            (e) =>
                              e.length >
                              bt.default.groupPoll.max_info_msg_display,
                          )
                        );
                      }
                      isShowPollCard(e, t, s) {
                        const i = this.getLastMessagePoll(e, t, s);
                        return xi.b.isSameMsg(t, i);
                      }
                      getPollInfoShowStatus(e, t, s) {
                        const i = this.getContinuosPollInfoSection(e, s);
                        for (const n of i)
                          for (let e = n.length - 1; e >= 0; e--)
                            if (xi.b.isSameMsg(t, n[e]))
                              return e !== n.length - 1
                                ? "HIDE"
                                : n[e - 1] &&
                                    this.viewedMoreFromMsgIds.has(
                                      n[e - 1].msgId,
                                    )
                                  ? "SHOW"
                                  : "SHOW_VIEW_MORE";
                        return "SHOW";
                      }
                      viewMore(e, t, s) {
                        let i = [];
                        const n = this.getContinuosPollInfoSection(e, s);
                        for (const a of n)
                          if (a[a.length - 1].msgId === t) {
                            i = a.map((e) => e.msgId);
                            break;
                          }
                        this.updateEmitter.emit("EXPAND_MSG_INFO", {
                          msgIds: i,
                        }),
                          this.viewedMoreFromMsgIds.add(t);
                      }
                      clearViewedMoreHistory(e) {
                        this.viewedMoreFromMsgIds.delete(e);
                      }
                    }),
                  ) || Tu),
              ) || Tu),
          ) || Tu;
        i.ModuleContainer.registerSingleton(Cu.a, Su),
          i.ModuleContainer.registerSingleton(wu.a, Ru);
        var Lu = s("3+ZU"),
          Du = s("MEZx");
        i.ModuleContainer.registerSingleton(
          Lu.a,
          class {
            getDebugMenu() {
              return bt.default.mediaStatus.debug.enable
                ? {
                    type: Du.MENU_ITEM_TYPE.SUBMENU,
                    text: "Media Status",
                    items: [
                      {
                        text: "Disable expired soon status",
                        onclick: () => {
                          bt.default.mediaStatus.enable_expired_soon =
                            !bt.default.mediaStatus.enable_expired_soon;
                        },
                        checked: !bt.default.mediaStatus.enable_expired_soon,
                      },
                      {
                        text: "Revert media status",
                        onclick: () => {
                          bt.default.mediaStatus.enable_media_status =
                            !bt.default.mediaStatus.enable_media_status;
                        },
                        checked: !bt.default.mediaStatus.enable_media_status,
                      },
                      {
                        text: "Disable view in folder for auto download",
                        onclick: () => {
                          bt.default.mediaStatus.enable_view_folder_option_for_auto_download =
                            !bt.default.mediaStatus
                              .enable_view_folder_option_for_auto_download;
                        },
                        checked:
                          !bt.default.mediaStatus
                            .enable_view_folder_option_for_auto_download,
                      },
                      {
                        text: "Disable inview file download",
                        onclick: () => {
                          bt.default.mediaStatus.enable_file_inview_download =
                            !bt.default.mediaStatus.enable_file_inview_download;
                        },
                        checked:
                          !bt.default.mediaStatus.enable_file_inview_download,
                      },
                      {
                        text: "Open Media Status Debugger Modal",
                        onclick: () => {
                          const e = s("h0sc");
                          e &&
                            e.ModalManagerV2 &&
                            e.ModalManagerV2.openModal({
                              windowId: "1",
                              name: R.ModalIdentitiesDefine
                                .MEDIA_STATUS_DEBUGGER,
                              params: { show: !0 },
                            });
                        },
                      },
                      {
                        text: "Enable force expired photo",
                        onclick: () => {
                          globalThis.__alwaysForcePhotoExpired =
                            !globalThis.__alwaysForcePhotoExpired;
                        },
                        checked: 1 == globalThis.__alwaysForcePhotoExpired,
                      },
                      {
                        text: "Enable force expired voice",
                        onclick: () => {
                          globalThis.__alwaysForceVoiceExpired =
                            !globalThis.__alwaysForceVoiceExpired;
                        },
                        checked: 1 == globalThis.__alwaysForceVoiceExpired,
                      },
                    ],
                  }
                : null;
            }
          },
        );
        var Fu,
          Au = s("tw7i");
        let ju =
          Object(i.injectable)()(
            (Fu =
              (function (e, t) {
                return Object(i.inject)(Au.e)(e, void 0, 0);
              })(
                (Fu =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (Fu =
                      Reflect.metadata("design:paramtypes", [Object])(
                        (Fu = class {
                          constructor(e) {
                            this.queue = e;
                          }
                          push(e, t) {
                            const s = { msgId: e, action: t };
                            this.queue.push(s);
                          }
                        }),
                      ) || Fu),
                  ) || Fu),
              ) || Fu),
          ) || Fu;
        class Pu extends Error {
          constructor(e) {
            let { message: t, name: s, options: i } = e;
            super(t),
              (this.code = void 0),
              (this.name = void 0),
              (this.name = s),
              i && i.code && (this.code = i.code),
              i && i.stack && (this.stack = new Error().stack),
              Object.setPrototypeOf(this, Pu.prototype);
          }
        }
        var Nu = (e, t) => {
          const s = { code: e.code, stack: t };
          return new Pu({ name: e.name, options: s, message: e.message });
        };
        const Uu = {
            name: "CANNOT_GET_MSG_FROM_DB",
            code: 1,
            message: "Cannot get message from Message Core database",
          },
          ku = {
            name: "QUEUE_TASK_EMPTY",
            code: 2,
            message: "Action log info queue is empty",
          },
          Bu = {
            name: "TASK_IS_RUNNING",
            code: 3,
            message: "Media action log info queue has task is running",
          },
          Gu = {
            name: "TEMP_DISABLE_LOG_PHOTO_SUBTYPE_2",
            code: 4,
            message: "Temporary disable actionlog info for photo in subType 2",
          };
        var xu = s("JJxn"),
          zu = s("tmLI"),
          Vu = s("UQla"),
          Hu = s("eZ5W");
        function $u(e) {
          return e === R.MSG_E2EE ? xu.e.YES : xu.e.NO;
        }
        function Wu(e) {
          return "0" != e ? xu.f.RECEIVER : xu.f.SENDER;
        }
        var Ku = s("HPXo");
        class qu {
          build(e, t) {
            var s, i;
            const n = {
              msg_type: xu.l[e.msg.msgType],
              entry_point: e.entryPoint,
              size: e.size,
              sent_time: e.msg.sendDttm,
              is_e2ee: $u(
                null === (s = e.msg) || void 0 === s ? void 0 : s.e2eeStatus,
              ),
              is_sender: Wu(
                null === (i = e.msg) || void 0 === i ? void 0 : i.fromUid,
              ),
              conv_type: xu.j[e.convType],
              sync_source: xu.k[e.msg.src],
              is_zCloud: e.isZCloud,
              msg_id: e.msg.msgId,
            };
            switch (
              (null != e && e.groupSize && (n.group_size = e.groupSize), t)
            ) {
              case xu.p.MediaExpiredWhenAction:
                n.original_status = Ku.a.get(e.msg.msgId);
                break;
              case xu.p.MediaStatusInView:
                null != e && e.forceStatus
                  ? (n.file_status = null == e ? void 0 : e.forceStatus)
                  : (n.file_status = null == e ? void 0 : e.mediaStatus);
            }
            return n;
          }
        }
        class Zu {
          build(e, t) {
            var s, i;
            const n = {
              msg_type: xu.l[e.msg.msgType],
              entry_point: e.entryPoint,
              size: e.size,
              sent_time: e.msg.sendDttm,
              is_e2ee: $u(
                null === (s = e.msg) || void 0 === s ? void 0 : s.e2eeStatus,
              ),
              is_sender: Wu(
                null === (i = e.msg) || void 0 === i ? void 0 : i.fromUid,
              ),
              conv_type: xu.j[e.convType],
              sync_source: xu.k[e.msg.src],
              is_zCloud: e.isZCloud,
            };
            switch (
              (null != e && e.groupSize && (n.group_size = e.groupSize), t)
            ) {
              case xu.p.MediaExpiredWhenAction:
                n.original_status = Ku.a.get(e.msg.msgId);
                break;
              case xu.p.MediaStatusInView:
                n.file_status = null == e ? void 0 : e.forceStatus;
            }
            return n;
          }
        }
        class Ju {
          build(e, t) {
            var s, i;
            const n = {
              msg_type: xu.l[e.msg.msgType],
              entry_point: e.entryPoint,
              size: e.size,
              sent_time: e.msg.sendDttm,
              is_e2ee: $u(
                null === (s = e.msg) || void 0 === s ? void 0 : s.e2eeStatus,
              ),
              is_sender: Wu(
                null === (i = e.msg) || void 0 === i ? void 0 : i.fromUid,
              ),
              conv_type: xu.j[e.convType],
              sync_source: xu.k[e.msg.src],
              is_zCloud: e.isZCloud,
              msg_id: e.msg.msgId,
            };
            switch (
              (null != e && e.groupSize && (n.group_size = e.groupSize), t)
            ) {
              case xu.p.MediaExpiredWhenAction:
                n.original_status = Ku.a.get(e.msg.msgId);
                break;
              case xu.p.MediaStatusInView:
                n.file_status = e.mediaStatus;
            }
            return n;
          }
        }
        class Qu {
          build(e, t) {
            var s, i;
            const n = {
              msg_type: xu.l[e.msg.msgType],
              entry_point: e.entryPoint,
              size: e.size,
              sent_time: e.msg.sendDttm,
              is_e2ee: $u(
                null === (s = e.msg) || void 0 === s ? void 0 : s.e2eeStatus,
              ),
              is_sender: Wu(
                null === (i = e.msg) || void 0 === i ? void 0 : i.fromUid,
              ),
              conv_type: xu.j[e.convType],
              sync_source: xu.k[e.msg.src],
              is_zCloud: e.isZCloud,
              msg_id: e.msg.msgId,
            };
            switch (
              (null != e && e.groupSize && (n.group_size = e.groupSize), t)
            ) {
              case xu.p.MediaExpiredWhenAction:
                n.original_status = Ku.a.get(e.msg.msgId);
                break;
              case xu.p.MediaStatusInView:
                n.file_status = e.mediaStatus;
            }
            return n;
          }
        }
        class Yu {
          constructor() {
            (this.msg = void 0),
              (this.subType = void 0),
              (this.entryPoint = void 0),
              (this.convType = void 0),
              (this.mediaStatus = void 0),
              (this.forceStatus = void 0),
              (this.isZCloud = void 0);
          }
          withMessage(e) {
            return (this.msg = e), this;
          }
          withSubType(e) {
            return (this.subType = e), this;
          }
          withEntryPoint(e) {
            return (this.entryPoint = e), this;
          }
          withStatus(e) {
            return (
              (this.mediaStatus =
                e &&
                (function (e) {
                  var t, s, i, n, a, r, o;
                  let d = "";
                  var l, c, h, u, g, m;
                  return (
                    null !== (t = e) &&
                      void 0 !== t &&
                      t.isExpired &&
                      (d = Vu.s.Expired),
                    null !== (s = e) &&
                      void 0 !== s &&
                      s.isExpiredSoon &&
                      (d = Vu.s.ExpiredSoon),
                    Object(Lo.b)().isEnableViewPCloudFileStatus() &&
                      null !== (i = e) &&
                      void 0 !== i &&
                      i.personalCloud &&
                      null !== (l = e) &&
                      void 0 !== l &&
                      null !== (c = l.personalCloud) &&
                      void 0 !== c &&
                      null !== (h = c.status) &&
                      void 0 !== h &&
                      h.isUncloud &&
                      e === Vu.s.ExpiredSoon &&
                      (e = Vu.s.ExpiredSoon),
                    Object(Lo.b)().isEnableViewPCloudFileStatus() &&
                      null !== (n = e) &&
                      void 0 !== n &&
                      n.personalCloud &&
                      null !== (u = e) &&
                      void 0 !== u &&
                      null !== (g = u.personalCloud) &&
                      void 0 !== g &&
                      null !== (m = g.status) &&
                      void 0 !== m &&
                      m.isClouded &&
                      (d = Vu.q.CloudSaved),
                    null !== (a = e) &&
                      void 0 !== a &&
                      a.autoDownloadPath &&
                      (d = Vu.s.DownloadedAuto),
                    ((null !== (r = e) && void 0 !== r && r.localPath) ||
                      (null !== (o = e) && void 0 !== o && o.folderPath)) &&
                      (d = Vu.s.DownloadedManual),
                    d
                  );
                })(e)),
              this
            );
          }
          withForceStatus(e) {
            return void 0 === e && (e = ""), (this.forceStatus = e), this;
          }
          withZCloud(e) {
            return void 0 === e && (e = 0), (this.isZCloud = e ? 1 : 0), this;
          }
          build() {
            var e, t;
            const s = (function (e) {
                const t = Object(zu.n)(null == e ? void 0 : e.params) || "";
                return t
                  ? (null == t ? void 0 : t.fileSize) && +t.fileSize / 1024
                  : -1;
              })(this.msg.message),
              i =
                (null === (e = this.msg) || void 0 === e ? void 0 : e.toUid) &&
                ((n =
                  null === (t = this.msg) || void 0 === t ? void 0 : t.toUid),
                Ct.default.isOAType(Ye.default.getProfileFriendSync(n))
                  ? xu.a.OA
                  : Ct.default.getConversationType(n));
            var n;
            const a =
                i === xu.a.GROUP &&
                (function (e) {
                  let t;
                  const s = ds.default.getGroupByIdSync(e);
                  return (
                    null != s &&
                      s.topMember &&
                      (null == s ? void 0 : s.topMember.length) > 0 &&
                      (t = null == s ? void 0 : s.topMember.length),
                    t
                  );
                })(this.msg.toUid),
              r =
                i === xu.a.CLOUD
                  ? (function (e, t) {
                      let s = e;
                      return (
                        e !== Vu.q.DownloadedAuto &&
                          e !== Vu.q.DownloadedManual &&
                          t <= Hu.b.getCloudLimitBigFileInBytes() &&
                          (s = Vu.q.CloudSaved),
                        s
                      );
                    })(this.mediaStatus, s)
                  : this.mediaStatus;
            let o = {};
            const d = {
              msg: this.msg,
              size: s,
              isZCloud: this.isZCloud,
              mediaStatus: r,
              convType: i,
              forceStatus: this.forceStatus,
              entryPoint: this.entryPoint,
              groupSize: a,
            };
            switch (this.msg.msgType) {
              case R.MSG_PHOTO:
              case R.MSG_PHOTO_2:
                o = new Zu().build(d, this.subType);
                break;
              case R.MSG_FILE:
                o = new qu().build(d, this.subType);
                break;
              case R.MSG_VIDEO:
                o = new Ju().build(d, this.subType);
                break;
              case R.MSG_VOICE:
                o = new Qu().build(d, this.subType);
            }
            return o;
          }
        }
        var Xu = class {
            verify(e) {
              return (
                !!e.file_status &&
                !!Object.values(xu.e).includes(e.is_e2ee) &&
                !!Object.values(xu.f).includes(e.is_sender) &&
                !!Object.values(xu.f).includes(e.is_sender) &&
                !!Object.values(xu.j).includes(e.conv_type) &&
                !!Object.values(xu.k).includes(e.sync_source) &&
                !!Object.values(xu.l).includes(e.msg_type)
              );
            }
          },
          eg = s("a4lh"),
          tg = s("o1u6"),
          sg = s("lJL2");
        const ig = [R.MSG_FILE, R.MSG_VIDEO, R.MSG_VOICE],
          ng = [R.MSG_PHOTO, R.MSG_PHOTO_2];
        var ag;
        let rg =
          Object(i.injectable)()(
            (ag =
              (function (e, t) {
                return Object(i.inject)(Au.e)(e, void 0, 0);
              })(
                (ag =
                  (function (e, t) {
                    return Object(i.inject)(q.ZLoggerFactory)(e, void 0, 1);
                  })(
                    (ag =
                      (function (e, t) {
                        return Object(i.inject)(Au.b)(e, void 0, 2);
                      })(
                        (ag =
                          Reflect.metadata(
                            "design:type",
                            Function,
                          )(
                            (ag =
                              Reflect.metadata("design:paramtypes", [
                                Object,
                                void 0 === q.ZLoggerFactory
                                  ? Object
                                  : q.ZLoggerFactory,
                                Object,
                              ])(
                                (ag = class {
                                  constructor(e, t, s) {
                                    (this.queue = e),
                                      (this.mediaActionLogInfoCronToGroupData =
                                        s),
                                      (this.logger = void 0),
                                      (this.DB = void 0),
                                      (this.isRunning = void 0),
                                      (this.logger = t.createZLogger(
                                        hs.ZLoggerNametags.mediaStatus,
                                        ["action-log-consumer"],
                                      )),
                                      (this.DB = K.default.getInstance()),
                                      (this.isRunning = !1);
                                  }
                                  async run() {
                                    if (!(this.queue.length <= 0)) {
                                      if (this.isRunning) return Nu(Bu);
                                      (this.isRunning = !0),
                                        requestAnimationFrame(async () => {
                                          try {
                                            const e = this.queue.pop();
                                            if (!e) return Nu(ku);
                                            const t = e.msgId,
                                              s = e.action,
                                              i =
                                                await this.DB.Core.Message.get(
                                                  t,
                                                );
                                            let n;
                                            if (!i) return Nu(Uu);
                                            if (
                                              (i.msgType === R.MSG_PHOTO ||
                                                i.msgType === R.MSG_PHOTO_2) &&
                                              !bt.default.mediaStatus
                                                .actionLogInfo
                                                .enable_sub_type_2_for_photo &&
                                              s.subType ===
                                                xu.p.MediaStatusInView
                                            )
                                              return Gu;
                                            if (null == s || !s.forceStatus) {
                                              let e = t;
                                              i.msgType !== R.MSG_FILE &&
                                                (e = i),
                                                (n =
                                                  ig.includes(i.msgType) &&
                                                  (sg.a.get(t) ||
                                                    (await tg.a.status(
                                                      e,
                                                      [],
                                                    ))));
                                            }
                                            const a = new Yu()
                                              .withEntryPoint(s.entryPoint)
                                              .withSubType(s.subType)
                                              .withMessage(i)
                                              .withStatus(n)
                                              .withForceStatus(
                                                (null == s
                                                  ? void 0
                                                  : s.forceStatus) || "",
                                              )
                                              .withZCloud(
                                                (null == s
                                                  ? void 0
                                                  : s.isZCloud) || 0,
                                              )
                                              .build();
                                            if (new Xu().verify(a))
                                              if (ng.includes(i.msgType)) {
                                                const e = Object(f.a)({}, a);
                                                delete e.sent_time,
                                                  delete e.size;
                                                const t = JSON.stringify(e);
                                                this.mediaActionLogInfoCronToGroupData.runCron(
                                                  {
                                                    key: t,
                                                    data: Object(f.a)(
                                                      Object(f.a)({}, a),
                                                      {},
                                                      { subType: s.subType },
                                                    ),
                                                  },
                                                );
                                              } else
                                                eg.a.LogActionInfo(
                                                  s.subType,
                                                  a,
                                                );
                                          } catch (e) {
                                            this.logger.zsymb(
                                              3,
                                              15425,
                                              3e4,
                                              "error {}",
                                              JSON.stringify(e),
                                            );
                                          } finally {
                                            (this.isRunning = !1), this.run();
                                          }
                                        });
                                    }
                                  }
                                }),
                              ) || ag),
                          ) || ag),
                      ) || ag),
                  ) || ag),
              ) || ag),
          ) || ag;
        var og;
        let dg =
          Object(i.injectable)()(
            (og =
              (function (e, t) {
                return Object(i.inject)(Au.d)(e, void 0, 0);
              })(
                (og =
                  (function (e, t) {
                    return Object(i.inject)(Au.a)(e, void 0, 1);
                  })(
                    (og =
                      Reflect.metadata(
                        "design:type",
                        Function,
                      )(
                        (og =
                          Reflect.metadata("design:paramtypes", [
                            Object,
                            Object,
                          ])(
                            (og = class {
                              constructor(e, t) {
                                (this.producer = e), (this.consumer = t);
                              }
                              run(e, t) {
                                (t.subType !== xu.p.MediaExpiredWhenAction ||
                                  bt.default.mediaStatus.actionLogInfo
                                    .enable_sub_type_1) &&
                                  (t.subType !== xu.p.MediaStatusInView ||
                                    bt.default.mediaStatus.actionLogInfo
                                      .enable_sub_type_2) &&
                                  (this.producer.push(e, t),
                                  this.consumer.run());
                              }
                            }),
                          ) || og),
                      ) || og),
                  ) || og),
              ) || og),
          ) || og;
        var lg = s("z97J");
        const cg = new (class {
          constructor(e) {
            (this.lru = void 0),
              (this.lru = new U.default({ maxSize: e.maxSize() }));
          }
          set(e, t) {
            if (t)
              if (this.has(e)) {
                const s = this.lru.get(e);
                (s.sent_time = `${parseInt(s.sent_time) + parseInt(t.sent_time)}`),
                  s.size &&
                    t.size &&
                    (s.size = `${parseInt(s.size) + parseInt(t.size)}`),
                  ++s.count,
                  this.lru.set(e, s);
              } else
                this.lru.set(
                  e,
                  Object(f.a)(Object(f.a)({}, t), {}, { count: 1 }),
                );
          }
          get(e) {
            return this.lru.get(e);
          }
          has(e) {
            return this.lru.has(e);
          }
          delete(e) {
            return this.lru.delete(e);
          }
          getAll() {
            return [...this.lru.values()];
          }
          clear() {
            this.lru.clear();
          }
        })({
          maxSize: () =>
            bt.default.maxSizeMemCacheMediaStatusPhotoActionLogInfo,
        });
        i.ModuleContainer.registerSingleton(
          Au.e,
          class {
            constructor() {
              (this.queue = void 0), (this.queue = []);
            }
            push(e) {
              this.queue.push(e);
            }
            pop() {
              return this.queue.pop();
            }
            get length() {
              return this.queue.length;
            }
          },
        ),
          i.ModuleContainer.registerSingleton(Au.d, ju),
          i.ModuleContainer.registerSingleton(
            Au.b,
            class {
              constructor() {
                (this.startCron = void 0), (this.startCron = !1);
              }
              setStart() {
                this.startCron || (this.startCron = !0);
              }
              isStartCron() {
                return this.startCron;
              }
              runCron(e) {
                const t = new lg.CronJob(
                  bt.default.mediaStatus.actionLogInfo.time_to_log_photo,
                  () => {
                    const e = cg.getAll();
                    if (e.length) {
                      for (const s of e) {
                        var t;
                        const e = s.subType;
                        delete s.subType,
                          (s.sent_time = Math.round(s.sent_time / s.count)),
                          (s.size =
                            (null !== (t = s.size) && void 0 !== t ? t : 0) /
                            s.count),
                          eg.a.LogActionInfo(e, s);
                      }
                      cg.clear();
                    }
                  },
                );
                this.isStartCron()
                  ? cg.set(e.key, e.data)
                  : (cg.set(e.key, e.data), t.start(), this.setStart());
              }
            },
          ),
          i.ModuleContainer.registerSingleton(Au.a, rg),
          i.ModuleContainer.registerSingleton(Au.c, dg);
        var hg = s("imbw"),
          ug = s("1EWQ");
        const gg = 1,
          mg = 2,
          pg = 3;
        let fg, vg, bg, Ig, yg, _g, Og;
        var Cg;
        !(function (e) {
          (e[(e.TEXT = 0)] = "TEXT"),
            (e[(e.STICKER = 1)] = "STICKER"),
            (e[(e.PHOTO = 2)] = "PHOTO"),
            (e[(e.LINK = 3)] = "LINK"),
            (e[(e.FILE = 4)] = "FILE"),
            (e[(e.GIF = 5)] = "GIF"),
            (e[(e.CONTACT = 6)] = "CONTACT");
        })(fg || (fg = {})),
          (function (e) {
            (e[(e.CHAT_11 = 1)] = "CHAT_11"),
              (e[(e.CHAT_GROUP = 2)] = "CHAT_GROUP"),
              (e[(e.MY_CLOUD = 3)] = "MY_CLOUD");
          })(vg || (vg = {})),
          (function (e) {
            (e[(e.SINGLE = 0)] = "SINGLE"), (e[(e.GROUP = 1)] = "GROUP");
          })(bg || (bg = {})),
          (function (e) {
            (e[(e.CONTEXT_MENU = 0)] = "CONTEXT_MENU"),
              (e[(e.BUBBLE = 1)] = "BUBBLE");
          })(Ig || (Ig = {})),
          (function (e) {
            (e[(e.RESEND = 1)] = "RESEND"), (e[(e.DELETE = 2)] = "DELETE");
          })(yg || (yg = {})),
          (function (e) {
            (e[(e.NO_RESEND = 1)] = "NO_RESEND"),
              (e[(e.RESEND_SINGLE = 2)] = "RESEND_SINGLE"),
              (e[(e.RESEND_ALL = 3)] = "RESEND_ALL");
          })(_g || (_g = {})),
          (function (e) {
            (e[(e.NO_DELETE = 1)] = "NO_DELETE"),
              (e[(e.DELETE_SINGLE = 2)] = "DELETE_SINGLE"),
              (e[(e.DELETE_ALL = 3)] = "DELETE_ALL");
          })(Og || (Og = {}));
        let Eg =
          Object($t.b)(hg.a)(
            (Cg =
              Reflect.metadata(
                "design:type",
                Function,
              )(
                (Cg =
                  Reflect.metadata(
                    "design:paramtypes",
                    [],
                  )(
                    (Cg = class {
                      constructor() {
                        (this.lastNetworkBannerAppearTime = void 0),
                          (this.logger = void 0),
                          (this.lastNetworkBannerAppearTime = null);
                      }
                      get Logger() {
                        return (
                          this.logger ||
                            (this.logger = i.ModuleContainer.resolve(
                              q.ZLoggerFactory,
                            ).createZLogger("auto-retry", ["action-log"])),
                          this.logger
                        );
                      }
                      logAction999(e) {
                        const { type: t, payload: s } = e;
                        let i;
                        switch (t) {
                          case "ShowManualRetry":
                            i = gg;
                            break;
                          case "InteractManualRetry":
                            i = mg;
                            break;
                          case "ShowBannerNetwork":
                            i = pg;
                        }
                        Xe.e.logActionInfoV2(Xe.b.AutoRetry, i, s);
                      }
                      getChatTypeFromConvId(e) {
                        return Ct.default.isGroup(e)
                          ? vg.CHAT_GROUP
                          : ug.a.isSendToMe(e)
                            ? vg.MY_CLOUD
                            : vg.CHAT_11;
                      }
                      getRetryMsgType(e) {
                        switch (e) {
                          case R.MSG_TEXT:
                            return fg.TEXT;
                          case R.MSG_GIF:
                            return fg.GIF;
                          case R.MSG_FILE:
                          case R.MSG_VIDEO:
                            return fg.FILE;
                          case R.MSG_PHOTO:
                          case R.MSG_PHOTO_GROUP:
                            return fg.PHOTO;
                          case R.MSG_CONTACT:
                            return fg.CONTACT;
                          case R.MSG_STICKER:
                          case R.MSG_STICKER_GROUP:
                          case R.MSG_STICKER_2:
                            return fg.STICKER;
                          case R.MSG_LINK_CLIENT:
                            return fg.LINK;
                          default:
                            return;
                        }
                      }
                      getMsgCombineType(e) {
                        return [
                          R.MSG_PHOTO_GROUP,
                          R.MSG_STICKER_GROUP,
                        ].includes(e)
                          ? bg.GROUP
                          : bg.SINGLE;
                      }
                      showManualRetryReport(e) {
                        const t = this.getRetryMsgType(e.msgType);
                        void 0 !== t &&
                          this.logAction999({
                            type: "ShowManualRetry",
                            payload: {
                              msg_type: t,
                              chat_type: this.getChatTypeFromConvId(
                                e.conversationId,
                              ),
                              error_id: e.errorCode,
                              is_groupping: this.getMsgCombineType(e.msgType),
                            },
                          });
                      }
                      networkBannerAppearCapture() {
                        this.lastNetworkBannerAppearTime =
                          _t.default.getTimeNow();
                      }
                      networkBannerDisappearReport() {
                        const e = _t.default.getTimeNow();
                        if (null === this.lastNetworkBannerAppearTime) return;
                        const t = e - this.lastNetworkBannerAppearTime;
                        t <= 0 ||
                          (this.logAction999({
                            type: "ShowBannerNetwork",
                            payload: {
                              showed_time: this.lastNetworkBannerAppearTime,
                              off_time: e,
                              duration: t,
                            },
                          }),
                          (this.lastNetworkBannerAppearTime = null));
                      }
                      resendErrorMessageReport(e) {
                        const t = this.getRetryMsgType(e.msgType);
                        void 0 !== t &&
                          this.logAction999({
                            type: "InteractManualRetry",
                            payload: {
                              msg_type: t,
                              chat_type: this.getChatTypeFromConvId(
                                e.conversationId,
                              ),
                              is_groupping: this.getMsgCombineType(e.msgType),
                              is_entrypoint: Ig[e.source],
                              is_resend:
                                this.getMsgCombineType(e.msgType) === bg.GROUP
                                  ? _g.RESEND_ALL
                                  : _g.RESEND_SINGLE,
                              is_deleted: Og.NO_DELETE,
                              action_type: yg.RESEND,
                            },
                          });
                      }
                      deleteErrorMessageReport(e) {
                        const t = this.getRetryMsgType(e.msgType);
                        void 0 !== t &&
                          this.logAction999({
                            type: "InteractManualRetry",
                            payload: {
                              msg_type: t,
                              chat_type: this.getChatTypeFromConvId(
                                e.conversationId,
                              ),
                              is_groupping: this.getMsgCombineType(e.msgType),
                              is_entrypoint: Ig[e.source],
                              is_resend: _g.NO_RESEND,
                              is_deleted:
                                this.getMsgCombineType(e.msgType) === bg.GROUP
                                  ? Og.DELETE_ALL
                                  : Og.DELETE_SINGLE,
                              action_type: yg.DELETE,
                            },
                          });
                      }
                    }),
                  ) || Cg),
              ) || Cg),
          ) || Cg;
        i.ModuleContainer.registerSingleton(hg.a, Eg);
        var Mg,
          Sg = s("Z1oQ"),
          Tg = s("QbTC"),
          wg = s("xtzN"),
          Rg = s("n32m"),
          Lg = s("hKna");
        let Dg =
          Object($t.b)(Rg.RetryErrorController)(
            (Mg =
              Reflect.metadata(
                "design:type",
                Function,
              )(
                (Mg =
                  Reflect.metadata(
                    "design:paramtypes",
                    [],
                  )(
                    (Mg = class {
                      constructor() {
                        (this.logger = void 0),
                          (this.errNetworkCounterMap = void 0),
                          (this.errNetworkCounterMap = new Map());
                      }
                      get Logger() {
                        return (
                          this.logger ||
                            (this.logger = i.ModuleContainer.resolve(
                              q.ZLoggerFactory,
                            ).createZLogger(hs.ZLoggerNametags.autoRetry, [
                              "retry-error-controller",
                            ])),
                          this.logger
                        );
                      }
                      getErrNetworkRetryCount(e) {
                        if (!e) return 0;
                        const t = this.errNetworkCounterMap.get(e);
                        if (void 0 !== t)
                          return 0 === t
                            ? (this.errNetworkCounterMap.delete(e), 0)
                            : t;
                        const s =
                          bt.default.retryConfig.max_err_network_retry_count;
                        return this.errNetworkCounterMap.set(e, s), s;
                      }
                      decreaseErrNetworkRetryCount(e) {
                        if (!e) return;
                        const t = this.getErrNetworkRetryCount(e);
                        t > 0
                          ? this.errNetworkCounterMap.set(e, t - 1)
                          : this.errNetworkCounterMap.delete(e);
                      }
                      deleteErrNetworkRetryCountItem(e) {
                        e && this.errNetworkCounterMap.delete(e);
                      }
                      logRetryError(e, t) {
                        this.Logger.zsymb(18, 11217, 3e4, e, t);
                      }
                      shouldRetry(e, t, s) {
                        if (!e || Lg.a.includes(e.code)) return !1;
                        if (!Lg.c.includes(e.code)) return !1;
                        const i = Lg.d.NO_NETWORK_ERROR_CODE.includes(e.code);
                        if (
                          i &&
                          (!bt.default.retry_err_no_network ||
                            (Dn.b.getStateNetwork() !== Dn.a.CHECKING &&
                              Dn.b.getStateNetwork() !== Dn.a.DISCONNECT))
                        )
                          return !1;
                        const n = this.getRetryErrorCodeGroupName(e.code);
                        if (n && this.getRetryErrorCodeMapping()[n].off)
                          return !1;
                        const a = i && this.getErrNetworkRetryCount(s) > 0;
                        if (0 === t.count && !a) return !1;
                        const r = this.getRetryTimeout(t);
                        return (
                          !!(r && _t.default.getTimeNow() - t.timestamp < r) &&
                          (t.count && !i && t.count--,
                          i && this.decreaseErrNetworkRetryCount(s),
                          !0)
                        );
                      }
                      getRetryTimeout(e) {
                        let t = 0;
                        return (
                          bt.default.retryConfig &&
                            bt.default.retryConfig.setting_feature &&
                            e.timestamp &&
                            e.timeout &&
                            (e.timeout === R.RETRY_MSG_TIMEOUT_DEFAULT
                              ? (t = bt.default.retryConfig.time_retry_default)
                              : e.timeout === R.RETRY_MSG_TIMEOUT_LONG &&
                                (t = bt.default.retryConfig.time_retry_long)),
                          t
                        );
                      }
                      getRetryErrorCodeGroupName(e) {
                        return Object.keys(Lg.d).find((t) =>
                          Lg.d[t].includes(e),
                        );
                      }
                      getNoRetryErrorCodeGroupName(e) {
                        return Object.keys(Lg.b).find((t) =>
                          Lg.b[t].includes(e),
                        );
                      }
                      getRetryErrorCodeMapping() {
                        return bt.default.retryConfig.retry_strategy &&
                          "object" ==
                            typeof bt.default.retryConfig.retry_strategy
                          ? Object.keys(
                              bt.default.retryConfig.retry_strategy,
                            ).reduce(
                              (e, t) => (
                                (e[t.toUpperCase()] =
                                  bt.default.retryConfig.retry_strategy[t]),
                                e
                              ),
                              {},
                            )
                          : Lg.e;
                      }
                    }),
                  ) || Mg),
              ) || Mg),
          ) || Mg;
        var Fg,
          Ag = s("yoj5"),
          jg = s("Qtro");
        let Pg =
          Object($t.b)(Tg.a)(
            (Fg =
              Reflect.metadata(
                "design:type",
                Function,
              )(
                (Fg =
                  Reflect.metadata(
                    "design:paramtypes",
                    [],
                  )(
                    (Fg = class {
                      constructor() {
                        (this.logger = void 0),
                          (this.waitingSocketOpenQueue = void 0),
                          (this.retryCountMapping = void 0),
                          (this.isDoneOffline = void 0),
                          (this.handleWaitingConnectionRetry = () => {
                            const e = [...this.waitingSocketOpenQueue];
                            this.waitingSocketOpenQueue = [];
                            for (const t of e) {
                              const e = Ag.getGapTime();
                              window.requestIdleCallback(
                                () => {
                                  t();
                                },
                                { timeout: e },
                              );
                            }
                          }),
                          (this.unlockProcessOffline = () => {
                            (this.isDoneOffline = !0),
                              Ec.default.getSocketState() === Lg.g.OPEN &&
                                this.handleWaitingConnectionRetry();
                          }),
                          (this.waitingSocketOpenQueue = []),
                          (this.retryCountMapping = new Map()),
                          (this.isDoneOffline = !1),
                          Mt.default.subscribe((e, t) => {
                            if (
                              e === St.WebsocketActions.CONNECTION_STATE_CHANGE
                            ) {
                              const { state: e, prevState: s } = t;
                              void 0 !== s &&
                                e === Lg.g.OPEN &&
                                this.isDoneOffline &&
                                this.handleWaitingConnectionRetry();
                            }
                          }),
                          Ec.default
                            .getChatHandler()
                            .subcribe(
                              jg.b.ON_DONE_OFFLINE,
                              this.unlockProcessOffline,
                            );
                      }
                      get Logger() {
                        return (
                          this.logger ||
                            (this.logger = i.ModuleContainer.resolve(
                              q.ZLoggerFactory,
                            ).createZLogger("auto-retry-socket", [
                              "retry-error-controller",
                            ])),
                          this.logger
                        );
                      }
                      getRetryTimeout(e) {
                        let t = 0;
                        return (
                          bt.default.retryConfig &&
                            bt.default.retryConfig.setting_feature &&
                            e.timestamp &&
                            e.timeout &&
                            (e.timeout === R.RETRY_MSG_TIMEOUT_DEFAULT
                              ? (t = bt.default.retryConfig.time_retry_default)
                              : e.timeout === R.RETRY_MSG_TIMEOUT_LONG &&
                                (t = bt.default.retryConfig.time_retry_long)),
                          t
                        );
                      }
                      getErrorCode(e) {
                        let t = e.code;
                        return (
                          e.code === Lg.f.ERR_CONNECTION_TIMED_OUT &&
                            Dn.b.getStateNetwork() !== Dn.a.CONNECTED &&
                            (t = Lg.f.ERR_NO_NETWORK),
                          t
                        );
                      }
                      shouldRetry(e, t, s) {
                        if (!e || !t || !s || s.count <= 0) return !1;
                        let i = this.getErrorCode(e);
                        if (
                          i === Lg.f.ERR_CONNECTION_TIMED_OUT ||
                          i === Lg.f.ERR_SOCKET_CLOSED ||
                          i === Lg.f.ERR_NO_NETWORK
                        ) {
                          var n;
                          const e =
                            null !== (n = this.retryCountMapping.get(t)) &&
                            void 0 !== n
                              ? n
                              : 0;
                          let a = bt.default.retryConfig.max_retry_count;
                          if (
                            (i === Lg.f.ERR_SOCKET_CLOSED &&
                              (a =
                                bt.default.retryConfig
                                  .max_err_network_retry_count),
                            void 0 !== e && e < a)
                          ) {
                            const e = this.getRetryTimeout(s);
                            return (
                              !!(
                                e && _t.default.getTimeNow() - s.timestamp < e
                              ) && (s.count && s.count--, !0)
                            );
                          }
                          return !1;
                        }
                        return !1;
                      }
                      pushToRetryQueue(e, t, s) {
                        const n = i.ModuleContainer.resolve(
                          Sg.a,
                        ).getRetryErrorCodeMapping();
                        this.logRetryError(e.code, s);
                        const a = this.getErrorCode(e);
                        if (a !== Lg.f.ERR_CONNECTION_TIMED_OUT) {
                          var r;
                          if (
                            a === Lg.f.ERR_SOCKET_CLOSED ||
                            a === Lg.f.ERR_NO_NETWORK
                          )
                            return (
                              this.retryCountMapping.set(
                                s,
                                null !== (r = this.retryCountMapping.get(s)) &&
                                  void 0 !== r
                                  ? r
                                  : 1,
                              ),
                              void this.waitingSocketOpenQueue.push(t)
                            );
                        } else {
                          var o, d;
                          const e =
                              (null !== (o = this.retryCountMapping.get(s)) &&
                              void 0 !== o
                                ? o
                                : 0) + 1,
                            i =
                              (null !==
                                (d = n.CONNECTION_TIMED_OUT_ERROR_CODE.delay) &&
                              void 0 !== d
                                ? d
                                : 3e4) *
                                e +
                              Ag.getGapTime();
                          setTimeout(() => {
                            this.retryCountMapping.set(s, e), t();
                          }, i);
                        }
                      }
                      logRetryError(e, t) {
                        this.Logger.zsymb(18, 14168, 3e4, e, t);
                      }
                      cleanUpItemQueue(e) {
                        this.retryCountMapping.delete(e);
                      }
                    }),
                  ) || Fg),
              ) || Fg),
          ) || Fg;
        i.ModuleContainer.registerSingleton(Sg.a, Dg),
          i.ModuleContainer.registerSingleton(Tg.a, Pg),
          i.ModuleContainer.registerSingleton(
            wg.a,
            class {
              constructor() {
                (this.waitingNetworkQueue = void 0),
                  (this.waitingCheckStatusQueue = void 0),
                  (this.waitingTimeout = void 0),
                  (this.onConnectionBack = () => {
                    const e = [...this.waitingNetworkQueue];
                    this.waitingNetworkQueue = [];
                    for (const t of e) {
                      const e = Ag.getGapTime();
                      window.requestIdleCallback(
                        () => {
                          t();
                        },
                        { timeout: e },
                      );
                    }
                  }),
                  (this.clearWaitingStatusTimeout = () => {
                    null !== this.waitingTimeout &&
                      (window.clearTimeout(this.waitingTimeout),
                      (this.waitingTimeout = null));
                  }),
                  (this.moveWaitingCheckStatusToWaitingConnection = () => {
                    this.clearWaitingStatusTimeout(),
                      this.waitingNetworkQueue.push(
                        ...this.waitingCheckStatusQueue,
                      ),
                      (this.waitingCheckStatusQueue = []);
                  }),
                  (this.processWaitingCheckStatus = () => {
                    this.clearWaitingStatusTimeout();
                    const e = [...this.waitingCheckStatusQueue];
                    this.waitingCheckStatusQueue = [];
                    for (const t of e) {
                      const e = Ag.getGapTime();
                      window.requestIdleCallback(
                        () => {
                          t();
                        },
                        { timeout: e },
                      );
                    }
                  }),
                  (this.waitingNetworkQueue = []),
                  (this.waitingCheckStatusQueue = []),
                  (this.waitingTimeout = null),
                  Q.p.listenEvent(Q.j, (e) => {
                    e === Dn.a.CONNECTED
                      ? (this.processWaitingCheckStatus(),
                        this.onConnectionBack())
                      : e === Dn.a.DISCONNECT &&
                        this.moveWaitingCheckStatusToWaitingConnection();
                  });
              }
              pushToRetryQueue(e) {
                Dn.b.getStateNetwork() === Dn.a.CONNECTED
                  ? (this.waitingCheckStatusQueue.push(e),
                    null === this.waitingTimeout &&
                      (this.waitingTimeout = window.setTimeout(() => {
                        (this.waitingTimeout = null),
                          this.processWaitingCheckStatus();
                      }, bt.default.retryConfig.max_waiting_check_status_time)))
                  : this.waitingNetworkQueue.push(e);
              }
            },
          );
        var Ng = s("dhS6"),
          Ug = s("WzIS"),
          kg = s("sLvT");
        let Bg;
        !(function (e) {
          (e[(e.ONE = 0)] = "ONE"), (e[(e.MULTI = 1)] = "MULTI");
        })(Bg || (Bg = {}));
        const Gg = (e) =>
          new Promise((t, s) => {
            setTimeout(() => {
              t(e || 3e3);
            }, e || 3e3);
          });
        var xg;
        let zg =
          Object($t.b)(Ng.a)(
            (xg =
              Reflect.metadata(
                "design:type",
                Function,
              )(
                (xg =
                  Reflect.metadata(
                    "design:paramtypes",
                    [],
                  )(
                    (xg = class {
                      get Logger() {
                        return (
                          this._Logger ||
                            (this._Logger = i.ModuleContainer.resolve(
                              q.ZLoggerFactory,
                            ).createZLogger(
                              hs.ZLoggerNametags.uiBannerController,
                              [hs.ZLoggerNametags.uiBannerQueue],
                            )),
                          this._Logger
                        );
                      }
                      constructor() {
                        (this.type = void 0),
                          (this.name = void 0),
                          (this.key = void 0),
                          (this.queue = void 0),
                          (this.uiState = new Map()),
                          (this.isFirtTriggerShowOnQueueCycle = void 0),
                          (this.timeoutNextBanner = void 0),
                          (this._Logger = void 0),
                          (this.name = Ng.b),
                          (this.key = "convId"),
                          (this.queue = []),
                          (this.isFirtTriggerShowOnQueueCycle = !0),
                          (this.timeoutNextBanner = null);
                      }
                      enBannerQueue(e, t) {
                        const s = this.queryBannerQueueItem(e.key);
                        switch ((s && this.doRemoveBannerQueueItem(s.key), t)) {
                          case Ug.a.NORMAL:
                            this.queue.push(e);
                            break;
                          case Ug.a.HIGH:
                            this.queue.unshift(e);
                        }
                      }
                      isEmptySyncSourceQueue() {
                        return 0 === this.queue.length;
                      }
                      deBannerQueue() {
                        return this.queue.shift();
                      }
                      removeBannerQueueItem(e) {
                        this.queue = [...this.queue].filter((t) => t.key !== e);
                      }
                      doRemoveBannerQueueItem(e) {
                        this.removeBannerQueueItem(e),
                          0 === this.queue.length &&
                            (this.isFirtTriggerShowOnQueueCycle = !0);
                      }
                      queryBannerQueueItem(e) {
                        return this.queue.find((t) => t.key === e);
                      }
                      handleShowUIBanner(e, t) {
                        Object(kg.b)().isEnableSingleUIBanner()
                          ? this.showSingleUI(e, t)
                          : this.showMultiUI(e, t);
                      }
                      isExistingShow() {
                        try {
                          const e = Object.fromEntries(this.uiState);
                          for (const t in e) if (e[t]) return t;
                          return null;
                        } catch (e) {
                          return null;
                        }
                      }
                      async showSingleUI(e, t) {
                        let s;
                        this.enBannerQueue({ key: e, priority: t }, t);
                        const i = this.isExistingShow();
                        if (
                          (i && (s = this.queryBannerQueueItem(i)),
                          Object(kg.b)().isEnableForceCloseNormalBanner() &&
                            i &&
                            t === Ug.a.HIGH &&
                            s)
                        )
                          return (
                            this.uiState.set(s.key, !1),
                            Object(nt.g)(this.name, s.key),
                            this.uiState.set(e, !0),
                            void Object(nt.g)(this.name, e)
                          );
                        i ||
                          (this.uiState.set(e, !0),
                          Object(nt.g)(this.name, e),
                          this.Logger.zsymb(
                            0,
                            16189,
                            3e4,
                            "[showSingleUI] Dont have displaying banner so show: " +
                              e +
                              ", current queue = " +
                              JSON.stringify(this.queue),
                          ));
                      }
                      showMultiUI(e, t) {
                        this.enBannerQueue({ key: e, priority: t }, t),
                          this.uiState.set(e, !0),
                          Object(nt.g)(this.name, e);
                      }
                      handleHideUIBanner(e) {
                        Object(kg.b)().isEnableSingleUIBanner()
                          ? this.hideSingleUI(e)
                          : this.hideMultiUI(e);
                      }
                      hideSingleUI(e) {
                        this.doRemoveBannerQueueItem(e),
                          this.uiState.get(e) &&
                            (this.uiState.set(e, !1),
                            Object(nt.g)(this.name, e),
                            this.timeoutNextBanner &&
                              clearTimeout(this.timeoutNextBanner),
                            (this.timeoutNextBanner = setTimeout(() => {
                              const e = this.queue[0];
                              e &&
                                !this.isExistingShow() &&
                                (this.uiState.set(e.key, !0),
                                Object(nt.g)(this.name, e.key),
                                this.Logger.zsymb(
                                  0,
                                  16189,
                                  30001,
                                  "[hideSingleUI] Pop next banner to show: " +
                                    e.key +
                                    ", current queue = " +
                                    JSON.stringify(this.queue),
                                ));
                            }, Object(kg.b)().getTimeDelayOnNextBanner())));
                      }
                      hideMultiUI(e) {
                        this.doRemoveBannerQueueItem(e),
                          this.uiState.set(e, !1),
                          Object(nt.g)(this.name, e);
                      }
                      async onShowBanner(e, t, s) {
                        s && (await Gg(s));
                        const i = Object(kg.b)().getTimeDelayOnStartApp();
                        this.isFirtTriggerShowOnQueueCycle && i
                          ? (await Gg(i), this.handleShowUIBanner(e, t))
                          : this.handleShowUIBanner(e, t),
                          (this.isFirtTriggerShowOnQueueCycle = !1);
                      }
                      async onHideBanner(e, t) {
                        t && (await Gg(t)), this.handleHideUIBanner(e);
                      }
                      getBannerList() {
                        return this.queue;
                      }
                      init(e) {
                        throw new Error("Method not implemented.");
                      }
                      getItem(e, t) {
                        return this.uiState.get(e.key);
                      }
                      getList(e, t) {
                        throw new Error("Method not implemented.");
                      }
                      onGetItemFailure(e, t) {
                        throw new Error("Method not implemented.");
                      }
                      onGetListFailure(e, t) {
                        throw new Error("Method not implemented.");
                      }
                      getDefaultItem() {
                        throw new Error("Method not implemented.");
                      }
                      getDefaultList() {
                        throw new Error("Method not implemented.");
                      }
                    }),
                  ) || xg),
              ) || xg),
          ) || xg;
        i.ModuleContainer.registerSingleton(Ng.a, zg);
        var Vg = s("k0yK"),
          Hg = s("Ivja"),
          $g = s("7cfu"),
          Wg = s("Sjwj"),
          Kg = s("P8xG"),
          qg = s("Pwb4"),
          Zg = s("BUsx"),
          Jg = s("RrMd"),
          Qg = s("N/wt"),
          Yg = s("JprO"),
          Xg = s("cTY6");
        (window.testUpload = function (e, t) {
          ni.a
            .uploadFile(
              {
                toUid: "g1966935908595292688",
                isGroup: !0,
                clientId: 1700187518372,
                additionalParams: { sendSource: 1, ttl: 0, idReq: 999 },
                extData: {
                  width: 330,
                  height: 276,
                  title: "",
                  photoBundle: {
                    groupLayoutId: "1700187518370",
                    totalItemInGroup: 1,
                    isGroupLayout: 1,
                    idInGroup: 0,
                  },
                  uploadMainType: 2,
                  fType: 1,
                  fdata: "{}",
                  pcloud: !0,
                },
                feature: 1,
                rawFile: {
                  name: "testuploadpcloud.png",
                  path: "/Users/lap15040/Desktop/testuploadpcloud.png",
                  size: 33547,
                  type: "image/png",
                  webkitRelativePath: "",
                },
              },
              { conflictWithServerRetry: 1 },
              {
                callbackError: (e, t, s) => {},
                onStart: () => {},
                signalProgress: (e) => {},
              },
            )
            .then(async (e) => {
              let { uploadData: t } = e;
              const s = t.secureOptions,
                i = Zg.a.arrayBufferToBase64(s.cryptography.key),
                n = Zg.a.arrayBufferToBase64(s.cryptography.iv),
                a = Zg.a.arrayBufferToBase64(s.cryptography.tag),
                r = await Hg.a.instance().encryptAESKey(i);
              (window._key = r.transformedText),
                (window._iv = n),
                (window._tag = a);
              const o = await Qg.c.enrichPCloudResp(
                  t.uploadMainType,
                  e.urlRes,
                  s.cryptography,
                  Hg.a.instance().encryptAESKey,
                ),
                d = o.fileAsync.fileUrl || o.fileAsync.rawUrl;
              (window._encryptedUrl = d),
                (window._checksum = e.urlRes.fileAsync.checksum);
            });
        }),
          (window.testDownload = function (e) {
            const t =
              e ||
              window._encryptedUrl ||
              "https://zalo-file-dl2.zdn.vn/1e625038b8b356ed0fa2/4851898059352493163@pcloudsession?abcakdjksadjasd";
            new Xg.a(t, Jg.b.DEV, (e) => {}).downloadBlob().then((e) => {
              const t = URL.createObjectURL(e),
                s = document.createElement("a");
              (s.href = t), (s.download = "a.jpg"), s.click();
            });
          }),
          (window.testDownloadPC = function (e) {
            Yg.a
              .run({
                type: Yg.a.constants.DownloadType.File,
                data: {
                  fileName: "test.jpg",
                  url:
                    e ||
                    window._encryptedUrl ||
                    "https://zalo-file-dl14.zdn.vn/e3fa67ba612c8f72d63d/6312426252984587938?pcloudsession=XVXCe8rgZQmAgbbVIMMHXq/Hpns8gDZh5lIAnBUTckYnwo+Gpng1/SzdZ34kizyrkmREqyp9xzyrbEnQMnTv3CZoraCtjsKeLaUmD0jBKYNas9RjrbEJbJ6VLlbJqKDGwhcanIGo1l4TWwUXfCvQ3gbp3E+gyiswCa1Mty1Z7dZhzzpyBSLqjx68XfNxxe+zhSZCYqx3M0ykR4KSfHDBQ6kGBIdXT6lugWgDJ00KpOccEt+wkcVKAl2/62RQ/hYREc27ULTXNCZSRkOwiOCDRaMDfaY34I4LV7hbONEcxuFeZdfx37l6Iiqpt/b2zRY2Yip+UAWpYCklXQVNMRpB5Q==",
                },
                options: {
                  saveDir: "/Users/lap15040/Downloads",
                  caching: !1,
                  duplicate: !1,
                  srcAction: Yg.a.constants.srcAction.Dev,
                  showProgress: { taskBar: !1, progressBar: !1 },
                  noiseDownload: !1,
                  timeOut: 1e4,
                  headers: [{ name: "viewer-key", value: "viewer-key-data" }],
                },
              })
              .then((e) => {})
              .catch((e) => {});
          });
        const em = Hg.a.instance();
        em.addEventListener(Vg.b.ReqKeyPermission, (e) => {
          e.callback(!0);
        }),
          em.addEventListener(Vg.b.ReqKeySuccess, (e) => {}),
          em.addEventListener(Vg.b.ReqKeyFail, (e) => {}),
          (window._fakeSVKey = async () => {
            var e;
            const [t, s] = await Object(Kg.f)(),
              i = {
                act: $g.b.repKeyActType,
                data: {
                  device_name: Object(Kg.g)(),
                  session_id:
                    (null === (e = qg.a.instance().getCurrentSession()) ||
                    void 0 === e
                      ? void 0
                      : e.sessionId) || "",
                  user_action: 1,
                  key_version: 1,
                  public_key: t,
                  encrypted_private_key: s,
                },
              };
            Object(Wg.a)([i]);
          });
        var tm = s("kZZr"),
          sm = s("rBV8");
        class im {
          constructor(e, t, s) {
            void 0 === s && (s = !0),
              (this.useDefaultList = s),
              (this.type = void 0),
              (this.name = void 0),
              (this.key = void 0),
              (this.data = void 0),
              (this.name = e),
              (this.key = t),
              (this.data = this.getInitialData());
          }
          init() {}
          getInitialData() {
            return new Map();
          }
          updateItem(e, t, s) {
            void 0 === s && (s = !1);
            const i = Object(wr.a)(this.data.get(t) || {}, e);
            this.data.set(t, i),
              s ||
                (Object(sm.f)(this.name, t),
                this.useDefaultList && Object(sm.h)(this.name, ""));
          }
          removeItem(e, t) {
            void 0 === t && (t = !1),
              this.data.delete(e),
              t || (Object(sm.c)(this.name, e), Object(sm.h)(this.name, ""));
          }
          getItem(e, t) {
            const s = e.key;
            return this.data.get(s);
          }
          getList(e, t) {
            return this.getDefaultList();
          }
          onGetItemFailure(e, t) {}
          onGetListFailure(e, t) {}
          getDefaultItem() {
            return { value: null };
          }
          getDefaultList() {
            return this.useDefaultList ? Array.from(this.data.keys()) : [];
          }
        }
        var nm = s("VteK"),
          am = s("UwMY"),
          rm = s("YbKq"),
          om = s("85uQ"),
          dm = s("Ilka"),
          lm = s("4LiO"),
          cm = s("bWos"),
          hm = s("/YHU");
        class um {
          constructor(e) {
            var t, s, i;
            if (
              ((this.zCloudKey = void 0),
              (this.size = void 0),
              (this.ts = void 0),
              (this.extraInfo = void 0),
              (this.message = void 0),
              (this.zCloudKey = cm.a.getZCloudKeyFromQueryItem(e)),
              (this.size = 0),
              null != e && null !== (t = e.message) && void 0 !== t && t.params)
            ) {
              const t = Object(hm.a)(e.message.params);
              var n;
              if (t)
                this.size =
                  (null === (n = e.cloudInfo) || void 0 === n
                    ? void 0
                    : n.mediaInfo.mediaSize) ||
                  +(null == t ? void 0 : t.fileSize) ||
                  0;
            }
            (this.ts = null == e ? void 0 : e.sendDttm),
              null !== (s = e.message) &&
                void 0 !== s &&
                s.title &&
                (this.extraInfo = Object(f.a)(
                  Object(f.a)({}, this.extraInfo),
                  {},
                  { title: e.message.title },
                )),
              null !== (i = e.message) &&
                void 0 !== i &&
                i.thumbUrl &&
                (this.extraInfo = Object(f.a)(
                  Object(f.a)({}, this.extraInfo),
                  {},
                  { title: e.message.thumbUrl },
                )),
              (this.message = e);
          }
          static transfer(e) {
            const t = new um(e);
            return Object.assign({}, t);
          }
        }
        var gm,
          mm = s("JP/W");
        const pm = function () {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
              t[s] = arguments[s];
            Object(mm.a)("[cloud-item-list-controller]", ...t);
          },
          fm = "cloud",
          vm = {
            cloudItems: null,
            displayData: null,
            currentFilter: rm.c.ALL,
            currentSort: rm.d.SIZE_DESCENDING,
            status: "",
            cloud: {
              total: 0,
              used: { all: 0, photo: 0, video: 0, file: 0, voice: 0 },
              plan: -1,
              remove_ts: 0,
            },
            myCloudUsage: 0,
            error: { displayData: { errCode: null } },
          };
        Object(i.singleton)(tm.b)(
          (gm =
            Object($t.b)(tm.b)(
              (gm =
                Object(i.injectable)()(
                  (gm =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (gm =
                        Reflect.metadata(
                          "design:paramtypes",
                          [],
                        )(
                          (gm = class extends im {
                            constructor() {
                              super(),
                                (this.type = void 0),
                                (this.name = void 0),
                                (this.key = void 0),
                                (this.data = new Map()),
                                (this.cloudViewItems = void 0),
                                (this.name = tm.a),
                                (this.key = tm.a),
                                this.data.set(fm, vm),
                                (this.cloudViewItems = null);
                            }
                            _getState(e) {
                              void 0 === e && (e = fm);
                              return this.data.get(e);
                            }
                            _sort(e) {
                              const t = this._getState();
                              let { displayData: s } = t;
                              if (Array.isArray(s)) {
                                switch (e) {
                                  case rm.d.SIZE_ASCENDING:
                                  case rm.d.SIZE_DESCENDING:
                                    s = s.slice().sort((t, s) => {
                                      const i = null == t ? void 0 : t.size,
                                        n = (null == s ? void 0 : s.size) - i;
                                      return e === rm.d.SIZE_DESCENDING
                                        ? n
                                        : -n;
                                    });
                                    break;
                                  case rm.d.TIME_ASCENDING:
                                  case rm.d.TIME_DESCENDING:
                                    s = s.slice().sort((t, s) => {
                                      const i = null == t ? void 0 : t.ts,
                                        n = (null == s ? void 0 : s.ts) - i;
                                      return e === rm.d.TIME_DESCENDING
                                        ? n
                                        : -n;
                                    });
                                }
                                this.updateItem((t) => {
                                  (t.displayData = s), (t.currentSort = e);
                                }, fm);
                              }
                            }
                            _filter(e) {
                              if (!Array.isArray(this.cloudViewItems)) return;
                              let t;
                              switch (e) {
                                case rm.c.ALL:
                                  t = this.cloudViewItems;
                                  break;
                                case rm.c.PHOTO_AND_VIDEO:
                                  t = this._filterByType(this.cloudViewItems, [
                                    R.MSG_PHOTO,
                                    R.MSG_PHOTO_2,
                                    R.MSG_DOODLE,
                                    R.MSG_VIDEO,
                                  ]);
                                  break;
                                case rm.c.FILE:
                                  t = this._filterByType(this.cloudViewItems, [
                                    R.MSG_FILE,
                                  ]);
                                  break;
                                case rm.c.VOICE:
                                  t = this._filterByType(this.cloudViewItems, [
                                    R.MSG_VOICE,
                                  ]);
                              }
                              this.updateItem((s) => {
                                (s.displayData = t), (s.currentFilter = e);
                              }, fm);
                            }
                            _filterByType(e, t) {
                              return e.filter((e) =>
                                t.includes(e.message.msgType),
                              );
                            }
                            _getCurrentSort() {
                              const { currentSort: e } = this._getState();
                              return e;
                            }
                            _getCurrentFilter() {
                              const { currentFilter: e } = this._getState();
                              return e;
                            }
                            _getSettledUsage(e, t) {
                              return (
                                void 0 === t && (t = "usage"),
                                "fulfilled" === e.status && e.value[t]
                                  ? e.value[t]
                                  : 0
                              );
                            }
                            async _getAllCloudTypeUsage() {
                              try {
                                const e = am.a.map((e) =>
                                  nm.c.getCloudUsageByType(
                                    e,
                                    bt.default.sendToMeId || "",
                                  ),
                                );
                                return (
                                  e.push(nm.c.getCloudUsage()),
                                  await Promise.allSettled(e)
                                );
                              } catch (e) {
                                throw e;
                              }
                            }
                            _getCloudInfoFromUsage(e) {
                              if (!e) return;
                              const [t, s, i, n, a, r, o] = e,
                                d = {
                                  used: {
                                    photo:
                                      this._getSettledUsage(t) +
                                      this._getSettledUsage(s) +
                                      this._getSettledUsage(i),
                                    video: this._getSettledUsage(n),
                                    file: this._getSettledUsage(a),
                                    voice: this._getSettledUsage(r),
                                  },
                                  total: this._getSettledUsage(o, "free_quota"),
                                  zCloudUsage: this._getSettledUsage(o),
                                },
                                l = this._getSettledUsage(o, "plan"),
                                c = this._getSettledUsage(o, "abuse_info");
                              return (
                                (d.used.all =
                                  d.used.photo +
                                  d.used.video +
                                  d.used.file +
                                  d.used.voice),
                                (d.plan = l),
                                (d.remove_ts =
                                  null != c && c.remove_ts ? c.remove_ts : 0),
                                d
                              );
                            }
                            async _getCloudUsage() {
                              try {
                                const e = await this._getAllCloudTypeUsage();
                                pm("usageResult: ", e);
                                const t = this._getCloudInfoFromUsage(e);
                                this.updateItem((e) => {
                                  e.cloud = t;
                                }, fm);
                              } catch (e) {
                                throw Error(e);
                              }
                            }
                            _calculateStatusFromUsage() {
                              var e;
                              let t = om.a.NORMAL;
                              const s = this._getState(),
                                i = (null == s ? void 0 : s.cloud) || {},
                                n = (null == i ? void 0 : i.total) || 0,
                                a =
                                  (null == i ||
                                  null === (e = i.used) ||
                                  void 0 === e
                                    ? void 0
                                    : e.all) || 0;
                              if (n && a) {
                                const e = n - a,
                                  s = Object(dm.n)(),
                                  r = Object(dm.k)();
                                a > s && (t = om.a.NEARY_FULL),
                                  e > 0 && e <= r && (t = om.a.ALMOST_FULL),
                                  e <= 0 &&
                                    (t =
                                      null != i && i.remove_ts
                                        ? om.a.DELETE_SOON
                                        : om.a.FULL);
                              }
                              return t;
                            }
                            _getCurrentCloudStatus() {
                              const e = this._calculateStatusFromUsage();
                              this.updateItem((t) => {
                                t.status = e;
                              }, fm);
                            }
                            _isInCloudViewItems(e) {
                              if (!Array.isArray(this.cloudViewItems))
                                return !1;
                              const t = cm.a.getZCloudKeyFromQueryItem(e);
                              return !!this.cloudViewItems.find(
                                (e) => e.zCloudKey === t,
                              );
                            }
                            filter(e) {
                              this._filter(e),
                                this._sort(this._getCurrentSort());
                            }
                            sort(e) {
                              this._sort(e);
                            }
                            async getCloudUsage() {
                              await this._getCloudUsage(),
                                this._getCurrentCloudStatus();
                            }
                            async getCloudMsgs() {
                              try {
                                const e = await nm.c.getMsgFromMyCloudOnly();
                                (this.cloudViewItems = e.map((e) =>
                                  um.transfer(e),
                                )),
                                  this.filter(this._getCurrentFilter());
                              } catch (e) {
                                throw (
                                  (this.updateItem((t) => {
                                    t.error.displayData.errCode = e.code;
                                  }, fm),
                                  pm("getCloudMsgs error: ", e),
                                  Error(e))
                                );
                              }
                            }
                            updateCloudViewItems(e) {
                              if (!Array.isArray(e)) return;
                              const t = e.filter(
                                (e) => !this._isInCloudViewItems(e),
                              );
                              if (!Array.isArray(t)) return;
                              const s = bt.default.sendToMeId || "";
                              if (Array.isArray(this.cloudViewItems)) {
                                const e = t.flatMap((e) =>
                                  e.toUid !== s ? [] : um.transfer(e),
                                );
                                this.cloudViewItems =
                                  this.cloudViewItems.concat(e);
                              }
                              this.filter(this._getCurrentFilter());
                            }
                            async updateCloudItems(e) {
                              if (!Array.isArray(e)) return;
                              const t = bt.default.sendToMeId || "",
                                s = e.flatMap((e) => {
                                  if (e.msgInfo.destId !== t) return [];
                                  const s = cm.a.getCloudQueryFromCloudItem(e);
                                  return null != s ? s : [];
                                }),
                                i = await nm.c.getMultiCloudMessages(t, s);
                              this.updateCloudViewItems(i);
                            }
                            async getOnlyMyCloudUsage() {
                              try {
                                const e = bt.default.sendToMeId || "",
                                  t = await nm.c.getCloudUsageByConversation(e);
                                this.updateItem((e) => {
                                  e.myCloudUsage = t;
                                }, fm);
                              } catch (e) {
                                throw Error(e);
                              }
                            }
                            async fetchAllData(e) {
                              if (
                                (await Promise.allSettled([
                                  this.getCloudUsage(),
                                  this.getOnlyMyCloudUsage(),
                                  this.getCloudMsgs(),
                                ]),
                                !e || "string" != typeof e)
                              )
                                return;
                              const { cloud: t } = this._getState(),
                                s = {
                                  cloud: t,
                                  cloudViewItems: this.cloudViewItems,
                                  fromEntry: e,
                                };
                              lm.a.logAllTypeUsage(s);
                            }
                            init(e) {
                              throw new Error("Method not implemented.");
                            }
                            getItem(e, t) {
                              return this._getState(e.key);
                            }
                            getList(e, t) {
                              throw new Error("Method not implemented.");
                            }
                            onGetItemFailure(e, t) {
                              throw new Error("Method not implemented.");
                            }
                            onGetListFailure(e, t) {
                              throw new Error("Method not implemented.");
                            }
                            getDefaultItem() {
                              throw new Error("Method not implemented.");
                            }
                            getDefaultList() {
                              throw new Error("Method not implemented.");
                            }
                          }),
                        ) || gm),
                    ) || gm),
                ) || gm),
            ) || gm),
        );
        var bm,
          Im = s("Jmku"),
          ym = s("tP1L"),
          _m = s("9XoL"),
          Om = s("bO3J"),
          Cm = s("cCVI"),
          Em = s("k+eZ"),
          Mm = s("CBkG");
        const Sm = "1",
          Tm = { showTip: !1, showEntry: !1 };
        Object(i.injectable)()(
          (bm =
            Object(i.singleton)(Em.b)(
              (bm =
                Object($t.b)(Em.b)(
                  (bm =
                    (function (e, t) {
                      return Object(i.inject)(_m.b)(e, void 0, 0);
                    })(
                      (bm =
                        (function (e, t) {
                          return Object(i.inject)(Cm.a)(e, void 0, 1);
                        })(
                          (bm =
                            Reflect.metadata(
                              "design:type",
                              Function,
                            )(
                              (bm =
                                Reflect.metadata("design:paramtypes", [
                                  void 0 === _m.b ? Object : _m.b,
                                  void 0 === Cm.a ? Object : Cm.a,
                                ])(
                                  (bm = class extends im {
                                    constructor(e, t) {
                                      super(),
                                        (this.eventsResolver = e),
                                        (this.onboardEventsResolver = t),
                                        (this.type = void 0),
                                        (this.name = void 0),
                                        (this.key = void 0),
                                        (this.data = new Map()),
                                        (this.name = Em.a),
                                        (this.key = Em.a),
                                        this.data.set(Sm, Tm),
                                        (this.triggerOnboardingHandler =
                                          this.triggerOnboardingHandler.bind(
                                            this,
                                          )),
                                        (this.offPlanHandler =
                                          this.offPlanHandler.bind(this));
                                    }
                                    _getState(e) {
                                      void 0 === e && (e = Sm);
                                      return this.data.get(e);
                                    }
                                    closePop() {
                                      const { popTabIndentity: e } =
                                        this._getState();
                                      e &&
                                        Im.a.isVisible(e) &&
                                        Im.a.closePopover(e);
                                    }
                                    triggerOnboardingHandler(e) {
                                      switch (e.type) {
                                        case Om.b.MOBILE_COMPLETED_BEFORE:
                                        case Om.b.MOBILE_JUST_MIGRATE_DONE:
                                          this.updateItem((e) => {
                                            (e.showEntry = !0),
                                              (e.showTip = !0);
                                          }, Sm);
                                      }
                                    }
                                    offPlanHandler(e) {
                                      this.closePop(),
                                        this.updateItem((e) => {
                                          (e.showEntry = !1), (e.showTip = !1);
                                        }, Sm);
                                    }
                                    initShouldShowEntry(e) {
                                      this.updateItem((t) => {
                                        t.showEntry = e;
                                      }, Sm);
                                    }
                                    addListener() {
                                      this.onboardEventsResolver.addEventListener(
                                        Om.b.MOBILE_COMPLETED_BEFORE,
                                        this.triggerOnboardingHandler,
                                      ),
                                        this.onboardEventsResolver.addEventListener(
                                          Om.b.MOBILE_JUST_MIGRATE_DONE,
                                          this.triggerOnboardingHandler,
                                        ),
                                        this.eventsResolver.addEventListener(
                                          Mm.a.OFF_PERSONAL_CLOUD_PLAN,
                                          this.offPlanHandler,
                                        );
                                    }
                                    removeListener() {
                                      this.onboardEventsResolver.removeEventListener(
                                        Om.b.MOBILE_COMPLETED_BEFORE,
                                        this.triggerOnboardingHandler,
                                      ),
                                        this.onboardEventsResolver.removeEventListener(
                                          Om.b.MOBILE_JUST_MIGRATE_DONE,
                                          this.triggerOnboardingHandler,
                                        ),
                                        this.eventsResolver.removeEventListener(
                                          Mm.a.OFF_PERSONAL_CLOUD_PLAN,
                                          this.offPlanHandler,
                                        );
                                    }
                                    onDoneOnboarding() {
                                      this.submitDoneOnboarding(),
                                        this.updateItem((e) => {
                                          e.showTip = !1;
                                        }, Sm);
                                    }
                                    setPopTabIdentity(e) {
                                      e &&
                                        this.updateItem((t) => {
                                          t.popTabIndentity = e;
                                        }, Sm);
                                    }
                                    async submitDoneOnboarding() {
                                      try {
                                        await ym.a.submitOnboardingInfo();
                                      } catch (e) {}
                                    }
                                  }),
                                ) || bm),
                            ) || bm),
                        ) || bm),
                    ) || bm),
                ) || bm),
            ) || bm),
        );
        var wm = s("iyDo"),
          Rm = s("UDME"),
          Lm = s("A9no"),
          Dm = s("tIXy");
        var Fm = class {
          constructor() {
            (this.data = void 0), (this.data = new Map());
          }
          startCapture(e, t) {
            void 0 === t && (t = {}),
              this.data.set(e, {
                start: _t.default.getTimeNow(),
                end: null,
                params: t,
              });
          }
          finishCapture(e, t) {
            void 0 === t && (t = {});
            const s = this.data.get(e);
            if (s) {
              const i = Object(f.a)(
                Object(f.a)({}, s),
                {},
                {
                  end: _t.default.getTimeNow(),
                  params: Object(Ud.a)(s.params, t),
                },
              );
              return this.data.set(e, i), i;
            }
            return s;
          }
          getItem(e) {
            return this.data.get(e);
          }
          clearItem(e) {
            this.data.delete(e);
          }
        };
        let Am, jm, Pm, Nm, Um, km;
        !(function (e) {
          (e[(e.NORMAL = 0)] = "NORMAL"),
            (e[(e.SILENTLY = 1)] = "SILENTLY"),
            (e[(e.BLOCKING = 2)] = "BLOCKING"),
            (e[(e.SILENTLY_BLOCKING = 3)] = "SILENTLY_BLOCKING");
        })(Am || (Am = {})),
          (function (e) {
            (e[(e.OFF = 0)] = "OFF"), (e[(e.ON = 1)] = "ON");
          })(jm || (jm = {})),
          (function (e) {
            (e[(e.MEMBER = 0)] = "MEMBER"),
              (e[(e.OWNER = 1)] = "OWNER"),
              (e[(e.ADMIN = 2)] = "ADMIN");
          })(Pm || (Pm = {})),
          (function (e) {
            (e[(e.CHAT_11 = 1)] = "CHAT_11"),
              (e[(e.CHAT_GROUP = 2)] = "CHAT_GROUP"),
              (e[(e.MY_CLOUD = 3)] = "MY_CLOUD");
          })(Nm || (Nm = {})),
          (function (e) {
            (e[(e.MANUAL = 0)] = "MANUAL"),
              (e[(e.DEFAULT = 1)] = "DEFAULT"),
              (e[(e.NOT_SILENTLY = -1)] = "NOT_SILENTLY");
          })(Um || (Um = {})),
          (function (e) {
            (e[(e.LEAVE_GROUP = 1)] = "LEAVE_GROUP"),
              (e[(e.CHANGE_HIDE_MEMBER_SETTING = 1)] =
                "CHANGE_HIDE_MEMBER_SETTING"),
              (e[(e.CLICK_GROUP_LINK = 1)] = "CLICK_GROUP_LINK"),
              (e[(e.UPGRADE_COMMUNITY = 1)] = "UPGRADE_COMMUNITY"),
              (e[(e.VERIFY_ACCOUNT = 2)] = "VERIFY_ACCOUNT"),
              (e[(e.CLICK_LEARN_MORE = 3)] = "CLICK_LEARN_MORE"),
              (e[(e.ENTER_UPGRADE_FLOW = 4)] = "ENTER_UPGRADE_FLOW"),
              (e[(e.ENTER_KYC_FLOW = 5)] = "ENTER_KYC_FLOW");
          })(km || (km = {}));
        i.ModuleContainer.registerSingleton(
          wm.a,
          class {
            constructor() {
              (this.upgradeCommunityCapture = void 0),
                (this.verificationCapture = void 0),
                (this.upgradeCommunityCapture = new Fm()),
                (this.verificationCapture = new Fm());
            }
            logAction999(e) {
              const { type: t, payload: s, noisedIds: i } = e;
              let n;
              switch (t) {
                case "LEAVE_GROUP":
                  (n = km.LEAVE_GROUP),
                    Xe.e.logActionInfoV2(Xe.b.LeaveGroupSilently, n, s, i);
                  break;
                case "CHANGE_HIDE_MEMBER_SETTING":
                  (n = km.CHANGE_HIDE_MEMBER_SETTING),
                    Xe.e.logActionInfoV2(Xe.b.HideMemberPresence, n, s, i);
                  break;
                case "CLICK_GROUP_LINK":
                  (n = km.CLICK_GROUP_LINK),
                    Xe.e.logActionInfoV2(Xe.b.ClickGroupLink, n, s, i);
                  break;
                case "UPGRADE_COMMUNITY":
                  (n = km.UPGRADE_COMMUNITY),
                    Xe.e.logActionInfoV2(Xe.b.Community, n, s, i);
                  break;
                case "VERIFY_ACCOUNT":
                  (n = km.VERIFY_ACCOUNT),
                    Xe.e.logActionInfoV2(Xe.b.Community, n, s, i);
                  break;
                case "CLICK_LEARN_MORE":
                  (n = km.CLICK_LEARN_MORE),
                    Xe.e.logActionInfoV2(Xe.b.Community, n, s, i);
                  break;
                case "ENTER_KYC_FLOW":
                  (n = km.ENTER_KYC_FLOW),
                    Xe.e.logActionInfoV2(Xe.b.Community, n, s, i);
                  break;
                case "ENTER_UPGRADE_FLOW":
                  (n = km.ENTER_UPGRADE_FLOW),
                    Xe.e.logActionInfoV2(Xe.b.Community, n, s, i);
              }
            }
            getChatTypeFromConvId(e) {
              return Ct.default.isGroup(e)
                ? Nm.CHAT_GROUP
                : ug.a.isSendToMe(e)
                  ? Nm.MY_CLOUD
                  : Nm.CHAT_11;
            }
            getMemberRole(e, t) {
              return Rm.GroupSettingHelper.isOwner(e, t)
                ? Pm.OWNER
                : Rm.GroupSettingHelper.isAdmin(e, t)
                  ? Pm.ADMIN
                  : Pm.MEMBER;
            }
            isDefaultLeaveSilently(e) {
              return (
                !(
                  !bt.default.group_privacy.hide_member.enable ||
                  !Rm.GroupSettingHelper.isLockViewMember(e)
                ) ||
                !(
                  !bt.default.group_privacy.leave_group_silently.enable ||
                  !Lm.isCommunity(e)
                )
              );
            }
            getLeaveGroupSilentlyType(e, t) {
              return this.isDefaultLeaveSilently(e)
                ? Um.DEFAULT
                : "SILENTLY" === t
                  ? Um.MANUAL
                  : Um.NOT_SILENTLY;
            }
            changeHideMemberSettingReport(e) {
              const t = Ct.default.getGroupIdFromConversationId(e.groupId),
                s = Ye.default.getUidMe();
              this.logAction999({
                type: "CHANGE_HIDE_MEMBER_SETTING",
                payload: {
                  mode: e.value ? jm.ON : jm.OFF,
                  des_id: t,
                  src_id: s,
                },
                noisedIds: [t, s],
              });
            }
            clickGroupLinkReport(e) {
              const t = Ct.default.getGroupIdFromConversationId(e.groupId),
                s = Ye.default.getUidMe();
              this.logAction999({
                type: "CLICK_GROUP_LINK",
                payload: {
                  chat_type: e.conversationId
                    ? this.getChatTypeFromConvId(e.conversationId)
                    : null,
                  src_id: s,
                  des_id: t,
                  lobby_version: bt.default.group_privacy.hide_member.enable
                    ? 1
                    : 0,
                },
                noisedIds: [s, t],
              });
            }
            leaveGroupReport(e) {
              let t = e.groupId;
              t.startsWith(R.GROUPID_PREFIX) || (t = R.GROUPID_PREFIX + t);
              const s = Ct.default.getGroupIdFromConversationId(e.groupId),
                i = Ye.default.getUidMe();
              this.logAction999({
                type: "LEAVE_GROUP",
                payload: {
                  des_id: s,
                  src_id: i,
                  user_role: this.getMemberRole(t, Ye.default.getUidMe()),
                  status: this.isDefaultLeaveSilently(t)
                    ? Am.SILENTLY
                    : Am[e.leaveType],
                  silent_default: this.getLeaveGroupSilentlyType(
                    t,
                    e.leaveType,
                  ),
                },
                noisedIds: [s, i],
              });
            }
            openPopupUpgradeCommunityReport(e) {
              const { groupId: t, entryPoint: s } = e;
              this.upgradeCommunityCapture.startCapture(t, { entryPoint: s });
            }
            getVerificationStatusLogNumber(e) {
              switch (e) {
                case Dm.b.NEED_VERIFY:
                  return 0;
                case Dm.b.VERIFIED:
                  return 1;
                default:
                  return 3;
              }
            }
            closePopupUpgradeCommunityReport(e) {
              const {
                  groupId: t,
                  verificationStatus: s,
                  upgradeStatus: i,
                  errorCode: n,
                } = e,
                a = this.upgradeCommunityCapture.finishCapture(t);
              if (!a) return;
              const r = Ct.default.getGroupIdFromConversationId(t);
              this.logAction999({
                type: "UPGRADE_COMMUNITY",
                payload: {
                  des_id: r,
                  upgrade_status: i,
                  fail_error: n,
                  duration: a.end - a.start,
                  is_kyc: this.getVerificationStatusLogNumber(s),
                  entrypoint: a.params.entryPoint,
                  action: n ? "confirm_upgrade" : "close",
                },
                noisedIds: [r],
              }),
                this.upgradeCommunityCapture.clearItem(t);
            }
            openPopupVerificationReport(e) {
              const { groupId: t, entryPoint: s } = e;
              this.verificationCapture.startCapture(t, { entryPoint: s });
            }
            closePopupVerificationReport(e) {
              const { groupId: t, verificationStatus: s, action: i } = e,
                n = this.verificationCapture.finishCapture(t);
              if (!n) return;
              const a = Ct.default.getGroupIdFromConversationId(t);
              this.logAction999({
                type: "VERIFY_ACCOUNT",
                payload: {
                  des_id: a,
                  duration: n.end - n.start,
                  is_kyc: this.getVerificationStatusLogNumber(s),
                  entrypoint: n.params.entryPoint,
                  action: i || "close",
                },
                noisedIds: [a],
              }),
                this.verificationCapture.clearItem(t);
            }
            clickCommunityLearnMoreReport(e) {
              const { groupId: t, entryPoint: s } = e,
                i = Ct.default.getGroupIdFromConversationId(t);
              this.logAction999({
                type: "CLICK_LEARN_MORE",
                payload: { des_id: i, entrypoint: s },
                noisedIds: [i],
              });
            }
            mapGroupEntryToCommunity(e) {
              switch (e) {
                case "gr_add_member":
                  return "comm_add_member";
                case "gr_member_approval":
                  return "comm_member_approval";
                case "message_info":
                  return "msg_info";
                default:
                  return e;
              }
            }
            openPreventAddMemberReport(e) {
              const { entryPoint: t, groupId: s, type: i } = e,
                n = Ct.default.getGroupIdFromConversationId(s);
              this.logAction999({
                type:
                  "need_kyc" === i ? "ENTER_KYC_FLOW" : "ENTER_UPGRADE_FLOW",
                payload: {
                  des_id: n,
                  entrypoint: this.mapGroupEntryToCommunity(t),
                },
                noisedIds: [n],
              });
            }
          },
        );
        var Bm = s("sEfC"),
          Gm = s.n(Bm);
        var xm,
          zm = class {
            constructor(e) {
              (this.key = void 0), (this._data = void 0), (this.key = e);
            }
            get data() {
              if (!this._data) {
                const e = E.default
                  .getInstance()
                  .getItemForCurrentUser(this.key);
                let t = [];
                if (null !== e) {
                  try {
                    t = JSON.parse(e);
                  } catch {
                    t = [];
                  }
                  Array.isArray(t) || (t = []);
                }
                this._data = new Set(t);
              }
              return this._data;
            }
            addItem(e) {
              this.data.has(e) ||
                (this.data.add(e),
                E.default
                  .getInstance()
                  .setItemForCurrentUser(
                    this.key,
                    JSON.stringify(Array.from(this.data.values())),
                  ));
            }
            removeItem(e) {
              this.data.has(e) &&
                (this.data.delete(e),
                E.default
                  .getInstance()
                  .setItemForCurrentUser(
                    this.key,
                    JSON.stringify(Array.from(this.data.values())),
                  ));
            }
            clear() {
              this.data.clear(),
                E.default.getInstance().removeItemForCurrentUser(this.key);
            }
            hasItem(e) {
              return this.data.has(e);
            }
          };
        Object(i.injectable)()(
          (xm =
            Object(V.h)()(
              (xm =
                Object(V.g)()(
                  (xm =
                    Object($t.b)(wi.e)(
                      (xm =
                        (function (e, t) {
                          return Object(i.inject)(wi.h)(e, void 0, 0);
                        })(
                          (xm =
                            Reflect.metadata(
                              "design:type",
                              Function,
                            )(
                              (xm =
                                Reflect.metadata("design:paramtypes", [
                                  void 0 === wi.h ? Object : wi.h,
                                ])(
                                  (xm = class {
                                    constructor(e) {
                                      (this.onboardController = e),
                                        (this.name = void 0),
                                        (this.key = void 0),
                                        (this.logger = void 0),
                                        (this.data = void 0),
                                        (this.verification = void 0),
                                        (this.hiddenChatBoxBannerGroups =
                                          void 0),
                                        (this.handleUpdateDataItemImmediately =
                                          (e) => {
                                            let { groupId: t } = e;
                                            const s = {
                                              groupId: t,
                                              bannerStatus:
                                                this.getBannerStatusForItem(t),
                                            };
                                            this.data.set(t, s),
                                              this.signalUpdateItem(t);
                                          }),
                                        (this.handleUpdateDataItem = Gm()(
                                          this.handleUpdateDataItemImmediately,
                                          300,
                                          { leading: !1, trailing: !0 },
                                        )),
                                        (this.handleUsagedGroupInfoChange = (
                                          e,
                                          t,
                                        ) => {
                                          let { groupId: s } = e;
                                          if (
                                            !t &&
                                            !Rm.GroupSettingHelper.isOwner(
                                              s,
                                              Ye.default.getUidMe(),
                                            )
                                          )
                                            return;
                                          const n =
                                              Ks.default.isOpenChildWindowByConvId(
                                                s,
                                              ),
                                            a =
                                              s ==
                                              i.ModuleContainer.resolve(
                                                Wt.SidebarController,
                                              ).getCurrMainConvId();
                                          (n || a) &&
                                            (this.shouldLoadVerificationStatus(
                                              s,
                                            )
                                              ? (this.getAccountVerificationStatus(
                                                  () => {
                                                    this.handleUpdateDataItem({
                                                      groupId: s,
                                                    });
                                                  },
                                                ),
                                                (this.verification.loaded = !0))
                                              : this.handleUpdateDataItem({
                                                  groupId: s,
                                                }));
                                        }),
                                        (this.handleChangeOwnnerEvent = (e) => {
                                          let { groupId: t, ownerId: s } = e;
                                          (s == Ye.default.getUidMe() ||
                                            this.data.has(t)) &&
                                            this.handleUsagedGroupInfoChange(
                                              { groupId: t },
                                              !0,
                                            );
                                        }),
                                        (this.handleMultiGroupInfoChange = (
                                          e,
                                        ) => {
                                          for (const t of e)
                                            this.handleUsagedGroupInfoChange({
                                              groupId: t,
                                            });
                                        }),
                                        (this.handleProfileVerificationChange =
                                          (e) => {
                                            this.verification = {
                                              loaded: !0,
                                              status: e,
                                            };
                                            const t = [];
                                            this.data.forEach((e) => {
                                              t.push([
                                                e.groupId,
                                                Object(f.a)(
                                                  Object(f.a)({}, e),
                                                  {},
                                                  {
                                                    bannerStatus:
                                                      this.getBannerStatusForItem(
                                                        e.groupId,
                                                      ),
                                                  },
                                                ),
                                              ]);
                                            }),
                                              (this.data = new Map(t)),
                                              this.signalUpdateAllItems();
                                          }),
                                        (this.handleLeaveGroupEvent = (e) => {
                                          for (const t of e)
                                            this.data.delete(t),
                                              this.hiddenChatBoxBannerGroups.removeItem(
                                                t,
                                              );
                                        }),
                                        (this.name = wi.a),
                                        (this.key = "groupId"),
                                        (this.data = new Map()),
                                        (this.verification = {
                                          loaded: !1,
                                          status: null,
                                        }),
                                        (this.hiddenChatBoxBannerGroups =
                                          new zm(wi.c));
                                    }
                                    init() {
                                      throw new Error(
                                        "Method not implemented.",
                                      );
                                    }
                                    onStart() {
                                      ds.default.subscribeEventGroup(
                                        R.EventGroup.LEAVE_GROUP,
                                        this.handleLeaveGroupEvent,
                                      ),
                                        ds.default.subscribeEventGroup(
                                          R.EventGroup.UPGRADE_COMMUNITY,
                                          this.handleUsagedGroupInfoChange,
                                        ),
                                        ds.default.subscribeEventGroup(
                                          R.EventGroup.CHANGE_OWNER,
                                          this.handleChangeOwnnerEvent,
                                        ),
                                        ds.default.subscribeEventGroup(
                                          R.EventGroup.SIZE_CHANGE,
                                          this.handleUsagedGroupInfoChange,
                                        ),
                                        ds.default.subscribeEventGroup(
                                          R.EventGroup.GROUP_INFO_CHANGED,
                                          this.handleMultiGroupInfoChange,
                                        ),
                                        Ye.default.subscribeEventFriend(
                                          R.EventFriend
                                            .PROFILE_VERIFICATION_CHANGE,
                                          this.handleProfileVerificationChange,
                                        );
                                    }
                                    onDispose() {
                                      ds.default.unsubscribeEventGroup(
                                        R.EventGroup.LEAVE_GROUP,
                                        this.handleLeaveGroupEvent,
                                      ),
                                        ds.default.unsubscribeEventGroup(
                                          R.EventGroup.UPGRADE_COMMUNITY,
                                          this.handleUsagedGroupInfoChange,
                                        ),
                                        ds.default.unsubscribeEventGroup(
                                          R.EventGroup.CHANGE_OWNER,
                                          this.handleUsagedGroupInfoChange,
                                        ),
                                        ds.default.unsubscribeEventGroup(
                                          R.EventGroup.SIZE_CHANGE,
                                          this.handleUsagedGroupInfoChange,
                                        ),
                                        ds.default.unsubscribeEventGroup(
                                          R.EventGroup.GROUP_INFO_CHANGED,
                                          this.handleMultiGroupInfoChange,
                                        ),
                                        Ye.default.unsubscribeEventFriend(
                                          R.EventFriend
                                            .PROFILE_VERIFICATION_CHANGE,
                                          this.handleProfileVerificationChange,
                                        );
                                    }
                                    getList() {
                                      return Array.from(this.data.keys());
                                    }
                                    signalUpdateItem(e) {
                                      Object(nt.g)(this.name, e);
                                    }
                                    signalUpdateAllItems() {
                                      this.data.forEach((e) => {
                                        this.signalUpdateItem(e.groupId);
                                      });
                                    }
                                    get Logger() {
                                      return (
                                        this.logger ||
                                          (this.logger =
                                            i.ModuleContainer.resolve(
                                              q.ZLoggerFactory,
                                            ).createZLogger(
                                              hs.ZLoggerNametags.community,
                                              [this.name],
                                            )),
                                        this.logger
                                      );
                                    }
                                    getItem(e) {
                                      return this.data.get(e.key);
                                    }
                                    onGetItemFailure(e) {
                                      this.Logger.zsymb(
                                        20,
                                        15092,
                                        3e4,
                                        "Get community data item failed with id",
                                        e,
                                      );
                                    }
                                    onGetListFailure(e) {
                                      this.Logger.zsymb(
                                        20,
                                        15092,
                                        30001,
                                        "Get community data list failed",
                                        e,
                                      );
                                    }
                                    getProfileVerificationStatus() {
                                      return this.verification.status;
                                    }
                                    getBannerStatusForItem(e) {
                                      if (null === this.verification.status)
                                        return { show: !1 };
                                      const t = ds.default.getGroupByIdSync(e);
                                      if (
                                        "number" !=
                                          typeof (null == t
                                            ? void 0
                                            : t.totalMember) ||
                                        t.creatorId != Ye.default.getUidMe()
                                      )
                                        return { show: !1 };
                                      const s = wi.o.isCommunityFromInfo(t);
                                      let i,
                                        n = !1;
                                      const a = new Set([
                                        wi.f.CHAT_BOX,
                                        wi.f.RIGHT_BAR,
                                      ]);
                                      return (
                                        this.verification.status ===
                                        Dm.b.VERIFIED
                                          ? ((n =
                                              !s &&
                                              t.totalMember >=
                                                bt.default.group_privacy
                                                  .community
                                                  .grouptype_threshold),
                                            (i = wi.g.REACHED_UPGRADE))
                                          : ((n =
                                              s ||
                                              t.totalMember >=
                                                bt.default.group_privacy
                                                  .community
                                                  .minimum_warn_upgrade),
                                            (i = s
                                              ? wi.g.UPGRADED_VERIFY
                                              : t.totalMember >=
                                                  bt.default.group_privacy
                                                    .community
                                                    .grouptype_threshold
                                                ? wi.g.REACHED_VERIFY
                                                : wi.g.NEARLY_REACH_VERIFY)),
                                        this.hiddenChatBoxBannerGroups.hasItem(
                                          e,
                                        ) && a.delete(wi.f.CHAT_BOX),
                                        { show: n, type: i, position: a }
                                      );
                                    }
                                    getAccountVerificationStatus(e) {
                                      Ye.default
                                        .getVerificationStatusMe()
                                        .then((t) => {
                                          (this.verification.status = t),
                                            null == e || e(t);
                                        })
                                        .catch((e) => {
                                          this.Logger.zsymb(
                                            18,
                                            15092,
                                            30002,
                                            "Get account verification status failed",
                                            e,
                                          );
                                        });
                                    }
                                    upgradeToCommunity(e) {
                                      return new Promise((t, s) => {
                                        Ot.default
                                          .upgradeGroupToCommunity(e)
                                          .then(() => {
                                            this.Logger.zsymb(
                                              18,
                                              15092,
                                              30003,
                                              "Upgrade community succeed",
                                              e,
                                            ),
                                              t();
                                          })
                                          .catch((t) => {
                                            this.Logger.zsymb(
                                              18,
                                              15092,
                                              30004,
                                              "Upgrade community failed",
                                              e,
                                              t,
                                            ),
                                              s(t);
                                          });
                                      });
                                    }
                                    shouldLoadVerificationStatus(e) {
                                      if (
                                        this.verification.loaded &&
                                        this.verification.status ===
                                          Dm.b.VERIFIED
                                      )
                                        return !1;
                                      const t = ds.default.getGroupByIdSync(e);
                                      return (
                                        "number" ==
                                          typeof (null == t
                                            ? void 0
                                            : t.totalMember) &&
                                        (wi.o.isCommunityFromInfo(t) ||
                                          t.totalMember >=
                                            bt.default.group_privacy.community
                                              .minimum_warn_upgrade)
                                      );
                                    }
                                    onConversationDidOpen(e) {
                                      this.onboardController.onConversationDidOpen(
                                        e,
                                      ),
                                        Hi.a.isGroup(e) &&
                                          Rm.GroupSettingHelper.isOwner(
                                            e,
                                            Ye.default.getUidMe(),
                                          ) &&
                                          (this.shouldLoadVerificationStatus(e)
                                            ? (this.getAccountVerificationStatus(
                                                () => {
                                                  this.handleUpdateDataItemImmediately(
                                                    { groupId: e },
                                                  );
                                                },
                                              ),
                                              (this.verification.loaded = !0))
                                            : this.data.has(e) ||
                                              this.handleUpdateDataItemImmediately(
                                                { groupId: e },
                                              ));
                                    }
                                    onReceivedCommunityError(e) {
                                      let {
                                        groupId: t,
                                        errorCode: s,
                                        windowId: n,
                                        src: a,
                                      } = e;
                                      switch (s) {
                                        case R.GROUP_MEMBER_ERROR
                                          .OWNER_NEED_VERIFY_PROFILE:
                                        case R.GROUP_MEMBER_ERROR
                                          .REACHED_LIMIT_MEMBER_GROUP:
                                          Je.ModalManagerV2.openModal({
                                            windowId: n,
                                            name: R.ModalIdentitiesDefine
                                              .COMMUNITY_PREVENT_ADD_MEMBER,
                                            params: {
                                              groupId: t,
                                              errorCode: s,
                                              src: a,
                                            },
                                          }),
                                            a &&
                                              Rm.GroupSettingHelper.isOwner(
                                                t,
                                                Ye.default.getUidMe(),
                                              ) &&
                                              i.ModuleContainer.resolve(
                                                wi.n,
                                              ).openPreventAddMemberReport({
                                                groupId: t,
                                                type:
                                                  s ==
                                                  R.GROUP_MEMBER_ERROR
                                                    .OWNER_NEED_VERIFY_PROFILE
                                                    ? "need_kyc"
                                                    : "need_upgrade",
                                                entryPoint: a,
                                              });
                                      }
                                    }
                                    closeChatBoxBanner(e) {
                                      this.hiddenChatBoxBannerGroups.addItem(e),
                                        this.handleUpdateDataItemImmediately({
                                          groupId: e,
                                        });
                                    }
                                  }),
                                ) || xm),
                            ) || xm),
                        ) || xm),
                    ) || xm),
                ) || xm),
            ) || xm),
        );
        var Vm,
          Hm = class {
            constructor(e) {
              (this.key = void 0), (this._data = void 0), (this.key = e);
            }
            get data() {
              if (!this._data) {
                const e = E.default
                  .getInstance()
                  .getItemForCurrentUser(this.key);
                let t = [];
                if (null !== e) {
                  try {
                    t = JSON.parse(e);
                  } catch {
                    t = [];
                  }
                  Array.isArray(t) || (t = []);
                }
                this._data = new Map(t);
              }
              return this._data;
            }
            setItem(e, t) {
              this.data.get(e) !== t &&
                (this.data.set(e, t),
                E.default
                  .getInstance()
                  .setItemForCurrentUser(
                    this.key,
                    JSON.stringify(Array.from(this.data.entries())),
                  ));
            }
            removeItem(e) {
              this.data.has(e) &&
                (this.data.delete(e),
                E.default
                  .getInstance()
                  .setItemForCurrentUser(
                    this.key,
                    JSON.stringify(Array.from(this.data.entries())),
                  ));
            }
            getItem(e) {
              return this.data.get(e);
            }
            values() {
              return Array.from(this.data.values());
            }
            clear() {
              this.data.clear(),
                E.default.getInstance().removeItemForCurrentUser(this.key);
            }
            hasItem(e) {
              return this.data.has(e);
            }
          };
        Object(V.h)()(
          (Vm =
            Object(V.g)()(
              (Vm =
                Object(i.singleton)(wi.h)(
                  (Vm =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (Vm =
                        Reflect.metadata(
                          "design:paramtypes",
                          [],
                        )(
                          (Vm = class {
                            constructor() {
                              (this.onboardedGroups = void 0),
                                (this.lastOnboardedGroupId = void 0),
                                (this.onboardingCounter = void 0),
                                (this.status = void 0),
                                (this.emitter = void 0),
                                (this.recentUpgradedGroups = void 0),
                                (this.closeOnboard = (e) => {
                                  this.status[e] &&
                                    ((this.status = Object(f.a)(
                                      Object(f.a)({}, this.status),
                                      {},
                                      { [e]: !1 },
                                    )),
                                    this.emitter.emit("change", this.status));
                                }),
                                (this.isCanShowOnboard = (e) => {
                                  const t = this.onboardingCounter.getItem(e);
                                  return (
                                    "number" != typeof t ||
                                    t <
                                      bt.default.group_privacy.community
                                        .max_onboard_times
                                  );
                                }),
                                (this.handleGroupUpgradeEvent = (e) => {
                                  let { groupId: t } = e;
                                  this.recentUpgradedGroups.add(t);
                                  const s =
                                      Ks.default.isOpenChildWindowByConvId(t),
                                    n =
                                      t ==
                                      i.ModuleContainer.resolve(
                                        Wt.SidebarController,
                                      ).getCurrMainConvId();
                                  bt.default.group_privacy.community
                                    .enable_ui &&
                                    (s || n) &&
                                    (Rm.GroupSettingHelper.isOwner(
                                      t,
                                      Ye.default.getUidMe(),
                                    )
                                      ? ((this.status = Object(f.a)(
                                          Object(f.a)({}, this.status),
                                          {},
                                          { popup: !0, tip: !1 },
                                        )),
                                        this.emitter.emit(
                                          "change",
                                          this.status,
                                        ),
                                        this.onDoneNewOnboardingLevel(
                                          t,
                                          wi.i.POPUP,
                                        ))
                                      : this.isCanShowOnboard(wi.i.TIP) &&
                                        ((this.status = Object(f.a)(
                                          Object(f.a)({}, this.status),
                                          {},
                                          { tip: !0, popup: !1 },
                                        )),
                                        this.emitter.emit(
                                          "change",
                                          this.status,
                                        ),
                                        setTimeout(() => {
                                          this.closeOnboard("tip");
                                        }, bt.default.group_privacy.community.onboard_tip_time),
                                        this.onDoneNewOnboardingLevel(
                                          t,
                                          wi.i.TIP,
                                        )));
                                }),
                                (this.handleLeaveGroupEvent = (e) => {
                                  for (const t of e)
                                    this.recentUpgradedGroups.delete(t);
                                }),
                                (this.handleOpenChildWindow = (e) => {
                                  let { windowId: t } = e;
                                  const s = Ks.default.getConvIdFromWindowId(t);
                                  this.onConversationDidOpen(s);
                                }),
                                (this.onboardedGroups = new Set()),
                                (this.lastOnboardedGroupId = null),
                                (this.onboardingCounter = new Hm(wi.d)),
                                (this.status = { tip: !1, popup: !1 }),
                                (this.recentUpgradedGroups = new Set()),
                                (this.emitter = new xr.a());
                            }
                            onStart() {
                              ds.default.subscribeEventGroup(
                                R.EventGroup.LEAVE_GROUP,
                                this.handleLeaveGroupEvent,
                              ),
                                ds.default.subscribeEventGroup(
                                  R.EventGroup.UPGRADE_COMMUNITY,
                                  this.handleGroupUpgradeEvent,
                                ),
                                Ks.default.subscribe(
                                  Qt.a.CHILD_WINDOW_ALIVE,
                                  this.handleOpenChildWindow,
                                );
                            }
                            onDispose() {
                              ds.default.unsubscribeEventGroup(
                                R.EventGroup.LEAVE_GROUP,
                                this.handleLeaveGroupEvent,
                              ),
                                ds.default.unsubscribeEventGroup(
                                  R.EventGroup.UPGRADE_COMMUNITY,
                                  this.handleGroupUpgradeEvent,
                                ),
                                Ks.default.unsubscribe(
                                  Qt.a.CHILD_WINDOW_ALIVE,
                                  this.handleOpenChildWindow,
                                ),
                                this.recentUpgradedGroups.clear();
                            }
                            getStatus() {
                              return this.status;
                            }
                            hasOnboardedGroupId(e) {
                              return this.onboardedGroups.has(e);
                            }
                            getLastOnboardedGroupId() {
                              return this.lastOnboardedGroupId;
                            }
                            isDoneOnboard() {
                              return !Object.values(wi.i).some(
                                this.isCanShowOnboard,
                              );
                            }
                            getStatusForGroup(e) {
                              return this.recentUpgradedGroups.has(e)
                                ? {
                                    tip: !1,
                                    popup: this.isCanShowOnboard(wi.i.POPUP),
                                  }
                                : {
                                    tip: this.isCanShowOnboard(wi.i.TIP),
                                    popup: !1,
                                  };
                            }
                            onConversationDidOpen(e) {
                              bt.default.group_privacy.community.enable_ui &&
                                Hi.a.isGroup(e) &&
                                wi.o.isCommunity(e) &&
                                !this.onboardedGroups.has(e) &&
                                ((this.status = this.getStatusForGroup(e)),
                                this.status.tip &&
                                  (this.emitter.emit("change", this.status),
                                  setTimeout(() => {
                                    this.closeOnboard("tip");
                                  }, bt.default.group_privacy.community.onboard_tip_time),
                                  this.onDoneNewOnboardingLevel(e, wi.i.TIP)),
                                this.status.popup &&
                                  (this.emitter.emit("change", this.status),
                                  this.onDoneNewOnboardingLevel(
                                    e,
                                    wi.i.POPUP,
                                  )));
                            }
                            onDoneNewOnboardingLevel(e, t) {
                              if (this.isDoneOnboard()) return;
                              (this.lastOnboardedGroupId = e),
                                e && this.onboardedGroups.add(e);
                              let s = this.onboardingCounter.getItem(t);
                              "number" != typeof s && (s = 0),
                                this.onboardingCounter.setItem(t, s + 1);
                            }
                            resetOnboardFlagFromLocal() {
                              (this.lastOnboardedGroupId = null),
                                this.onboardedGroups.clear(),
                                this.onboardingCounter.clear();
                            }
                          }),
                        ) || Vm),
                    ) || Vm),
                ) || Vm),
            ) || Vm),
        );
        var $m,
          Wm = s("eCBG");
        Object(V.g)()(
          ($m =
            Object(V.h)()(
              ($m =
                Object(i.singleton)(wi.m)(
                  ($m =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      ($m =
                        Reflect.metadata(
                          "design:paramtypes",
                          [],
                        )(
                          ($m = class extends te.b {
                            constructor() {
                              super(),
                                (this.cachedGroupOwnerInfo = void 0),
                                (this.logger = void 0),
                                (this.onOpenConvChildWindow = (e) => {
                                  const t = Ks.default.getConvIdFromWindowId(e);
                                  this.onOpenConversation(t);
                                }),
                                (this.cachedGroupOwnerInfo = new Set());
                            }
                            get Logger() {
                              return (
                                this.logger ||
                                  (this.logger = i.ModuleContainer.resolve(
                                    q.ZLoggerFactory,
                                  ).createZLogger(
                                    hs.ZLoggerNametags.community,
                                    [wi.j],
                                  )),
                                this.logger
                              );
                            }
                            handlePreloadOwnerInfo(e) {
                              const t = ds.default.getMiniInfoGroup(e);
                              null != t &&
                                t.creatorId &&
                                !this.cachedGroupOwnerInfo.has(e) &&
                                i.ModuleContainer.resolve(Wm.b)
                                  .getUserInfo(t.creatorId)
                                  .then((t) => {
                                    this.cachedGroupOwnerInfo.add(e),
                                      this.dispatchEvent(
                                        new wi.k("done-preload-owner-info", e, {
                                          info: t,
                                        }),
                                      );
                                  })
                                  .catch((e) => {
                                    this.Logger.zsymb(
                                      18,
                                      16248,
                                      3e4,
                                      "Load owner info fail",
                                      t,
                                      e,
                                    );
                                  });
                            }
                            onStart() {
                              Ks.default.subscribe(
                                Qt.a.CHILD_WINDOW_ALIVE,
                                this.onOpenConvChildWindow,
                              );
                            }
                            onDispose() {
                              Ks.default.unsubscribe(
                                Qt.a.CHILD_WINDOW_ALIVE,
                                this.onOpenConvChildWindow,
                              ),
                                this.cachedGroupOwnerInfo.clear();
                            }
                            onOpenConversation(e) {
                              Ct.default.isGroup(e) &&
                                bt.default.group_privacy.group_created_by_oa &&
                                this.handlePreloadOwnerInfo(e);
                            }
                          }),
                        ) || $m),
                    ) || $m),
                ) || $m),
            ) || $m),
        );
        var Km = s("P+Nn");
        let qm, Zm;
        !(function (e) {
          (e[(e.SEND_FSS = 4)] = "SEND_FSS"),
            (e[(e.SEND_CARD = 5)] = "SEND_CARD");
        })(qm || (qm = {})),
          (function (e) {
            (e[(e.CHAT_11 = 1)] = "CHAT_11"),
              (e[(e.CHAT_GROUP = 2)] = "CHAT_GROUP"),
              (e[(e.MY_CLOUD = 3)] = "MY_CLOUD");
          })(Zm || (Zm = {}));
        var Jm = s("nmtd");
        i.ModuleContainer.registerSingleton(
          Km.a,
          class {
            logAction999(e) {
              const { type: t, payload: s, noisedIds: i } = e;
              switch (t) {
                case Jm.a.CARD:
                  Xe.e.logActionInfoV2(Xe.b.SendFSS, qm.SEND_CARD, s, i);
                  break;
                case Jm.a.STICKER:
                  Xe.e.logActionInfoV2(Xe.b.SendFSS, qm.SEND_FSS, s, i);
              }
            }
            getChatTypeFromConvId(e) {
              return Ct.default.isGroup(e)
                ? Zm.CHAT_GROUP
                : ug.a.isSendToMe(e)
                  ? Zm.MY_CLOUD
                  : Zm.CHAT_11;
            }
            getRawDestinationId(e, t) {
              return t === Zm.CHAT_GROUP
                ? Ct.default.getGroupIdFromConversationId(e)
                : e;
            }
            sendCardReport(e) {
              const t = this.getChatTypeFromConvId(e.toUid),
                s = this.getRawDestinationId(e.toUid, t),
                i = Ye.default.getUidMe();
              this.logAction999({
                type: Jm.a.CARD,
                payload: {
                  src_id: i,
                  des_id: s,
                  chat_type: t,
                  group_id: t === Zm.CHAT_GROUP ? s : null,
                  ecard: {
                    background_id: e.backgroundId,
                    char_count: e.charCount,
                    list_title_id: e.listTitleId,
                    tagline_id: e.taglineId,
                  },
                },
                noisedIds: [i, s],
              });
            }
            sendFSSReport(e) {
              const t = this.getChatTypeFromConvId(e.toUid),
                s = this.getRawDestinationId(e.toUid, t),
                i = Ye.default.getUidMe();
              this.logAction999({
                type: Jm.a.STICKER,
                payload: {
                  src_id: i,
                  des_id: s,
                  chat_type: t,
                  cate_id: e.categoryId,
                  sticker_id: e.stickerId,
                  group_id: t === Zm.CHAT_GROUP ? s : null,
                },
                noisedIds: [i, s],
              });
            }
          },
        );
        var Qm = s("yQd5");
        const Ym = `${Qm.b}-network-manager`;
        var Xm = Object(i.define)(Ym),
          ep = s("DPHK");
        var tp = class {
          constructor() {}
          updateMyAvatar(e, t, s, i, n) {
            return (
              void 0 === i && (i = {}),
              void 0 === n && (n = !1),
              Ye.default.updateMyAvatar(e, s, t, i)
            );
          }
          updateGroupAvatar(e, t, s, i, n) {
            let a = Qm.a.w,
              r = Qm.a.h;
            return (
              n &&
                (n.originWidth && (a = n.originWidth),
                n.originHeight && (r = n.originHeight)),
              this.resolveRequest(Ln.default.updateAvatar(e, t, i, s, a, r))
            );
          }
          updateAvatar(e, t, s, i, n) {
            void 0 === s && (s = 120),
              void 0 === i && (i = {}),
              void 0 === n && (n = !1);
            const a = e + ep.a.getFullTimeFromMilisecond(new Date().getTime());
            return Ct.default.isGroup(e)
              ? this.updateGroupAvatar(e, s, t, a, i)
              : this.updateMyAvatar(s, t, a, i, n);
          }
          async reuseAvatar(e, t) {
            let s = { photoId: e, isPostSocial: t ? 1 : 0 };
            const i =
              mt.b.getProfileDomain() +
              "/api/social/reuse-avatar?" +
              this._getCommonParams() +
              "&params=" +
              this.getEncodedParams(s);
            return this.resolveRequest(this._get(i, null, 12453));
          }
          async getAvatarHistory(e, t, s, i) {
            let n = { page: e, albumId: s, count: i };
            t && (n.photoId = t);
            const a =
              mt.b.getProfileDomain() +
              "/api/social/avatar-list?" +
              this._getCommonParams() +
              "&params=" +
              this.getEncodedParams(n);
            return this.resolveRequest(this._get(a, null, 12451));
          }
          deleteAvatarHistory(e) {
            let t = {
              delPhotos: JSON.stringify(
                e.map((e) => ({ photoId: e.toString() })),
              ),
            };
            const s =
              mt.b.getProfileDomain() +
              "/api/social/del-avatars?" +
              this._getCommonParams() +
              "&params=" +
              this.getEncodedParams(t);
            return this.resolveRequest(this._get(s, null, 12452));
          }
          _get(e, t, s) {
            return Ln.default._get(e, t, s);
          }
          _getCommonParams() {
            return Ln.default._getCommonParams();
          }
          getEncodedParams(e) {
            return Ln.default.getEncodedParams(e);
          }
          resolveRequest(e) {
            return new Promise((t, s) => {
              e.then(wn.a).then(t).catch(s);
            });
          }
        };
        i.ModuleContainer.register(
          Xm,
          class {
            get api() {
              return this._api || (this._api = new tp()), this._api;
            }
            constructor() {
              (this._api = void 0),
                (this._logger = void 0),
                (this._logger = i.ModuleContainer.resolve(
                  q.ZLoggerFactory,
                ).createZLogger(Qm.b, ["network-manager"]));
            }
            async updateAvatar(e, t, s, i, n) {
              this._logger.zsymb(
                0,
                11994,
                3e4,
                `updateAvatar [convId: ${e}], [s: ${t.size}] [share: ${n}] [meta:`,
                i,
              );
              try {
                return (
                  await this.api.updateAvatar(e, t, s, i, n),
                  Promise.resolve(!0)
                );
              } catch (a) {
                return (
                  this._logger.zsymb(
                    18,
                    11994,
                    30001,
                    `updateAvatar [convId: ${e}], [err:`,
                    a,
                  ),
                  Promise.reject(a)
                );
              }
            }
            async getAvatarHistory(e, t, s, i) {
              return (
                this._logger.zsymb(
                  0,
                  11994,
                  30002,
                  `getAvatarHistory [p:${e}], [pId:${t}], [aId:${s}], [c:${i}]`,
                ),
                this.api.getAvatarHistory(e, t, s, i)
              );
            }
            async reuseAvatar(e, t) {
              return (
                this._logger.zsymb(
                  0,
                  11994,
                  30003,
                  `reuseAvatar [photoId: ${e}], [isPostSocial:`,
                  t,
                  "]",
                ),
                this.api.reuseAvatar(e, t)
              );
            }
            async deleteAvatarHistory(e) {
              this._logger.zsymb(
                0,
                11994,
                30004,
                "deleteAvatarHistory [photoIds: ",
                e,
              );
              try {
                return (
                  await this.api.deleteAvatarHistory(e), Promise.resolve(!0)
                );
              } catch (t) {
                return Promise.reject(t);
              }
            }
          },
        );
        const sp = `${Qm.b}-repository`;
        var ip = Object(i.define)(sp);
        const np = `${Qm.b}-storage`;
        var ap,
          rp = Object(i.define)(np),
          op = s("nKYX");
        let dp =
          Object(i.injectable)()(
            (ap =
              (function (e, t) {
                return Object(i.inject)(rp)(e, void 0, 0);
              })(
                (ap =
                  (function (e, t) {
                    return Object(i.inject)(Xm)(e, void 0, 1);
                  })(
                    (ap =
                      Reflect.metadata(
                        "design:type",
                        Function,
                      )(
                        (ap =
                          Reflect.metadata("design:paramtypes", [
                            Object,
                            Object,
                          ])(
                            (ap = class {
                              constructor(e, t) {
                                (this.storage = e), (this.fetcher = t);
                              }
                              reuseAvatar(e, t) {
                                return this.fetcher.reuseAvatar(e, t);
                              }
                              updateAvatar(e, t, s, i, n) {
                                return this.fetcher.updateAvatar(e, t, s, i, n);
                              }
                              async getAvatarHistory(e, t, s, i) {
                                void 0 === e && (e = 0),
                                  void 0 === t && (t = ""),
                                  void 0 === s && (s = "0"),
                                  void 0 === i && (i = 50);
                                try {
                                  return this.mapApiDataToModel(
                                    await this.fetcher.getAvatarHistory(
                                      e,
                                      t,
                                      s,
                                      i,
                                    ),
                                  );
                                } catch (n) {
                                  let e = op.a.ERR_GET_AVA_HISTORY;
                                  return (
                                    n && n.code && (e = n.code),
                                    Promise.reject({
                                      code: e,
                                      message:
                                        (null == n ? void 0 : n.message) || n,
                                    })
                                  );
                                }
                              }
                              deleteAvatarHistory(e) {
                                return this.fetcher.deleteAvatarHistory(e);
                              }
                              mapApiDataToModel(e) {
                                return {
                                  albumId: e.albumId,
                                  hasMore: Boolean(e.hasMore),
                                  nextPhotoId: e.nextPhotoId,
                                  photos: e.photos.length
                                    ? e.photos.map((e) => ({
                                        photoId: e.photoId,
                                        thumb: e.thumbnail,
                                        url: e.url,
                                      }))
                                    : [],
                                };
                              }
                            }),
                          ) || ap),
                      ) || ap),
                  ) || ap),
              ) || ap),
          ) || ap;
        i.ModuleContainer.register(ip, dp);
        var lp;
        i.ModuleContainer.register(
          rp,
          class {
            constructor() {
              (this._storage = void 0), (this._logger = void 0);
            }
            get storage() {
              return (
                this._storage || (this._storage = K.default.getInstance()),
                this._storage
              );
            }
            get logger() {
              return (
                this._logger ||
                  (this._logger = i.ModuleContainer.resolve(
                    q.ZLoggerFactory,
                  ).createZLogger(Qm.b, ["storage"])),
                this._logger
              );
            }
            async getAvatarHistory() {
              return new Promise(async (e, t) => {
                try {
                  e(await this.storage.Core.AvaHistory.getAll());
                } catch (s) {
                  return (
                    this.logger.zsymb(18, 12128, 3e4, "getAvatarHistory", s),
                    t(s)
                  );
                }
              });
            }
            addNewAvatarToHistory(e) {
              const t = new Date().getTime();
              return this.storage.Core.AvaHistory.insert(
                Object(f.a)(Object(f.a)({}, e), {}, { submit_dttm: t }),
                { replace: !0 },
              );
            }
            deleteAvatarHistory(e) {
              return this.storage.Core.AvaHistory.delete(e);
            }
          },
        );
        let cp =
          Object(i.injectable)()(
            (lp =
              (function (e, t) {
                return Object(i.inject)(ip)(e, void 0, 0);
              })(
                (lp =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (lp =
                      Reflect.metadata("design:paramtypes", [Object])(
                        (lp = class {
                          get logger() {
                            return (
                              this._logger ||
                                (this._logger = i.ModuleContainer.resolve(
                                  q.ZLoggerFactory,
                                ).createZLogger(Qm.b, [
                                  hs.ZLoggerNametags.controller,
                                ])),
                              this._logger
                            );
                          }
                          constructor(e) {
                            (this.repository = e),
                              (this._logger = void 0),
                              (this._avatarHistoryMeta = {
                                page: 1,
                                photoId: "",
                                albumId: "0",
                                hasMore: !0,
                              }),
                              (this._historyAvatars = []),
                              (this._retryLoadMore = 1);
                          }
                          getFrameList(e) {
                            return e
                              ? bt.default.operation_frame_list.group
                              : bt.default.operation_frame_list.personal;
                          }
                          getDefaultAvatarList() {
                            var e, t;
                            return (
                              (null === bt.default ||
                              void 0 === bt.default ||
                              null === (e = bt.default.settings) ||
                              void 0 === e ||
                              null === (t = e.group) ||
                              void 0 === t
                                ? void 0
                                : t.avt_group_template) || null
                            );
                          }
                          async getInitialAvatarHistory(e) {
                            return (
                              void 0 === e && (e = 50),
                              (this._avatarHistoryMeta = {
                                page: 1,
                                photoId: "",
                                albumId: "0",
                                hasMore: !0,
                              }),
                              (this._retryLoadMore = 1),
                              await this.getAvatarHistory(e)
                            );
                          }
                          async loadMoreAvatarHistory() {
                            if (
                              this._avatarHistoryMeta.hasMore &&
                              this._retryLoadMore < 3
                            )
                              try {
                                return await this.getAvatarHistory();
                              } catch (e) {
                                return (
                                  this.logger.zsymb(
                                    0,
                                    12087,
                                    3e4,
                                    "loadMoreAvatarHistory error",
                                    e,
                                  ),
                                  this.logger.zsymb(
                                    0,
                                    12087,
                                    30001,
                                    "retry loadmore",
                                    this._retryLoadMore,
                                  ),
                                  this._retryLoadMore++,
                                  this.loadMoreAvatarHistory()
                                );
                              }
                            return [];
                          }
                          async getAvatarHistory(e) {
                            if (!this.isValidNetwork())
                              return Promise.reject({
                                code: op.a.ERR_NO_NETWORK,
                                message: "",
                              });
                            try {
                              const t = await this.repository.getAvatarHistory(
                                this._avatarHistoryMeta.page,
                                this._avatarHistoryMeta.photoId,
                                this._avatarHistoryMeta.albumId,
                                e || 50,
                              );
                              return (
                                (this._avatarHistoryMeta = {
                                  albumId: t.albumId,
                                  page: this._avatarHistoryMeta.page + 1,
                                  photoId: t.nextPhotoId,
                                  hasMore: t.hasMore,
                                }),
                                Array.prototype.push.apply(
                                  this._historyAvatars,
                                  t.photos,
                                ),
                                t.photos
                              );
                            } catch (t) {
                              return (
                                this.logger.zsymb(
                                  18,
                                  12087,
                                  30002,
                                  "Error getting avatar history",
                                  t,
                                ),
                                Promise.reject({
                                  code: op.a.ERR_GET_AVA_HISTORY,
                                  message:
                                    (null == t ? void 0 : t.msg) ||
                                    (null == t ? void 0 : t.message),
                                })
                              );
                            }
                          }
                          async deleteAvatarHistory(e) {
                            if (!this.isValidNetwork())
                              return Promise.reject({
                                code: op.a.ERR_NO_NETWORK,
                                message: "",
                              });
                            try {
                              return (
                                await this.repository.deleteAvatarHistory([e]),
                                (this._historyAvatars =
                                  this._historyAvatars.filter(
                                    (t) => t.photoId !== e,
                                  )),
                                !0
                              );
                            } catch (t) {
                              if (
                                (this.logger.zsymb(
                                  18,
                                  12087,
                                  30003,
                                  "deleteAvatarHistory",
                                  t,
                                ),
                                t && t.errMap)
                              ) {
                                const s = t.errMap;
                                return Promise.reject({
                                  code: s[e],
                                  message: "",
                                });
                              }
                              return Promise.reject({
                                code: op.a.DELETE_AVATAR_ERROR,
                                message: "",
                              });
                            }
                          }
                          updateAvatar(e, t, s, i, n) {
                            return this.isValidNetwork()
                              ? this.repository.updateAvatar(e, t, s, i, n)
                              : Promise.reject({
                                  code: op.a.ERR_NO_NETWORK,
                                  message: "",
                                });
                          }
                          async reuseAvatar(e, t) {
                            try {
                              await this.repository.reuseAvatar(e, t);
                              const s = this._historyAvatars.find(
                                (t) => t.photoId === e,
                              );
                              return (
                                s &&
                                  ((this._historyAvatars =
                                    this._historyAvatars.filter(
                                      (t) => t.photoId !== e,
                                    )),
                                  this._historyAvatars.unshift(s)),
                                !0
                              );
                            } catch (s) {
                              return Promise.reject(!1);
                            }
                          }
                          isValidNetwork() {
                            return Dn.b.getStateNetwork() === Dn.a.CONNECTED;
                          }
                        }),
                      ) || lp),
                  ) || lp),
              ) || lp),
          ) || lp;
        var hp = s("TGcW").a;
        i.ModuleContainer.registerSingleton(hp, cp);
        var up = s("YZti"),
          gp = s("1UUk"),
          mp = s("Mk04");
        s("LwMt"), s("DOOx");
        const pp = Object(mp.a)(() => {
            try {
              $zapp.notifyDbFail();
            } catch (e) {}
          }),
          fp = Object(mp.a)(() => {
            Q.p.triggerEvent(Q.b, [!0, "zkey-out-mem"]);
          }),
          vp = Object(mp.a)(() => {
            Q.p.triggerEvent(Q.b, [!0]);
          }),
          bp = Object(mp.a)(() => {
            Q.p.triggerEvent(Q.b, [!0, "zkey-miss-object-store"]), pp();
          }),
          Ip = Object(mp.a)(() => {
            Q.p.triggerEvent(Q.b, [!1]), pp();
          }),
          yp = Object(mp.a)(() => {
            0;
          });
        let _p = !1;
        const Op = 151004;
        var Cp;
        let Ep =
          Object(V.g)()(
            (Cp =
              Reflect.metadata(
                "design:type",
                Function,
              )(
                (Cp =
                  Reflect.metadata(
                    "design:paramtypes",
                    [],
                  )(
                    (Cp = class {
                      constructor() {
                        (this.logger = void 0),
                          (this.logErrorMessageOnce = Object(mp.a)((e) => {
                            this.logger.zsymb(18, 15318, 3e4, e);
                          })),
                          (this.dispose = () => {});
                        const e = i.ModuleContainer.resolve(q.ZLoggerFactory);
                        this.logger = e.createZLogger("db", ["error-handler"]);
                      }
                      onDispose() {
                        this.dispose();
                      }
                      init() {
                        const e = i.ModuleContainer.resolve(gp.b),
                          t = (e) => {
                            const { error: t } = e,
                              { name: s, message: i } = t;
                            ("QuotaExceededError" === s ||
                              ("AbortError" === s &&
                                i.includes(
                                  "Version change transaction was aborted in upgradeneeded event handler.",
                                )) ||
                              i.includes("malformed")) &&
                              (this.logErrorMessageOnce(`OutOfMemError: ${i}`),
                              fp());
                          },
                          s = (e) => {
                            const { error: t } = e;
                            up.b.isInvalidVersionError(t) &&
                              (this.logErrorMessageOnce(`${t}`), vp());
                          },
                          n = (e) => {
                            const { error: t } = e;
                            up.b.isMissingTableError(t) &&
                              (this.logErrorMessageOnce(`${t}`), bp());
                          },
                          a = (e) => {
                            const { error: t } = e;
                            if (up.b.isFailedToOpenConnectionError(t)) {
                              const e = `${t}`;
                              this.logErrorMessageOnce(e),
                                Ip(),
                                ((e) => {
                                  if (!_p) {
                                    _p = !0;
                                    try {
                                      const t = i.ModuleContainer.resolve(J);
                                      t.log({ commandId: Op, success: !0 });
                                      const s = Date.now(),
                                        n = E.default.getInstance();
                                      let a = n.getItem("fa_op_d_rec_dt");
                                      if (null !== a) {
                                        const i = +a;
                                        Number.isNaN(i) ||
                                          (s - i <= 36e5 &&
                                            t.log({
                                              commandId: Op,
                                              success: !1,
                                              params: [e],
                                            }));
                                      }
                                      n.setItem("fa_op_d_rec_dt", `${s}`);
                                    } catch (t) {}
                                  }
                                })(e);
                            }
                          },
                          r = (e) => {
                            t(e), s(e), n(e), a(e);
                          },
                          o = (e) => {
                            yp();
                          },
                          d = (e) => {
                            this.logErrorMessageOnce(
                              `DB connection closed abnormally: '${e.database}'`,
                            );
                          };
                        e.addEventListener(H.b.QueryError, r),
                          e.addEventListener(H.b.SuccessOpenDB, o),
                          e.addEventListener(H.b.ConnectionClosedAbnormally, d),
                          (this.dispose = () => {
                            e.removeEventListener(H.b.QueryError, r),
                              e.removeEventListener(H.b.SuccessOpenDB, o),
                              e.removeEventListener(
                                H.b.ConnectionClosedAbnormally,
                                d,
                              );
                          });
                      }
                    }),
                  ) || Cp),
              ) || Cp),
          ) || Cp;
        new Ep().init();
        var Mp = s("GaKD"),
          Sp = s("Y65e");
        const Tp = i.ModuleContainer.resolve(J),
          wp = (e, t) => (s, i, n) => {
            const a = n.value;
            n.value = function () {
              for (
                var s = arguments.length, i = new Array(s), n = 0;
                n < s;
                n++
              )
                i[n] = arguments[n];
              const r = performance.now(),
                o = a.apply(this, i);
              if (o instanceof Promise)
                return Ba.b
                  .catchAsyncFn(() => o)
                  .then((s) => {
                    let [n, a] = s;
                    const o = performance.now() - r,
                      d = Object(f.a)(
                        {
                          commandId: e,
                          success: !n,
                          errorCode: null == n ? void 0 : n.code,
                          duration: o,
                        },
                        null == t ? void 0 : t(i, [n, a], o),
                      );
                    if ((Tp.log(d), n)) throw n;
                    return a;
                  });
              {
                const s = performance.now() - r,
                  n = Object(f.a)(
                    { commandId: e, success: !0, duration: s },
                    null == t ? void 0 : t(i, [null, o], s),
                  );
                return Tp.log(n), o;
              }
            };
          };
        let Rp;
        var Lp, Dp, Fp, Ap, jp;
        !(function (e) {
          (e[(e.CLIENT_PARSER = 111026)] = "CLIENT_PARSER"),
            (e[(e.SERVER_PARSER = 111027)] = "SERVER_PARSER"),
            (e[(e.NOOP_PARSER = 111028)] = "NOOP_PARSER"),
            (e[(e.DOWNLOAD_THUMB = 111029)] = "DOWNLOAD_THUMB"),
            (e[(e.UPLOAD_THUMB = 111030)] = "UPLOAD_THUMB"),
            (e[(e.PREVIEW_INTEGRITY = 111031)] = "PREVIEW_INTEGRITY");
        })(Rp || (Rp = {}));
        let Pp =
          ((Lp = wp(Rp.NOOP_PARSER, (e) => {
            let [t] = e;
            return { params: [t] };
          })),
          (Dp = Reflect.metadata("design:type", Function)),
          (Fp = Reflect.metadata("design:paramtypes", [String])),
          (jp = class e {
            constructor() {}
            static getInstance() {
              return null === e.instance && (e.instance = new e()), e.instance;
            }
            isMatchParser(e) {
              return !0;
            }
            async parse(e) {
              return null;
            }
          }),
          (jp.instance = null),
          (Ap = jp),
          Object(Sp.a)(
            Ap.prototype,
            "parse",
            [Lp, Dp, Fp],
            Object.getOwnPropertyDescriptor(Ap.prototype, "parse"),
            Ap.prototype,
          ),
          Ap);
        var Np = s("G95d"),
          Up = s("dXzg");
        let kp;
        !(function (e) {
          (e[(e.UNKNOWN_ERROR = 100)] = "UNKNOWN_ERROR"),
            (e[(e.URL_ERROR = 101)] = "URL_ERROR"),
            (e[(e.HTTP_STATUS_ERROR = 102)] = "HTTP_STATUS_ERROR"),
            (e[(e.REDIRECT_ERROR = 103)] = "REDIRECT_ERROR"),
            (e[(e.PARSE_XML_HEAD_ERROR = 104)] = "PARSE_XML_HEAD_ERROR"),
            (e[(e.HTTP_REQUEST_ERROR = 105)] = "HTTP_REQUEST_ERROR"),
            (e[(e.EMPTY_METADATA = 106)] = "EMPTY_METADATA"),
            (e[(e.PARSE_LINK_SERVER_ERROR = 200)] = "PARSE_LINK_SERVER_ERROR"),
            (e[(e.DOWNLOAD_THUMB_ERROR = 300)] = "DOWNLOAD_THUMB_ERROR"),
            (e[(e.THUMB_SIZE_ERROR = 301)] = "THUMB_SIZE_ERROR"),
            (e[(e.THUMB_TYPE_ERROR = 302)] = "THUMB_TYPE_ERROR"),
            (e[(e.UPLOAD_THUMB_ERROR = 400)] = "UPLOAD_THUMB_ERROR"),
            (e[(e.COMPRESS_THUMB_ERROR = 401)] = "COMPRESS_THUMB_ERROR"),
            (e[(e.GET_PARSER_ERROR = 500)] = "GET_PARSER_ERROR");
        })(kp || (kp = {}));
        const Bp = (e, t) => {
          if (e) throw t;
        };
        class Gp extends Error {
          constructor(e, t, s, i) {
            void 0 === i && (i = []),
              super(s),
              (this.code = void 0),
              (this.qosParams = void 0),
              (this.name = e),
              (this.qosParams = [s, ...i]),
              (this.code = t);
          }
          setStack(e) {
            const t = `${this.name}: ${this.message}`;
            this.stack = t + (e || "");
          }
          toObject() {
            return {
              name: this.name,
              code: this.code,
              message: this.message,
              stack: this.stack,
              qosParams: this.qosParams,
            };
          }
          static createFromObject(e) {
            const {
                name: t = "UnknownError",
                code: s = kp.UNKNOWN_ERROR,
                message: i,
                stack: n,
                qosParams: a = [],
              } = e,
              r = new Gp(t, s, i, a);
            return r.setStack(n), r;
          }
        }
        class xp extends Gp {
          constructor(e, t, s) {
            super(
              "ParseLinkServerError",
              kp.PARSE_LINK_SERVER_ERROR,
              `Parse link server failed. Url: ${e}. Message: ${t}`,
              s,
            );
          }
        }
        const zp = 1048576,
          Vp = { GB: 1073741824, MB: zp, KB: 1024, byte: 1 };
        let Hp;
        var $p, Wp, Kp;
        (($p = Hp || (Hp = {})).sizeInByte = (e) => {
          const t = /(\d+)(byte|KB|MB|GB)/g;
          let s,
            i = 0;
          for (; (s = t.exec(e)); ) i += parseInt(s[1]) * Vp[s[2]];
          return i;
        }),
          ($p.getFileSizeByHead = async (e, t) => {
            const s = await fetch(e, { method: "HEAD" }),
              i = s.headers.get("content-length"),
              n = s.headers.get("content-type");
            if (t && t != n)
              throw new Error(
                `An error occurred when trying to get file size. Error: unexpected content-type.Content-type expectation is "${t}" but received Content-type is "${n}".`,
              );
            return Number(null != i ? i : 0);
          }),
          (function (e) {
            (e[(e.META_TITLE = 0)] = "META_TITLE"),
              (e[(e.META_DESCRIPTION = 1)] = "META_DESCRIPTION"),
              (e[(e.META_THUMB = 2)] = "META_THUMB"),
              (e[(e.DOCUMENT = 3)] = "DOCUMENT");
          })(Wp || (Wp = {})),
          (function (e) {
            (e[(e.NOT_FOUND = 0)] = "NOT_FOUND"),
              (e[(e.INVALID_FORMAT = 1)] = "INVALID_FORMAT"),
              (e[(e.DOWNLOAD_ERROR = 2)] = "DOWNLOAD_ERROR");
          })(Kp || (Kp = {}));
        class qp {
          constructor() {}
          async fetch(e) {
            const [t, s] = await Ba.b.catchAsyncFn(() =>
              this.fetchLinkInfoFromServer(e),
            );
            Bp(!!t, t && new xp(e, null == t ? void 0 : t.message));
            const [i, n] = await this.transformResponse(e, s);
            return Bp(!!i, i), n;
          }
          fetchLinkInfoFromServer(e) {
            return Ln.default.getLinkInformation(e).then(wn.a);
          }
          async transformResponse(e, t) {
            var s, n, a;
            if (
              i.ModuleContainer.resolve(Up.a).get(
                "enable_verify_parse_link_server",
              ) &&
              Ba.e.isNotEmptyObject(t.error_maps)
            )
              return [new xp(e, JSON.stringify(t.error_maps)), null];
            if (
              (null === (s = t.error_maps) || void 0 === s
                ? void 0
                : s[Wp.DOCUMENT]) === Kp.DOWNLOAD_ERROR
            )
              return [new xp(e, JSON.stringify(t.error_maps)), null];
            if (e.endsWith(".pdf")) {
              var r;
              const s = await Hp.getFileSizeByHead(e);
              return (
                (t.data = null !== (r = t.data) && void 0 !== r ? r : {}),
                (t.data.title = pd.a.getFileNameFromUrl(e)),
                (t.data.desc = Ct.default.sizeToString(s)),
                (t.data.thumb = Ct.DEFAULT_THUMB_URLS.ICON_PDF),
                [null, t.data]
              );
            }
            return (t.data.thumb &&
              !(
                (null === (n = t.error_maps) || void 0 === n
                  ? void 0
                  : n[Wp.META_THUMB]) in Kp
              )) ||
              t.data.thumb ||
              (t.data.title && t.data.desc)
              ? ((null === (a = t.error_maps) || void 0 === a
                  ? void 0
                  : a[Wp.META_THUMB]) in Kp && (t.data.thumb = ""),
                [null, t.data])
              : [new xp(e, JSON.stringify(t)), null];
          }
        }
        var Zp,
          Jp,
          Qp,
          Yp,
          Xp,
          ef = s("o2mE"),
          tf = s("/vDv");
        let sf =
          ((Zp = wp(Rp.SERVER_PARSER, (e, t, s) => {
            let [n] = e;
            return (
              i.ModuleContainer.resolve(ef.b).linkParser.zsymb(
                12,
                13044,
                3e4,
                "ParseLinkMetric",
                Rp[Rp.SERVER_PARSER],
                n,
                s,
              ),
              { params: [n] }
            );
          })),
          (Jp = Reflect.metadata("design:type", Function)),
          (Qp = Reflect.metadata("design:paramtypes", [String])),
          (Xp = class e {
            constructor() {}
            static getInstance() {
              return null === e.instance && (e.instance = new e()), e.instance;
            }
            isMatchParser(e, t) {
              const s = i.ModuleContainer.resolve(Up.a);
              if (s.get("enable_force_parse_link_server")) return !0;
              if (!s.get("enable_parse_link_server")) return !1;
              const n = s.get("white_list_domain");
              for (const i of n) if (pd.a.isHrefMatchDomain(e, i)) return !0;
              if ((null == t ? void 0 : t.entry) === Np.a.MESSAGE_WIDGET)
                return !0;
              if (!s.get("enable_parse_link_client")) {
                if (null != t && t.convId) {
                  if (!tf.a.isE2eeConv(t.convId)) return !0;
                }
                if ((null == t ? void 0 : t.entry) === Np.a.SHARE_MESSAGE)
                  return !0;
              }
              return !1;
            }
            async parse(e) {
              const [t, s] = await Ba.b.catchAsyncFn(() => new qp().fetch(e));
              return (
                Bp(!!t, t),
                {
                  typeParse: Np.b.SERVER,
                  href: e,
                  desc: null == s ? void 0 : s.desc,
                  media: null == s ? void 0 : s.media,
                  src: null == s ? void 0 : s.src,
                  stream_icon: null == s ? void 0 : s.stream_icon,
                  thumb: null == s ? void 0 : s.thumb,
                  title: null == s ? void 0 : s.title,
                }
              );
            }
          }),
          (Xp.instance = null),
          (Yp = Xp),
          Object(Sp.a)(
            Yp.prototype,
            "parse",
            [Zp, Jp, Qp],
            Object.getOwnPropertyDescriptor(Yp.prototype, "parse"),
            Yp.prototype,
          ),
          Yp);
        var nf;
        Object(i.injectable)()(
          (nf =
            Object(i.singleton)(Mp.a)(
              (nf =
                Reflect.metadata(
                  "design:type",
                  Function,
                )(
                  (nf =
                    Reflect.metadata(
                      "design:paramtypes",
                      [],
                    )(
                      (nf = class {
                        constructor() {}
                        getLinkParser(e, t) {
                          return sf.getInstance().isMatchParser(e, t)
                            ? sf.getInstance()
                            : Pp.getInstance();
                        }
                      }),
                    ) || nf),
                ) || nf),
            ) || nf),
        );
        var af,
          rf = s("TQME");
        class of {
          constructor() {}
          static getInstance() {
            return of.instance || (of.instance = new of()), of.instance;
          }
          async process(e) {
            return e;
          }
        }
        of.instance = null;
        class df {
          constructor() {}
          static getInstance() {
            return df.instance || (df.instance = new df()), df.instance;
          }
          async process(e) {
            return e;
          }
        }
        df.instance = null;
        Object(i.injectable)()(
          (af =
            Object(i.singleton)(rf.a)(
              (af =
                Reflect.metadata(
                  "design:type",
                  Function,
                )(
                  (af =
                    Reflect.metadata(
                      "design:paramtypes",
                      [],
                    )(
                      (af = class {
                        constructor() {}
                        getDownloadProcessor(e) {
                          switch (e) {
                            case Np.b.CLIENT:
                            case Np.b.SERVER:
                          }
                          return df.getInstance();
                        }
                        getUploadProcessor(e) {
                          switch (e) {
                            case Np.b.CLIENT:
                            case Np.b.SERVER:
                          }
                          return of.getInstance();
                        }
                      }),
                    ) || af),
                ) || af),
            ) || af),
        );
        const lf = Object(i.define)("parser-config-event-emitter");
        i.ModuleContainer.registerFactory(
          lf,
          Ga.f(() => new xr.a()),
        );
        var cf,
          hf = s("LvDl"),
          uf = s.n(hf);
        Object(i.injectable)()(
          (cf =
            Object(i.singleton)(Up.b)(
              (cf =
                (function (e, t) {
                  return Object(i.inject)(lf)(e, void 0, 0);
                })(
                  (cf =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (cf =
                        Reflect.metadata("design:paramtypes", [
                          "undefined" == typeof IParserConfigEventEmitter
                            ? Object
                            : IParserConfigEventEmitter,
                        ])(
                          (cf = class {
                            constructor(e) {
                              (this.eventEmitter = e), (this.config = {});
                            }
                            setConfig(e) {
                              this.isConfigChange(e) &&
                                ((this.config = this.mergeConfig(e)),
                                this.eventEmitter.emit(
                                  "on-config-change",
                                  this.config,
                                ));
                            }
                            mergeConfig(e) {
                              return Object(f.a)(
                                Object(f.a)({}, this.config),
                                e,
                              );
                            }
                            isConfigChange(e) {
                              return !new Ba.e.Comparer(this.config, e, !0)
                                .AND("enable_force_parse_link_server")
                                .AND("enable_parse_link_server")
                                .AND("enable_parse_link_client")
                                .AND("enable_auto_download_thumb")
                                .AND("enable_parse_link_receiver")
                                .AND("enable_parse_link_sender")
                                .AND("enable_download_partial_media_e2ee")
                                .AND("enable_verify_parse_link_server")
                                .AND("enable_show_loading_thumb")
                                .AND("white_list_domain", uf.a.isEqual)
                                .AND("white_list_domain_mode")
                                .AND("max_time_reparse")
                                .AND("max_thumb_size")
                                .AND("max_age_cache_preview")
                                .AND("max_item_cache")
                                .AND("max_url_character")
                                .AND("max_title_character")
                                .AND("max_desc_character")
                                .AND("max_delay_send_message")
                                .AND("max_redirect")
                                .AND("debug", uf.a.isEqual)
                                .exec();
                            }
                          }),
                        ) || cf),
                    ) || cf),
                ) || cf),
            ) || cf),
        );
        var gf,
          mf = s("XJ/a"),
          pf = s("1e0e");
        const ff = {
          enable_force_parse_link_server: !0,
          enable_parse_link_server: !0,
          enable_parse_link_client: !1,
          enable_auto_download_thumb: !0,
          enable_parse_link_receiver: !0,
          enable_parse_link_sender: !1,
          enable_download_partial_media_e2ee: !0,
          enable_verify_parse_link_server: !1,
          enable_show_loading_thumb: !0,
          white_list_domain: [
            ".zalo.me",
            ".zaloapp.com",
            "s120.avatar.talk.zdn.vn",
            "cover.talk.zdn.vn",
            "qr.talk.zdn.vn",
            "f22.w640.photo.talk.zdn.vn",
            "res-zalo.zadn.vn",
            "vng.com.vn",
            "stg-shop.zalo.me",
            ".zingplay.me",
            "zalopay.vn",
            "kaka.me",
            "api-internal.mp3.zalo",
            "zstudio.io",
            "123c.vn",
            "adtimaserver.vn",
            "adtima.vn",
            "ad.zing.vn",
            "baomoi.com",
            "baomoi.vn",
            "brand.zing.vn",
            "chat-talk.zing.vn",
            "click.123.vn",
            "epi.com.vn",
            "epi.vn",
            "kakaapp.me",
            "laban.vn",
            "lab.zing.vn",
            "mp3.zing.vn",
            "m.zing.vn",
            "news.zing.vn",
            "nhatkyzalo.vn",
            "playzing.vn",
            "plo.com.vn",
            "plo.vn",
            "stc-tv.zing.vn",
            "sukien.net.vn",
            "tachthongtin.com",
            "talk.zing.vn",
            "trithuctructuyen.com.vn",
            "trithuctructuyen.vn",
            "tv.zing.vn",
            "xdn.vn",
            "xone.fm",
            "zagoo.vn",
            "zalo.ai",
            "zalo.careers",
            "zalochat.com",
            "zalo.cx",
            "zalo.gg",
            "zalo.me",
            "zalomusic.com",
            "zalonews.net",
            "zaloplus.vn",
            "zalo-shop.vn",
            "zalo.vn",
            "zamoji.vn",
            "zapps.vn",
            "zavatar.vn",
            "zavi.me",
            "za.zdvn.vn",
            "zdn.vn",
            "zingmp3.com",
            "zingmp3.vn",
            "zingnews.com.vn",
            "zingnews.vn",
            "zingtv.vn",
            "zstudio.io",
            "zaloshop.me",
            "dr.zapps.vn",
            "hc.zalo.me",
          ],
          white_list_domain_mode: "append",
          max_time_reparse: pf.a.timeInMs("24h"),
          max_thumb_size: Hp.sizeInByte("2MB"),
          max_age_cache_preview: pf.a.timeInMs("24h"),
          max_item_cache: 300,
          max_url_character: 500,
          max_title_character: 80,
          max_desc_character: 200,
          max_delay_send_message: pf.a.timeInMs("2s"),
          max_redirect: 2,
          debug: {
            enable_log_metric: !1,
            delay_parse_client: pf.a.timeInMs("0s"),
          },
        };
        Object(i.injectable)()(
          (gf =
            Object(i.singleton)(Up.a)(
              (gf =
                Reflect.metadata(
                  "design:type",
                  Function,
                )(
                  (gf =
                    Reflect.metadata(
                      "design:paramtypes",
                      [],
                    )(
                      (gf = class {
                        constructor() {
                          (this.config = void 0),
                            (this.configValidator = void 0),
                            (this.config = ff),
                            (this.configValidator = new mf.a({
                              enable_force_parse_link_server: mf.b
                                .field()
                                .boolean(),
                              enable_parse_link_server: mf.b.field().boolean(),
                              enable_parse_link_client: mf.b.field().boolean(),
                              enable_auto_download_thumb: mf.b
                                .field()
                                .boolean(),
                              enable_parse_link_receiver: mf.b
                                .field()
                                .boolean(),
                              enable_parse_link_sender: mf.b.field().boolean(),
                              enable_download_partial_media_e2ee: mf.b
                                .field()
                                .boolean(),
                              enable_verify_parse_link_server: mf.b
                                .field()
                                .boolean(),
                              enable_show_loading_thumb: mf.b.field().boolean(),
                              white_list_domain: mf.b.field().array("string"),
                              white_list_domain_mode: mf.b
                                .field()
                                .string()
                                .oneOf(["append", "override"]),
                              max_time_reparse: mf.b.field().number().min(0),
                              max_thumb_size: mf.b.field().number().min(0),
                              max_age_cache_preview: mf.b
                                .field()
                                .number()
                                .min(0),
                              max_item_cache: mf.b.field().number().min(0),
                              max_url_character: mf.b.field().number().min(0),
                              max_title_character: mf.b.field().number().min(0),
                              max_desc_character: mf.b.field().number().min(0),
                              max_delay_send_message: mf.b
                                .field()
                                .number()
                                .min(0),
                              max_redirect: mf.b.field().number().min(0),
                              debug: mf.b.field().object({
                                enable_log_metric: mf.b.field().boolean(),
                                delay_parse_client: mf.b.field().number(),
                              }),
                            }));
                        }
                        get(e, t) {
                          var s;
                          return null !== (s = this.config[e]) && void 0 !== s
                            ? s
                            : t;
                        }
                        setConfig(e) {
                          const t = this.configValidator.validateWithFallback(
                            e,
                            ff,
                          );
                          this.config = Object(f.a)(
                            Object(f.a)(Object(f.a)({}, this.config), t),
                            this.mergeWhiteListDomainConfig(t),
                          );
                        }
                        mergeWhiteListDomainConfig(e) {
                          const t = e.white_list_domain_mode,
                            s = e.white_list_domain,
                            i = this.config.white_list_domain;
                          switch (t) {
                            case "append":
                            default:
                              return { white_list_domain: i.concat(s) };
                            case "override":
                              return { white_list_domain: s };
                          }
                        }
                      }),
                    ) || gf),
                ) || gf),
            ) || gf),
        );
        i.ModuleContainer.resolve(lf).on("on-config-change", (e) => {
          i.ModuleContainer.resolve(Up.a).setConfig(e);
        });
        class vf {
          constructor(e) {
            (this.maxAge = e),
              (this.mapTsItemIsSet = void 0),
              (this.mapTsItemIsSet = new Map());
          }
          hookBeforeGet(e, t) {
            const s = this.mapTsItemIsSet.get(e);
            if (!s) return;
            Date.now() - s >= this.maxAge && t(e);
          }
          hookAfterSet(e) {
            this.mapTsItemIsSet.set(e, Date.now());
          }
          hookAfterDelete(e) {
            this.mapTsItemIsSet.delete(e);
          }
          hookAfterClear() {
            this.mapTsItemIsSet.clear();
          }
        }
        class bf {
          constructor(e) {
            (this.maxItem = e),
              (this.mapTsItemIsVisited = void 0),
              (this.mapTsItemIsVisited = new Map());
          }
          hookBeforeGet(e) {
            this.mapTsItemIsVisited.set(e, { key: e, ts: Date.now() });
          }
          hookAfterSet(e, t) {
            this.mapTsItemIsVisited.set(e, { key: e, ts: Date.now() });
            let s = Math.max(this.mapTsItemIsVisited.size - this.maxItem, 0);
            if (s > 0) {
              Array.from(this.mapTsItemIsVisited.values())
                .sort((e, t) => (t.ts > e.ts ? -1 : 0))
                .slice(0, s)
                .forEach((e) => t(e.key));
            }
          }
          hookAfterDelete(e) {
            this.mapTsItemIsVisited.delete(e);
          }
          hookAfterClear() {
            this.mapTsItemIsVisited.clear();
          }
        }
        class If {
          constructor() {
            (this.strategies = void 0),
              (this.repository = void 0),
              (this.repositoryDeadItem = void 0),
              (this.markDeadItem = (e) => {
                const t = this.repository.get(e);
                t && ((t.isAlive = !1), this.repositoryDeadItem.push(e));
              });
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
              t[s] = arguments[s];
            (this.strategies = t),
              (this.repository = new Map()),
              (this.repositoryDeadItem = []);
          }
          get(e) {
            this.beforeGet(e);
            const t = this.repository.get(e);
            return t && t.isAlive ? t.value : null;
          }
          set(e, t) {
            const s = { isAlive: !0, key: e, value: t };
            this.repository.set(e, s), this.afterSet(e);
          }
          delete(e) {
            this.repository.delete(e), this.afterDelete(e);
          }
          reset() {
            this.repository.clear(), this.afterClear();
          }
          beforeGet(e) {
            this.strategies.forEach((t) =>
              t.hookBeforeGet(e, this.markDeadItem),
            ),
              this.doGC();
          }
          afterSet(e) {
            this.strategies.forEach((t) =>
              t.hookAfterSet(e, this.markDeadItem),
            ),
              this.doGC();
          }
          afterDelete(e) {
            this.strategies.forEach((t) => t.hookAfterDelete(e));
          }
          afterClear() {
            this.strategies.forEach((e) => e.hookAfterClear());
          }
          doGC() {
            this.repositoryDeadItem.length &&
              (this.repositoryDeadItem.forEach((e) => this.delete(e)),
              (this.repositoryDeadItem = []));
          }
        }
        var yf;
        Object(i.injectable)()(
          (yf =
            Object(i.singleton)(Mp.c)(
              (yf =
                (function (e, t) {
                  return Object(i.inject)(Up.a)(e, void 0, 0);
                })(
                  (yf =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (yf =
                        Reflect.metadata("design:paramtypes", [
                          "undefined" == typeof IParserConfigConsumer
                            ? Object
                            : IParserConfigConsumer,
                        ])(
                          (yf = class {
                            constructor(e) {
                              (this.metaData = void 0),
                                (this.thumbLocal = void 0),
                                (this.thumbLive = void 0);
                              const t = e.get("max_item_cache"),
                                s = e.get("max_age_cache_preview");
                              (this.metaData = new If(new bf(t), new vf(s))),
                                (this.thumbLocal = new If(
                                  new bf(t),
                                  new vf(s),
                                )),
                                (this.thumbLive = new If(new bf(t), new vf(s)));
                            }
                            getKey(e, t) {
                              switch (e) {
                                case "meta-data":
                                case "thumb-local": {
                                  const [e] = t;
                                  return pd.a.removeProtocol(e);
                                }
                                case "thumb-live": {
                                  const [e, s = ""] = t;
                                  return [
                                    tf.a.getPrefixConv(s),
                                    tf.a.isE2eeConv(s) ? "e2ee" : "none-e2ee",
                                    pd.a.removeProtocol(e),
                                  ].join("_");
                                }
                                default:
                                  return t.join(".");
                              }
                            }
                          }),
                        ) || yf),
                    ) || yf),
                ) || yf),
            ) || yf),
        );
        var _f,
          Of = s("WOja");
        Object(i.injectable)()(
          (_f =
            Object(i.singleton)(Mp.b)(
              (_f =
                (function (e, t) {
                  return Object(i.inject)(ef.b)(e, void 0, 0);
                })(
                  (_f =
                    (function (e, t) {
                      return Object(i.inject)(Mp.c)(e, void 0, 1);
                    })(
                      (_f =
                        (function (e, t) {
                          return Object(i.inject)(Mp.a)(e, void 0, 2);
                        })(
                          (_f =
                            (function (e, t) {
                              return Object(i.inject)(Up.a)(e, void 0, 3);
                            })(
                              (_f =
                                Reflect.metadata(
                                  "design:type",
                                  Function,
                                )(
                                  (_f =
                                    Reflect.metadata("design:paramtypes", [
                                      void 0 === ef.IParserLogger
                                        ? Object
                                        : ef.IParserLogger,
                                      "undefined" ==
                                      typeof ILinkPreviewRepository
                                        ? Object
                                        : ILinkPreviewRepository,
                                      "undefined" == typeof ILinkParserFactory
                                        ? Object
                                        : ILinkParserFactory,
                                      void 0 === Of.IParserConfigConsumer
                                        ? Object
                                        : Of.IParserConfigConsumer,
                                    ])(
                                      (_f = class {
                                        constructor(e, t, s, i) {
                                          (this.repository = t),
                                            (this.linkParserFactory = s),
                                            (this.config = i),
                                            (this.logger = void 0),
                                            (this.logger = e.linkParser);
                                        }
                                        parse(e) {
                                          var t;
                                          const s = this.repository.getKey(
                                            "meta-data",
                                            [e],
                                          );
                                          return (
                                            (null ===
                                              (t =
                                                this.repository.metaData.get(
                                                  s,
                                                )) || void 0 === t
                                              ? void 0
                                              : t.value) || null
                                          );
                                        }
                                        async preparseAsync(e, t) {
                                          await this.parseAsync(e, t);
                                        }
                                        async parseAsync(e, t) {
                                          if (
                                            !this.config.get(
                                              "enable_parse_link_client",
                                            )
                                          ) {
                                            const e =
                                                (null == t
                                                  ? void 0
                                                  : t.entry) !==
                                                Np.a.SHARE_MESSAGE,
                                              s = tf.a.isE2eeConv(
                                                (null == t
                                                  ? void 0
                                                  : t.convId) || "",
                                              );
                                            if (e && s) return null;
                                          }
                                          const s = this.repository.getKey(
                                              "meta-data",
                                              [e],
                                            ),
                                            i = this.repository.metaData.get(s);
                                          if (i && null !== i.value)
                                            return i.promise;
                                          const n = new Ba.b.Container();
                                          this.repository.metaData.set(s, n);
                                          const [a, r] =
                                            await Ba.b.catchAsyncFn(() =>
                                              this.linkParserFactory
                                                .getLinkParser(e, t)
                                                .parse(e),
                                            );
                                          return (
                                            a &&
                                              this.logger.zsymb(
                                                18,
                                                13084,
                                                3e4,
                                                `parse link failed ${a}`,
                                              ),
                                            n.resolve(r),
                                            n.promise
                                          );
                                        }
                                      }),
                                    ) || _f),
                                ) || _f),
                            ) || _f),
                        ) || _f),
                    ) || _f),
                ) || _f),
            ) || _f),
        );
        var Cf;
        Object(i.injectable)()(
          (Cf =
            Object(i.singleton)(rf.b)(
              (Cf =
                (function (e, t) {
                  return Object(i.inject)(ef.b)(e, void 0, 0);
                })(
                  (Cf =
                    (function (e, t) {
                      return Object(i.inject)(Mp.c)(e, void 0, 1);
                    })(
                      (Cf =
                        (function (e, t) {
                          return Object(i.inject)(rf.a)(e, void 0, 2);
                        })(
                          (Cf =
                            Reflect.metadata(
                              "design:type",
                              Function,
                            )(
                              (Cf =
                                Reflect.metadata("design:paramtypes", [
                                  void 0 === ef.IParserLogger
                                    ? Object
                                    : ef.IParserLogger,
                                  "undefined" == typeof ILinkPreviewRepository
                                    ? Object
                                    : ILinkPreviewRepository,
                                  "undefined" ==
                                  typeof IPreviewLinkProcessorFactory
                                    ? Object
                                    : IPreviewLinkProcessorFactory,
                                ])(
                                  (Cf = class {
                                    constructor(e, t, s) {
                                      (this.repository = t),
                                        (this.linkProcessorFactory = s),
                                        (this.logger = void 0),
                                        (this.logger = e.linkParser);
                                    }
                                    async processDownload(e) {
                                      var t;
                                      const s = this.repository.getKey(
                                          "meta-data",
                                          [e],
                                        ),
                                        i = this.repository.getKey(
                                          "thumb-local",
                                          [e],
                                        ),
                                        n = this.repository.thumbLocal.get(i);
                                      if (n && null !== n.value) {
                                        if (!n.value) return n.promise;
                                        {
                                          const e = n.value.thumbLocal;
                                          if (e) {
                                            const [t, s] =
                                              await Ba.b.catchAsyncFn(() => {
                                                var t, s;
                                                return null === (t = $znode) ||
                                                  void 0 === t ||
                                                  null === (s = t.fsPromise) ||
                                                  void 0 === s
                                                  ? void 0
                                                  : s.stat(e);
                                              });
                                            if (!t && s) return n.promise;
                                          }
                                        }
                                      }
                                      const a = new Ba.b.Container();
                                      this.repository.thumbLocal.set(i, a);
                                      const r =
                                          (await (null ===
                                            (t =
                                              this.repository.metaData.get(
                                                s,
                                              )) || void 0 === t
                                            ? void 0
                                            : t.promise)) || null,
                                        o = await this.linkProcessorFactory
                                          .getDownloadProcessor(
                                            null == r ? void 0 : r.typeParse,
                                          )
                                          .process(r);
                                      return a.resolve(o), a.promise;
                                    }
                                    async processUpload(e, t) {
                                      var s;
                                      const i = this.repository.getKey(
                                          "thumb-local",
                                          [e],
                                        ),
                                        n = this.repository.getKey(
                                          "thumb-live",
                                          [e, t],
                                        ),
                                        a = this.repository.thumbLive.get(n);
                                      if (a && null !== a.value)
                                        return a.promise;
                                      const r = new Ba.b.Container();
                                      this.repository.thumbLive.set(n, r);
                                      const o =
                                          (await (null ===
                                            (s =
                                              this.repository.thumbLocal.get(
                                                i,
                                              )) || void 0 === s
                                            ? void 0
                                            : s.promise)) || null,
                                        d = await this.linkProcessorFactory
                                          .getUploadProcessor(
                                            null == o ? void 0 : o.typeParse,
                                          )
                                          .process(o, t);
                                      return r.resolve(d), r.promise;
                                    }
                                  }),
                                ) || Cf),
                            ) || Cf),
                        ) || Cf),
                    ) || Cf),
                ) || Cf),
            ) || Cf),
        );
        var Ef = s("6e5J");
        class Mf {
          constructor() {}
          async getDimension(e) {
            const t = { key: Date.now(), file: e, srcAction: 3 },
              [s, i] = await Ba.b.catchAsyncFn(() =>
                Ef.default.getDimension(t),
              );
            return (
              Bp(s, s && this.transformError(s)), this.transformResponse(i)
            );
          }
          transformError(e) {
            return e;
          }
          transformResponse(e) {
            return {
              width: e.width,
              height: e.height,
              rotation: e.orientation,
            };
          }
        }
        var Sf = s("8I6r"),
          Tf = s("oSk7"),
          wf = s("taJj");
        class Rf {
          constructor() {}
          async download(e) {
            const [t, s] = Ct.default.parseE2eeProtocol(e),
              n = new Headers();
            if (t) {
              let e = "unsafe-flush";
              i.ModuleContainer.resolve(Up.a).get(
                "enable_download_partial_media_e2ee",
              ) &&
                (n.set("Range", `bytes=0-${Hp.sizeInByte("64KB")}`),
                (e = "safe-flush"));
              const [a, r] = await Ba.b.catchAsyncFn(() =>
                fetch(s, { headers: n }),
              );
              Bp(a, a);
              const o = new Tf.a(r.body)
                .pipe(new wf.a(Hp.sizeInByte("1MB")))
                .pipe(new Lf(new Sf.b(t, "decrypt"), e))
                .getStream();
              return await new Response(o, { headers: r.headers }).blob();
            }
            n.set("Range", `bytes=0-${Hp.sizeInByte("64KB")}`);
            const [a, r] = await Ba.b.catchAsyncFn(() =>
              fetch(e, { headers: n }),
            );
            return Bp(a, a), await r.blob();
          }
        }
        class Lf {
          constructor(e, t) {
            (this.zaes = e),
              (this.modeFlush = t),
              (this.transform = (e, t) => {
                const s = this.zaes.update(e);
                t.enqueue(s);
              }),
              (this.flush = (e) => {
                if ("safe-flush" !== this.modeFlush)
                  try {
                    this.zaes.end();
                  } catch (t) {
                    e.error(t);
                  }
              });
          }
        }
        const Df = {
          "image/gif": R.IMAGE_TYPE_GIF,
          "image/jpg": R.IMAGE_TYPE_JPEG,
          "image/jpeg": R.IMAGE_TYPE_JPEG,
          "image/png": R.IMAGE_TYPE_PNG,
        };
        class Ff {
          constructor() {}
          static getInstance() {
            return Ff.instance || (Ff.instance = new Ff()), Ff.instance;
          }
          isMatchParser(e) {
            return Object.keys(Df).includes(e);
          }
          async parse(e) {
            const [t, s] = await Ba.b.catchAsyncFn(() => new Rf().download(e));
            Bp(t, t);
            const [i, n] = await Ba.b.catchAsyncFn(() =>
              new Mf().getDimension(s),
            );
            return (
              Bp(i, i),
              Object(f.a)(
                Object(f.a)({}, n),
                {},
                { type: this.transformType(s) },
              )
            );
          }
          transformType(e) {
            return Df[e.type];
          }
        }
        Ff.instance = null;
        class Af {
          constructor() {}
          static getInstance() {
            return Af.instance || (Af.instance = new Af()), Af.instance;
          }
          isMatchParser(e) {
            return !0;
          }
          async parse(e) {
            return null;
          }
        }
        Af.instance = null;
        const jf = { "application/pdf": R.LINK_TYPE_PDF };
        class Pf {
          constructor() {}
          static getInstance() {
            return Pf.instance || (Pf.instance = new Pf()), Pf.instance;
          }
          isMatchParser(e) {
            return Object.keys(jf).includes(e);
          }
          async parse(e) {
            try {
              const t = Ct.default.removeE2eeProtocol(e),
                s = (await fetch(t, { method: "HEAD" })).headers.get(
                  "content-length",
                );
              return null === s
                ? null
                : {
                    size: Number(s),
                    name: pd.a.getFileNameFromUrl(e),
                    type: jf["application/pdf"],
                  };
            } catch (t) {
              throw t;
            }
          }
        }
        var Nf;
        Pf.instance = null;
        Object(i.singleton)(Mp.d)(
          (Nf = class {
            async getSizeParser(e) {
              const [t, s] = await Ba.b.catchAsyncFn(() =>
                this.tryGetContentType(e),
              );
              return t || !s
                ? Af.getInstance()
                : Ff.getInstance().isMatchParser(s)
                  ? Ff.getInstance()
                  : Pf.getInstance().isMatchParser(s)
                    ? Pf.getInstance()
                    : Af.getInstance();
            }
            async tryGetContentType(e) {
              if (!pd.a.isBlobUrl(e)) {
                const [t, s] = await Ba.b.catchAsyncFn(() =>
                  this.tryGetContentTypeByHead(e),
                );
                if (!t) return s;
              }
              return this.tryGetContentTypeByGet(e);
            }
            async tryGetContentTypeByHead(e) {
              const t = Ct.default.removeE2eeProtocol(e);
              return (await fetch(t, { method: "HEAD" })).headers.get(
                "content-type",
              );
            }
            async tryGetContentTypeByGet(e) {
              const t = Ct.default.removeE2eeProtocol(e),
                s = new AbortController(),
                i = await fetch(t, { signal: s.signal });
              s.abort();
              return i.headers.get("content-type");
            }
          }),
        );
        var Uf;
        Object(i.injectable)()(
          (Uf =
            Object(i.singleton)(Mp.e)(
              (Uf =
                (function (e, t) {
                  return Object(i.inject)(ef.b)(e, void 0, 0);
                })(
                  (Uf =
                    (function (e, t) {
                      return Object(i.inject)(Mp.d)(e, void 0, 1);
                    })(
                      (Uf =
                        Reflect.metadata(
                          "design:type",
                          Function,
                        )(
                          (Uf =
                            Reflect.metadata("design:paramtypes", [
                              void 0 === ef.IParserLogger
                                ? Object
                                : ef.IParserLogger,
                              "undefined" == typeof ISizeParserFactory
                                ? Object
                                : ISizeParserFactory,
                            ])(
                              (Uf = class {
                                constructor(e, t) {
                                  (this.sizeParserFactory = t),
                                    (this.cache = void 0),
                                    (this.cacheDedupe = void 0),
                                    (this.logger = void 0),
                                    (this.cache = new If(new bf(300))),
                                    (this.logger = e.mediaSizeLogger),
                                    (this.cacheDedupe = new Map());
                                }
                                parse(e) {
                                  const t = this.getCacheKey(e);
                                  return this.cache.get(t);
                                }
                                async preparseAsync(e) {
                                  await Ba.b.catchAsyncFn(() =>
                                    this.parseAsync(e),
                                  );
                                }
                                async parseAsync(e) {
                                  const t = this.getCacheKey(e),
                                    s = this.cache.get(t);
                                  if (s) return s;
                                  const i = this.cacheDedupe.get(t);
                                  if (i) return i;
                                  const n = (
                                    await this.sizeParserFactory.getSizeParser(
                                      e,
                                    )
                                  ).parse(e);
                                  this.cacheDedupe.set(t, n);
                                  const [a, r] = await Ba.b.catchAsyncFn(
                                    () => n,
                                  );
                                  return (
                                    this.cacheDedupe.delete(t),
                                    Bp(null !== a, a),
                                    null === r
                                      ? null
                                      : (this.cache.set(t, r), r)
                                  );
                                }
                                getCacheKey(e) {
                                  return e;
                                }
                              }),
                            ) || Uf),
                        ) || Uf),
                    ) || Uf),
                ) || Uf),
            ) || Uf),
        );
        var kf,
          Bf = s("2fgy"),
          Gf = s("dG4g"),
          xf = s("DBGg"),
          zf = s("bGlS");
        Object($t.b)(Bf.b)(
          (kf =
            Object(i.injectable)()(
              (kf =
                Reflect.metadata(
                  "design:type",
                  Function,
                )(
                  (kf =
                    Reflect.metadata(
                      "design:paramtypes",
                      [],
                    )(
                      (kf = class {
                        constructor() {
                          (this.type = void 0),
                            (this.name = void 0),
                            (this.key = void 0),
                            (this.data = void 0),
                            (this.name = Bf.a),
                            (this.key = Bf.a),
                            (this.data = {
                              list: new Map(),
                              photoViewData: void 0,
                            });
                        }
                        initialize() {}
                        destroy() {}
                        async onChangeMessages(e, t) {
                          const s = {};
                          e.forEach((e) => {
                            if (Object(Gf.b)(e)) {
                              let t = ls.b.isGroupPhoto(e);
                              "number" == typeof t && (t = t.toString()),
                                e.msgId && (s[e.msgId] = t || "");
                            }
                          }),
                            await this.getDataFromCache(s, t);
                        }
                        onChangeReactionDataList(e, t, s) {
                          const i = new Date().getTime(),
                            n = i.toString();
                          Object(nt.j)(n),
                            e.forEach((e, a) => {
                              var r;
                              const o = this.data.list.get(a);
                              if (
                                ((null === (r = this.data.photoViewData) ||
                                void 0 === r
                                  ? void 0
                                  : r.rMsgId) === a &&
                                  ((this.data.photoViewData = Object(f.a)(
                                    Object(f.a)({}, this.data.photoViewData),
                                    e,
                                  )),
                                  Object(nt.f)(n, this.name, zf.a)),
                                !s && !o)
                              )
                                return;
                              const d =
                                  Object.keys(
                                    (null == o ? void 0 : o.reactions) || {},
                                  ).length >
                                  Object.keys(
                                    (null == e ? void 0 : e.reactions) || {},
                                  ).length,
                                l =
                                  !t || Object(xf.a)(e.reactions) || d ? 0 : i,
                                c = Object(f.a)(
                                  Object(f.a)(Object(f.a)({}, o), e),
                                  {},
                                  { lastUpdateEffects: l },
                                );
                              this.data.list.set(a, c);
                              const h = null == c ? void 0 : c.groupPhotoMsgId;
                              h
                                ? (this.data.list.set(h, {
                                    isGroupPhotoMsg: !0,
                                    lastUpdate: i,
                                    lastUpdateEffects: l,
                                  }),
                                  Object(nt.f)(n, this.name, h),
                                  Object(nt.f)(n, this.name, a))
                                : Object(nt.f)(n, this.name, a);
                            }),
                            Object(nt.c)(n);
                        }
                        getReactedListFromMessage(e, t) {
                          if (t) {
                            if (!e.msgId || !this.data.photoViewData) return {};
                            const t = new Map();
                            return (
                              t.set(e.msgId, this.data.photoViewData),
                              Object(Gf.d)(e, t)
                            );
                          }
                          return Object(Gf.d)(e, this.data.list);
                        }
                        removeReactionDataFromList(e) {
                          if (!e.msgId) return;
                          const t = this.data.list.get(e.msgId);
                          null != t &&
                            t.isGroupPhotoMsg &&
                            this.data.list.forEach((t, s) => {
                              t.groupPhotoMsgId === e.msgId &&
                                this.data.list.delete(s);
                            }),
                            this.data.list.delete(e.msgId);
                        }
                        async onChangePhotoViewData(e) {
                          if (!e.msgId) return;
                          const t = [e.msgId],
                            s = await sn.a.get(t);
                          s &&
                            ((this.data.photoViewData = s[e.msgId]),
                            Object(nt.g)(this.name, zf.a));
                        }
                        removePhotoViewData() {
                          this.data.photoViewData = void 0;
                        }
                        async resyncReactionData() {
                          var e;
                          const t = {};
                          null !== (e = this.data.photoViewData) &&
                            void 0 !== e &&
                            e.rMsgId &&
                            (t[this.data.photoViewData.rMsgId] = ""),
                            this.data.list.forEach((e, s) => {
                              t[s] = e.groupPhotoMsgId || "";
                            }),
                            await this.getDataFromCache(t);
                        }
                        async getDataFromCache(e, t) {
                          const s = Object.keys(e),
                            i = await sn.a.get(s);
                          if (!i) return;
                          const n = new Map();
                          for (const a in i)
                            n.set(
                              a,
                              Object(f.a)(
                                Object(f.a)({}, i[a]),
                                {},
                                { groupPhotoMsgId: e[a] },
                              ),
                            );
                          this.onChangeReactionDataList(n, !1, !0),
                            null == t || t(Object.keys(i));
                        }
                        clearData() {
                          this.data.list.clear();
                        }
                        getData(e) {
                          return this.data.list.get(e);
                        }
                        getItem(e, t) {
                          return e.key === zf.a
                            ? this.data.photoViewData
                            : this.data.list.get(e.key);
                        }
                        init(e) {
                          throw new Error("Method not implemented.");
                        }
                        getList(e, t) {
                          throw new Error("Method not implemented.");
                        }
                        onGetItemFailure(e, t) {
                          throw new Error("Method not implemented.");
                        }
                        onGetListFailure(e, t) {
                          throw new Error("Method not implemented.");
                        }
                      }),
                    ) || kf),
                ) || kf),
            ) || kf),
        );
        var Vf,
          Hf = s("VhZi");
        Object($t.b)(Hf.b)(
          (Vf =
            Object(i.injectable)()(
              (Vf =
                Object(i.singleton)()(
                  (Vf =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (Vf =
                        Reflect.metadata(
                          "design:paramtypes",
                          [],
                        )(
                          (Vf = class {
                            constructor() {
                              (this.type = void 0),
                                (this.name = void 0),
                                (this.key = void 0),
                                (this.data = new Map()),
                                (this.windowId = void 0),
                                (this.name = Hf.a),
                                (this.key = Hf.a);
                            }
                            initialize(e) {
                              this.windowId === zf.c &&
                                Je.ModalManagerV2.addModal(
                                  Object(f.a)(
                                    Object(f.a)({}, zf.b),
                                    {},
                                    { altWindowId: void 0 },
                                  ),
                                ),
                                Je.ModalManagerV2.subscribeTriggers({
                                  windowId: this.windowId || zf.c,
                                  name: zf.b.name,
                                  trigger: (e) => {},
                                });
                              const t = e || zf.b.windowId;
                              this.data.set(t, { message: void 0 });
                            }
                            destroy(e) {
                              const t = e || zf.b.windowId;
                              this.data.delete(t);
                            }
                            toggleReactionPopup(e, t) {
                              const s = e || zf.b.windowId;
                              this.data.set(s, { message: t }),
                                t
                                  ? Je.ModalManagerV2.openModal(
                                      Object(f.a)(
                                        Object(f.a)({}, zf.b),
                                        {},
                                        {
                                          windowId: this.windowId,
                                          params: null,
                                        },
                                      ),
                                    )
                                  : Je.ModalManagerV2.closeModal(
                                      Object(f.a)(
                                        Object(f.a)({}, zf.b),
                                        {},
                                        { windowId: this.windowId },
                                      ),
                                    ),
                                Object(nt.g)(this.name, s);
                            }
                            getItem(e, t) {
                              return this.data.get(e.key);
                            }
                            init(e) {
                              throw new Error("Method not implemented.");
                            }
                            getList(e, t) {
                              throw new Error("Method not implemented.");
                            }
                            onGetItemFailure(e, t) {
                              throw new Error("Method not implemented.");
                            }
                            onGetListFailure(e, t) {
                              throw new Error("Method not implemented.");
                            }
                          }),
                        ) || Vf),
                    ) || Vf),
                ) || Vf),
            ) || Vf),
        );
        var $f = s("NmZm"),
          Wf = s("66W5"),
          Kf = s("xU41");
        var qf;
        Object(i.injectable)()(
          (qf =
            Object(i.singleton)()(
              (qf =
                Object($t.b)($f.b)(
                  (qf =
                    (function (e, t) {
                      return Object(i.inject)(q.ZLoggerFactory)(e, void 0, 0);
                    })(
                      (qf =
                        Reflect.metadata(
                          "design:type",
                          Function,
                        )(
                          (qf =
                            Reflect.metadata("design:paramtypes", [
                              void 0 === q.ZLoggerFactory
                                ? Object
                                : q.ZLoggerFactory,
                            ])(
                              (qf = class {
                                constructor(e) {
                                  (this.type = void 0),
                                    (this.key = Wf.c),
                                    (this.name = $f.a),
                                    (this._chatBoxInputDOMMap = new Map()),
                                    (this._chatBoxInputStateMap = new Map()),
                                    (this._logger = void 0),
                                    (this._logger = e.createZLogger(
                                      hs.ZLoggerNametags.cbiController,
                                      [hs.ZLoggerNametags.controllCbi],
                                    ));
                                }
                                init() {}
                                getItem(e, t) {
                                  if ((s = e.key) && s.startsWith(Wf.c))
                                    return this._getChatBoxInputState(e.key);
                                  var s;
                                }
                                getList(e, t) {
                                  return [];
                                }
                                onGetItemFailure(e, t) {
                                  this._logger.zsymb(
                                    21,
                                    15972,
                                    3e4,
                                    "[onGetItemFailure] key: {}, error: {}",
                                    e,
                                    t.message,
                                  );
                                }
                                onGetListFailure(e, t) {
                                  this._logger.zsymb(
                                    21,
                                    15972,
                                    30001,
                                    "[onGetListFailure] key: {}, error: {}",
                                    e,
                                    t.message,
                                  );
                                }
                                setChatInputType(e, t, s, i) {
                                  if ((void 0 === i && (i = !0), !e || !t))
                                    return this._logger.zsymb(
                                      21,
                                      15972,
                                      30002,
                                      "[setChatInputType] {} or {} isn't valid!",
                                      e,
                                      t,
                                    );
                                  if (!s)
                                    return this._logger.zsymb(
                                      21,
                                      15972,
                                      30003,
                                      "[setChatInputType] chatInputType isn't existed!",
                                    );
                                  let n = this._getChatBoxInputState(
                                    Object(Kf.a)(e, t),
                                  );
                                  const a = Object(wr.a)(n, (e) => {
                                    e.chatInputType = Object(f.a)({}, s);
                                  });
                                  this._chatBoxInputStateMap.set(
                                    Object(Kf.a)(e, t),
                                    a,
                                  ),
                                    i &&
                                      a !== n &&
                                      Object(nt.g)(
                                        this.name,
                                        Object(Kf.a)(e, t),
                                      );
                                }
                                getChatInputType(e, t) {
                                  return this._getChatBoxInputState(
                                    Object(Kf.a)(e, t),
                                  ).chatInputType;
                                }
                                getDefaultChatInputType() {
                                  return { name: Wf.g.NORMAL, info: {} };
                                }
                                getChatInputTypeInfo(e, t) {
                                  return this._getChatBoxInputState(
                                    Object(Kf.a)(e, t),
                                  ).chatInputType.info;
                                }
                                getChatInputTypeName(e, t) {
                                  return this._getChatBoxInputState(
                                    Object(Kf.a)(e, t),
                                  ).chatInputType.name;
                                }
                                bindChatInputScroller(e) {
                                  return (t) => {
                                    const s = this._getChatBoxInputDOM(e);
                                    (s.chatInputScroller = t),
                                      this._chatBoxInputDOMMap.set(e, s);
                                  };
                                }
                                bindChatInputContent(e) {
                                  return (t) => {
                                    const s = this._getChatBoxInputDOM(e);
                                    (s.chatInputContent = t),
                                      this._chatBoxInputDOMMap.set(e, s);
                                  };
                                }
                                bindChatBoxInputContainer(e) {
                                  return (t) => {
                                    const s = this._getChatBoxInputDOM(e);
                                    (s.chatBoxInputContainer = t),
                                      this._chatBoxInputDOMMap.set(e, s);
                                  };
                                }
                                getChatInputScroller(e, t) {
                                  if (e) {
                                    var s;
                                    return null !==
                                      (s =
                                        this._getChatBoxInputDOM(
                                          e,
                                        ).chatInputScroller) && void 0 !== s
                                      ? s
                                      : null == t
                                        ? void 0
                                        : t.document.getElementById(Wf.f);
                                  }
                                  return null;
                                }
                                getChatInputContent(e) {
                                  if (e) {
                                    return this._getChatBoxInputDOM(e)
                                      .chatInputContent;
                                  }
                                  return null;
                                }
                                getChatBoxInputContainer(e) {
                                  if (e) {
                                    return this._getChatBoxInputDOM(e)
                                      .chatBoxInputContainer;
                                  }
                                  return null;
                                }
                                _getChatBoxInputState(e) {
                                  let t = this._chatBoxInputStateMap.get(e);
                                  return (
                                    t ||
                                      ((t =
                                        this._getDefaultChatBoxInputState()),
                                      this._chatBoxInputStateMap.set(e, t)),
                                    t
                                  );
                                }
                                _getDefaultChatBoxInputState() {
                                  return {
                                    chatInputType:
                                      this.getDefaultChatInputType(),
                                  };
                                }
                                _getChatBoxInputDOM(e) {
                                  let t = this._chatBoxInputDOMMap.get(e);
                                  return (
                                    t ||
                                      ((t = this._getDefaultChatBoxInputDOM()),
                                      this._chatBoxInputDOMMap.set(e, t)),
                                    t
                                  );
                                }
                                _getDefaultChatBoxInputDOM() {
                                  return {
                                    chatBoxInputContainer: null,
                                    chatInputScroller: null,
                                    chatInputContent: null,
                                  };
                                }
                              }),
                            ) || qf),
                        ) || qf),
                    ) || qf),
                ) || qf),
            ) || qf),
        );
        var Zf,
          Jf = s("VO3D");
        const Qf = () => bt.default.chat_box_input.use_new_cbi_2023;
        Object(i.injectable)()(
          (Zf =
            Object(V.d)()(
              (Zf =
                Object(i.singleton)(Jf.a)(
                  (Zf =
                    (function (e, t) {
                      return Object(i.inject)(q.ZLoggerFactory)(e, void 0, 0);
                    })(
                      (Zf =
                        Reflect.metadata(
                          "design:type",
                          Function,
                        )(
                          (Zf =
                            Reflect.metadata("design:paramtypes", [
                              void 0 === q.ZLoggerFactory
                                ? Object
                                : q.ZLoggerFactory,
                            ])(
                              (Zf = class {
                                constructor(e) {
                                  (this._currentFlag = Qf()),
                                    (this._newFlag = Qf()),
                                    (this._prevConvId = ""),
                                    (this._isFlagChanged = !1),
                                    (this._flagChangeListeners = []),
                                    (this._logger = void 0),
                                    (this._logger = e.createZLogger(
                                      hs.ZLoggerNametags
                                        .auditCBIFlagCoordinator,
                                      [
                                        hs.ZLoggerNametags
                                          .coordinateAuditCBIFlag,
                                      ],
                                    )),
                                    (this._handleUpdateFlag =
                                      this._handleUpdateFlag.bind(this));
                                }
                                onApplicationReady(e) {
                                  (this._currentFlag = Qf()),
                                    (this._newFlag = Qf()),
                                    (this._isFlagChanged = !1),
                                    this._logger.zsymb(
                                      0,
                                      16688,
                                      3e4,
                                      "[onApplicationReady] _currentFlag: ",
                                      this._currentFlag,
                                    ),
                                    bt.$AppConfig.subscribe(
                                      this._handleUpdateFlag,
                                    );
                                }
                                getFlag() {
                                  return this._currentFlag;
                                }
                                listenConvChange(e) {
                                  this._logger.zsymb(
                                    0,
                                    16688,
                                    30001,
                                    "[listenConvChange] newConvId: ",
                                    e,
                                  ),
                                    (this._prevConvId &&
                                      this._prevConvId === e) ||
                                      (this._isFlagChanged &&
                                        ((this._currentFlag = this._newFlag),
                                        (this._isFlagChanged = !1),
                                        this._notifyFlagChanged())),
                                    (this._prevConvId = e);
                                }
                                addFlagChangeListener(e) {
                                  return "function" != typeof e ||
                                    this._flagChangeListeners.includes(e)
                                    ? () => {}
                                    : (this._flagChangeListeners.push(e),
                                      () => {
                                        this._flagChangeListeners =
                                          this._flagChangeListeners.filter(
                                            (t) => t !== e,
                                          );
                                      });
                                }
                                _handleUpdateFlag(e) {
                                  const { use_new_cbi_2023: t } =
                                    this._getFlagConfig(e);
                                  this._logger.zsymb(
                                    0,
                                    16688,
                                    30002,
                                    "[_handleUpdateFlag] newFlag: ",
                                    t,
                                  ),
                                    t !== this._currentFlag
                                      ? (this._isFlagChanged = !0)
                                      : (this._isFlagChanged = !1),
                                    this._newFlag !== t && (this._newFlag = t);
                                }
                                _getFlagConfig(e) {
                                  return e.chat_box_input || {};
                                }
                                _notifyFlagChanged() {
                                  this._flagChangeListeners.forEach((e, t) => {
                                    "function" == typeof e &&
                                      (this._logger.zsymb(
                                        0,
                                        16688,
                                        30003,
                                        "[_notifyFlagChanged] _currentFlag: ",
                                        this._currentFlag,
                                        t,
                                      ),
                                      e(this._currentFlag));
                                  });
                                }
                              }),
                            ) || Zf),
                        ) || Zf),
                    ) || Zf),
                ) || Zf),
            ) || Zf),
        );
        var Yf = s("/ApO"),
          Xf = s("DIKB"),
          ev = s("/wiu"),
          tv = s("WJhq");
        function sv(e, t) {
          var s, i;
          const n = null !== (s = t.duration) && void 0 !== s ? s : 0,
            a = null !== (i = t.easing) && void 0 !== i ? i : "ease",
            r = t.animId;
          return e.animate([{ height: t.fromHeight }, { height: t.toHeight }], {
            id: r,
            duration: n,
            fill: t.fill,
            easing: a,
          });
        }
        var iv = s("gn4y");
        let nv;
        !(function (e) {
          (e.NORMAL_TO_RTF = "normal-to-rtf"),
            (e.RTF_TO_NORMAL = "rtf-to-normal"),
            (e.MINI_TO_EXPAND = "mini-to-expand"),
            (e.EXPAND_TO_MINI = "expand-to-mini"),
            (e.RESIZE_WHEN_WINDOW_RESIZE = "resize-when-window-resize"),
            (e.FADE_IN_RTF_TOOLBAR = "fade-in-rtf-toolbar"),
            (e.FADE_OUT_RTF_TOOLBAR = "fade-out-rtf-toolbar");
        })(nv || (nv = {}));
        var av,
          rv = s("dZd7");
        const ov = new Ol.a(0);
        Object(i.injectable)()(
          (av =
            Object(i.singleton)(Yf.a)(
              (av =
                (function (e, t) {
                  return Object(i.inject)(q.ZLoggerFactory)(e, void 0, 0);
                })(
                  (av =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (av =
                        Reflect.metadata("design:paramtypes", [
                          void 0 === q.ZLoggerFactory
                            ? Object
                            : q.ZLoggerFactory,
                        ])(
                          (av = class {
                            constructor(e) {
                              (this._chatBoxInputAnimsMap = new Map()),
                                (this._logger = void 0),
                                (this._isDevelopment = void 0),
                                (this._logger = e.createZLogger(
                                  hs.ZLoggerNametags.cbiAnimationController,
                                  [hs.ZLoggerNametags.manageCBIAnimation],
                                )),
                                (this._isDevelopment = !1);
                            }
                            applyChatInputType(e, t, s) {
                              this._isDevelopment &&
                                this._logger.zsymb(
                                  0,
                                  16683,
                                  3e4,
                                  "(@=@)! >>>applyChatInputType<<<",
                                );
                              const {
                                windowId: i,
                                convId: n,
                                selfWindow: a,
                                hasAnim: r,
                              } = s;
                              if (
                                (this._isDevelopment &&
                                  this._logger.zsymb(
                                    3,
                                    16683,
                                    30001,
                                    "from: {} to: {}",
                                    JSON.stringify(e),
                                    JSON.stringify(t),
                                  ),
                                ev.e(e, t))
                              ) {
                                if (ev.d(t))
                                  return this.switchNormalModeToRTFMode(
                                    i,
                                    n,
                                    a,
                                    r,
                                  );
                                if (ev.c(t))
                                  return this.switchRTFModeToNormalMode(
                                    i,
                                    n,
                                    a,
                                    r,
                                  );
                              } else if (ev.c(e) && ev.d(t)) {
                                if (t.info.mode === Wf.h.MINI)
                                  return this.switchNormalModeToRTFMode(
                                    i,
                                    n,
                                    a,
                                    r,
                                  );
                                t.info.mode, Wf.h.EXPAND;
                              } else {
                                if (ev.d(e) && ev.c(t))
                                  return this.switchRTFModeToNormalMode(
                                    i,
                                    n,
                                    a,
                                    r,
                                  );
                                if (ev.d(e) && ev.d(t)) {
                                  if (
                                    e.info.mode === Wf.h.EXPAND &&
                                    t.info.mode === Wf.h.MINI
                                  )
                                    return this.switchExpandModeToMiniModeInRTFMode(
                                      i,
                                      n,
                                      a,
                                      r,
                                    );
                                  if (
                                    e.info.mode === Wf.h.MINI &&
                                    t.info.mode === Wf.h.EXPAND
                                  )
                                    return this.switchMiniModeToExpandModeInRTFMode(
                                      i,
                                      n,
                                      a,
                                      r,
                                    );
                                }
                              }
                              this._isDevelopment &&
                                this._logger.zsymb(
                                  3,
                                  16683,
                                  30002,
                                  "Do not support this case!",
                                );
                            }
                            switchNormalModeToRTFMode(e, t, s, i) {
                              if (
                                (void 0 === i && (i = !0),
                                this._isDevelopment &&
                                  this._logger.zsymb(
                                    0,
                                    16683,
                                    30003,
                                    "(@=@)! >>>switchNormalModeToRTFMode<<<",
                                  ),
                                !e || !t)
                              )
                                return;
                              const n = null != s ? s : Ks.default.getWindow(e);
                              if (!Object(iv.a)(!!n, "window isn't existed."))
                                return;
                              const a = this._getChatInputContainerEl(n);
                              if (
                                !Object(iv.a)(
                                  !!a,
                                  "chatInputContainerEl isn't existed.",
                                )
                              )
                                return;
                              const r = this._getRTFToolbarEl(n);
                              if (
                                !Object(iv.a)(
                                  !!r,
                                  "rtfToolbarEl isn't existed.",
                                )
                              )
                                return;
                              const o = () => {
                                a.classList.add(
                                  "--rtf-mode",
                                  "--rtf-mini-mode",
                                ),
                                  r.classList.add("--visible"),
                                  this._chatBoxInputController.setChatInputType(
                                    e,
                                    t,
                                    {
                                      name: Wf.g.RTF,
                                      info: { mode: Wf.h.MINI },
                                    },
                                  );
                              };
                              if ((this._cancelAllAnimation(e, !0), !i))
                                return o();
                              const d = a.clientHeight,
                                l = Math.round(
                                  2 * tv.c.PADDING_TOP_BOTTOM +
                                    5.5 * tv.e +
                                    tv.g +
                                    tv.b,
                                );
                              this._isDevelopment &&
                                this._logger.zsymb(
                                  3,
                                  16683,
                                  30004,
                                  "heights: {} {}",
                                  d,
                                  l,
                                );
                              let c = this._getTransitionDuration(l, d);
                              if (
                                (this._isDevelopment &&
                                  this._logger.zsymb(
                                    3,
                                    16683,
                                    30005,
                                    "duration: {}",
                                    c,
                                  ),
                                c > 0)
                              ) {
                                const s = this._getChatInputContentEl(n);
                                if (
                                  !Object(iv.a)(
                                    !!s,
                                    "chatInputContentEl isn't existed.",
                                  )
                                )
                                  return;
                                const i = s.clientHeight / tv.e >= 2;
                                i ||
                                  a.classList.add(
                                    "--animate-from-smallest-height",
                                  ),
                                  a.classList.add("--rtf-mode");
                                const o = sv(a, {
                                  animId: `${nv.NORMAL_TO_RTF}::${ov.next()}`,
                                  duration: c,
                                  easing: "ease",
                                  fromHeight: `${d}px`,
                                  toHeight: `${l}px`,
                                });
                                this._setAnimationById(e, o.id, o),
                                  (o.onfinish = () => {
                                    this._isDevelopment &&
                                      this._logger.zsymb(
                                        3,
                                        16683,
                                        30006,
                                        "finished: {}",
                                        o.id,
                                      ),
                                      i ||
                                        a.classList.remove(
                                          "--animate-from-smallest-height",
                                        ),
                                      a.classList.add("--rtf-mini-mode"),
                                      o.cancel();
                                  }),
                                  (o.oncancel = () => {
                                    this._isDevelopment &&
                                      this._logger.zsymb(
                                        3,
                                        16683,
                                        30007,
                                        "canceled: {}",
                                        o.id,
                                      ),
                                      i ||
                                        a.classList.remove(
                                          "--animate-from-smallest-height",
                                        ),
                                      a.classList.add("--rtf-mini-mode"),
                                      this._deleteAnimationById(e, o.id),
                                      this._chatBoxInputController.setChatInputType(
                                        e,
                                        t,
                                        {
                                          name: Wf.g.RTF,
                                          info: { mode: Wf.h.MINI },
                                        },
                                      );
                                  });
                                const h = (function (e, t) {
                                  var s, i, n;
                                  const a = t.animId,
                                    r =
                                      null !== (s = t.duration) && void 0 !== s
                                        ? s
                                        : 0,
                                    o =
                                      null !== (i = t.delay) && void 0 !== i
                                        ? i
                                        : 0;
                                  return e.animate(
                                    [{ opacity: 0 }, { opacity: 1 }],
                                    {
                                      id: a,
                                      duration: r,
                                      fill: t.fill,
                                      delay: o,
                                      easing:
                                        null !== (n = t.easing) && void 0 !== n
                                          ? n
                                          : "ease",
                                    },
                                  );
                                })(r, {
                                  animId: `${nv.FADE_IN_RTF_TOOLBAR}::${ov.next()}`,
                                  duration: c,
                                  easing: "ease",
                                });
                                this._setAnimationById(e, h.id, h),
                                  (h.onfinish = () => {
                                    this._isDevelopment &&
                                      this._logger.zsymb(
                                        3,
                                        16683,
                                        30008,
                                        "finished: {}",
                                        h.id,
                                      ),
                                      r.classList.add("--visible"),
                                      h.cancel();
                                  }),
                                  (h.oncancel = () => {
                                    this._isDevelopment &&
                                      this._logger.zsymb(
                                        3,
                                        16683,
                                        30009,
                                        "canceled: {}",
                                        h.id,
                                      ),
                                      r.classList.add("--visible"),
                                      this._deleteAnimationById(e, h.id);
                                  }),
                                  this._chatBoxInputController.setChatInputType(
                                    e,
                                    t,
                                    {
                                      name: Wf.g.SWITCHING,
                                      info: {
                                        inputType: Wf.g.RTF,
                                        from: Wf.g.NORMAL,
                                        to: Wf.g.RTF,
                                      },
                                    },
                                  );
                              } else o();
                            }
                            switchRTFModeToNormalMode(e, t, s, i) {
                              if (
                                (void 0 === i && (i = !0),
                                this._isDevelopment &&
                                  this._logger.zsymb(
                                    0,
                                    16683,
                                    30010,
                                    "(@=@)! >>>switchRTFModeToNormalMode<<<",
                                  ),
                                !e || !t)
                              )
                                return;
                              const n = null != s ? s : Ks.default.getWindow(e);
                              if (!Object(iv.a)(!!n, "window isn't existed."))
                                return;
                              const a = this._getChatInputContainerEl(n);
                              if (
                                !Object(iv.a)(
                                  !!a,
                                  "chatInputContainerEl isn't existed.",
                                )
                              )
                                return;
                              const r = this._getRTFToolbarEl(n);
                              if (
                                !Object(iv.a)(
                                  !!r,
                                  "rtfToolbarEl isn't existed.",
                                )
                              )
                                return;
                              const o = this._getChatBoxInputContainerEl(n);
                              if (
                                !Object(iv.a)(
                                  !!o,
                                  "chatBoxInputContainerEl isn't existed.",
                                )
                              )
                                return;
                              const d = () => {
                                a.classList.remove(
                                  "--rtf-mode",
                                  "--rtf-mini-mode",
                                ),
                                  r.classList.remove("--visible"),
                                  (o.style.height = ""),
                                  this._chatBoxInputController.setChatInputType(
                                    e,
                                    t,
                                    { name: Wf.g.NORMAL, info: {} },
                                  );
                              };
                              if ((this._cancelAllAnimation(e, !0), !i))
                                return d();
                              const l = this._getChatInputContentEl(n);
                              if (
                                !Object(iv.a)(
                                  !!l,
                                  "chatInputContentEl isn't existed.",
                                )
                              )
                                return;
                              const c = l.clientHeight,
                                h = a.clientHeight,
                                u = c / tv.e >= 2;
                              let g = tv.c.SMALLEST_HEIGHT_IN_NORMAL,
                                m = !1;
                              u ||
                                (a.classList.add("--simple-normal-mode"),
                                (m = l.clientHeight / tv.e >= 2),
                                a.classList.remove("--simple-normal-mode")),
                                (g =
                                  u || m
                                    ? Math.round(
                                        (c > tv.d.NORMAL.MAX
                                          ? tv.d.NORMAL.MAX
                                          : c) +
                                          tv.g +
                                          2 * tv.c.PADDING_TOP_BOTTOM +
                                          tv.b,
                                      )
                                    : tv.c.SMALLEST_HEIGHT_IN_NORMAL),
                                this._isDevelopment &&
                                  this._logger.zsymb(
                                    3,
                                    16683,
                                    30011,
                                    "heights: {} {}",
                                    h,
                                    g,
                                  );
                              let p = this._getTransitionDuration(g, h);
                              if (
                                (this._isDevelopment &&
                                  this._logger.zsymb(
                                    3,
                                    16683,
                                    30012,
                                    "duration: {}",
                                    p,
                                  ),
                                p > 0)
                              ) {
                                u ||
                                  m ||
                                  a.classList.add(
                                    "--animate-to-smallest-height",
                                  ),
                                  a.classList.add(
                                    "--switching-rtf-to-normal-mode",
                                  ),
                                  a.classList.remove(
                                    "--rtf-mode",
                                    "--rtf-mini-mode",
                                  ),
                                  r.classList.remove("--visible"),
                                  (o.style.height = "");
                                const s = sv(a, {
                                  animId: `${nv.RTF_TO_NORMAL}::${ov.next()}`,
                                  duration: p,
                                  easing: "ease",
                                  fromHeight: `${h}px`,
                                  toHeight: `${g}px`,
                                });
                                this._setAnimationById(e, s.id, s),
                                  (s.onfinish = () => {
                                    this._isDevelopment &&
                                      this._logger.zsymb(
                                        3,
                                        16683,
                                        30013,
                                        "finished: {}",
                                        s.id,
                                      ),
                                      a.classList.remove(
                                        "--switching-rtf-to-normal-mode",
                                        "--animate-to-smallest-height",
                                      ),
                                      s.cancel();
                                  }),
                                  (s.oncancel = () => {
                                    this._isDevelopment &&
                                      this._logger.zsymb(
                                        3,
                                        16683,
                                        30014,
                                        "canceled: {}",
                                        s.id,
                                      ),
                                      a.classList.remove(
                                        "--switching-rtf-to-normal-mode",
                                        "--animate-to-smallest-height",
                                      ),
                                      this._chatBoxInputController.setChatInputType(
                                        e,
                                        t,
                                        { name: Wf.g.NORMAL, info: {} },
                                      ),
                                      this._deleteAnimationById(e, s.id);
                                  });
                                const i = (function (e, t) {
                                  var s, i, n;
                                  const a = t.animId,
                                    r =
                                      null !== (s = t.duration) && void 0 !== s
                                        ? s
                                        : 0,
                                    o =
                                      null !== (i = t.delay) && void 0 !== i
                                        ? i
                                        : 0;
                                  return e.animate(
                                    [{ opacity: 1 }, { opacity: 0 }],
                                    {
                                      id: a,
                                      duration: r,
                                      fill: t.fill,
                                      delay: o,
                                      easing:
                                        null !== (n = t.easing) && void 0 !== n
                                          ? n
                                          : "ease",
                                    },
                                  );
                                })(r, {
                                  animId: `${nv.FADE_OUT_RTF_TOOLBAR}::${ov.next()}`,
                                  duration: Math.max(p - 50, 0),
                                  easing: "ease-in",
                                });
                                this._setAnimationById(e, i.id, i),
                                  (i.onfinish = () => {
                                    this._isDevelopment &&
                                      this._logger.zsymb(
                                        3,
                                        16683,
                                        30015,
                                        "finished: {}",
                                        i.id,
                                      ),
                                      i.cancel();
                                  }),
                                  (i.oncancel = () => {
                                    this._isDevelopment &&
                                      this._logger.zsymb(
                                        3,
                                        16683,
                                        30016,
                                        "canceled: {}",
                                        i.id,
                                      ),
                                      this._deleteAnimationById(e, i.id);
                                  }),
                                  this._chatBoxInputController.setChatInputType(
                                    e,
                                    t,
                                    {
                                      name: Wf.g.SWITCHING,
                                      info: {
                                        inputType: Wf.g.NORMAL,
                                        from: Wf.g.RTF,
                                        to: Wf.g.NORMAL,
                                      },
                                    },
                                  );
                              } else d();
                            }
                            switchMiniModeToExpandModeInRTFMode(e, t, s, i) {
                              var n, a;
                              if (
                                (void 0 === i && (i = !0),
                                this._isDevelopment &&
                                  this._logger.zsymb(
                                    0,
                                    16683,
                                    30017,
                                    "(@=@)! >>>switchMiniModeToExpandModeInRTFMode<<<",
                                  ),
                                !e || !t)
                              )
                                return;
                              const r = null != s ? s : Ks.default.getWindow(e);
                              if (!Object(iv.a)(!!r, "window isn't existed."))
                                return;
                              const o = this._getChatInputContainerEl(r);
                              if (
                                !Object(iv.a)(
                                  !!o,
                                  "chatInputContainerEl isn't existed.",
                                )
                              )
                                return;
                              const d = this._getRTFToolbarEl(r);
                              if (
                                !Object(iv.a)(
                                  !!d,
                                  "rtfToolbarEl isn't existed.",
                                )
                              )
                                return;
                              const l = this._getChatBoxInputContainerEl(r);
                              if (
                                !Object(iv.a)(
                                  !!l,
                                  "chatBoxInputContainerEl isn't existed.",
                                )
                              )
                                return;
                              let c = l.clientHeight,
                                h = Math.round(
                                  (null !==
                                    (n =
                                      null === (a = this._getChatViewEl(r)) ||
                                      void 0 === a
                                        ? void 0
                                        : a.clientHeight) && void 0 !== n
                                    ? n
                                    : 0) * tv.a,
                                );
                              const u = () => {
                                o.classList.replace(
                                  "--rtf-mini-mode",
                                  "--rtf-expand-mode",
                                ),
                                  (l.style.height = `${h}px`),
                                  this._chatBoxInputController.setChatInputType(
                                    e,
                                    t,
                                    {
                                      name: Wf.g.RTF,
                                      info: { mode: Wf.h.EXPAND },
                                    },
                                  );
                              };
                              if ((this._cancelAllAnimation(e, !0), !i))
                                return u();
                              c >= h && (h = c),
                                this._isDevelopment &&
                                  this._logger.zsymb(
                                    3,
                                    16683,
                                    30018,
                                    "heights: {} {}",
                                    c,
                                    h,
                                  );
                              let g = this._getTransitionDuration(h, c);
                              if (
                                (this._isDevelopment &&
                                  this._logger.zsymb(
                                    3,
                                    16683,
                                    30019,
                                    "duration: {}",
                                    g,
                                  ),
                                g > 0)
                              ) {
                                this._chatBoxInputController.setChatInputType(
                                  e,
                                  t,
                                  {
                                    name: Wf.g.SWITCHING,
                                    info: {
                                      inputType: Wf.g.RTF,
                                      from: Wf.h.MINI,
                                      to: Wf.h.EXPAND,
                                    },
                                  },
                                ),
                                  o.classList.replace(
                                    "--rtf-mini-mode",
                                    "--rtf-expand-mode",
                                  );
                                const s = sv(l, {
                                  animId: `${nv.MINI_TO_EXPAND}::${ov.next()}`,
                                  duration: g,
                                  fromHeight: `${c}px`,
                                  toHeight: `${h}px`,
                                });
                                this._setAnimationById(e, s.id, s),
                                  (s.onfinish = () => {
                                    this._isDevelopment &&
                                      this._logger.zsymb(
                                        3,
                                        16683,
                                        30020,
                                        "finished: {}",
                                        s.id,
                                      ),
                                      (l.style.height = `${h}px`),
                                      s.cancel();
                                  }),
                                  (s.oncancel = () => {
                                    this._isDevelopment &&
                                      this._logger.zsymb(
                                        3,
                                        16683,
                                        30021,
                                        "canceled: {}",
                                        s.id,
                                      ),
                                      (l.style.height = `${h}px`),
                                      this._deleteAnimationById(e, s.id),
                                      this._chatBoxInputController.setChatInputType(
                                        e,
                                        t,
                                        {
                                          name: Wf.g.RTF,
                                          info: { mode: Wf.h.EXPAND },
                                        },
                                      );
                                  });
                              } else u();
                            }
                            switchExpandModeToMiniModeInRTFMode(e, t, s, i) {
                              if (
                                (void 0 === i && (i = !0),
                                this._isDevelopment &&
                                  this._logger.zsymb(
                                    0,
                                    16683,
                                    30022,
                                    "(@=@)! >>>switchExpandModeToMiniModeInRTFMode<<<",
                                  ),
                                !e || !t)
                              )
                                return;
                              const n = null != s ? s : Ks.default.getWindow(e);
                              if (!Object(iv.a)(!!n, "window isn't existed."))
                                return;
                              const a = this._getChatInputContainerEl(n);
                              if (
                                !Object(iv.a)(
                                  !!a,
                                  "chatInputContainerEl isn't existed.",
                                )
                              )
                                return;
                              const r = this._getRTFToolbarEl(n);
                              if (
                                !Object(iv.a)(
                                  !!r,
                                  "rtfToolbarEl isn't existed.",
                                )
                              )
                                return;
                              const o = this._getChatBoxInputContainerEl(n);
                              if (
                                !Object(iv.a)(
                                  !!o,
                                  "chatBoxInputContainerEl isn't existed.",
                                )
                              )
                                return;
                              const d = () => {
                                a.classList.replace(
                                  "--rtf-expand-mode",
                                  "--rtf-mini-mode",
                                ),
                                  (o.style.height = ""),
                                  this._chatBoxInputController.setChatInputType(
                                    e,
                                    t,
                                    {
                                      name: Wf.g.RTF,
                                      info: { mode: Wf.h.MINI },
                                    },
                                  );
                              };
                              if ((this._cancelAllAnimation(e, !0), !i))
                                return d();
                              const l = o.clientHeight,
                                c = a.clientHeight,
                                h = Math.round(
                                  l -
                                    c +
                                    tv.d.RTF.MIN +
                                    tv.g +
                                    2 * tv.c.PADDING_TOP_BOTTOM +
                                    tv.b,
                                );
                              this._isDevelopment &&
                                this._logger.zsymb(
                                  3,
                                  16683,
                                  30023,
                                  "heights: {} {}",
                                  l,
                                  h,
                                );
                              let u = this._getTransitionDuration(h, l);
                              if (
                                (this._isDevelopment &&
                                  this._logger.zsymb(
                                    3,
                                    16683,
                                    30024,
                                    "duration: {}",
                                    u,
                                  ),
                                u > 0)
                              ) {
                                this._chatBoxInputController.setChatInputType(
                                  e,
                                  t,
                                  {
                                    name: Wf.g.SWITCHING,
                                    info: {
                                      inputType: Wf.g.RTF,
                                      from: Wf.h.EXPAND,
                                      to: Wf.h.MINI,
                                    },
                                  },
                                );
                                const s = sv(o, {
                                  animId: `${nv.EXPAND_TO_MINI}::${ov.next()}`,
                                  duration: u,
                                  fromHeight: `${l}px`,
                                  toHeight: `${h}px`,
                                });
                                this._setAnimationById(e, s.id, s),
                                  (s.onfinish = () => {
                                    this._isDevelopment &&
                                      this._logger.zsymb(
                                        3,
                                        16683,
                                        30025,
                                        "finished: {}",
                                        s.id,
                                      ),
                                      a.classList.replace(
                                        "--rtf-expand-mode",
                                        "--rtf-mini-mode",
                                      ),
                                      (o.style.height = ""),
                                      s.cancel();
                                  }),
                                  (s.oncancel = () => {
                                    this._isDevelopment &&
                                      this._logger.zsymb(
                                        3,
                                        16683,
                                        30026,
                                        "canceled: {}",
                                        s.id,
                                      ),
                                      a.classList.replace(
                                        "--rtf-expand-mode",
                                        "--rtf-mini-mode",
                                      ),
                                      (o.style.height = ""),
                                      this._deleteAnimationById(e, s.id),
                                      this._chatBoxInputController.setChatInputType(
                                        e,
                                        t,
                                        {
                                          name: Wf.g.RTF,
                                          info: { mode: Wf.h.MINI },
                                        },
                                      );
                                  });
                              } else d();
                            }
                            resizeChatBoxInputWhenWindowResize(e, t, s) {
                              var i, n;
                              if (
                                (void 0 === s && (s = !0),
                                this._isDevelopment &&
                                  this._logger.zsymb(
                                    0,
                                    16683,
                                    30027,
                                    "(@=@)! >>>resizeChatBoxInputWhenWindowResize<<<",
                                  ),
                                !e)
                              )
                                return;
                              const a = null != t ? t : Ks.default.getWindow(e);
                              if (!Object(iv.a)(!!a, "window isn't existed."))
                                return;
                              const r = this._getChatBoxInputContainerEl(a);
                              if (
                                !Object(iv.a)(
                                  !!r,
                                  "chatBoxInputContainerEl isn't existed.",
                                )
                              )
                                return;
                              const o = r.clientHeight,
                                d = Math.round(
                                  (null !==
                                    (i =
                                      null === (n = this._getChatViewEl(a)) ||
                                      void 0 === n
                                        ? void 0
                                        : n.clientHeight) && void 0 !== i
                                    ? i
                                    : 0) * tv.a,
                                ),
                                l = () => {
                                  r.style.height = `${d}px`;
                                };
                              if ((this._cancelAllAnimation(e, !0), !s))
                                return l();
                              this._isDevelopment &&
                                this._logger.zsymb(
                                  3,
                                  16683,
                                  30028,
                                  "heights: {} {}",
                                  o,
                                  d,
                                );
                              let c = this._getTransitionDuration(d, o);
                              if (
                                (this._isDevelopment &&
                                  this._logger.zsymb(
                                    3,
                                    16683,
                                    30029,
                                    "duration: {}",
                                    c,
                                  ),
                                c > 0)
                              ) {
                                const t = sv(r, {
                                  animId: `${nv.RESIZE_WHEN_WINDOW_RESIZE}::${ov.next()}`,
                                  duration: c,
                                  fromHeight: `${o}px`,
                                  toHeight: `${d}px`,
                                });
                                this._setAnimationById(e, t.id, t),
                                  (t.onfinish = () => {
                                    this._isDevelopment &&
                                      this._logger.zsymb(
                                        3,
                                        16683,
                                        30030,
                                        "finished: {}",
                                        t.id,
                                      ),
                                      (r.style.height = `${d}px`),
                                      t.cancel();
                                  }),
                                  (t.oncancel = () => {
                                    this._isDevelopment &&
                                      this._logger.zsymb(
                                        3,
                                        16683,
                                        30031,
                                        "canceled: {}",
                                        t.id,
                                      ),
                                      (r.style.height = `${d}px`),
                                      this._deleteAnimationById(e, t.id);
                                  });
                              } else l();
                            }
                            get _chatBoxInputController() {
                              return i.ModuleContainer.resolve(Xf.b);
                            }
                            _getChatInputContainerEl(e) {
                              return e.document.getElementById(Wf.d);
                            }
                            _getRTFToolbarEl(e) {
                              return e.document.getElementById(Wf.i);
                            }
                            _getChatBoxInputContainerEl(e) {
                              return e.document.getElementById(Wf.b);
                            }
                            _getChatInputContentEl(e) {
                              return e.document.getElementById(Wf.f);
                            }
                            _getChatViewEl(e) {
                              return e.document.getElementById(tv.f);
                            }
                            _getTransitionDuration(e, t) {
                              if (
                                (void 0 === e && (e = 0),
                                void 0 === t && (t = 0),
                                !e || e <= 0 || !t || t <= 0)
                              )
                                return 0;
                              const s = Object(rv.a)(),
                                i = Math.abs(e - t);
                              return i <= 1 ? 0 : Math.round(s * Math.log(i));
                            }
                            _getAnimationById(e, t) {
                              const s = this._chatBoxInputAnimsMap.get(e);
                              if (s) return s[t];
                            }
                            _setAnimationById(e, t, s) {
                              if (!e || !t || !s) return;
                              let i = this._chatBoxInputAnimsMap.get(e);
                              i || (i = {}),
                                (i[t] = s),
                                this._chatBoxInputAnimsMap.set(e, i);
                            }
                            _deleteAnimationById(e, t) {
                              const s = this._chatBoxInputAnimsMap.get(e);
                              s &&
                                (delete s[t],
                                this._chatBoxInputAnimsMap.set(e, s));
                            }
                            _cancelAnimation(e, t, s) {
                              void 0 === s && (s = !1);
                              let i = this._chatBoxInputAnimsMap.get(e);
                              if (!i) return;
                              i = Object(f.a)({}, i);
                              const n = i[t];
                              n &&
                                (n.cancel(),
                                s &&
                                  (delete i[t],
                                  this._chatBoxInputAnimsMap.set(e, i)));
                            }
                            _cancelAllAnimation(e, t) {
                              void 0 === t && (t = !1);
                              const s = this._chatBoxInputAnimsMap.get(e);
                              if (s && 0 !== Object.keys(s).length) {
                                for (const e in s) {
                                  var i;
                                  if (s[e])
                                    null === (i = s[e]) ||
                                      void 0 === i ||
                                      i.cancel(),
                                      t && delete s[e];
                                }
                                this._chatBoxInputAnimsMap.set(e, s);
                              }
                            }
                          }),
                        ) || av),
                    ) || av),
                ) || av),
            ) || av),
        );
        var dv,
          lv = s("CkSj"),
          cv = s("uUhV"),
          hv = s("I9t9"),
          uv = s("XoGZ");
        Object(i.singleton)(cv.a)(
          (dv =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (dv =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (dv = class {
                    constructor() {
                      (this._chatBoxToolbarButtonsMap = new Map()),
                        this._registerChatBoxToolbarButtons();
                    }
                    _registerChatBoxToolbarButtons() {
                      this._chatBoxToolbarButtonsMap.set(
                        lv.b.SEND_STICKER_ITEM,
                        (e) => Te.a.createElement(hv.r, e),
                      ),
                        this._chatBoxToolbarButtonsMap.set(
                          lv.b.PICK_PHOTO_ITEM,
                          (e) => Te.a.createElement(hv.l, e),
                        ),
                        this._chatBoxToolbarButtonsMap.set(
                          lv.b.PICK_FILE_ITEM,
                          (e) => Te.a.createElement(hv.j, e),
                        ),
                        this._chatBoxToolbarButtonsMap.set(
                          lv.b.SCREEN_CAPTURE_ITEM,
                          (e) => Te.a.createElement(hv.n, e),
                        ),
                        this._chatBoxToolbarButtonsMap.set(
                          lv.b.SCREEN_CAPTURE_OPTIONS_ITEM,
                          (e) => Te.a.createElement(hv.p, e),
                        ),
                        this._chatBoxToolbarButtonsMap.set(
                          lv.b.SHARE_CONTACT_ITEM,
                          (e) => Te.a.createElement(hv.s, e),
                        ),
                        this._chatBoxToolbarButtonsMap.set(
                          lv.b.CREATE_REMINDER_ITEM,
                          (e) => Te.a.createElement(hv.d, e),
                        ),
                        this._chatBoxToolbarButtonsMap.set(
                          lv.b.CREATE_TODO_ITEM,
                          (e) => Te.a.createElement(hv.e, e),
                        ),
                        this._chatBoxToolbarButtonsMap.set(
                          lv.b.TOGGLE_RTF_MODE_ITEM,
                          (e) => Te.a.createElement(hv.u, e),
                        ),
                        this._chatBoxToolbarButtonsMap.set(
                          lv.b.MARK_IMPORTANT_MESSAGE_ITEM,
                          (e) => Te.a.createElement(hv.g, e),
                        ),
                        this._chatBoxToolbarButtonsMap.set(
                          lv.b.QUICK_MESSAGE_ITEM,
                          (e) =>
                            Te.a.createElement(uv.a, {
                              conversationId: e.convId,
                            }),
                        ),
                        this._chatBoxToolbarButtonsMap.set(
                          lv.b.MORE_ITEM,
                          (e) => Te.a.createElement(hv.h, e),
                        );
                    }
                    getChatBoxToolbarButton(e) {
                      return this._chatBoxToolbarButtonsMap.get(e);
                    }
                  }),
                ) || dv),
            ) || dv),
        );
        var gv,
          mv = s("RPT1"),
          pv = s("TsEa"),
          fv = s("Y25x"),
          vv = s("7fvu");
        Object($t.b)(mv.b)(
          (gv =
            (function (e, t) {
              return Object(i.inject)(q.ZLoggerFactory)(e, void 0, 0);
            })(
              (gv =
                Reflect.metadata(
                  "design:type",
                  Function,
                )(
                  (gv =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === q.ZLoggerFactory ? Object : q.ZLoggerFactory,
                    ])(
                      (gv = class {
                        constructor(e) {
                          (this.type = void 0),
                            (this.key = vv.a),
                            (this.name = mv.a),
                            (this._chatBoxCommandUIStateMap = new Map()),
                            (this._isSupportCommandModeMap = new Map()),
                            (this._logger = void 0),
                            (this._logger = e.createZLogger(
                              hs.ZLoggerNametags.cbiCommandController,
                              [hs.ZLoggerNametags.cbiCommandMode],
                            ));
                        }
                        init() {}
                        getItem(e, t) {
                          if (!e.key) return;
                          const s = this._chatBoxCommandUIStateMap.get(e.key);
                          if (s) return s;
                          if (Object(fv.b)(e.key)) {
                            const t = this._initDefaultState();
                            return (
                              this._chatBoxCommandUIStateMap.set(e.key, t), t
                            );
                          }
                        }
                        getList(e, t) {
                          return [];
                        }
                        onGetItemFailure(e, t) {
                          this._logger.zsymb(
                            21,
                            15532,
                            3e4,
                            "[onGetItemFailure] key: {}, error: {}",
                            e,
                            t.message,
                          );
                        }
                        onGetListFailure(e, t) {
                          this._logger.zsymb(
                            21,
                            15532,
                            30001,
                            "[onGetListFailure] key: {}, error: {}",
                            e,
                            t.message,
                          );
                        }
                        getChatBoxCommandModeOfConv(e) {
                          if (!e) {
                            const t = `[getChatBoxCommandModeOfConv] ${e} is invalid!`;
                            return this._logger.zsymb(18, 15532, 30002, t), -1;
                          }
                          let t = this._chatBoxCommandUIStateMap.get(
                            Object(fv.a)(e),
                          );
                          return (
                            t ||
                              ((t = this._initDefaultState()),
                              this._chatBoxCommandUIStateMap.set(
                                Object(fv.a)(e),
                                t,
                              )),
                            t.currentMode
                          );
                        }
                        setNewChatBoxCommandModeOfConv(e, t) {
                          if (!t) {
                            const e = `[setNewChatBoxCommandModeOfConv] ${t} is invalid!`;
                            return void this._logger.zsymb(18, 15532, 30003, e);
                          }
                          let s = this._chatBoxCommandUIStateMap.get(
                            Object(fv.a)(t),
                          );
                          s || (s = this._initDefaultState());
                          let i = Object(wr.a)(s, (t) => {
                            t.currentMode = e;
                          });
                          i !== s &&
                            (this._chatBoxCommandUIStateMap.set(
                              Object(fv.a)(t),
                              i,
                            ),
                            Object(nt.g)(this.name, Object(fv.a)(t)));
                        }
                        resetChatBoxCommandModeToNormalModeOfConv(e) {
                          this.setNewChatBoxCommandModeOfConv(pv.b.NORMAL, e);
                        }
                        getPlaceholderOfMode(e) {
                          if (!e || -1 === e) return "";
                          const t = pv.c[e];
                          return t.hasOwnProperty("placeholder") &&
                            t.placeholder
                            ? t.placeholder
                            : "";
                        }
                        _initDefaultState() {
                          return { currentMode: pv.b.NORMAL };
                        }
                      }),
                    ) || gv),
                ) || gv),
            ) || gv),
        );
        var bv = s("u/Xa"),
          Iv = s("0EGn"),
          yv = s("ETgL"),
          _v = s("JRkD"),
          Ov = (s("uP4a"), s("xHgQ")),
          Cv = s("3/Az");
        const Ev = "ROTATE_LEFT",
          Mv = "ROTATE_RIGHT";
        var Sv,
          Tv,
          wv,
          Rv,
          Lv,
          Dv,
          Fv,
          Av,
          jv,
          Pv,
          Nv,
          Uv,
          kv = s("pr8J");
        function Bv() {
          return function (e, t, s) {
            const i = s.value;
            return (
              (s.value = async function () {
                const e = this.onFunctionDone || function () {};
                try {
                  for (
                    var t = arguments.length, s = new Array(t), n = 0;
                    n < t;
                    n++
                  )
                    s[n] = arguments[n];
                  const a = await i.apply(this, s);
                  return e(), a;
                } catch (a) {
                  throw (e(), a);
                }
              }),
              s
            );
          };
        }
        const Gv = {
          conversationId: "",
          showSlider: !0,
          items: [],
          selectedId: null,
          hasOlder: !0,
          hasNewer: !0,
          entry: Cv.i.Unknown,
        };
        (Sv = Object(i.injectable)()),
          (Tv = Object($t.b)(bv.b)),
          (wv = Reflect.metadata("design:type", Function)),
          (Rv = Reflect.metadata("design:paramtypes", [])),
          (Lv = Bv()),
          (Dv = Reflect.metadata("design:type", Function)),
          (Fv = Reflect.metadata("design:paramtypes", [
            void 0 === kv.LoadConfig ? Object : kv.LoadConfig,
            String,
            Boolean,
          ])),
          (Av = Bv()),
          (jv = Reflect.metadata("design:type", Function)),
          (Pv = Reflect.metadata("design:paramtypes", [
            void 0 === kv.LoadConfig ? Object : kv.LoadConfig,
          ])),
          Sv(
            (Nv =
              Tv(
                (Nv =
                  wv(
                    (Nv =
                      Rv(
                        ((Uv = class {
                          constructor() {
                            var e = this;
                            (this._runningTasks = new Map()),
                              (this._eventEmitter = new ed.a()),
                              (this._abortedTask = new Set()),
                              (this.dispose = () => {
                                this._runningTasks.forEach((e) => e.abort()),
                                  this._runningTasks.clear(),
                                  this._abortedTask.clear(),
                                  this._eventEmitter.removeAllListeners(),
                                  i.ModuleContainer.resolve(
                                    Yo.b,
                                  ).removeActiveWindowContext();
                              }),
                              (this.toggleSlider = (e) => {
                                this.ensureInitState(e);
                                let t = this.data.get(e);
                                (t = Object(f.a)(
                                  Object(f.a)({}, t),
                                  {},
                                  { showSlider: !t.showSlider },
                                )),
                                  this.data.set(e, t),
                                  this._signalRenderItem(this.name, e);
                              }),
                              (this.ensureInitState = function (t, s) {
                                void 0 === s && (s = !0);
                                e.data.get(t) ||
                                  (e.data.set(
                                    t,
                                    Object(f.a)(
                                      Object(f.a)({}, Gv),
                                      {},
                                      { conversationId: t },
                                    ),
                                  ),
                                  s || e._signalRenderItem(e.name, t));
                              }),
                              (this.getSelectedItem = (e) => {
                                const t = this.data.get(e);
                                if (!t) return null;
                                const s = t.selectedId;
                                if (!s) return null;
                                return t.items.find(
                                  (e) =>
                                    e.msgId === s ||
                                    (null == e ? void 0 : e.fakeMsgId) === s,
                                );
                              }),
                              (this.manualDownload = (e, t, s, i) => {
                                const n = this.getSelectedItem(s);
                                Object(_v.a)(
                                  !!n,
                                  `imageViewer: download item not found for ${s} ${i}`,
                                );
                                {
                                  var a, r;
                                  const s =
                                    "string" == typeof n
                                      ? n
                                      : null != n &&
                                          null !== (a = n.message) &&
                                          void 0 !== a &&
                                          a.href
                                        ? n.message.href
                                        : null == n ||
                                            null === (r = n.message) ||
                                            void 0 === r
                                          ? void 0
                                          : r.oriUrl;
                                  Object(Ov.a)(
                                    e,
                                    t.document,
                                    void 0,
                                    void 0,
                                    s,
                                    !1,
                                  );
                                }
                              }),
                              (this.resetShowSlider = (e) => {
                                const t = this.data.get(e);
                                t &&
                                  (this.data.set(
                                    e,
                                    Object(f.a)(
                                      Object(f.a)({}, t),
                                      {},
                                      { showSlider: !0 },
                                    ),
                                  ),
                                  this._signalRenderItem(this.name, e));
                              }),
                              (this._signalRenderItem = function () {
                                Object(nt.h)(...arguments);
                              }),
                              (this._abortRunningTasks = function (t, s) {
                                void 0 === s && (s = () => !1);
                                Array.from(e._runningTasks.keys())
                                  .filter((e) => e.startsWith(t) && !s(e))
                                  .forEach((t) => {
                                    const s = e._runningTasks.get(t);
                                    null == s || s.abort(),
                                      e._runningTasks.delete(t),
                                      e._abortedTask.add(t);
                                  });
                              }),
                              (this._isValidMessage = (e) =>
                                (null == e ? void 0 : e.msgType) !==
                                R.MSG_UNDO),
                              (this._filterDuplicatedImages = (e) => {
                                let t = new Map();
                                return e.reduce((e, s) => {
                                  if (!s) return e;
                                  if (null == s.cliMsgId || null == s.fromUid) {
                                    if (s.msgType && !isNaN(s.msgType)) {
                                      let t = +s.msgType;
                                      if (
                                        t <= 0 ||
                                        [
                                          R.MSG_TODO,
                                          R.MSG_TODO_DONE,
                                          R.MSG_FRIEND_SENT_REQUEST,
                                          R.MSG_SUGGEST_IN_CHAT,
                                        ].includes(t)
                                      )
                                        return e.push(s), e;
                                    }
                                    return e.push(s), e;
                                  }
                                  const i = `${s.cliMsgId}_${s.fromUid}`,
                                    n = `[${i}]|[${s.msgId}][${s.sendDttm}|${s.src}]`;
                                  if (t.has(i)) {
                                    const { msg: n } = t.get(i);
                                    return (
                                      n.src === R.MSG_SRC.SYNC_MOBILE_DB &&
                                        ((s.fakeMsgId = n.msgId),
                                        Object.assign(n, s)),
                                      e
                                    );
                                  }
                                  return (
                                    t.set(i, { data: n, msg: s }), e.push(s), e
                                  );
                                }, []);
                              }),
                              (this._eventBusHandler = (e, t) => {}),
                              (this.name = bv.a),
                              (this.data = new Map()),
                              (this.key = "conversationId"),
                              this.init();
                          }
                          on(e, t) {
                            return (
                              this._eventEmitter.on(e, t),
                              () => this._eventEmitter.off(e, t)
                            );
                          }
                          off(e, t) {
                            this._eventEmitter.off(e, t);
                          }
                          emit(e, t) {
                            switch (e) {
                              case Ev: {
                                const e = null == t ? void 0 : t.mediaId;
                                Object(_v.a)(
                                  "string" == typeof e,
                                  "payload must be an object with mediaId property",
                                ),
                                  i.ModuleContainer.resolve(Yo.b).rotateMedia(
                                    e,
                                    -90,
                                  );
                                break;
                              }
                              case Mv: {
                                const e = null == t ? void 0 : t.mediaId;
                                Object(_v.a)(
                                  "string" == typeof e,
                                  "payload must be an object with mediaId property",
                                ),
                                  i.ModuleContainer.resolve(Yo.b).rotateMedia(
                                    e,
                                    90,
                                  );
                                break;
                              }
                              default:
                                this._eventEmitter.emit(e, t);
                            }
                          }
                          undoDeleteMulti(e, t) {
                            const s = this.data.get(e);
                            if (!s || !t.length) return;
                            const i = [...s.items, ...t];
                            let n = this._filterDuplicatedImages(
                              i.sort((e, t) => +e.sendDttm - +t.sendDttm),
                            );
                            (n = this._filterDeletingMessages(e, n)),
                              this.data.set(
                                e,
                                Object(f.a)(
                                  Object(f.a)({}, s),
                                  {},
                                  { items: n },
                                ),
                              ),
                              this._signalRenderItem(this.name, e);
                          }
                          removeItem(e, t) {
                            var s;
                            const i = this.data.get(e);
                            if (!i || !t) return;
                            let n = i.items.findIndex(
                              (e) => e.msgId === i.selectedId,
                            );
                            const a = i.items.filter(
                              (e) => e.msgId !== t.msgId,
                            );
                            n = Math.min(n, a.length - 1);
                            const r =
                              null === (s = a[n]) || void 0 === s
                                ? void 0
                                : s.msgId;
                            this.data.set(
                              e,
                              Object(f.a)(
                                Object(f.a)({}, i),
                                {},
                                { items: a, selectedId: r },
                              ),
                            ),
                              0 === a.length &&
                                this.emit("CLOSE_VIEWER", {
                                  conversationId: e,
                                }),
                              this._signalRenderItem(this.name, e);
                          }
                          removeMulti(e, t) {
                            var s;
                            const i = this.data.get(e);
                            if (!i || !t.length) return;
                            let n = i.items.findIndex(
                              (e) => e.msgId === i.selectedId,
                            );
                            const a = i.items.filter(
                              (e) => !t.includes(e.msgId),
                            );
                            n = Math.min(n, a.length - 1);
                            const r =
                              null === (s = a[n]) || void 0 === s
                                ? void 0
                                : s.msgId;
                            this.data.set(
                              e,
                              Object(f.a)(
                                Object(f.a)({}, i),
                                {},
                                { items: a, selectedId: r },
                              ),
                            ),
                              0 === a.length &&
                                this.emit("CLOSE_VIEWER", {
                                  conversationId: e,
                                }),
                              this._signalRenderItem(this.name, e);
                          }
                          async loadSlider(e) {
                            const { conversationId: t } = e;
                            Object(_v.a)(
                              "string" == typeof t,
                              "conversationId must be provided",
                            );
                            try {
                              await this._refreshSliderData(e);
                            } catch (s) {}
                          }
                          async loadMore(e, t, s) {
                            const {
                              conversationId: i,
                              entry: n,
                              isMessageConv: a,
                            } = e;
                            Object(_v.a)(
                              "string" == typeof i && i.length > 0,
                              `conversationId must be provided. Got ${i}`,
                            ),
                              Object(_v.a)(
                                "backward" === t || "forward" === t,
                                `direction must be backward or forward. Got ${t}`,
                              );
                            const r = this.data.get(i);
                            if (
                              (Object(_v.a)(
                                !!r,
                                "imageViewer: load more failed. SliderState must be initialized",
                              ),
                              "backward" === t)
                            ) {
                              let t = r.hasOlder || s;
                              if (!t) return;
                              const d = `${i}-${n}-backward`;
                              var o;
                              if (
                                (this._abortRunningTasks(i, (e) => e !== d),
                                this._runningTasks.has(d))
                              )
                                return void (await (null ===
                                  (o = this._runningTasks.get(d)) ||
                                void 0 === o
                                  ? void 0
                                  : o.promise));
                              this.onFunctionDone = () => {
                                this._runningTasks.delete(d),
                                  this._abortedTask.delete(d);
                              };
                              const l = Jo(this._loadMore, {
                                conversationId: i,
                                limit: 20,
                                message: r.items[0],
                                options: {
                                  backward: !0,
                                  forward: !1,
                                  isMessageConv: a,
                                },
                              });
                              this._runningTasks.set(d, l);
                              let c = await l.promise;
                              if (this._abortedTask.has(d))
                                return void this._abortedTask.delete(d);
                              e.isMessageConv && (c = c.result || c);
                              const h = c;
                              let u = this._filterDuplicatedImages([
                                ...h,
                                ...r.items,
                              ]);
                              (u = this._filterDeletingMessages(i, u)),
                                (t = 20 === h.length),
                                this.data.set(
                                  i,
                                  Object(f.a)(
                                    Object(f.a)({}, r),
                                    {},
                                    { items: u, hasOlder: t },
                                  ),
                                ),
                                this._signalRenderItem(this.name, i);
                            } else {
                              let t = r.hasNewer || s;
                              if (!t) return;
                              const o = `${i}-${n}-forward`;
                              var d;
                              if (
                                (this._abortRunningTasks(i, (e) => e !== o),
                                this._runningTasks.has(o))
                              )
                                return void (await (null ===
                                  (d = this._runningTasks.get(o)) ||
                                void 0 === d
                                  ? void 0
                                  : d.promise));
                              this.onFunctionDone = () => {
                                this._runningTasks.delete(o);
                              };
                              const l = Jo(this._loadMore, {
                                conversationId: i,
                                limit: 20,
                                message: r.items[r.items.length - 1],
                                options: {
                                  backward: !1,
                                  forward: !0,
                                  isMessageConv: a,
                                },
                              });
                              this._runningTasks.set(o, l);
                              let c = await l.promise;
                              if (this._abortedTask.has(o))
                                return void this._abortedTask.delete(o);
                              e.isMessageConv && (c = c.result || c);
                              const h = c;
                              let u = this._filterDuplicatedImages([
                                ...r.items,
                                ...h,
                              ]);
                              (u = this._filterDeletingMessages(i, u)),
                                (t = 20 === h.length),
                                this.data.set(
                                  i,
                                  Object(f.a)(
                                    Object(f.a)({}, r),
                                    {},
                                    { items: u, hasNewer: t },
                                  ),
                                ),
                                this._signalRenderItem(this.name, i);
                            }
                          }
                          selectPreviousItem(e) {
                            const t = this.data.get(e);
                            Object(_v.a)(
                              !!t,
                              "imageViewer: select previous item failed. SliderState must be initialized",
                            );
                            const s = t.items.findIndex(
                              (e) =>
                                e.msgId === t.selectedId ||
                                (null == e ? void 0 : e.fakeMsgId) ===
                                  t.selectedId,
                            );
                            if (0 === s || !t.items.length) return;
                            const i = t.items[s - 1],
                              n = i.msgId;
                            i.cliMsgId, i.fromUid;
                            this.data.set(
                              e,
                              Object(f.a)(
                                Object(f.a)({}, t),
                                {},
                                { selectedId: n },
                              ),
                            ),
                              this._signalRenderItem(this.name, e);
                          }
                          selectNextItem(e) {
                            const t = this.data.get(e);
                            Object(_v.a)(
                              !!t,
                              "imageViewer: select next item failed. SliderState must be initialized",
                            );
                            const s = t.items.findIndex(
                              (e) =>
                                e.msgId === t.selectedId ||
                                (null == e ? void 0 : e.fakeMsgId) ===
                                  t.selectedId,
                            );
                            if (s === t.items.length - 1 || !t.items.length)
                              return;
                            const i = t.items[s + 1],
                              n = i.msgId;
                            i.cliMsgId, i.fromUid;
                            this.data.set(
                              e,
                              Object(f.a)(
                                Object(f.a)({}, t),
                                {},
                                { selectedId: n },
                              ),
                            ),
                              this._signalRenderItem(this.name, e);
                          }
                          selectItem(e, t) {
                            const s = this.data.get(e);
                            Object(_v.a)(
                              !!s,
                              "imageViewer: select item failed. SliderState must be initialized",
                            ),
                              this.data.set(
                                e,
                                Object(f.a)(
                                  Object(f.a)({}, s),
                                  {},
                                  { selectedId: t },
                                ),
                              ),
                              this._signalRenderItem(this.name, e);
                          }
                          reset(e) {
                            Array.from(this._runningTasks.keys())
                              .filter((t) => t.startsWith(e))
                              .forEach((e) => {
                                const t = this._runningTasks.get(e);
                                null == t || t.abort(),
                                  this._runningTasks.delete(e);
                              }),
                              this._abortedTask.clear(),
                              this.data.has(e) && this.data.delete(e);
                          }
                          _secureSliderState(e) {
                            var t;
                            let {
                                conversationId: s,
                                selectedId: i,
                                defaultItems: n,
                                entry: a,
                              } = e,
                              r = this.data.get(e.conversationId);
                            const o =
                              null === (t = r) || void 0 === t
                                ? void 0
                                : t.items.some(
                                    (e) => e.msgId === i || e.fakeMsgId === i,
                                  );
                            let d = !0;
                            if (e.disableLoadMore)
                              return (
                                a === Cv.i.Profile && (n = n.slice().reverse()),
                                (r = Object(f.a)(
                                  Object(f.a)({}, Gv),
                                  {},
                                  {
                                    conversationId: s,
                                    items: n,
                                    selectedId: i,
                                    showSlider: !0,
                                    hasOlder: !1,
                                    hasNewer: !1,
                                    entry: e.entry,
                                  },
                                )),
                                this.data.set(e.conversationId, r),
                                this._signalRenderItem(this.name, s),
                                d
                              );
                            const l = this._filterDeletingMessages(s, n);
                            return (
                              r && o
                                ? i !== r.selectedId &&
                                  ((r = Object(f.a)(
                                    Object(f.a)({}, r),
                                    {},
                                    { selectedId: i, entry: e.entry },
                                  )),
                                  (d = !1))
                                : ((r = Object(f.a)(
                                    Object(f.a)({}, Gv),
                                    {},
                                    {
                                      conversationId: s,
                                      items: l,
                                      selectedId: i,
                                      showSlider: !0,
                                      hasOlder: !0,
                                      hasNewer: !0,
                                      entry: e.entry,
                                    },
                                  )),
                                  (d = !1)),
                              d ||
                                (this.data.set(e.conversationId, r),
                                this._signalRenderItem(this.name, s)),
                              d
                            );
                          }
                          async _refreshSliderData(e) {
                            const {
                                conversationId: t,
                                selectedId: s,
                                isMessageConv: i,
                                entry: n,
                                defaultItems: a,
                              } = e,
                              r = 10;
                            let o = this._secureSliderState(e);
                            if (e.disableLoadMore) return;
                            let d = this.data.get(e.conversationId);
                            const l = d.items.findIndex(
                                (e) => e.msgId === s || e.fakeMsgId === s,
                              ),
                              c = d.items[l],
                              h = `${t}-${n}-${s}`;
                            this._abortRunningTasks(t);
                            let u = d.hasOlder,
                              g = d.hasNewer;
                            const m = l < r && u,
                              p = l >= d.items.length - r && g;
                            if (!m && !p)
                              return void (
                                o || this._signalRenderItem(this.name, t)
                              );
                            this.onFunctionDone = () => {
                              this._runningTasks.delete(h),
                                this._abortedTask.delete(h);
                            };
                            const v = {
                                conversationId: t,
                                limit: r,
                                message: c,
                                options: {
                                  backward: m,
                                  forward: p,
                                  isMessageConv: i,
                                },
                              },
                              b = Jo(this._loadMore, v);
                            this._runningTasks.set(h, b);
                            let I = await b.promise;
                            if (
                              (e.isMessageConv && (I = I.result || I),
                              this._abortedTask.has(h))
                            )
                              return void this._abortedTask.delete(h);
                            const y = I,
                              _ = d.items;
                            if (p && m) {
                              const e = y.findIndex(
                                (e) => e.msgId === s || e.fakeMsgId === s,
                              );
                              m && e < 9 && (u = !1),
                                p && y.length - e < 9 && (g = !1);
                              const i = e,
                                n = y.length - e,
                                a = _.slice(0, Math.max(0, l - i)),
                                r = _.slice(l + n, _.length);
                              let c = this._filterDuplicatedImages([
                                ...a,
                                ...y,
                                ...r,
                              ]);
                              (c = this._filterDeletingMessages(t, c)),
                                this.data.set(
                                  t,
                                  Object(f.a)(
                                    Object(f.a)({}, d),
                                    {},
                                    {
                                      selectedId: s,
                                      items: c,
                                      hasOlder: u,
                                      hasNewer: g,
                                    },
                                  ),
                                ),
                                (o = !1);
                            } else if (m) {
                              let e = this._filterDuplicatedImages([
                                ...y,
                                ..._,
                              ]);
                              (e = this._filterDeletingMessages(t, e)),
                                y.length < r && (u = !1),
                                this.data.set(
                                  t,
                                  Object(f.a)(
                                    Object(f.a)({}, d),
                                    {},
                                    {
                                      selectedId: s,
                                      items: e,
                                      hasOlder: u,
                                      hasNewer: g,
                                    },
                                  ),
                                ),
                                (o = !1);
                            } else if (p) {
                              let e = this._filterDuplicatedImages([
                                ..._,
                                ...y,
                              ]);
                              (e = this._filterDeletingMessages(t, e)),
                                y.length < r && (g = !1),
                                this.data.set(
                                  t,
                                  Object(f.a)(
                                    Object(f.a)({}, d),
                                    {},
                                    {
                                      selectedId: s,
                                      items: e,
                                      hasOlder: u,
                                      hasNewer: g,
                                    },
                                  ),
                                ),
                                (o = !1);
                            }
                            o || this._signalRenderItem(this.name, t);
                          }
                          async _loadMore(e) {
                            const {
                                conversationId: t,
                                message: s,
                                limit: n,
                                options: {
                                  forward: a = !0,
                                  backward: r = !1,
                                  filter: o = null,
                                  isMessageConv: d = !1,
                                } = {},
                              } = e,
                              l = s.msgId;
                            if (!1 === d) {
                              let e = await i.ModuleContainer.resolve(
                                Iv.a,
                              ).getImageMessagesForPhotoViewer(
                                t,
                                l,
                                n,
                                a,
                                r,
                                o,
                              );
                              const s = yv.b.getOneBannedGroup(t);
                              return (
                                s &&
                                  (e = yv.b.filterBannedMediaGroup(
                                    s.groupId,
                                    e,
                                  )),
                                e
                              );
                            }
                            return await Ee.default.getImagesForPhotoViewerFromMessage(
                              s.toUid,
                              s.sendDttm,
                              l,
                              n,
                              a,
                              r,
                            );
                          }
                          _filterDeletingMessages(e, t) {
                            return t.filter(
                              (t) =>
                                !Na.d.isDeleteMessage(e, t) &&
                                this._isValidMessage(t),
                            );
                          }
                          listenEvents() {
                            Mt.default.subscribe(this._eventBusHandler);
                          }
                          init() {
                            this.listenEvents();
                          }
                          getItem(e) {
                            return this.data.get(e.key);
                          }
                          getList(e) {
                            return "all" === e.key
                              ? Array.from(this.data.keys())
                              : [];
                          }
                          onGetItemFailure(e) {}
                          onGetListFailure(e) {}
                        }),
                        Object(Sp.a)(
                          Uv.prototype,
                          "loadMore",
                          [Lv, Dv, Fv],
                          Object.getOwnPropertyDescriptor(
                            Uv.prototype,
                            "loadMore",
                          ),
                          Uv.prototype,
                        ),
                        Object(Sp.a)(
                          Uv.prototype,
                          "_refreshSliderData",
                          [Av, jv, Pv],
                          Object.getOwnPropertyDescriptor(
                            Uv.prototype,
                            "_refreshSliderData",
                          ),
                          Uv.prototype,
                        ),
                        (Nv = Uv)),
                      ) || Nv),
                  ) || Nv),
              ) || Nv),
          );
        var xv = s("DRxf"),
          zv = s("ftrm"),
          Vv = s("pDj3");
        const Hv = "zcloud-status-service",
          $v = Object(i.define)(Hv),
          Wv = "zcloud-key-service",
          Kv = Object(i.define)(Wv),
          qv = "zcloud-plan-service-key",
          Zv = Object(i.define)(qv);
        var Jv,
          Qv = s("2T8k");
        let Yv =
          Object(V.d)()(
            (Jv =
              Object(i.injectable)()(
                (Jv =
                  (function (e, t) {
                    return Object(i.inject)(Vv.a)(e, void 0, 0);
                  })(
                    (Jv =
                      (function (e, t) {
                        return Object(i.inject)($v)(e, void 0, 1);
                      })(
                        (Jv =
                          (function (e, t) {
                            return Object(i.inject)(Kv)(e, void 0, 2);
                          })(
                            (Jv =
                              (function (e, t) {
                                return Object(i.inject)(Zv)(e, void 0, 3);
                              })(
                                (Jv =
                                  Reflect.metadata(
                                    "design:type",
                                    Function,
                                  )(
                                    (Jv =
                                      Reflect.metadata("design:paramtypes", [
                                        void 0 === Vv.a ? Object : Vv.a,
                                        void 0 === $v ? Object : $v,
                                        void 0 === Kv ? Object : Kv,
                                        void 0 === Zv ? Object : Zv,
                                      ])(
                                        (Jv = class {
                                          get Logger() {
                                            return (
                                              this._Logger ||
                                                (this._Logger =
                                                  i.ModuleContainer.resolve(
                                                    q.ZLoggerFactory,
                                                  ).createZLogger(
                                                    hs.ZLoggerNametags.zCloud,
                                                    [
                                                      hs.ZLoggerNametags
                                                        .zCloudStatusController,
                                                    ],
                                                  )),
                                              this._Logger
                                            );
                                          }
                                          constructor(e, t, s, i) {
                                            (this.metrics = e),
                                              (this.statusService = t),
                                              (this.keyService = s),
                                              (this.planService = i),
                                              (this.name = void 0),
                                              (this.key = void 0),
                                              (this._Logger = void 0),
                                              (this.name = xv.a),
                                              (this.key = xv.a);
                                          }
                                          onApplicationReady() {}
                                          onBizConfigReady() {
                                            if (
                                              !Object(
                                                zv.a,
                                              )().isEnableUserPCloud()
                                            )
                                              return (
                                                this.Logger.zsymb(
                                                  3,
                                                  16158,
                                                  3e4,
                                                  "requestRSAKey but no permission!",
                                                ),
                                                void this.keyService.removeRSAKey()
                                              );
                                            this.metrics.setGetKeyAfterLoginTime(),
                                              this.keyService.requestRSAKey(
                                                Mm.c.LOGIN,
                                              ),
                                              i.ModuleContainer.resolve(
                                                Em.b,
                                              ).initShouldShowEntry(
                                                Object(
                                                  zv.a,
                                                )().isEnableUserPCloud(),
                                              );
                                          }
                                          async onLoadInitPCloudList(e, t) {
                                            if (!zv.b.shouldLoadInitStatus(t))
                                              return;
                                            let s = zv.b.filterValidMsgs(e);
                                            if (
                                              ((s = zv.b.normalizedMsgs(s)),
                                              !s || !s.length)
                                            )
                                              return;
                                            const i =
                                              await this.statusService.getInitPCloudUpdate(
                                                s,
                                                t,
                                              );
                                            i &&
                                              1 === Object.keys(i).length &&
                                              this.Logger.zsymb(
                                                3,
                                                16158,
                                                30001,
                                                "onLoadInitPCloudList with one item, pCloudUpdate",
                                                i,
                                              ),
                                              this.onUpdatePersonalCloud(i);
                                          }
                                          debug(e, t) {
                                            Object(
                                              zv.a,
                                            )().isEnableShowToastDebug() &&
                                              zv.c.showToastPCloudDebug(e, t);
                                          }
                                          getErrorPCloudHandler(e, t) {
                                            const {
                                              error: s,
                                              msgIds: i,
                                              windowId: n,
                                              showNoti: a,
                                              type: r,
                                            } = e;
                                            return s &&
                                              null != s &&
                                              s.hasNoKey &&
                                              Object(
                                                zv.a,
                                              )().isEnableTriggerTransferKey()
                                              ? () =>
                                                  this.onInteractMediaWithoutKey(
                                                    {
                                                      msgIds: i,
                                                      windowId: n,
                                                      showNoti: a,
                                                      type: r,
                                                    },
                                                    t,
                                                  )
                                              : () => {};
                                          }
                                          checkPCloudWithoutKey(e) {
                                            return this.keyService.checkPCloudWithoutKey(
                                              e,
                                            );
                                          }
                                          onUpdatePersonalCloud(e) {
                                            if (Object(Qv.d)(e)) return;
                                            this.debug({}, e);
                                            const t = Object.keys(e);
                                            this.statusService.syncCachePCloudInfo(
                                              e,
                                            ),
                                              this.statusService.signalUIPCloudInfo(
                                                e,
                                              ),
                                              this.statusService.syncMediaStatus(
                                                t,
                                              ),
                                              this.statusService.shareUpdatePCloudAction(
                                                e,
                                              );
                                          }
                                          onHandleHaveKey() {
                                            const e =
                                              this.keyService.createPCloudUpdateWithValidRSAKey();
                                            this.keyService.shareHaveKeyPCloudAction(
                                              e,
                                            ),
                                              this.onUpdatePersonalCloud(e);
                                          }
                                          async onInteractMediaWithoutKey(
                                            e,
                                            t,
                                          ) {
                                            if (
                                              !Object(
                                                zv.a,
                                              )().isEnableTriggerTransferKey()
                                            )
                                              return;
                                            if (
                                              (this.keyService.showToastWarningNoKey(
                                                e,
                                              ),
                                              !Object(
                                                zv.a,
                                              )().isEnableUserPCloud())
                                            )
                                              return void this.Logger.zsymb(
                                                3,
                                                16158,
                                                30002,
                                                "requestRSAKey but no permission!",
                                              );
                                            const s = t || Mm.c.RETRY;
                                            s === Mm.c.INVIEW
                                              ? this.metrics.setGetKeyAfterInviewTime()
                                              : s === Mm.c.RETRY &&
                                                this.metrics.setGetKeyAfterRetryTime(),
                                              this.keyService.requestRSAKey(s);
                                          }
                                          onOffPCloudPlan() {
                                            const e =
                                              this.statusService.createEmptyPCloudUpdate();
                                            this.keyService.removeRSAKey(),
                                              this.onUpdatePersonalCloud(e),
                                              this.planService.shareOffPlanEvent();
                                          }
                                          onUpgradeZCloudPlan() {
                                            this.metrics.setGetKeyAfterChangePlanTime(),
                                              this.keyService.requestRSAKey(
                                                Mm.c.CHANGE_PLAN,
                                              ),
                                              this.planService.shareUpgradePlanEvent();
                                          }
                                        }),
                                      ) || Jv),
                                  ) || Jv),
                              ) || Jv),
                          ) || Jv),
                      ) || Jv),
                  ) || Jv),
              ) || Jv),
          ) || Jv;
        var Xv,
          eb = s("/1VS"),
          tb = s("0VmO");
        const sb = {
            valid: !1,
            status: { isClouded: !0, isUncloud: !1 },
            error: { hasNoKey: !0 },
          },
          ib = {
            valid: !1,
            status: { isClouded: !1, isUncloud: !0 },
            error: null,
          },
          nb = {
            valid: !0,
            status: { isClouded: !0, isUncloud: !1 },
            error: null,
          };
        let ab =
          Object(V.d)()(
            (Xv =
              Object(i.injectable)()(
                (Xv =
                  (function (e, t) {
                    return Object(i.inject)(tb.a)(e, void 0, 0);
                  })(
                    (Xv =
                      Reflect.metadata(
                        "design:type",
                        Function,
                      )(
                        (Xv =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === tb.a ? Object : tb.a,
                          ])(
                            (Xv = class extends te.b {
                              get Logger() {
                                return (
                                  this._Logger ||
                                    (this._Logger = i.ModuleContainer.resolve(
                                      q.ZLoggerFactory,
                                    ).createZLogger(hs.ZLoggerNametags.zCloud, [
                                      hs.ZLoggerNametags
                                        .zCloudStatusEventsResolver,
                                    ])),
                                  this._Logger
                                );
                              }
                              get controller() {
                                return i.ModuleContainer.resolve(xv.b);
                              }
                              get cloudDataManager() {
                                return eb.c;
                              }
                              constructor(e) {
                                super(),
                                  (this.zaloCloudConfig = e),
                                  (this.name = void 0),
                                  (this.key = void 0),
                                  (this.msgs = void 0),
                                  (this.convId = void 0),
                                  (this._Logger = void 0),
                                  (this.name = _m.a),
                                  (this.key = _m.a),
                                  (this.msgs = []),
                                  (this.convId = null);
                              }
                              onApplicationReady() {
                                (Object(dm.d)() ||
                                  Object(zv.a)().isEnableBizPCloud()) &&
                                  (this.addPublicZCloudEvents(),
                                  this.addDataCloudListeners(),
                                  Object(zv.a)().isEnableDebugTool() &&
                                    this.addTestListeners());
                              }
                              addTestListeners() {
                                this.addEventListener(
                                  Mm.g.INIT_DATA,
                                  this.handleTestCloudEvents.bind(this),
                                ),
                                  this.addEventListener(
                                    Mm.g.NO_KEY,
                                    this.handleTestCloudEvents.bind(this),
                                  ),
                                  this.addEventListener(
                                    Mm.g.HAVE_KEY,
                                    this.handleTestCloudEvents.bind(this),
                                  ),
                                  this.addEventListener(
                                    Mm.g.NOT_YET_CLOUDED,
                                    this.handleTestCloudEvents.bind(this),
                                  );
                              }
                              addPublicZCloudEvents() {}
                              addDataCloudListeners() {
                                this.cloudDataManager.addListener(
                                  am.c.ADD_OR_UPDATE_CLOUD_ITEMS,
                                  this.handleCloudedItems.bind(this),
                                ),
                                  this.cloudDataManager.addListener(
                                    am.c.TEMP_CLOUD_ITEMS,
                                    this.handleTempCloudItems.bind(this),
                                  ),
                                  this.cloudDataManager.addListener(
                                    am.c.REMOVE_CLOUD_ITEMS,
                                    this.handleCloudRemoveItems.bind(this),
                                  ),
                                  this.cloudDataManager.addListener(
                                    am.c.UPDATE_CLOUD_KEY_STATUS,
                                    this.handleHaveCloudKey.bind(this),
                                  );
                              }
                              async handleTestCloudEvents(e) {
                                const t = {};
                                switch (e.type) {
                                  case Mm.g.INIT_DATA:
                                    for (const s of e.payload) {
                                      t[Object(Qv.h)(s)] = {
                                        personalCloud: Object(f.a)({}, nb),
                                      };
                                    }
                                    this.controller.onUpdatePersonalCloud(t);
                                    break;
                                  case Mm.g.NO_KEY:
                                    for (const s of e.payload) {
                                      t[Object(Qv.h)(s)] = {
                                        personalCloud: Object(f.a)({}, sb),
                                      };
                                    }
                                    this.controller.onUpdatePersonalCloud(t);
                                    break;
                                  case Mm.g.HAVE_KEY:
                                    this.controller.onHandleHaveKey();
                                    break;
                                  case Mm.g.NOT_YET_CLOUDED:
                                    for (const s of e.payload) {
                                      t[Object(Qv.h)(s)] = {
                                        personalCloud: Object(f.a)({}, ib),
                                      };
                                    }
                                    this.controller.onUpdatePersonalCloud(t);
                                }
                              }
                              get openedConv() {
                                return i.ModuleContainer.resolve(
                                  Qs.b,
                                ).getConvId();
                              }
                              handleCloudedItems(e) {
                                if (
                                  !(e = zv.b.filterCloudItemsStatus(
                                    this.openedConv,
                                    e,
                                  )).length
                                )
                                  return;
                                const t = {},
                                  s = this.cloudDataManager.checkUpgraded()
                                    ? null
                                    : { hasInvalidKey: !0 };
                                for (const i of e)
                                  if (i) {
                                    const e = i.msgInfo.isE2EE ? null : s,
                                      n = zv.b.transferCloudItemRes(!0, i, e),
                                      a = Object(Qv.i)(i);
                                    a && n && (t[a] = { personalCloud: n });
                                  }
                                this.controller.onUpdatePersonalCloud(t);
                              }
                              handleTempCloudItems(e) {
                                if (
                                  !(e = zv.b.filterCloudItemsStatus(
                                    this.openedConv,
                                    e,
                                  )).length
                                )
                                  return;
                                const t = {},
                                  s = this.cloudDataManager.checkUpgraded()
                                    ? null
                                    : { hasInvalidKey: !0 };
                                for (const i of e)
                                  if (i) {
                                    const e = i.msgInfo.isE2EE ? null : s,
                                      n = zv.b.transferCloudItemRes(!1, i, e),
                                      a = Object(Qv.i)(i);
                                    a && n && (t[a] = { personalCloud: n });
                                  }
                                this.controller.onUpdatePersonalCloud(t);
                              }
                              handleCloudRemoveItems(e) {
                                const t = {};
                                for (const s of e)
                                  if (s) {
                                    const e = Object(Qv.i)(s);
                                    e && (t[e] = { personalCloud: void 0 });
                                  }
                                this.controller.onUpdatePersonalCloud(t);
                              }
                              handleHaveCloudKey(e) {
                                e &&
                                  (this.Logger.zsymb(
                                    3,
                                    15898,
                                    3e4,
                                    "handleHaveCloudKey",
                                  ),
                                  this.controller.onHandleHaveKey());
                              }
                              bindMsg(e, t) {
                                Object(zv.a)().isEnableDebugTool() &&
                                  ((this.msgs = e), (this.convId = t));
                              }
                              forceInitData(e) {
                                (e = e || this.msgs) &&
                                  0 !== e.length &&
                                  this.convId &&
                                  this.dispatchEvent(
                                    new Mm.b(Mm.g.INIT_DATA, e),
                                  );
                              }
                              forceOffPCloud(e) {
                                this.zaloCloudConfig.onUpdateUsage({
                                  plan: -1,
                                });
                              }
                              forceNoKey(e) {
                                if (
                                  !(e = e || this.msgs) ||
                                  0 === e.length ||
                                  !this.convId
                                )
                                  return;
                                Object(zv.a)().isSend2Me(this.convId) ||
                                  this.dispatchEvent(new Mm.b(Mm.g.NO_KEY, e));
                              }
                              forceHaveKey(e) {
                                if (
                                  !(e = e || this.msgs) ||
                                  0 === e.length ||
                                  !this.convId
                                )
                                  return;
                                Object(zv.a)().isSend2Me(this.convId) ||
                                  this.dispatchEvent(
                                    new Mm.b(Mm.g.HAVE_KEY, e),
                                  );
                              }
                              forceNotYetClouded(e) {
                                (e = e || this.msgs) &&
                                  0 !== e.length &&
                                  this.convId &&
                                  this.dispatchEvent(
                                    new Mm.b(Mm.g.NOT_YET_CLOUDED, e),
                                  );
                              }
                            }),
                          ) || Xv),
                      ) || Xv),
                  ) || Xv),
              ) || Xv),
          ) || Xv;
        var rb,
          ob = s("3+fW");
        let db =
          Object($t.b)(ob.a)(
            (rb =
              Object(i.injectable)()(
                (rb =
                  (function (e, t) {
                    return Object(i.inject)(Vv.a)(e, void 0, 0);
                  })(
                    (rb =
                      Reflect.metadata(
                        "design:type",
                        Function,
                      )(
                        (rb =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === Vv.a ? Object : Vv.a,
                          ])(
                            (rb = class {
                              get Logger() {
                                return (
                                  this._Logger ||
                                    (this._Logger = i.ModuleContainer.resolve(
                                      q.ZLoggerFactory,
                                    ).createZLogger(hs.ZLoggerNametags.zCloud, [
                                      hs.ZLoggerNametags.zCloudStatusController,
                                    ])),
                                  this._Logger
                                );
                              }
                              constructor(e) {
                                (this.name = void 0),
                                  (this.type = void 0),
                                  (this.key = void 0),
                                  (this.data = new Map()),
                                  (this.metrics = void 0),
                                  (this._Logger = void 0),
                                  (this.name = ob.b),
                                  (this.key = ob.b),
                                  (this.metrics = e);
                              }
                              _getState(e) {
                                return this.data.get(e);
                              }
                              setPCloudInfo(e, t) {
                                this.data.set(t, e);
                              }
                              signalUIPCloudInfo(e) {
                                Object(nt.g)(this.name, e);
                              }
                              getListPCloudInfo() {
                                return this.data.entries();
                              }
                              getPCloudBizState(e) {
                                var t, s, i;
                                let n;
                                n = "string" == typeof e ? e : Object(Qv.h)(e);
                                const a = this.data.get(n);
                                return a && a.status
                                  ? {
                                      valid: a.valid,
                                      hasNoKey:
                                        (null === (t = a.error) || void 0 === t
                                          ? void 0
                                          : t.hasNoKey) || !1,
                                      isClouded:
                                        null === (s = a.status) || void 0 === s
                                          ? void 0
                                          : s.isClouded,
                                      isUncloud:
                                        null === (i = a.status) || void 0 === i
                                          ? void 0
                                          : i.isUncloud,
                                      error: a.error,
                                      isFreeCloudItem: a.isFreeCloudItem,
                                    }
                                  : null;
                              }
                              getPCloudInfo(e) {
                                let t;
                                return (
                                  (t =
                                    "string" == typeof e ? e : Object(Qv.h)(e)),
                                  this._getState(t)
                                );
                              }
                              getItem(e) {
                                return this._getState(e.key);
                              }
                              init(e) {
                                throw new Error("Method not implemented.");
                              }
                              getList(e, t) {
                                throw new Error("Method not implemented.");
                              }
                              onGetItemFailure(e, t) {
                                throw new Error("Method not implemented.");
                              }
                              onGetListFailure(e, t) {
                                throw new Error("Method not implemented.");
                              }
                              getDefaultItem() {
                                throw new Error("Method not implemented.");
                              }
                              getDefaultList() {
                                throw new Error("Method not implemented.");
                              }
                            }),
                          ) || rb),
                      ) || rb),
                  ) || rb),
              ) || rb),
          ) || rb;
        const lb = "zcloud-repository",
          cb = Object(i.define)(lb);
        var hb;
        let ub =
          Object(i.injectable)()(
            (hb =
              Reflect.metadata(
                "design:type",
                Function,
              )(
                (hb =
                  Reflect.metadata(
                    "design:paramtypes",
                    [],
                  )(
                    (hb = class {
                      get Logger() {
                        return (
                          this._Logger ||
                            (this._Logger = i.ModuleContainer.resolve(
                              q.ZLoggerFactory,
                            ).createZLogger(hs.ZLoggerNametags.zCloud, [
                              hs.ZLoggerNametags.zCloudStatusRepository,
                            ])),
                          this._Logger
                        );
                      }
                      constructor() {
                        (this.name = void 0),
                          (this.key = void 0),
                          (this._Logger = void 0),
                          (this.name = lb),
                          (this.key = lb);
                      }
                      get cloudDataManager() {
                        return eb.c;
                      }
                      getZCloudList(e, t) {
                        return 0 === t.length
                          ? Promise.resolve({
                              cloudedItems: [],
                              tempCloudItems: [],
                            })
                          : new Promise((e) => {
                              this.cloudDataManager
                                .getCloudItems(t)
                                .then((s) => {
                                  let i = [];
                                  for (const e of s) e && i.push(e);
                                  const n = i,
                                    a = n.map((e) => Object(Qv.i)(e)),
                                    r = t.filter(
                                      (e) => !a.includes(Object(Qv.h)(e)),
                                    );
                                  e({ cloudedItems: n, tempCloudItems: r });
                                })
                                .catch((t) => {
                                  this.Logger.zsymb(
                                    3,
                                    15227,
                                    3e4,
                                    "getZCloudList, err:",
                                    t,
                                  ),
                                    e({ cloudedItems: [], tempCloudItems: [] });
                                });
                            });
                      }
                    }),
                  ) || hb),
              ) || hb),
          ) || hb;
        var gb;
        let mb =
          Object(i.injectable)()(
            (gb =
              (function (e, t) {
                return Object(i.inject)(Vv.a)(e, void 0, 0);
              })(
                (gb =
                  (function (e, t) {
                    return Object(i.inject)(ob.a)(e, void 0, 1);
                  })(
                    (gb =
                      (function (e, t) {
                        return Object(i.inject)(_m.b)(e, void 0, 2);
                      })(
                        (gb =
                          (function (e, t) {
                            return Object(i.inject)(cb)(e, void 0, 3);
                          })(
                            (gb =
                              Reflect.metadata(
                                "design:type",
                                Function,
                              )(
                                (gb =
                                  Reflect.metadata("design:paramtypes", [
                                    void 0 === Vv.a ? Object : Vv.a,
                                    void 0 === ob.a ? Object : ob.a,
                                    void 0 === _m.b ? Object : _m.b,
                                    void 0 === cb ? Object : cb,
                                  ])(
                                    (gb = class {
                                      get Logger() {
                                        return (
                                          this._Logger ||
                                            (this._Logger =
                                              i.ModuleContainer.resolve(
                                                q.ZLoggerFactory,
                                              ).createZLogger(
                                                hs.ZLoggerNametags.zCloud,
                                                [
                                                  hs.ZLoggerNametags
                                                    .zCloudStatusServices,
                                                ],
                                              )),
                                          this._Logger
                                        );
                                      }
                                      get cloudDataManager() {
                                        return eb.c;
                                      }
                                      constructor(e, t, s, i) {
                                        (this.name = void 0),
                                          (this.key = void 0),
                                          (this.metrics = void 0),
                                          (this.zCloudInfo = void 0),
                                          (this.eventsResolver = void 0),
                                          (this.zCloudStatusRepository =
                                            void 0),
                                          (this._Logger = void 0),
                                          (this.name = Hv),
                                          (this.key = Hv),
                                          (this.metrics = e),
                                          (this.zCloudInfo = t),
                                          (this.eventsResolver = s),
                                          (this.zCloudStatusRepository = i);
                                      }
                                      async getInitPCloudUpdate(e, t) {
                                        const s = {},
                                          {
                                            cloudedItems: i,
                                            tempCloudItems: n,
                                          } =
                                            await this.zCloudStatusRepository.getZCloudList(
                                              t,
                                              e,
                                            ),
                                          a =
                                            this.cloudDataManager.checkUpgraded()
                                              ? null
                                              : { hasInvalidKey: !0 };
                                        for (const r of i) {
                                          const e = r.msgInfo.isE2EE ? null : a,
                                            t = Object(Qv.i)(r);
                                          if (
                                            !this.zCloudInfo.getPCloudInfo(t) &&
                                            t
                                          ) {
                                            const i = zv.b.transferCloudItemRes(
                                              !0,
                                              r,
                                              e,
                                            );
                                            i && (s[t] = { personalCloud: i });
                                          }
                                        }
                                        for (const r of n) {
                                          const e = xi.b.isMsgE2ee(r)
                                              ? null
                                              : a,
                                            t = Object(Qv.h)(r);
                                          if (
                                            !this.zCloudInfo.getPCloudInfo(t) &&
                                            t
                                          ) {
                                            const i = zv.b.transferCloudItemRes(
                                              !1,
                                              r,
                                              e,
                                            );
                                            i && (s[t] = { personalCloud: i });
                                          }
                                        }
                                        return Promise.resolve(s);
                                      }
                                      syncCachePCloudInfo(e) {
                                        for (const t in e) {
                                          const s = e[t].personalCloud;
                                          this.zCloudInfo.setPCloudInfo(s, t);
                                        }
                                      }
                                      signalUIPCloudInfo(e) {
                                        for (const t in e)
                                          this.zCloudInfo.signalUIPCloudInfo(t);
                                      }
                                      syncMediaStatus(e) {
                                        if (
                                          !i.ModuleContainer.resolve(
                                            Qs.b,
                                          ).getConvId()
                                        )
                                          return void this.Logger.zsymb(
                                            3,
                                            15224,
                                            3e4,
                                            "syncMediaStatus: MediaStatus Calculator is not initilized to synup",
                                          );
                                        const t =
                                          this.zCloudInfo.getListPCloudInfo();
                                        for (let [s, i] of t) {
                                          if (!s || !e.includes(s)) continue;
                                          const t = Object(Qv.e)(s);
                                          t &&
                                            Hu.a
                                              .status(t, [], !0)
                                              .then(() => {})
                                              .catch(() => {});
                                        }
                                      }
                                      shareUpdatePCloudAction(e) {
                                        this.eventsResolver.dispatchEvent(
                                          new Mm.b(Mm.a.UPDATE_STATUS, e),
                                        );
                                      }
                                      createEmptyPCloudUpdate() {
                                        const e = {},
                                          t =
                                            this.zCloudInfo.getListPCloudInfo();
                                        for (let [s, i] of t)
                                          s &&
                                            i &&
                                            (i.isFreeCloudItem ||
                                              (e[s] = {
                                                personalCloud: void 0,
                                              }));
                                        return e;
                                      }
                                    }),
                                  ) || gb),
                              ) || gb),
                          ) || gb),
                      ) || gb),
                  ) || gb),
              ) || gb),
          ) || gb;
        var pb;
        let fb =
          Object(i.injectable)()(
            (pb =
              (function (e, t) {
                return Object(i.inject)(Vv.a)(e, void 0, 0);
              })(
                (pb =
                  (function (e, t) {
                    return Object(i.inject)(ob.a)(e, void 0, 1);
                  })(
                    (pb =
                      (function (e, t) {
                        return Object(i.inject)(_m.b)(e, void 0, 2);
                      })(
                        (pb =
                          Reflect.metadata(
                            "design:type",
                            Function,
                          )(
                            (pb =
                              Reflect.metadata("design:paramtypes", [
                                void 0 === Vv.a ? Object : Vv.a,
                                void 0 === ob.a ? Object : ob.a,
                                void 0 === _m.b ? Object : _m.b,
                              ])(
                                (pb = class {
                                  get Logger() {
                                    return (
                                      this._Logger ||
                                        (this._Logger =
                                          i.ModuleContainer.resolve(
                                            q.ZLoggerFactory,
                                          ).createZLogger(
                                            hs.ZLoggerNametags.zCloud,
                                            [
                                              hs.ZLoggerNametags
                                                .zCloudKeyServices,
                                            ],
                                          )),
                                      this._Logger
                                    );
                                  }
                                  get cloudDataManager() {
                                    return eb.c;
                                  }
                                  constructor(e, t, s) {
                                    (this.metrics = e),
                                      (this.zCloudInfo = t),
                                      (this.eventsResolver = s),
                                      (this.name = void 0),
                                      (this.key = void 0),
                                      (this._Logger = void 0),
                                      (this.name = Wv),
                                      (this.key = Wv);
                                  }
                                  removeRSAKey() {
                                    this.cloudDataManager.checkUpgraded() &&
                                      this.cloudDataManager.removeKey();
                                  }
                                  requestRSAKey(e) {
                                    this.cloudDataManager.checkUpgraded() ||
                                      ((e !== Mm.c.LOGIN &&
                                        e !== Mm.c.CHANGE_PLAN) ||
                                        (this.cloudDataManager.updateZCloudKey(
                                          !1,
                                          e,
                                        ),
                                        this.metrics.onAutoRequestKey()),
                                      e === Mm.c.RETRY &&
                                        (this.cloudDataManager.updateZCloudKey(
                                          !0,
                                          e,
                                        ),
                                        this.metrics.onManualRequestKey()));
                                  }
                                  checkPCloudWithoutKey(e) {
                                    var t;
                                    const s = this.zCloudInfo.getPCloudInfo(e);
                                    return Boolean(
                                      null == s ||
                                        null === (t = s.error) ||
                                        void 0 === t
                                        ? void 0
                                        : t.hasNoKey,
                                    );
                                  }
                                  createPCloudUpdateWithValidRSAKey() {
                                    const e = {},
                                      t = this.zCloudInfo.getListPCloudInfo();
                                    for (let [s, i] of t) {
                                      if (!s || !i) continue;
                                      if (i.isFreeCloudItem) continue;
                                      const t = Object(f.a)(
                                          Object(f.a)({}, i.error),
                                          {},
                                          { hasNoKey: !1 },
                                        ),
                                        n = i.status,
                                        a = {
                                          valid: zv.b.checkValidFromBizState(
                                            t,
                                            n,
                                          ),
                                          status: n,
                                          error: t,
                                        };
                                      e[s] = { personalCloud: a };
                                    }
                                    return e;
                                  }
                                  shareHaveKeyPCloudAction(e) {
                                    this.eventsResolver.dispatchEvent(
                                      new Mm.b(Mm.a.HAVE_KEY, e),
                                    );
                                  }
                                  showToastWarningNoKey(e) {
                                    const {
                                        showNoti: t = !0,
                                        windowId: s = Qt.c,
                                        type: i = "file",
                                      } = e,
                                      n =
                                        Lc.ZToastManagerHolder.getZToastManagerByWindowId(
                                          s,
                                        );
                                    t &&
                                      n.show({
                                        noBackground: !0,
                                        textKey:
                                          "STR_PERSONAL_CLOUD_NO_KEY_TOAST",
                                        textArguments: [Object(zv.d)(i), "\n"],
                                        type: Lc.TOAST_TYPE.INFO,
                                        duration: 3e3,
                                        styles: { width: "400px" },
                                        styleText: { whiteSpace: "pre-line" },
                                      });
                                  }
                                }),
                              ) || pb),
                          ) || pb),
                      ) || pb),
                  ) || pb),
              ) || pb),
          ) || pb;
        var vb;
        let bb =
          Object(i.injectable)()(
            (vb =
              (function (e, t) {
                return Object(i.inject)(_m.b)(e, void 0, 0);
              })(
                (vb =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (vb =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === _m.b ? Object : _m.b,
                      ])(
                        (vb = class {
                          constructor(e) {
                            (this.eventsResolver = e),
                              (this.name = void 0),
                              (this.key = void 0),
                              (this.name = qv),
                              (this.key = qv);
                          }
                          shareUpgradePlanEvent(e) {
                            this.eventsResolver.dispatchEvent(
                              new Mm.b(Mm.a.UPGRADE_ZCLOUD_PLAN, e || {}),
                            );
                          }
                          shareOffPlanEvent(e) {
                            this.eventsResolver.dispatchEvent(
                              new Mm.b(Mm.a.OFF_PERSONAL_CLOUD_PLAN, e || {}),
                            );
                          }
                        }),
                      ) || vb),
                  ) || vb),
              ) || vb),
          ) || vb;
        var Ib = s("MNOV");
        i.ModuleContainer.registerSingleton(xv.b, Yv),
          i.ModuleContainer.registerSingleton(_m.b, ab),
          i.ModuleContainer.registerSingleton(ob.a, db),
          i.ModuleContainer.registerSingleton(cb, ub),
          i.ModuleContainer.registerSingleton($v, mb),
          i.ModuleContainer.registerSingleton(Kv, fb),
          i.ModuleContainer.registerSingleton(Zv, bb),
          i.ModuleContainer.registerSingleton(Vv.a, Vv.b),
          i.ModuleContainer.registerSingleton(Ib.a, Ib.b),
          i.ModuleContainer.registerSingleton(tb.a, tb.b);
        var yb = s("hmll"),
          _b = s("NL/6");
        const Ob = [
          {
            chord: `${R.CmdOrCtrl}${R.K_I}`,
            commandId: _b.a.FOCUS_MAIN_CHAT_INPUT_AT_ACTIVE_WINDOW,
            commandTitle: "",
            isMatchedContext: (e, t) => !0,
          },
          {
            chord: `${R.CmdOrCtrl}${R.K_I}`,
            commandId: _b.a.APPLY_ITALIC_STYLE_FOR_SELECTED_TEXT,
            commandTitle: "",
            isMatchedContext: (e, t) => !0,
          },
          {
            chord: `${R.CmdOrCtrl}${R.K_B}`,
            commandId: _b.a.APPLY_BOLD_STYLE_FOR_SELECTED_TEXT,
            commandTitle: "",
            isMatchedContext: (e, t) => !0,
          },
          {
            chord: `${R.CmdOrCtrl}${R.K_U}`,
            commandId: _b.a.APPLY_UNDERLINE_STYLE_FOR_SELECTED_TEXT,
            commandTitle: "",
            isMatchedContext: (e, t) => !0,
          },
          {
            chord: `${R.CmdOrCtrl}${R.Shift}${R.K_X}`,
            commandId: _b.a.TOGGLE_RTF_MODE,
            commandTitle: "",
            isMatchedContext: (e, t) => !0,
          },
        ];
        i.ModuleContainer.register(
          yb.a,
          class {
            constructor() {
              (this._keybindings = []),
                Ob.forEach((e) => {
                  this._keybindings.push({
                    chord: e.chord,
                    commandId: e.commandId,
                    commandTitle: e.commandTitle,
                    isMatchedContext: e.isMatchedContext,
                    eventHandlers: [],
                  });
                });
            }
            registerEventHandlerByCommandId(e, t) {
              return e && t
                ? (this._keybindings.forEach((s) => {
                    s.commandId !== e ||
                      s.eventHandlers.includes(t) ||
                      s.eventHandlers.push(t);
                  }),
                  () => {
                    this._keybindings.forEach((s) => {
                      s.commandId === e &&
                        s.eventHandlers.includes(t) &&
                        (s.eventHandlers = s.eventHandlers.filter(
                          (e) => e !== t,
                        ));
                    });
                  })
                : () => {};
            }
            loopkupKeybindingByCommandId(e) {
              return e
                ? this._keybindings.reduce(
                    (t, s) => (e === s.commandId && t.push(s), t),
                    [],
                  )
                : [];
            }
            loopkupKeybindingByChord(e) {
              return e
                ? this._keybindings.reduce(
                    (t, s) => (e === s.chord && t.push(s), t),
                    [],
                  )
                : [];
            }
          },
        );
        var Cb = s("XRso"),
          Eb = s("Xt6Q");
        i.ModuleContainer.register(
          Cb.a,
          class {
            buildChord(e) {
              let t = "";
              return (
                e &&
                  this._isChord(e) &&
                  ((e.ctrlKey || e.metaKey) && (t += R.CmdOrCtrl),
                  e.shiftKey && (t += R.Shift),
                  e.altKey && (t += R.Alt),
                  (t += e.keyCode || e.which)),
                t
              );
            }
            buildKeybindingContext(e, t) {
              return e && t ? `${e}#${t}` : "";
            }
            getChordByCommandId(e) {
              return e === _b.a.TOGGLE_RTF_MODE
                ? (Object(Eb.c)() ? "Cmd" : "Ctrl") + " + Shift + X"
                : "";
            }
            _isOnlyModifier(e) {
              return ["Shift", "Control", "Alt", "Meta"].includes(e.key);
            }
            _isOnlyNonModifier(e) {
              return !(e.ctrlKey || e.metaKey || e.shiftKey || e.altKey);
            }
            _isChord(e) {
              return !(this._isOnlyModifier(e) || this._isOnlyNonModifier(e));
            }
          },
        );
        var Mb = s("GNMY"),
          Sb = s("sGG0");
        var Tb,
          wb = s("72EQ"),
          Rb = s("v+vz"),
          Lb = s("F1+M"),
          Db = s("XbxG"),
          Fb = s("U/XY"),
          Ab = s("1PLK");
        function jb() {
          if (!bt.default.profile.cover.randomUrls.length) return "";
          const { randomUrls: e } = bt.default.profile.cover;
          return e[Math.floor(Math.random() * e.length)];
        }
        Object($t.b)(Mb.a)(
          (Tb =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (Tb =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (Tb = class {
                    constructor() {
                      (this.name = Mb.b),
                        (this.key = "convId"),
                        (this.didInit = !1),
                        (this.data = void 0),
                        (this._cachedFriendRequest = {}),
                        (this._dispatch = void 0),
                        (this._genMessageServer = void 0),
                        (this._randomCoverSrc = jb()),
                        (this._logger = void 0),
                        (this.type = void 0),
                        (this.data = new Map());
                    }
                    get Logger() {
                      return (
                        this._logger ||
                          (this._logger = i.ModuleContainer.resolve(
                            q.ZLoggerFactory,
                          ).createZLogger(this.name, ["personal-controller"])),
                        this._logger
                      );
                    }
                    init(e) {
                      this.didInit ||
                        (this._fetchReceiveFriendList(),
                        i.ModuleContainer.resolve(qn.n).addEventListener(
                          qn.m.ReceiveAddFriendEvent,
                          this.invitationEventHandler.bind(this),
                        ),
                        i.ModuleContainer.resolve(qn.n).addEventListener(
                          qn.m.UndoAddFriendEvent,
                          this.invitationEventHandler.bind(this),
                        ),
                        i.ModuleContainer.resolve(qn.n).addEventListener(
                          qn.m.AcceptAddFriendEvent,
                          this.invitationEventHandler.bind(this),
                        ),
                        i.ModuleContainer.resolve(qn.n).addEventListener(
                          qn.m.RejectAddFriendEvent,
                          this.invitationEventHandler.bind(this),
                        ),
                        i.ModuleContainer.resolve(qn.n).addEventListener(
                          qn.m.UndoSentRequestFriendEvent,
                          this.invitationEventHandler.bind(this),
                        ),
                        (this.didInit = !0));
                    }
                    bindDispatch(e) {
                      (this._dispatch = e),
                        Mt.default.subscribe(this.eventHandler.bind(this)),
                        (this._randomCoverSrc = jb());
                    }
                    unbind() {
                      (this._dispatch = null),
                        (this._genMessageServer = null),
                        this.data.clear(),
                        Mt.default.unsubscribe(this.eventHandler);
                    }
                    dispatch(e) {
                      this._dispatch
                        ? this._dispatch(e)
                        : this.Logger.zsymb(0, 14799, 3e4, "Lost dispatch");
                    }
                    bindGenMessageServer(e) {
                      this._genMessageServer = e;
                    }
                    clearState(e) {
                      this.data.has(e) && this.data.delete(e);
                    }
                    _signalUpdate(e) {
                      Object(nt.g)(Mb.b, e);
                    }
                    _updateData(e, t, s) {
                      const i = this.data.get(e);
                      i
                        ? this.data.set(
                            e,
                            Object(f.a)(
                              Object(f.a)({}, i),
                              {},
                              {
                                [t]:
                                  i && i[t] ? Ct.default.deepMerge(i[t], s) : s,
                              },
                            ),
                          )
                        : this.data.set(e, { [t]: s, version: 0 }),
                        this._signalUpdate(e);
                    }
                    _udapteInfoData(e, t) {
                      var s;
                      const i = this.data.get(e);
                      return (
                        null != i &&
                          null !== (s = i.info) &&
                          void 0 !== s &&
                          s.avatar &&
                          (t.avatar = i.info.avatar),
                        this._updateData(e, "info", t)
                      );
                    }
                    _updateVersion(e) {
                      const t = this.data.get(e);
                      t
                        ? this.data.set(
                            e,
                            Object(f.a)(
                              Object(f.a)({}, t),
                              {},
                              { version: t.version + 1 },
                            ),
                          )
                        : this.data.set(e, { version: 0 }),
                        this._signalUpdate(e);
                    }
                    getCover(e) {
                      var t;
                      const s =
                        null === (t = this.data.get(e)) || void 0 === t
                          ? void 0
                          : t.info;
                      if (s) {
                        const e = s.cover;
                        return e && e == bt.default.profile.cover.defaultUrl
                          ? this._randomCoverSrc ||
                              bt.default.profile.cover.defaultUrl
                          : e;
                      }
                      return (
                        this._randomCoverSrc ||
                        bt.default.profile.cover.defaultUrl
                      );
                    }
                    async getUserInfo(e, t) {
                      void 0 === t && (t = !1);
                      const s = Object(f.a)(
                        {},
                        Ye.default.getProfileFriendByIdSync(e),
                      );
                      this._udapteInfoData(e, s);
                      const i = async () => {
                        try {
                          const t = await Ye.default.getProfileFriendById(
                            e,
                            R.SRC_GET_PROFILE.FORCE_GET,
                          );
                          return (
                            Ye.default.isFriend(e) ||
                              this.getStatusFriendRequest(e),
                            t &&
                              (Rb.y(e) &&
                                Mt.default.send(
                                  St.FetchActions.UDPATE_BUSINESS_INFO,
                                  { user: t },
                                ),
                              this._udapteInfoData(e, t)),
                            this.getFullAvatar(e),
                            t
                          );
                        } catch (t) {
                          return (
                            this.Logger.zsymb(
                              0,
                              14799,
                              30001,
                              "[getUserInfo]",
                              t,
                            ),
                            Ye.default.getProfileFriendByIdSync(e)
                          );
                        }
                      };
                      return t ||
                        !this.data.has(e) ||
                        !s ||
                        Object.keys(s).length <= 4
                        ? i()
                        : s;
                    }
                    async getExtraInfo(e) {
                      try {
                        const t = await zn.a.getProfileExtra(
                          e,
                          Ye.default.getUidMe(),
                        );
                        if (t) {
                          const s = ((e) => {
                            const t = e.photos
                              ? e.photos.map((t, s) => ({
                                  url: t,
                                  meta: e.photoMetas && e.photoMetas[s],
                                }))
                              : [];
                            let s = [];
                            return (
                              e.groupIds &&
                                e.groupIds.length > 0 &&
                                e.groupIds.forEach((e) => {
                                  Jt.a.checkHiddenChatByPureGroupId(e) ||
                                    s.push(e);
                                }),
                              { mutualGroups: s, photos: t }
                            );
                          })(t);
                          return (
                            this._updateData(e, "extra", s),
                            !0 === t.fetched &&
                              this.dispatch({
                                type: St.ConversationListActions
                                  .FORCE_UPDATE_MUTUAL_GROUP_ITEM,
                                payload: e,
                              }),
                            s
                          );
                        }
                      } catch (s) {
                        var t;
                        this.Logger.zsymb(0, 14799, 30002, "[getExtraInfo]", s),
                          this._updateData(
                            e,
                            "extra",
                            (null === (t = this.data.get(e)) || void 0 === t
                              ? void 0
                              : t.extra) || {},
                          );
                      }
                      return null;
                    }
                    async getFullAvatar(e, t) {
                      void 0 === t && (t = !1);
                      const s = (t) => {
                          this._updateData(e, "info", { avatar: t });
                        },
                        i = async () => {
                          try {
                            const t = await Rb.k(e);
                            t && s(t.full_avatar);
                          } catch (t) {
                            if (
                              (this.Logger.zsymb(
                                18,
                                14799,
                                30003,
                                "fetch full avatar error:",
                                t,
                              ),
                              n)
                            ) {
                              if (Ct.default.isWeb()) {
                                let e = n.url;
                                return e && s(e), e;
                              }
                              {
                                let e = n.path;
                                if (await Object(wb.a)(e))
                                  return s("file://" + e), "file://" + e;
                              }
                            }
                          }
                        };
                      let n = Ee.default.getProfileAvatar(e);
                      if (t || !n) return i();
                      {
                        let e = n.ts;
                        if (Date.now() - 3e5 > e) return i();
                        if (Ct.default.isWeb()) {
                          let e = n.url;
                          return s(e), e;
                        }
                        {
                          let e = n.path;
                          Object(wb.a)(e).then((t) =>
                            t ? (s("file://" + e), "file://" + e) : i(),
                          );
                        }
                      }
                    }
                    async getProfileRank(e) {
                      try {
                        const t = await zn.a.getProfileRank(
                          e,
                          Ye.default.getUidMe(),
                        );
                        return this._updateData(e, "rank", t), t;
                      } catch (s) {
                        var t;
                        this.Logger.zsymb(
                          0,
                          14799,
                          30004,
                          "[getProfileRank]",
                          s,
                        ),
                          this._updateData(
                            e,
                            "rank",
                            (null === (t = this.data.get(e)) || void 0 === t
                              ? void 0
                              : t.rank) || {},
                          );
                      }
                      return null;
                    }
                    async getStatusFriendRequest(e) {
                      const t = async () => {
                        try {
                          await qs.a.getStatusFriendRequest(e, !1);
                        } catch (t) {}
                      };
                      let s = Q.p.getFriendRequestStatus(e);
                      if (s) {
                        let e = s.ts;
                        e && e > -1 && e < Date.now() - 2e3 && t();
                      } else t();
                    }
                    async _fetchReceiveFriendList(e) {
                      void 0 === e && (e = !1);
                      let t = Vn.a.getRecommendedFriendsSync();
                      if (!Object.keys(t).length || e)
                        try {
                          t = await Vn.a.getRecommendedFriendsV2(!0, !0);
                        } catch (i) {
                          this.Logger.zsymb(
                            0,
                            14799,
                            30005,
                            "_fetchReceiveFriendList [ERROR]",
                            t,
                          );
                        }
                      const s = Object.keys(t);
                      s.length &&
                        s.forEach((e) => {
                          var s, i, n;
                          (null === (s = t[e]) ||
                          void 0 === s ||
                          null === (i = s.dataInfo) ||
                          void 0 === i
                            ? void 0
                            : i.recommType) === ua.RECEIVE &&
                            (this._cachedFriendRequest[e] =
                              null === (n = t[e]) || void 0 === n
                                ? void 0
                                : n.dataInfo);
                        });
                    }
                    getRequestInfo(e) {
                      return this._cachedFriendRequest[e];
                    }
                    async toggleBlock(e, t) {
                      var s;
                      const i = this.data.get(e),
                        n =
                          (null == i || null === (s = i.info) || void 0 === s
                            ? void 0
                            : s.isBlocked) || Ye.default.isBlocked(e);
                      Xe.e.logAction(1460207);
                      try {
                        const s = await Ye.default.blockFriend(
                          e,
                          n ? R.UNSET_BLOCK : R.SET_BLOCK,
                        );
                        return (
                          Fb.c(
                            t,
                            n
                              ? "STR_UNBLOCK_USER_TOAST_SUCCESS"
                              : "STR_BLOCK_USER_TOAST_SUCCESS",
                          ),
                          i && this._updateData(e, "info", { isBlocked: !n }),
                          n || Xe.e.logAction(146020701),
                          this.dispatch({
                            type: St.ConversationListActions.BLOCK_CONVERSATION,
                            payload: { blocked: !n, userId: e },
                          }),
                          s
                        );
                      } catch (a) {
                        this.Logger.zsymb(18, 14799, 30006, "toggleBlock", a),
                          Fb.c(
                            t,
                            n
                              ? "STR_UNBLOCK_USER_TOAST_FAIL"
                              : "STR_BLOCK_USER_TOAST_FAIL",
                          );
                      }
                    }
                    async toggleRemoveFriend(e, t) {
                      Xe.e.logAction(1460206);
                      try {
                        const s = await Rb.B(e);
                        return (
                          Ee.default.removeNewFriend(e),
                          Ee.default.removeFriend(e).then((t) => {
                            Mt.default.send(
                              St.PopupActions.TOGGLE_REMOVE_FRIEND,
                              e,
                            );
                          }),
                          this.dispatch({
                            type: St.FetchActions.FRIENDS_REMOVED,
                            payload: e,
                          }),
                          Fb.c(t, "STR_DELETE_SUCCESS"),
                          s
                        );
                      } catch (s) {
                        this.Logger.zsymb(
                          18,
                          14799,
                          30007,
                          "toggleRemoveFriend",
                          s,
                        );
                      }
                    }
                    async toggleShareContact(e, t) {
                      const s = this.data.get(e),
                        i = await Object(Lb.c)([e]);
                      Xe.e.logAction(1460205);
                      let n = "",
                        a = "";
                      s &&
                        s.info &&
                        ((n = s.info.avatar), (a = s.info.displayName));
                      let r = {
                        message: {
                          action: "recommened.user",
                          description: JSON.stringify({ qrCodeUrl: i[e] }),
                          params: e,
                          thumb: n,
                          title: a,
                        },
                        msgType: R.MSG_CONTACT,
                        windowId: t,
                      };
                      Mt.default.send(St.PopupActions.SHARE_MSG, r);
                    }
                    showImage(e, t, s) {
                      var i;
                      void 0 === s && (s = Cv.i.ProfileAvatar);
                      let n =
                        null === (i = this.data.get(e)) || void 0 === i
                          ? void 0
                          : i.info;
                      if (!n) return;
                      const a = {
                        user: Ye.default.getProfileMeSync(),
                        userId: e,
                        conversation: Object(f.a)({}, n),
                        isVideo: !1,
                        selectedId: null,
                        isProfileImg: !0,
                        href: t,
                        appConfig: Object(bt.getPVConfigs)(),
                        source: s,
                      };
                      Ct.default.isWeb() ||
                        (a.appConfig = {
                          enable_feature_alias: bt.default.enable_feature_alias,
                          enable_stranger_alias:
                            bt.default.enable_stranger_alias,
                        }),
                        Pt.a.OpenPhoto.openPhotoViewer(a);
                    }
                    voiceCall(e, t) {
                      const s = this.data.get(e);
                      if (
                        (Xe.e.logAction(10643),
                        Xe.e.logActionInfo(Xe.b.BusinessAccount, 1460203, [
                          e,
                          Ye.default.isFriend(e) ? 0 : 1,
                        ]),
                        !ii.c.isSupport() || null == s || !s.info)
                      )
                        return;
                      if (ii.c.isCalling())
                        return void Fb.b(
                          t,
                          void 0,
                          tt.default.trans(ii.b.IN_CALL),
                        );
                      const i = s.info;
                      var n;
                      Ct.default.isWeb() ||
                        ((n = e), Ee.default.getConversation(n)).then((t) => {
                          let s = {
                              lastSmsLocalId: t ? t.lastSmsLocalId : null,
                              displayName: i.displayName,
                              userId: e,
                            },
                            n = [s.userId];
                          ii.c.makeCall(n, !1, !1, (e) => {
                            this._genMessageServer &&
                              this._genMessageServer(s, e),
                              e.caller &&
                                e.duration > 0 &&
                                Db.b.updateLastActionTime(
                                  s.userId,
                                  this.dispatch,
                                  -1,
                                  Db.a.CALL,
                                );
                          });
                        });
                    }
                    jumpToConversation(e) {
                      let t = this.data.get(e);
                      if (!t || !t.info) return;
                      i.ModuleContainer.resolve(rs.b).openConversation(
                        e,
                        rs.c.fromProfileInfo(t.info),
                      );
                      const s = Ye.default.isFriend(e);
                      Xe.e.logActionInfo(Xe.b.BusinessAccount, 1460204, [
                        e,
                        s ? 1 : 0,
                      ]),
                        Je.ModalManagerV2.closeAllModal();
                    }
                    async undoFriendRequest(e) {
                      Xe.e.logAction(146020802);
                      try {
                        return (
                          await qs.a.undoRequestAddFriend(e),
                          i.ModuleContainer.resolve(qn.n).dispatchEvent(
                            new qn.o(qn.m.UndoSentRequestFriendEvent, null, e),
                          ),
                          this.getUserInfo(e),
                          !0
                        );
                      } catch (t) {
                        t && t.error_message && Fb.a(t.error_message);
                      }
                      return !1;
                    }
                    async addFriend(e, t) {
                      const s = this.data.get(e);
                      return (
                        !(!s || !s.info || s.info.isBlocked) &&
                        (qs.a.isYouRequestMe(e)
                          ? (Xe.e.logAction(146020801),
                            i.ModuleContainer.resolve(Gn.b).acceptFriendRequest(
                              e,
                              t,
                            ),
                            Ee.default.getAcceptNewFriend(s))
                          : Xe.e.logAction(1460208),
                        !0)
                      );
                    }
                    async sendFriendRequest(e, t, s, i) {
                      const n = qs.a.getFriendRequestSource(e);
                      try {
                        await qs.a.requestAddFriend(e, s, n),
                          this.dispatch({
                            type: St.ChatBoxActions.SEND_FRIEND_REQUEST,
                            payload: e,
                          }),
                          Mt.default.send(
                            St.SideBarActions.SENT_FRIEND_REQUEST,
                            e,
                          ),
                          Fb.c(t, "STR_REQ_FR_SUCCESS"),
                          Ee.default.setStrangerCache(e, 1),
                          Sb.a.callUpdate(e, i);
                      } catch (a) {
                        this.Logger.zsymb(
                          18,
                          14799,
                          30008,
                          "sendFriendRequest",
                          a,
                        ),
                          a && a.error_message && Fb.a(t, a.error_message),
                          Ee.default.setStrangerCache(e, 0);
                      }
                    }
                    openLink(e) {
                      Ab.b.open(e);
                    }
                    eventHandler(e, t) {
                      switch (e) {
                        case St.FetchActions.STATUS_BLOCKED_CHANGED:
                          if (t) {
                            this.data.has(t) &&
                              this._updateData(t, "info", {
                                isBlocked: Ye.default.isBlocked(t),
                              });
                          }
                          break;
                        case St.FetchActions.UPDATE_NAME:
                          if (t)
                            if (t.constructor === Object) {
                              this.data.has(t.userId) &&
                                this.getUserInfo(t.userId);
                            } else if (t.constructor === Array)
                              for (const [e, s] of Object.entries(this.data)) {
                                t.includes(e) && this.getUserInfo(e);
                              }
                          break;
                        case St.FetchActions.USERID_FETCHED:
                        case St.FetchActions.PROFILE_ME_FETCHED: {
                          const e = Ye.default.getUidMe();
                          t &&
                            this._udapteInfoData(
                              e,
                              Object(f.a)(
                                Object(f.a)({}, t),
                                {},
                                { isBlocked: !1, isFr: !0 },
                              ),
                            ),
                            this.data.has(t.userId) &&
                              this.getFullAvatar(t.userId, !0);
                          break;
                        }
                        case St.FetchActions.FRIEND_REQUEST_UPDATE:
                          t &&
                            this.data.has(t.userId) &&
                            this._updateVersion(t.userId);
                          break;
                        case St.ConversationListActions.BLOCK_CONVERSATION:
                          t &&
                            this.data.has(t.userId) &&
                            this._updateData(t.userId, "info", {
                              isBlocked: t.blocked,
                            });
                          break;
                        case St.FriendListActions.UPDATE_EXTRA_PROFILE_CACHE:
                          t &&
                            t.userId &&
                            this.data.has(t.userId) &&
                            this.getExtraInfo(t.userId);
                          break;
                        case St.GeneralActions.NETWORK_STATUS_CHANGED:
                          break;
                        case St.FriendsAction.FRIENDS_CHANGE_INFO:
                          if (t)
                            for (const e of t)
                              this.data.has(e.userId) &&
                                this.getUserInfo(e.userId);
                      }
                    }
                    invitationEventHandler(e) {
                      switch (e.type) {
                        case qn.m.ReceiveAddFriendEvent:
                          Array.isArray(e.payload) &&
                            e.payload.forEach((e) => {
                              const t = e.dataInfo.userId;
                              e &&
                                e.dataInfo &&
                                ((this._cachedFriendRequest[t] = e.dataInfo),
                                this.data.has(t) && this._updateVersion(t));
                            });
                          break;
                        case qn.m.UndoAddFriendEvent:
                        case qn.m.AcceptAddFriendEvent:
                        case qn.m.RejectAddFriendEvent:
                        case qn.m.UndoSentRequestFriendEvent:
                          this._cachedFriendRequest[e.payload] &&
                            (delete this._cachedFriendRequest[e.payload],
                            this.data.has(e.payload) &&
                              this._updateVersion(e.payload));
                      }
                    }
                    getItem(e, t) {
                      return this.data.get(e.key);
                    }
                    getList(e, t) {
                      return Array.from(this.data.keys());
                    }
                    onGetItemFailure(e, t) {}
                    onGetListFailure(e, t) {}
                    getDefaultItem() {
                      throw new Error("Method not implemented.");
                    }
                    getDefaultList() {
                      throw new Error("Method not implemented.");
                    }
                  }),
                ) || Tb),
            ) || Tb),
        );
        var Pb,
          Nb = s("786D");
        Object($t.b)(Nb.a)(
          (Pb =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (Pb =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (Pb = class {
                    constructor() {
                      (this.name = Nb.b),
                        (this.key = "convId"),
                        (this.didInit = !1),
                        (this.data = void 0),
                        (this._cachedFriendRequest = {}),
                        (this._dispatch = void 0),
                        (this._genMessageServer = void 0),
                        (this._connectClose = []),
                        (this._logger = void 0),
                        (this.type = void 0),
                        (this.data = new Map()),
                        (this.eventHandler = this.eventHandler.bind(this));
                    }
                    get Logger() {
                      return (
                        this._logger ||
                          (this._logger = i.ModuleContainer.resolve(
                            q.ZLoggerFactory,
                          ).createZLogger(this.name, ["group-controller"])),
                        this._logger
                      );
                    }
                    init(e) {
                      this.didInit || (this.didInit = !0);
                    }
                    clearState(e) {
                      this.data.has(e) && this.data.delete(e);
                    }
                    bindDispatch(e) {
                      (this._dispatch = e),
                        Mt.default.subscribe(this.eventHandler);
                    }
                    unbind() {
                      (this._dispatch = null),
                        (this._genMessageServer = null),
                        (this._connectClose = []),
                        this.data.clear(),
                        Mt.default.unsubscribe(this.eventHandler);
                    }
                    dispatch(e) {
                      this._dispatch
                        ? this._dispatch(e)
                        : this.Logger.zsymb(0, 14536, 3e4, "Lost dispatch");
                    }
                    bindGenMessageServer(e) {
                      this._genMessageServer = e;
                    }
                    connectCloseModalCallback(e) {
                      this._connectClose.push(e);
                    }
                    _updateData(e, t, s) {
                      const i = this.data.get(e);
                      i
                        ? this.data.set(
                            e,
                            Object(f.a)(
                              Object(f.a)({}, i),
                              {},
                              {
                                [t]:
                                  i && i[t] ? Ct.default.deepMerge(i[t], s) : s,
                              },
                            ),
                          )
                        : this.data.set(e, { [t]: s }),
                        Object(nt.g)(Nb.b, e);
                    }
                    _udapteInfoData(e, t) {
                      var s;
                      const i = this.data.get(e);
                      return (
                        null != i &&
                          null !== (s = i.info) &&
                          void 0 !== s &&
                          s.avatar &&
                          (t.avatar = i.info.avatar),
                        this._updateData(e, "info", t)
                      );
                    }
                    async getGroupInfo(e) {
                      const t = async () => {
                          try {
                            const t = await ds.default.getFullInfoGroupById(
                              e,
                              R.SRC_GET_PROFILE.FORCE_GET,
                            );
                            return t && this._udapteInfoData(e, t), t;
                          } catch (t) {
                            return (
                              this.Logger.zsymb(
                                0,
                                14536,
                                30001,
                                "[getGroupInfo]",
                                t,
                              ),
                              ds.default.getGroupByIdSync(e, void 0)
                            );
                          }
                        },
                        s = ds.default.getGroupByIdSync(e, void 0);
                      return this.data.has(e)
                        ? (this._udapteInfoData(e, s), s)
                        : (this._udapteInfoData(e, s), await t());
                    }
                    selectConversation(e) {
                      const t = this.data.get(e);
                      if (t) {
                        Xe.e.logAction(1460204),
                          this.dispatch({
                            type: St.ConversationListActions
                              .SELECT_CONVERSATION,
                            payload: t,
                          }),
                          zn.a.openConversation(e);
                        const s = Q.p.getSelectConversationSource();
                        s && Xe.e.logAction(s);
                      }
                      Je.ModalManagerV2.closeAllModal();
                    }
                    async addGroupAdmin(e, t, s) {
                      try {
                        return await ds.default.addGroupAdmin(t, s), !0;
                      } catch (i) {
                        if (
                          (this.Logger.zsymb(
                            18,
                            14536,
                            30002,
                            "[addGroupAdmin] error",
                            i,
                          ),
                          !i)
                        )
                          return;
                        if (i.error_code) {
                          let s = "";
                          switch (i.error_code) {
                            case 161:
                              s = tt.default.str(
                                Oa.a.get("STR_GROUP_NO_EXIST", t),
                              );
                              break;
                            case 166:
                              s = tt.default.str(
                                Oa.a.get("STR_GROUP_NO_PERMISION", t),
                              );
                              break;
                            default:
                              s =
                                tt.default.str(
                                  Oa.a.get("STR_ADD_ADMIN_TOAST_UNSUCCESS", t),
                                ) +
                                " (" +
                                i.error_code +
                                ")";
                          }
                          Fb.a(e, void 0, s);
                        } else
                          i.code &&
                            "ERR_NO_NETWORK" === i.code &&
                            Fb.a(e, "STR_CONNECTION_ERROR");
                      }
                      return !1;
                    }
                    async changeGroupOwner(e, t, s, i) {
                      var n;
                      void 0 === i && (i = !1);
                      let a = !1;
                      const r =
                        (null === (n = ds.default.getGroupByIdSync(t)) ||
                        void 0 === n
                          ? void 0
                          : n.topMember) || [];
                      for (const l of r)
                        if (l.id === s) {
                          a = !0;
                          break;
                        }
                      if (!a)
                        return void Fb.b(
                          tt.default.trans(
                            Oa.a.get("STR_NO_LONGER_MEMBER_IN_GROUP", t),
                            Rb.h(s),
                          ),
                        );
                      let o = t;
                      o && o.startsWith(R.GROUPID_PREFIX) && (o = o.slice(1));
                      try {
                        return (
                          await Ot.default.changeGroupOwner(o, s),
                          this._updateData(t, "info", { creatorId: s }),
                          this.dispatch({
                            type: St.ConversationListActions.UPDATE_GROUP_OWNER,
                            payload: { userId: t, creatorId: s },
                          }),
                          i && (await this.leaveGroup(e, o)),
                          !0
                        );
                      } catch (d) {
                        return (
                          Fb.a(e, Oa.a.get("STR_CHANGE_GROUP_OWNER_FAIL", t)),
                          !1
                        );
                      }
                    }
                    async leaveGroup(e, t) {
                      try {
                        await Ot.default.leaveGroup(t);
                      } catch (s) {
                        s &&
                          "ERR_NO_NETWORK" == s.code &&
                          Fb.a(e, "STR_CHECK_NET");
                      }
                    }
                    eventHandler(e, t) {
                      switch (e) {
                        case St.FetchActions.UPDATE_NAME:
                          t.constructor === Object && this.data.has(t.userId)
                            ? this.getGroupInfo(t.userId)
                            : t.constructor === Array &&
                              t.forEach((e) => {
                                this.data.has(e) && this.getGroupInfo(e);
                              });
                          break;
                        case St.FetchActions.GROUP_UPDATED:
                          if (t) {
                            let {
                              topMember: e = [],
                              userId: i,
                              isGroup: n,
                            } = t;
                            const a = this.data.get(i);
                            if (a && n) {
                              var s;
                              let t =
                                null === (s = a.info) || void 0 === s
                                  ? void 0
                                  : s.topMember;
                              (null == e ? void 0 : e.length) > 0 && (t = e),
                                this._updateData(i, "info", { topMember: t }),
                                this.getGroupInfo(i);
                            }
                          }
                          break;
                        case St.FetchActions.UPDATE_GROUP_SETTING:
                          if (t && t.data) {
                            let e = t.data.groupId;
                            if (
                              e &&
                              ((e = R.GROUPID_PREFIX + e), this.data.has(e))
                            ) {
                              var i, n;
                              const s =
                                t.data.groupSetting ||
                                (null === (i = this.data.get(e)) ||
                                void 0 === i ||
                                null === (n = i.info) ||
                                void 0 === n
                                  ? void 0
                                  : n.setting);
                              this._updateData(e, "info", { newSetting: s });
                            }
                          }
                          break;
                        case St.GroupsAction.GROUPS_CHANGE_INFO:
                          t &&
                            t.forEach((e) => {
                              this.data.has(e) && this.getGroupInfo(e);
                            });
                          break;
                        case St.FetchActions.DELETE_CONVERSATION:
                        case St.FetchActions.GROUP_LEAVE:
                          this.data.has(t) &&
                            this._connectClose.forEach((e) => e());
                          break;
                        case St.ConversationListActions.UPDATE_GROUP_OWNER:
                          t &&
                            this.data.has(t.userId) &&
                            this._updateData(t.userId, "info", {
                              creatorId: t.creatorId,
                            });
                      }
                    }
                    getItem(e, t) {
                      return this.data.get(e.key);
                    }
                    getList(e, t) {
                      return Array.from(this.data.keys());
                    }
                    onGetItemFailure(e, t) {}
                    onGetListFailure(e, t) {}
                    getDefaultItem() {
                      throw new Error("Method not implemented.");
                    }
                    getDefaultList() {
                      throw new Error("Method not implemented.");
                    }
                  }),
                ) || Pb),
            ) || Pb),
        );
        var Ub = s("BpN3"),
          kb = s("UJhs");
        function Bb(e) {
          return (
            "object" == typeof e &&
            !!e &&
            e.hasOwnProperty("loading") &&
            "boolean" == typeof e.loading &&
            e.type in kb.d &&
            e.hasOwnProperty("data") &&
            "object" == typeof e.data &&
            !!e.data
          );
        }
        const Gb = "SEND_INPUT_PREVIEW",
          xb = { [Gb]: { feature: Xe.b.InputBoxPreview, subType: 1 } };
        var zb;
        !(function (e) {
          (e[(e.Chat = 1)] = "Chat"),
            (e[(e.Group = 2)] = "Group"),
            (e[(e.MyCloud = 3)] = "MyCloud"),
            (e[(e.OA = 4)] = "OA");
        })(zb || (zb = {}));
        class Vb {}
        (Vb.actionlogSendPreview = (e) => {
          requestIdleCallback(
            () => {
              try {
                var t;
                if (!e.length) return;
                const n = e.filter((e) => e.type === kb.d.PHOTO);
                if (!n.length) return;
                let a;
                const r =
                  null == n || null === (t = n[0]) || void 0 === t
                    ? void 0
                    : t.toUid;
                a = Object(Rb.z)(r)
                  ? zb.OA
                  : Ct.default.isGroup(r)
                    ? zb.Group
                    : Object(Rb.f)() === r
                      ? zb.MyCloud
                      : zb.Chat;
                const o = e.length,
                  d = [];
                for (let e = 0; e < n.length; e++) {
                  var s, i;
                  const t = n[e],
                    a = {
                      photo_position: e + 1,
                      caption_length:
                        (null == t || null === (s = t.caption) || void 0 === s
                          ? void 0
                          : s.length) || 0,
                      is_caption_form:
                        null != t &&
                        null !== (i = t.caption) &&
                        void 0 !== i &&
                        i.length
                          ? 1
                          : 0,
                    };
                  d.push(a);
                }
                const l = {
                  total_item_in_group: o,
                  caption_info: d,
                  chat_type: a,
                };
                Vb._actionlogSendInputPreview(Gb, l);
              } catch (n) {
                q.dangerouslyLogConsole.error(
                  "InputPreviewActionLog.logSendPreview",
                  n,
                );
              }
            },
            { timeout: 5e3 },
          );
        }),
          (Vb._actionlogSendInputPreview = async (e, t) => {
            const s = xb[e].feature,
              i = xb[e].subType;
            Xe.e.logActionInfoV2(s, i, t);
          });
        var Hb,
          $b = Vb;
        Object(i.injectable)()(
          (Hb =
            Object($t.b)(Ub.b)(
              (Hb = class {
                constructor() {
                  (this._eventEmitter = new ed.a()),
                    (this.addPreviewItem = (e) => {
                      var t;
                      Object(_v.a)(
                        (function (e) {
                          return Bb(e) && e.type !== kb.d.PLACEHOLDER;
                        })(e),
                        "invalid item for input preview, must be InputPreviewData",
                      );
                      const s = e,
                        i = s.data,
                        n = i.toUid,
                        a = this.mayInitState(n),
                        r =
                          null !== (t = s.previewId) && void 0 !== t
                            ? t
                            : i.clientId,
                        o =
                          a.oriItems.length > 0
                            ? [...a.oriItems]
                            : [...a.items],
                        d = o.findIndex((e) => e.previewId === r),
                        l = s.data.clientId;
                      (this.removedItems.get(n) || new Set()).has(l) ||
                        (-1 !== d
                          ? (o[d] = Object(f.a)(
                              Object(f.a)(Object(f.a)({}, a.items[d]), s),
                              {},
                              { previewId: r },
                            ))
                          : o.push(s),
                        this.data.set(
                          n,
                          Object(f.a)(
                            Object(f.a)({}, a),
                            {},
                            { items: o, oriItems: o },
                          ),
                        ),
                        Object(nt.g)(this.name, n),
                        this.emit("ON_ADD_INPUT_PREVIEW", {
                          conversationId: n,
                        }));
                    }),
                    (this.getOrderedItemsForSending = (e) => {
                      const t = this.getOrderedItems(e).map((e) =>
                        e && e.type === kb.d.GIF
                          ? Object(f.a)(
                              Object(f.a)({}, e),
                              {},
                              { type: kb.d.PHOTO },
                            )
                          : e,
                      );
                      return (
                        $b.actionlogSendPreview(
                          t.map((e) => Object(f.a)({}, e)),
                        ),
                        t
                      );
                    }),
                    (this.removePreviewItemById = (e, t) => {
                      const s = this.data.get(e);
                      if (!s) return;
                      const i = s.items.filter((e) => e.data.clientId !== t),
                        n = s.oriItems.filter((e) => e.data.clientId !== t);
                      this.data.set(
                        e,
                        Object(f.a)(
                          Object(f.a)({}, s),
                          {},
                          { items: i, oriItems: n },
                        ),
                      ),
                        Object(nt.g)(this.name, e);
                    }),
                    (this.name = Ub.a),
                    (this.data = new Map()),
                    (this.removedItems = new Map()),
                    (this.key = "conversationId");
                }
                on(e, t) {
                  return (
                    this._eventEmitter.on(e, t),
                    () => this._eventEmitter.off(e, t)
                  );
                }
                off(e, t) {
                  this._eventEmitter.off(e, t);
                }
                emit(e, t) {
                  this._eventEmitter.emit(e, t);
                }
                hasPreviewItems(e) {
                  const t = this.data.get(e);
                  return !!t && t.items.length > 0;
                }
                selectItem(e, t) {
                  if (!e || !t) return;
                  const s = this.mayInitState(e);
                  this.data.set(
                    e,
                    Object(f.a)(Object(f.a)({}, s), {}, { selectedItem: t }),
                  ),
                    Object(nt.g)(this.name, e);
                }
                selectPreviousItem(e) {
                  const t = this.mayInitState(e),
                    s = t.items,
                    i = t.selectedItem;
                  if (!i) return;
                  const n = s.findIndex((e) => e.data.clientId === i.cliMsgId);
                  if (-1 === n) return;
                  const a = Math.max(n - 1, 0);
                  this.data.set(
                    e,
                    Object(f.a)(Object(f.a)({}, t), {}, { selectedItem: s[a] }),
                  ),
                    Object(nt.g)(this.name, e);
                }
                selectNextItem(e) {
                  const t = this.mayInitState(e),
                    s = t.items,
                    i = t.selectedItem;
                  if (!i) return;
                  const n = s.findIndex((e) => e.data.clientId === i.cliMsgId);
                  if (-1 === n) return;
                  const a = Math.min(n + 1, s.length - 1);
                  this.data.set(
                    e,
                    Object(f.a)(Object(f.a)({}, t), {}, { selectedItem: s[a] }),
                  ),
                    Object(nt.g)(this.name, e);
                }
                addPlaceholder(e, t) {
                  Object(_v.a)(
                    "string" == typeof e && !!e,
                    "conversationId must be string",
                  ),
                    Object(_v.a)(
                      "object" == typeof t && !(null == t || !t.clientId),
                      "invalid item for input preview placeholder",
                    );
                  const s = this.mayInitState(e),
                    i = {
                      loading: !0,
                      type: kb.d.PLACEHOLDER,
                      previewId: t.clientId,
                      data: { clientId: t.clientId },
                    };
                  this.data.set(
                    e,
                    Object(f.a)(
                      Object(f.a)({}, s),
                      {},
                      { items: [...s.items, i], oriItems: [...s.oriItems, i] },
                    ),
                  ),
                    Object(nt.g)(this.name, e);
                }
                getPreviewItemsCount(e) {
                  var t, s;
                  return null !==
                    (t =
                      null === (s = this.data.get(e)) || void 0 === s
                        ? void 0
                        : s.items.length) && void 0 !== t
                    ? t
                    : 0;
                }
                getOrderedItems(e) {
                  const t = this.data.get(e);
                  if (!t) return [];
                  let s = [];
                  const i = t.oriItems
                    .filter((e) => {
                      const t = e.type !== kb.d.PLACEHOLDER;
                      return t && s.push(e.data.clientId), t;
                    })
                    .map((e) => {
                      var s;
                      const i =
                          (null === (s = t.caption[e.data.clientId]) ||
                          void 0 === s
                            ? void 0
                            : s.saved) || "",
                        n = Object(f.a)(
                          Object(f.a)({}, e.data),
                          {},
                          { caption: i },
                        );
                      return Object(f.a)(Object(f.a)({}, e), {}, { data: n });
                    });
                  s = s.sort((e, t) => e - t);
                  return i.map((e, t) =>
                    Object(f.a)(
                      Object(f.a)({}, e.data),
                      {},
                      { clientId: s[t] },
                    ),
                  );
                }
                getRawOrderedItems(e) {
                  const t = this.data.get(e);
                  return t ? t.oriItems : [];
                }
                updateOrder(e, t) {
                  const s = this.mayInitState(e);
                  Object(_v.a)(
                    Array.isArray(t),
                    `invalid items for input preview at ${e}`,
                  ),
                    this.data.set(
                      e,
                      Object(f.a)(Object(f.a)({}, s), {}, { oriItems: t }),
                    ),
                    Object(nt.g)(this.name, e);
                }
                removePreviewItem(e, t) {
                  const s = this.data.get(e);
                  if (!s) return;
                  const i = [...s.items],
                    n = [...s.oriItems],
                    a = i[t];
                  if (!a) return;
                  const r = n.indexOf(a);
                  i.splice(t, 1),
                    -1 !== r && n.splice(r, 1),
                    this.data.set(
                      e,
                      Object(f.a)(
                        Object(f.a)({}, s),
                        {},
                        { items: i, oriItems: n },
                      ),
                    ),
                    a.type === kb.d.PHOTO && URL.revokeObjectURL(a.data.img),
                    Object(nt.g)(this.name, e),
                    this.emit("ON_REMOVE_INPUT_PREVIEW", { conversationId: e });
                }
                removeAllItems(e, t) {
                  void 0 === t && (t = !1);
                  const s = this.data.get(e);
                  if (!s) return;
                  const i = this.removedItems.get(e) || new Set();
                  if (!t)
                    for (let n of s.items)
                      i.add(n.data.clientId),
                        n.type === kb.d.PHOTO &&
                          URL.revokeObjectURL(n.data.img);
                  this.removedItems.set(e, i),
                    this.data.delete(e),
                    Object(nt.g)(this.name, e),
                    this.emit("ON_REMOVE_INPUT_PREVIEW", { conversationId: e });
                }
                saveDraft(e, t, s) {
                  const i = "string" == typeof s ? s.trimStart().trimEnd() : "",
                    n = this.mayInitState(e);
                  Object(_v.a)(
                    !!n,
                    `invalid state when saveDraft for conversationId ${e}`,
                  ),
                    Object(_v.a)(
                      "string" == typeof i,
                      `invalid draft for conversationId ${e}`,
                    );
                  let a = n.caption[t] || { saved: "", draft: "" };
                  if (a.saved === i && a.draft === i) return;
                  a = Object(f.a)(Object(f.a)({}, a), {}, { draft: i });
                  const r = Object(f.a)(
                      Object(f.a)({}, n.caption),
                      {},
                      { [t]: a },
                    ),
                    o = new Set(n.unsavedChanges);
                  a.saved !== a.draft ? o.add(t) : o.delete(t),
                    this.data.set(
                      e,
                      Object(f.a)(
                        Object(f.a)({}, n),
                        {},
                        { caption: r, unsavedChanges: Array.from(o) },
                      ),
                    ),
                    Object(nt.g)(this.name, e);
                }
                applyDraft(e, t) {
                  return (
                    Object(_v.a)(
                      "string" == typeof e && !!e,
                      "InputCaption: conversationId must be string",
                    ),
                    "number" == typeof t
                      ? this.applyDraftSingle(e, t)
                      : this.applyDraftMulti(e)
                  );
                }
                resetSelectedItem(e) {
                  if (!e) return;
                  const t = this.mayInitState(e);
                  this.data.set(
                    e,
                    Object(f.a)(Object(f.a)({}, t), {}, { selectedItem: null }),
                  ),
                    Object(nt.g)(this.name, e);
                }
                applyDraftSingle(e, t) {
                  const s = this.mayInitState(e);
                  Object(_v.a)(
                    !!s,
                    `invalid state when addCaption for conversationId ${e}`,
                  );
                  let i = s.caption[t];
                  if (!i || i.saved === i.draft) return;
                  const n = i.draft || "";
                  i = Object(f.a)(Object(f.a)({}, i), {}, { saved: n });
                  const a = Object(f.a)(
                      Object(f.a)({}, s.caption),
                      {},
                      { [t]: i },
                    ),
                    r = new Set(s.unsavedChanges);
                  r.delete(t),
                    this.data.set(
                      e,
                      Object(f.a)(
                        Object(f.a)({}, s),
                        {},
                        { caption: a, unsavedChanges: Array.from(r) },
                      ),
                    ),
                    Object(nt.g)(this.name, e);
                }
                applyDraftMulti(e) {
                  const t = this.mayInitState(e);
                  Object(_v.a)(
                    !!t,
                    `invalid state when addCaption for conversationId ${e}`,
                  );
                  const s = Object(f.a)({}, t.caption);
                  Object.keys(s).forEach((e) => {
                    const t = s[e];
                    if (!t || t.saved === t.draft) return;
                    const i = t.draft || "";
                    s[e] = Object(f.a)(Object(f.a)({}, t), {}, { saved: i });
                  });
                  const i = Object(f.a)(
                    Object(f.a)({}, t),
                    {},
                    { caption: s, unsavedChanges: [] },
                  );
                  this.data.set(e, i), Object(nt.g)(this.name, e);
                }
                discardDraftedCaption(e, t) {
                  return (
                    Object(_v.a)(
                      "string" == typeof e && !!e,
                      "InputCaption: conversationId must be string",
                    ),
                    "number" == typeof t
                      ? this.discardDraftedCaptionSingle(e, t)
                      : this.discardDraftedCaptionMulti(e)
                  );
                }
                discardDraftedCaptionSingle(e, t) {
                  const s = this.mayInitState(e);
                  if (!s) return;
                  const i = s.caption[t];
                  if (!i || !i.draft) return;
                  const n = s.caption[t],
                    a = Object(f.a)(
                      Object(f.a)({}, s.caption),
                      {},
                      {
                        [t]: Object(f.a)(
                          Object(f.a)({}, n),
                          {},
                          { draft: null == n ? void 0 : n.saved },
                        ),
                      },
                    ),
                    r = new Set(s.unsavedChanges);
                  r.delete(t),
                    this.data.set(
                      e,
                      Object(f.a)(
                        Object(f.a)({}, s),
                        {},
                        { caption: a, unsavedChanges: Array.from(r) },
                      ),
                    ),
                    Object(nt.g)(this.name, e);
                }
                discardDraftedCaptionMulti(e) {
                  let t = this.data.get(e);
                  if (!t) return;
                  const s = Object(f.a)({}, t.caption);
                  if (s) for (const i in s) s[i].draft = s[i].saved;
                  (t = Object(f.a)(
                    Object(f.a)({}, t),
                    {},
                    { caption: s, unsavedChanges: [] },
                  )),
                    this.data.set(e, t),
                    Object(nt.g)(this.name, e);
                }
                getCaption(e, t) {
                  return this.mayInitState(e).caption[t];
                }
                _listenEvents() {}
                mayInitState(e) {
                  let t = this.data.get(e);
                  return (
                    t ||
                      ((t = {
                        conversationId: e,
                        items: [],
                        oriItems: [],
                        selectedItem: null,
                        caption: {},
                        unsavedChanges: [],
                      }),
                      this.data.set(e, t)),
                    t
                  );
                }
                init() {
                  this._listenEvents();
                }
                getItem(e) {
                  return this.data.get(e.key);
                }
                getList(e) {
                  return "all" === e.key ? Array.from(this.data.keys()) : [];
                }
                onGetItemFailure(e) {}
                onGetListFailure(e) {}
              }),
            ) || Hb),
        );
        var Wb = s("ONNR"),
          Kb = s("1Q0E"),
          qb = s("kCjk");
        function Zb(e, t) {
          switch (t) {
            case "byte-to-mb":
              return e / 1024 / 1024;
            case "kb-to-mb":
              return e / 1024;
            default:
              return;
          }
        }
        function Jb(e, t) {
          return (
            void 0 === t && (t = ""),
            e.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",") + t
          );
        }
        var Qb = s("IpzU"),
          Yb = s("XnIt"),
          Xb = s("CaBZ"),
          eI = s("mHfx");
        let tI, sI;
        try {
          (tI = $znode.fs), (sI = $znode.path);
        } catch (oC) {}
        async function iI(e) {
          return new Promise((t) => {
            try {
              tI.readdir(e, async (s, i) => {
                if (s) return t(0);
                let n = 0;
                for (let t = 0; t < i.length; t++) {
                  const s = i[t],
                    a = sI.join(e, s),
                    r = tI.statSync(a);
                  if (Object(eI.a)(r)) {
                    n += await iI(a);
                  }
                  n += r.size;
                }
                t(n);
              });
            } catch (s) {
              t(0);
            }
          });
        }
        var nI,
          aI = new (class {
            constructor() {
              (this.lastFrameTime = 0), (this.fps = 0), (this.pause = !0);
            }
            loop(e) {
              if (this.pause) return;
              const t = e;
              if (0 === this.lastFrameTime)
                return (
                  (this.lastFrameTime = t),
                  void requestAnimationFrame(this.loop.bind(this))
                );
              const s = t - this.lastFrameTime;
              s > 0 &&
                ((this.fps = Math.round(1e3 / s)), (this.lastFrameTime = t)),
                requestAnimationFrame(this.loop.bind(this));
            }
            start() {
              (this.pause = !1), requestAnimationFrame(this.loop.bind(this));
            }
            stop() {
              (this.lastFrameTime = 0), (this.fps = 0), (this.pause = !0);
            }
            get value() {
              return this.fps;
            }
          })();
        const rI = "z_m_h_",
          oI = "z_m_h_i___",
          dI = {
            CPU: !0,
            GPU: !0,
            RAM: !0,
            FPS: !0,
            "JS Heap": !0,
            "Root Render": !0,
            LCP: !0,
          };
        Object($t.b)(Kb.b)(
          (nI =
            Object(i.injectable)()(
              (nI =
                Object(i.singleton)()(
                  (nI =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (nI =
                        Reflect.metadata(
                          "design:paramtypes",
                          [],
                        )(
                          (nI = class {
                            constructor() {
                              (this.type = void 0),
                                (this.name = void 0),
                                (this.key = void 0),
                                (this.isStarted = !1),
                                (this.userId = void 0),
                                (this.monitorItems = []),
                                (this.showMonitorItems = new Map()),
                                (this.rootRenderInitTime = vs.a.now()),
                                (this.rootRenderNumber = 1),
                                (this.lcpMetric = void 0),
                                (this.intervalCheck = void 0),
                                (this.intervalCheckSteps = 0),
                                (this.data = {
                                  isShowZPCHealth: !1,
                                  monitorItemForUIs: [],
                                }),
                                (this.usageMonitor = void 0),
                                (this.name = Kb.a),
                                (this.key = Kb.a);
                            }
                            initialize(e) {
                              this.isStarted ||
                                ((this.isStarted = !0),
                                (function () {
                                  const e = i.ModuleContainer.resolve(Xb.b);
                                  e.registerMonitorItem({
                                    expectedOrderPosition: 1,
                                    title: "Database",
                                    description: "Cache & IndexedDB",
                                    getValue: async () => {
                                      var e, t, s;
                                      let i =
                                        (null ===
                                          (e = await (null ===
                                            (t = navigator.storage) ||
                                          void 0 === t ||
                                          null === (s = t.estimate) ||
                                          void 0 === s
                                            ? void 0
                                            : s.call(t))) || void 0 === e
                                          ? void 0
                                          : e.usage) || 0;
                                      return (
                                        (i = Math.round(
                                          Zb(i, "byte-to-mb") || 0,
                                        )),
                                        i
                                      );
                                    },
                                    getType: (e) =>
                                      e >= 200 && e <= 500
                                        ? "medium"
                                        : e > 500
                                          ? "high"
                                          : "low",
                                    getContent: (e) => Jb(e, " MB"),
                                    checkSteps: 10,
                                  }),
                                    e.registerMonitorItem({
                                      expectedOrderPosition: 2,
                                      title: "DOM",
                                      description: "DOM nodes",
                                      getValue: () =>
                                        document.getElementsByTagName("*")
                                          .length || 0,
                                      getType: (e) =>
                                        e >= 3e3 && e <= 6e3
                                          ? "medium"
                                          : e > 6e3
                                            ? "high"
                                            : "low",
                                      getContent: (e) => Jb(e, " nodes"),
                                      checkSteps: 2,
                                    }),
                                    e.registerMonitorItem({
                                      expectedOrderPosition: 3,
                                      title: "Temp Files",
                                      description: "ZaloTemp & zTemp",
                                      getValue: async () => {
                                        try {
                                          const e = await Object(Qb.x)(),
                                            t = await iI(e),
                                            s = await Object(Qb.F)(),
                                            i = await iI(s);
                                          return Math.round(
                                            Zb(t + i, "byte-to-mb") || 0,
                                          );
                                        } catch (e) {
                                          return 0;
                                        }
                                      },
                                      getType: (e) =>
                                        e >= 50 && e <= 100
                                          ? "medium"
                                          : e > 100
                                            ? "high"
                                            : "low",
                                      getContent: (e) => Jb(e, " MB"),
                                      checkSteps: 100,
                                    }),
                                    e.registerMonitorItem({
                                      expectedOrderPosition: 6,
                                      title: "Custom Domains",
                                      description: "Count custom domains usage",
                                      getValue: async () => {
                                        const e = i.ModuleContainer.resolve(
                                          Yb.a,
                                        ).getDomainConfig();
                                        let t = 0;
                                        if (!e) return t;
                                        for (const s in e)
                                          e.hasOwnProperty(s) &&
                                            e[s].useDevDomain &&
                                            t++;
                                        return t;
                                      },
                                      getType: (e) => "low",
                                      getContent: (e) => Jb(e, ""),
                                      checkSteps: 2,
                                    });
                                })());
                              const t = this.getStorage().getItem(rI);
                              this.data.isShowZPCHealth = "1" === t;
                              const s = this.getStorage().getItem(oI);
                              if (s) {
                                s.split(",").forEach((e) => {
                                  e && this.showMonitorItems.set(e, 1);
                                });
                              }
                              this.data.isShowZPCHealth &&
                                Object(qb.b)() &&
                                (Object(Wb.a)(
                                  (e) => {
                                    this.lcpMetric = e;
                                  },
                                  { reportAllChanges: !0 },
                                ),
                                (this.userId = e),
                                this.startHealthCheck());
                            }
                            destroy() {
                              this.stopHealthCheck();
                            }
                            registerMonitorItem(e) {
                              const t = `${e.expectedOrderPosition || ""}_${e.title.replace(" ", "")}`,
                                s = Object(f.a)(
                                  Object(f.a)({}, e),
                                  {},
                                  { id: t },
                                );
                              this.monitorItems.push(s),
                                (this.monitorItems = this.monitorItems.sort(
                                  (e, t) =>
                                    e.expectedOrderPosition &&
                                    t.expectedOrderPosition
                                      ? e.expectedOrderPosition -
                                        t.expectedOrderPosition
                                      : 0,
                                ));
                            }
                            addRootRender() {
                              this.data.isShowZPCHealth &&
                                Object(qb.b)() &&
                                this.rootRenderNumber++;
                            }
                            resetRootRender() {
                              this.rootRenderNumber = 1;
                            }
                            startHealthCheck() {
                              this.intervalCheck ||
                                (aI.start(),
                                this.getMonitorItems(this.userId),
                                (this.intervalCheck = setInterval(() => {
                                  this.getMonitorItems(this.userId),
                                    this.intervalCheckSteps++;
                                }, qb.a.INTERVAL_CHECK_TIME)));
                            }
                            stopHealthCheck() {
                              aI.stop(),
                                (this.rootRenderNumber = 1),
                                this.intervalCheck &&
                                  (clearInterval(this.intervalCheck),
                                  (this.intervalCheck = void 0),
                                  (this.intervalCheckSteps = 0));
                            }
                            toggleZPCHealth() {
                              (this.data.isShowZPCHealth =
                                !this.data.isShowZPCHealth),
                                this.getStorage().setItem(
                                  rI,
                                  this.data.isShowZPCHealth ? "1" : "0",
                                ),
                                this.data.isShowZPCHealth ||
                                  this.stopHealthCheck(),
                                Object(nt.g)(this.name, "");
                            }
                            getMonitorList() {
                              return this.monitorItems.map((e) => ({
                                id: e.id,
                                title: e.title,
                                isShow: !(
                                  !this.showMonitorItems.get(e.id) &&
                                  !dI[e.title]
                                ),
                              }));
                            }
                            showZPCHealthItem(e, t) {
                              if (!e) return;
                              t
                                ? this.showMonitorItems.set(e, 1)
                                : this.showMonitorItems.delete(e);
                              let s = "";
                              this.showMonitorItems.forEach((e, t) => {
                                s += t + ",";
                              }),
                                this.getStorage().setItem(oI, s),
                                this.stopHealthCheck(),
                                this.startHealthCheck();
                            }
                            async getMonitorItems(e) {
                              var t, s, i, n;
                              const a = await $zperf.getCpuInfos();
                              let r = 0,
                                o = 0,
                                d = 0;
                              null == a ||
                                a.forEach((e) => {
                                  var t, s;
                                  const i =
                                      (null == e ||
                                      null === (t = e.cpu) ||
                                      void 0 === t
                                        ? void 0
                                        : t.percentCPUUsage) || 0,
                                    n =
                                      (null == e ||
                                      null === (s = e.memory) ||
                                      void 0 === s
                                        ? void 0
                                        : s.workingSetSize) || 0;
                                  "GPU" !== e.type ? (r += i) : (o += i),
                                    (d += n);
                                }),
                                (r = Math.round(r)),
                                (o = Math.round(o)),
                                (d = Math.round(Zb(d, "kb-to-mb") || 0));
                              let l =
                                (null === (t = performance.memory) ||
                                void 0 === t
                                  ? void 0
                                  : t.usedJSHeapSize) || 0;
                              l = Math.round(Zb(l, "byte-to-mb") || 0);
                              const c = aI.value;
                              let h =
                                (null ===
                                  (s = await (null ===
                                    (i = navigator.storage) ||
                                  void 0 === i ||
                                  null === (n = i.estimate) ||
                                  void 0 === n
                                    ? void 0
                                    : n.call(i))) || void 0 === s
                                  ? void 0
                                  : s.usage) || 0;
                              h = Math.round(Zb(h, "byte-to-mb") || 0);
                              const u =
                                  Math.round(
                                    (vs.a.now() - this.rootRenderInitTime) /
                                      1e3 /
                                      60,
                                  ) || 1,
                                g = Math.round(this.rootRenderNumber / u),
                                m = [
                                  ...[
                                    {
                                      id: "0_CPU",
                                      title: "CPU",
                                      description: "CPU usage",
                                      getValue: () => r,
                                      getType: (e) =>
                                        e >= 20 && e <= 40
                                          ? "medium"
                                          : e > 40
                                            ? "high"
                                            : "low",
                                      getContent: (e) => Jb(e, " %"),
                                      checkSteps: 2,
                                    },
                                    {
                                      id: "0_GPU",
                                      title: "GPU",
                                      description: "GPU usage",
                                      getValue: () => o,
                                      getType: (e) =>
                                        e >= 10 && e <= 30
                                          ? "medium"
                                          : e > 30
                                            ? "high"
                                            : "low",
                                      getContent: (e) => Jb(e, " %"),
                                      checkSteps: 2,
                                    },
                                    {
                                      id: "0_FPS",
                                      title: "FPS",
                                      description: "Frame Per Second",
                                      getValue: () => c,
                                      getType: (e) =>
                                        e >= 20 && e <= 30
                                          ? "medium"
                                          : e < 20
                                            ? "high"
                                            : "low",
                                      getContent: (e) => Jb(e),
                                      checkSteps: 1,
                                    },
                                    {
                                      id: "0_RAM",
                                      title: "RAM",
                                      description: "RAM usage",
                                      getValue: () => d,
                                      getType: (e) =>
                                        e >= 500 && e <= 1e3
                                          ? "medium"
                                          : e > 1e3
                                            ? "high"
                                            : "low",
                                      getContent: (e) => Jb(e, " MB"),
                                      checkSteps: 2,
                                    },
                                    {
                                      id: "0_JSHeap",
                                      title: "JS Heap",
                                      description: "JS Heap usage",
                                      getValue: () => l,
                                      getType: (e) =>
                                        e >= 200 && e <= 300
                                          ? "medium"
                                          : e > 300
                                            ? "high"
                                            : "low",
                                      getContent: (e) => Jb(e, " MB"),
                                      checkSteps: 2,
                                    },
                                    {
                                      id: "0_RootRender",
                                      title: "Root Render",
                                      description: "Root Render in minutes",
                                      getValue: () => g,
                                      getType: (e) =>
                                        e >= 10 && e <= 20
                                          ? "medium"
                                          : e > 20
                                            ? "high"
                                            : "low",
                                      getContent: (e) =>
                                        Jb(e, " times / minute"),
                                      checkSteps: 2,
                                    },
                                    {
                                      id: "0_LCP",
                                      title: "LCP",
                                      description: "Largest Contentful Paint",
                                      getValue: () => {
                                        var e;
                                        return Math.round(
                                          ((null === (e = this.lcpMetric) ||
                                          void 0 === e
                                            ? void 0
                                            : e.value) || 0) / 1e3,
                                        );
                                      },
                                      getType: (e) => {
                                        var t;
                                        switch (
                                          null === (t = this.lcpMetric) ||
                                          void 0 === t
                                            ? void 0
                                            : t.rating
                                        ) {
                                          case "poor":
                                            return "high";
                                          case "needs-improvement":
                                            return "medium";
                                          default:
                                            return "low";
                                        }
                                      },
                                      getContent: (e) => Jb(e, " s"),
                                      checkSteps: 2,
                                    },
                                  ],
                                  ...this.monitorItems,
                                ],
                                p = [];
                              for (let I = 0; I < m.length; I++) {
                                const t = m[I];
                                let s = !1;
                                s = !(
                                  !this.showMonitorItems.get(t.id) &&
                                  !dI[t.title]
                                );
                                let i,
                                  n,
                                  a = 0;
                                var f, v, b;
                                if (s)
                                  if (
                                    this.data.monitorItemForUIs[I] &&
                                    this.intervalCheckSteps %
                                      (t.checkSteps || 1) !=
                                      0
                                  )
                                    (i = this.data.monitorItemForUIs[I].type),
                                      (n =
                                        this.data.monitorItemForUIs[I].content);
                                  else
                                    (a =
                                      (await (null === (f = t.getValue) ||
                                      void 0 === f
                                        ? void 0
                                        : f.call(t, e))) || 0),
                                      (i =
                                        null === (v = t.getType) || void 0 === v
                                          ? void 0
                                          : v.call(t, a)),
                                      (n =
                                        null === (b = t.getContent) ||
                                        void 0 === b
                                          ? void 0
                                          : b.call(t, a));
                                const r = {
                                  id: t.id,
                                  title: t.title,
                                  description: t.description,
                                  type: i,
                                  content: n,
                                  isShow: s,
                                  checkTime:
                                    (t.checkSteps || 1) *
                                    qb.a.INTERVAL_CHECK_TIME,
                                };
                                p.push(r);
                              }
                              (this.data.monitorItemForUIs = p),
                                Object(nt.g)(this.name, "");
                            }
                            getStorage() {
                              return E.default.getInstance();
                            }
                            getItem(e, t) {
                              return this.data;
                            }
                            init(e) {
                              throw new Error("Method not implemented.");
                            }
                            getList(e, t) {
                              throw new Error("Method not implemented.");
                            }
                            onGetItemFailure(e, t) {
                              throw new Error("Method not implemented.");
                            }
                            onGetListFailure(e, t) {
                              throw new Error("Method not implemented.");
                            }
                          }),
                        ) || nI),
                    ) || nI),
                ) || nI),
            ) || nI),
        );
        var lI = s("zdwi"),
          cI = s("E/Lo");
        const hI = "1",
          uI = { windowId: hI, name: "ZPC_HEALTH" },
          gI = { windowId: hI, name: "METRICS" };
        var mI,
          pI = s("Igfx");
        const fI = "z_m_h_f_",
          vI = "z_m_h_r_";
        Object($t.b)(lI.a)(
          (mI =
            Object(i.injectable)()(
              (mI =
                Object(i.singleton)()(
                  (mI =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (mI =
                        Reflect.metadata(
                          "design:paramtypes",
                          [],
                        )(
                          (mI = class {
                            constructor() {
                              (this.type = void 0),
                                (this.name = void 0),
                                (this.key = void 0),
                                (this.data = {
                                  isShow: !1,
                                  isShowRenderingDebugger: !1,
                                  isShowReactiveLogger: !1,
                                }),
                                (this.observeRendering = Object(cI.b)()),
                                (this.name = lI.b),
                                (this.key = lI.b);
                            }
                            initialize() {
                              if (!Object(qb.b)()) return;
                              Je.ModalManagerV2.addModal(
                                Object(f.a)(
                                  Object(f.a)({}, uI),
                                  {},
                                  { altWindowId: void 0 },
                                ),
                              ),
                                Je.ModalManagerV2.subscribeTriggers({
                                  windowId: hI,
                                  name: uI.name,
                                  trigger: (e) => {},
                                });
                              const e = this.getStorage().getItem(fI);
                              (this.data.isShowRenderingDebugger = "1" === e),
                                "1" === e && this.observeRendering.observe();
                              const t = this.getStorage().getItem(vI);
                              (this.data.isShowReactiveLogger = "1" === t),
                                this.data.isShowReactiveLogger
                                  ? pI.a.enable()
                                  : pI.a.disable();
                            }
                            destroy() {}
                            showZPCHealthPopup(e) {
                              Object(qb.b)() &&
                                (e
                                  ? Je.ModalManagerV2.openModal(
                                      Object(f.a)(
                                        Object(f.a)({}, uI),
                                        {},
                                        { windowId: hI, params: null },
                                      ),
                                    )
                                  : Je.ModalManagerV2.closeModal(
                                      Object(f.a)(
                                        Object(f.a)({}, uI),
                                        {},
                                        { windowId: hI },
                                      ),
                                    ),
                                (this.data.isShow = e),
                                Object(nt.g)(this.name, "all"));
                            }
                            setIsShowRenderingDebugger(e) {
                              (this.data.isShowRenderingDebugger = e),
                                this.getStorage().setItem(fI, e ? "1" : "0"),
                                e
                                  ? this.observeRendering.observe()
                                  : this.observeRendering.disconnect();
                            }
                            setIsShowReactiveLogger(e) {
                              (this.data.isShowReactiveLogger = e),
                                this.getStorage().setItem(vI, e ? "1" : "0"),
                                e ? pI.a.enable() : pI.a.disable();
                            }
                            getStorage() {
                              return E.default.getInstance();
                            }
                            getItem(e, t) {
                              return this.data;
                            }
                            init(e) {
                              throw new Error("Method not implemented.");
                            }
                            getList(e, t) {
                              throw new Error("Method not implemented.");
                            }
                            onGetItemFailure(e, t) {
                              throw new Error("Method not implemented.");
                            }
                            onGetListFailure(e, t) {
                              throw new Error("Method not implemented.");
                            }
                          }),
                        ) || mI),
                    ) || mI),
                ) || mI),
            ) || mI),
        );
        var bI,
          II = s("Bwur");
        Object($t.b)(II.b)(
          (bI =
            Object(i.injectable)()(
              (bI =
                Object(i.singleton)()(
                  (bI =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (bI =
                        Reflect.metadata(
                          "design:paramtypes",
                          [],
                        )(
                          (bI = class {
                            constructor() {
                              (this.type = void 0),
                                (this.name = void 0),
                                (this.key = void 0),
                                (this.data = { isShow: !1 }),
                                (this.name = II.a),
                                (this.key = II.a);
                            }
                            initialize() {
                              Object(qb.b)() &&
                                (Je.ModalManagerV2.addModal(
                                  Object(f.a)(
                                    Object(f.a)({}, gI),
                                    {},
                                    { altWindowId: void 0 },
                                  ),
                                ),
                                Je.ModalManagerV2.subscribeTriggers({
                                  windowId: hI,
                                  name: gI.name,
                                  trigger: (e) => {},
                                }));
                            }
                            destroy() {}
                            showMetricsPopup(e) {
                              Object(qb.b)() &&
                                (e
                                  ? Je.ModalManagerV2.openModal(
                                      Object(f.a)(
                                        Object(f.a)({}, gI),
                                        {},
                                        { windowId: hI, params: null },
                                      ),
                                    )
                                  : Je.ModalManagerV2.closeModal(
                                      Object(f.a)(
                                        Object(f.a)({}, gI),
                                        {},
                                        { windowId: hI },
                                      ),
                                    ),
                                (this.data.isShow = e),
                                Object(nt.g)(this.name, "all"));
                            }
                            getItem(e, t) {
                              return this.data;
                            }
                            init(e) {
                              throw new Error("Method not implemented.");
                            }
                            getList(e, t) {
                              throw new Error("Method not implemented.");
                            }
                            onGetItemFailure(e, t) {
                              throw new Error("Method not implemented.");
                            }
                            onGetListFailure(e, t) {
                              throw new Error("Method not implemented.");
                            }
                          }),
                        ) || bI),
                    ) || bI),
                ) || bI),
            ) || bI),
        );
        const yI = { maxRetry: 3 },
          _I = (e) => (t, s, i) => {
            const n = i.value,
              a = new Map();
            i.value = async function () {
              for (
                var t = arguments.length, s = new Array(t), i = 0;
                i < t;
                i++
              )
                s[i] = arguments[i];
              const r = e(s);
              let o = a.get(r);
              return (
                o ||
                  ((o = n.apply(this, s)),
                  o.finally(() => a.delete(r)),
                  a.set(r, o)),
                o
              );
            };
          };
        var OI,
          CI,
          EI,
          MI,
          SI,
          TI,
          wI,
          RI = s("Hk5Z"),
          LI = s("Y3Ul"),
          DI = s("kuNG"),
          FI = s("5miw");
        (OI = Object(i.injectable)()),
          (CI = Object(i.singleton)(RI.a)),
          (EI = _I((e) => {
            let [t] = e;
            return t;
          })),
          (MI = Reflect.metadata("design:type", Function)),
          (SI = Reflect.metadata("design:paramtypes", [
            void 0 === FI.RemoteURL ? Object : FI.RemoteURL,
          ])),
          OI(
            (TI =
              CI(
                ((wI = class {
                  constructor() {
                    this.responseCache_ = void 0;
                  }
                  async convert(e) {
                    if (!e || "string" != typeof e)
                      return LI.a.Error({
                        error: new Error("Invalid Remote URL!"),
                      });
                    if ("blob:" === e.slice(0, 5))
                      return LI.a.Success({ blobURL: e });
                    this.responseCache_ ||
                      (this.responseCache_ = this.getCacheLazily_());
                    if (this.responseCache_.has(e)) {
                      const t = this.responseCache_.get(e);
                      return LI.a.Success({ blobURL: t.blobURL });
                    }
                    try {
                      const t = Bo(fetch, {
                          min: 1e3,
                          max: 5e3,
                          retries: 3,
                          afterRetry: async (e) => {
                            let { success: t } = e;
                          },
                        }),
                        s = await t(e),
                        i = await s.blob(),
                        n = URL.createObjectURL(i);
                      return (
                        this.responseCache_.set(e, {
                          remoteURL: e,
                          blobURL: n,
                        }),
                        LI.a.Success({ blobURL: n })
                      );
                    } catch (t) {
                      return LI.a.Error({ error: t });
                    }
                  }
                  revokeBlobUrl_(e) {
                    URL.revokeObjectURL(e);
                  }
                  getCacheLazily_() {
                    return new U.default({
                      maxSize: Object(DI.a)().config.max_bu_cache_size,
                      onEviction: (e, t) => {
                        this.revokeBlobUrl_(t.blobURL);
                      },
                    });
                  }
                }),
                Object(Sp.a)(
                  wI.prototype,
                  "convert",
                  [EI, MI, SI],
                  Object.getOwnPropertyDescriptor(wI.prototype, "convert"),
                  wI.prototype,
                ),
                (TI = wI)),
              ) || TI),
          );
        const AI = Object(i.define)("InternalEventBus");
        var jI;
        Object(i.injectable)()(
          (jI = Object(i.singleton)(AI)((jI = class extends te.b {})) || jI),
        );
        const PI = Object(i.define)("AIStickerMapper");
        var NI = s("z80d");
        function UI(e, t) {
          if (
            (void 0 === t && (t = "token"),
            "number" != typeof e || Number.isNaN(e))
          )
            throw Error(`${t}=${e} is invalid!`);
          return e;
        }
        class kI {
          constructor(e, t, s, i, n) {
            (this.id = void 0),
              (this.rootStickerCateId = void 0),
              (this.url = void 0),
              (this.width = void 0),
              (this.height = void 0),
              (this.id = UI(e, "id")),
              (this.rootStickerCateId = UI(t, "rootStickerCateId")),
              (this.url = (function (e, t) {
                if ((void 0 === t && (t = "token"), !e))
                  throw Error(`${t}=${e} is invalid!`);
                return e;
              })(s, "url")),
              (this.width = UI(i, "width")),
              (this.height = UI(n, "height"));
          }
          equals(e) {
            return this.id === e.id;
          }
        }
        var BI;
        s("SF1S");
        Object(i.injectable)()(
          (BI =
            Object(i.singleton)(PI)(
              (BI = class {
                toAIStickerDTOFromDomain(e) {
                  return {
                    id: e.id,
                    url: e.url,
                    thumb: "",
                    type: NI.f.AI_GENERATED,
                    intrinsicWidth: e.width,
                    intrinsicHeight: e.height,
                    renderedWidth: e.width,
                    renderedHeight: e.height,
                    animatable: !1,
                  };
                }
                toEntityFromSchema(e) {
                  return new kI(
                    e.id,
                    e.rootStickerCateId,
                    e.url,
                    e.width,
                    e.height,
                  );
                }
                toSchemaFromEntity(e) {
                  return {
                    id: e.id,
                    rootStickerCateId: e.rootStickerCateId,
                    url: e.url,
                    width: e.width,
                    height: e.height,
                  };
                }
              }),
            ) || BI),
        );
        const GI = Object(i.define)("AIStickerAPIClient");
        var xI;
        let zI =
          Object(i.injectable)()(
            (xI = class {
              forwardAIStickerMessage(e, t, s, i, n, a) {
                return Ot.default.apiForwardMessage(
                  e,
                  R.MSG_PHOTO,
                  t,
                  s,
                  i,
                  n,
                  a,
                );
              }
              fetchAIStickerList() {
                const e = { imei: ai.a.getZaloClientID() },
                  t = `${mt.b.getStickerDomain()}/api/message/sticker/ai/list?${this.getCommonParams_()}&params=${this.encodeParams_(e)}`;
                return new Promise((e, s) => {
                  this.makeGETRequest_(t, null, 12190)
                    .then(wn.a)
                    .then(e)
                    .catch(s);
                });
              }
              makeGETRequest_(e, t, s, i, n, a, r, o, d) {
                return Ln.default._get(e, t, s, i, n, a, r, o, d);
              }
              getCommonParams_() {
                return Ln.default._getCommonParams();
              }
              encodeParams_(e) {
                return Ln.default.getEncodedParams(e);
              }
            }),
          ) || xI;
        i.ModuleContainer.register(GI, zI);
        const VI = Object(i.define)("AIStickerLocalStorageDB");
        var HI;
        Object(V.e)()(
          (HI =
            Object(i.injectable)()(
              (HI =
                Object(i.singleton)(VI)(
                  (HI =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (HI =
                        Reflect.metadata(
                          "design:paramtypes",
                          [],
                        )(
                          (HI = class {
                            constructor() {
                              this.tableName_ = "ai_sticker_tbl_1706849065515";
                            }
                            onAuthenticated(e) {}
                            async countAsync() {
                              const e = await this.getRecords_();
                              return e ? e.length : 0;
                            }
                            async getAsync(e) {
                              var t;
                              const s = await this.getRecords_();
                              return s &&
                                null !== (t = s.find((t) => t.id === e)) &&
                                void 0 !== t
                                ? t
                                : null;
                            }
                            async getAllAsync() {
                              return await this.getRecords_();
                            }
                            async insertMultiAsync(e) {
                              var t;
                              const s =
                                  null !== (t = await this.getRecords_()) &&
                                  void 0 !== t
                                    ? t
                                    : [],
                                i = [];
                              e.forEach((e) => {
                                const t = s.findIndex((t) => t.id === e.id);
                                -1 === t ? i.push(e) : (s[t] = e);
                              });
                              const n = [...s, ...i];
                              return await this.writeRecords_(n), e;
                            }
                            async delete(e) {
                              let t = await this.getRecords_();
                              return (
                                !t ||
                                ((t = t.filter((t) => t.id !== e)),
                                await this.writeRecords_(t),
                                !0)
                              );
                            }
                            async deleteAll() {
                              return await this.writeRecords_([]), !0;
                            }
                            async destroyAsync() {
                              const e = this.getLocalStorageDB_();
                              await e.removeItemForCurrentUserAsync(
                                this.tableName_,
                              );
                            }
                            async getMultiAsync(e) {
                              throw new Error("Method not implemented yet!");
                            }
                            async insertAsync(e) {
                              throw new Error("Method not implemented yet!");
                            }
                            async updateAsync(e, t) {
                              throw new Error("Method not implemented yet!");
                            }
                            async deleteMulti(e) {
                              throw new Error("Method not implemented yet!");
                            }
                            getLocalStorageDB_() {
                              return E.default.getInstance();
                            }
                            async getRecords_() {
                              const e = this.getLocalStorageDB_(),
                                t = await e.getItemForCurrentUserAsync(
                                  this.tableName_,
                                );
                              return t ? JSON.parse(t) : null;
                            }
                            async writeRecords_(e) {
                              const t = this.getLocalStorageDB_(),
                                s = JSON.stringify(e);
                              await t.setItemForCurrentUserAsync(
                                this.tableName_,
                                s,
                              );
                            }
                          }),
                        ) || HI),
                    ) || HI),
                ) || HI),
            ) || HI),
        );
        const $I = Object(i.define)("AIStickerRepository");
        var WI;
        Object(i.injectable)()(
          (WI =
            Object(i.singleton)($I)(
              (WI =
                (function (e, t) {
                  return Object(i.inject)(VI)(e, void 0, 0);
                })(
                  (WI =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (WI =
                        Reflect.metadata("design:paramtypes", [Object])(
                          (WI = class {
                            constructor(e) {
                              (this.aiStickerDB_ = void 0),
                                (this.aiStickerDB_ = e);
                            }
                            getFakeAIStickers_() {
                              const e = [];
                              return (
                                e.push(
                                  new kI(
                                    1,
                                    123,
                                    "https://media-ten.z-cdn.me/oXS0nzgaaTQAAAAl/pyonium-cute.webp",
                                    498,
                                    498,
                                  ),
                                ),
                                e.push(
                                  new kI(
                                    2,
                                    123,
                                    "https://media-ten.z-cdn.me/krDtrF9w1wYAAAAl/chinese-dragon-dragon.webp",
                                    498,
                                    498,
                                  ),
                                ),
                                e.push(
                                  new kI(
                                    3,
                                    123,
                                    "https://media-ten.z-cdn.me/XwHQ_iIQT6MAAAAl/dragon-ball.webp",
                                    360,
                                    360,
                                  ),
                                ),
                                e
                              );
                            }
                            async getAllAsync() {
                              return this.getFakeAIStickers_();
                            }
                            async countAsync() {
                              return this.aiStickerDB_.countAsync();
                            }
                            async deleteAll() {
                              return this.aiStickerDB_.deleteAll();
                            }
                            async delete(e) {
                              return this.aiStickerDB_.delete(e);
                            }
                            async insertMultiAsync(e) {
                              const t = e.map((e) => ({
                                id: e.id,
                                rootStickerCateId: e.rootStickerCateId,
                                url: e.url,
                                width: e.width,
                                height: e.height,
                              }));
                              return (
                                await this.aiStickerDB_.insertMultiAsync(t), e
                              );
                            }
                            async insertAsync(e) {
                              throw new Error("Method not implemented yet!");
                            }
                            async updateAsync(e, t) {
                              throw new Error("Method not implemented yet!");
                            }
                            async getAsync(e) {
                              throw new Error("Method not implemented yet!");
                            }
                            async find(e) {
                              throw new Error("Method not implemented yet!");
                            }
                          }),
                        ) || WI),
                    ) || WI),
                ) || WI),
            ) || WI),
        );
        var KI = s("xvqP");
        let qI;
        !(function (e) {
          (e[(e.SUCCESS = 0)] = "SUCCESS"),
            (e[(e.NO_DATA = 252)] = "NO_DATA"),
            (e[(e.MISSING_PARAM = 111)] = "MISSING_PARAM");
        })(qI || (qI = {}));
        var ZI = s("VLUZ");
        let JI;
        !(function (e) {
          (e.SETUP_AI_STICKER_LIST_UPDATER = "SETUP_AI_STICKER_LIST_UPDATER"),
            (e.FETCH_AI_STICKER_LIST = "FETCH_AI_STICKER_LIST"),
            (e.FORWARD_AI_STICKER_MESSAGE = "FORWARD_AI_STICKER_MESSAGE");
        })(JI || (JI = {}));
        class QI extends te.a {
          constructor(e, t) {
            super(JI.SETUP_AI_STICKER_LIST_UPDATER),
              (this.expiredTime = void 0),
              (this.version = void 0),
              (this.expiredTime = e),
              (this.version = t);
          }
        }
        class YI extends te.a {
          constructor(e, t) {
            super(JI.FETCH_AI_STICKER_LIST),
              (this.onCompleted = void 0),
              (this.onFailed = void 0),
              (this.onCompleted = null != e ? e : () => {}),
              (this.onFailed = null != t ? t : () => {});
          }
        }
        class XI extends te.a {
          constructor(e, t, s) {
            super(JI.FORWARD_AI_STICKER_MESSAGE),
              (this.payload = void 0),
              (this.onCompleted = void 0),
              (this.onFailed = void 0),
              (this.payload = null != e ? e : {}),
              (this.onCompleted = null != t ? t : () => {}),
              (this.onFailed = null != s ? s : () => {});
          }
        }
        var ey;
        Object(i.injectable)()(
          (ey =
            Object(V.e)()(
              (ey =
                Object(i.singleton)(KI.c)(
                  (ey =
                    (function (e, t) {
                      return Object(i.inject)(GI)(e, void 0, 0);
                    })(
                      (ey =
                        (function (e, t) {
                          return Object(i.inject)(AI)(e, void 0, 1);
                        })(
                          (ey =
                            Reflect.metadata(
                              "design:type",
                              Function,
                            )(
                              (ey =
                                Reflect.metadata("design:paramtypes", [
                                  Object,
                                  Object,
                                ])(
                                  (ey = class {
                                    constructor(e, t) {
                                      (this.apiClient_ = void 0),
                                        (this.internalEventBus_ = void 0),
                                        (this.apiClient_ = e),
                                        (this.internalEventBus_ = t);
                                    }
                                    onAuthenticated(e) {
                                      this.internalEventBus_.addEventListener(
                                        JI.FETCH_AI_STICKER_LIST,
                                        this.handleFetchAPIStickerListEvent_.bind(
                                          this,
                                        ),
                                      ),
                                        this.internalEventBus_.addEventListener(
                                          JI.FORWARD_AI_STICKER_MESSAGE,
                                          this.handleForwardAPIStickerMessageEvent_.bind(
                                            this,
                                          ),
                                        );
                                    }
                                    getAIStickerList() {
                                      return new Promise((e, t) => {
                                        const s = (t) => {
                                            e({
                                              errorCode: ZI.a.SUCCESS,
                                              data: {
                                                expiredTime: t.expired_time,
                                                version: t.version,
                                                stickers: t.stickers.map(
                                                  (e) => ({
                                                    id: e.id,
                                                    url: e.url,
                                                    width: e.width,
                                                    height: e.height,
                                                    rootStickerCateId:
                                                      e.cateid_root,
                                                  }),
                                                ),
                                              },
                                            });
                                          },
                                          i = (t) => {
                                            e({
                                              errorCode: ZI.a.FAIL,
                                              data: void 0,
                                            });
                                          };
                                        this.apiClient_
                                          .fetchAIStickerList()
                                          .then(s)
                                          .catch((e) => {
                                            this.requestErrorHandler_(
                                              e,
                                              this.getAIStickerList,
                                            )
                                              .then(s)
                                              .catch(i);
                                          });
                                      });
                                    }
                                    handleForwardAPIStickerMessageEvent_(e) {
                                      const {
                                          payload: t,
                                          onCompleted: s,
                                          onFailed: i,
                                        } = e,
                                        n = t.retryTimeout
                                          ? {
                                              count:
                                                bt.default.retryConfig
                                                  .max_retry_count,
                                              timeout: t.retryTimeout,
                                              timestamp: Date.now(),
                                              lowPriority: t.lowPriority,
                                            }
                                          : null,
                                        a = Ki.a.newReq();
                                      this.apiClient_
                                        .forwardAIStickerMessage(
                                          t.toUid,
                                          t.messageContent,
                                          t.clientMsgId,
                                          n,
                                          a,
                                          t.additional,
                                        )
                                        .then(s)
                                        .catch(i);
                                    }
                                    handleFetchAPIStickerListEvent_(e) {
                                      this.getAIStickerList()
                                        .then(e.onCompleted)
                                        .catch(e.onFailed);
                                    }
                                    requestErrorHandler_(e, t, s) {
                                      return (
                                        void 0 === s && (s = 0),
                                        new Promise((i, n) => {
                                          if (s >= 1) return n(e);
                                          let a = -1;
                                          switch (
                                            e
                                              ? e.error_code || e.code
                                              : "UNKNOWN"
                                          ) {
                                            case 112:
                                              a = 5e3;
                                              break;
                                            case "ERR_NO_NETWORK":
                                            case "ERR_CONNECTION_TIMED_OUT":
                                              a = 1e4;
                                              break;
                                            default:
                                              a = -1;
                                          }
                                          if (a < 0) return n(e);
                                          setTimeout(() => {
                                            t()
                                              .then(i)
                                              .catch((e) => {
                                                this.requestErrorHandler_(
                                                  e,
                                                  t,
                                                  s + 1,
                                                )
                                                  .then(i)
                                                  .catch(n);
                                              });
                                          }, a);
                                        })
                                      );
                                    }
                                  }),
                                ) || ey),
                            ) || ey),
                        ) || ey),
                    ) || ey),
                ) || ey),
            ) || ey),
        );
        const ty = "ai_sticker_list_ver_1706778251026",
          sy = "ai_sticker_list_expt_1707057455164";
        class iy {
          constructor() {
            (this.aiStickerListVersion_ = null),
              (this.versionExpiredTime_ = null);
          }
          getAIStickerListVersion() {
            if (null == this.aiStickerListVersion_) {
              const t = E.default.getInstance().getItemForCurrentUser(ty);
              let s = NI.b;
              if (t)
                try {
                  s = JSON.parse(t);
                } catch (e) {}
              this.aiStickerListVersion_ = s;
            }
            return this.aiStickerListVersion_;
          }
          setAIStickerListVersion(e) {
            this.aiStickerListVersion_ = e;
            E.default
              .getInstance()
              .setItemForCurrentUser(ty, JSON.stringify(e));
          }
          getVersionExpiredTime() {
            if (null == this.versionExpiredTime_) {
              const t = E.default.getInstance().getItemForCurrentUser(sy);
              let s = -1;
              if (t)
                try {
                  s = JSON.parse(t);
                } catch (e) {}
              this.versionExpiredTime_ = s;
            }
            return this.versionExpiredTime_;
          }
          setVersionExpiredTime(e) {
            this.versionExpiredTime_ = e;
            E.default
              .getInstance()
              .setItemForCurrentUser(sy, JSON.stringify(e));
          }
        }
        (iy.NOT_AI_STICKER_LIST_VERSION = NI.b),
          (iy.NOT_VERSION_EXPIRED_TIME = -1);
        var ny,
          ay = new iy();
        let ry =
          Object(i.injectable)()(
            (ny =
              (function (e, t) {
                return Object(i.inject)(PI)(e, void 0, 0);
              })(
                (ny =
                  (function (e, t) {
                    return Object(i.inject)($I)(e, void 0, 1);
                  })(
                    (ny =
                      (function (e, t) {
                        return Object(i.inject)(AI)(e, void 0, 2);
                      })(
                        (ny =
                          Reflect.metadata(
                            "design:type",
                            Function,
                          )(
                            (ny =
                              Reflect.metadata("design:paramtypes", [
                                Object,
                                Object,
                                Object,
                              ])(
                                (ny = class {
                                  constructor(e, t, s) {
                                    (this.aiStickerListVersion_ = void 0),
                                      (this.aiStickerMapper_ = void 0),
                                      (this.aiStickerRepository_ = void 0),
                                      (this.internalEventBus_ = void 0),
                                      (this.aiStickerMapper_ = e),
                                      (this.aiStickerRepository_ = t),
                                      (this.internalEventBus_ = s),
                                      (this.aiStickerListVersion_ = ay);
                                  }
                                  transformFromAIStickerMessage(e) {
                                    var t, s, i, n, a;
                                    const r = e.content,
                                      o = e.content.parsedParams,
                                      d = o.contentId,
                                      l =
                                        null !==
                                          (t =
                                            null !==
                                              (s =
                                                null !== (i = r.oriUrl) &&
                                                void 0 !== i
                                                  ? i
                                                  : r.hdUrl) && void 0 !== s
                                              ? s
                                              : null === (n = o.webp) ||
                                                  void 0 === n
                                                ? void 0
                                                : n.url) && void 0 !== t
                                          ? t
                                          : "";
                                    return {
                                      id: d,
                                      url: l,
                                      thumb:
                                        null !== (a = r.thumbUrl) &&
                                        void 0 !== a
                                          ? a
                                          : l,
                                      intrinsicWidth: o.width,
                                      intrinsicHeight: o.height,
                                      renderedWidth: Object(DI.a)().config
                                        .ai_sticker_message.w,
                                      renderedHeight: Object(DI.a)().config
                                        .ai_sticker_message.h,
                                      animatable: undefined,
                                      type: NI.f.AI_GENERATED,
                                      extra: { fromSrc: NI.a.MESSAGE },
                                    };
                                  }
                                  transformRecentAIStickerFromAISticker(e) {
                                    return Object(f.a)(
                                      Object(f.a)({}, e),
                                      {},
                                      { extra: { fromSrc: NI.a.RECENT } },
                                    );
                                  }
                                  transformFromAIStickerMessageContent(e) {
                                    throw new Error(
                                      "Method does not be implemented yet!",
                                    );
                                  }
                                  isValidAISticker(e) {
                                    const t = !!e.id,
                                      s = !!e.url,
                                      i = e.type === NI.f.AI_GENERATED;
                                    return t && s && i;
                                  }
                                  isValidAIStickerFromRecentStickerPanel(e) {
                                    var t;
                                    return (
                                      (null == e ||
                                      null === (t = e.extra) ||
                                      void 0 === t
                                        ? void 0
                                        : t.fromSrc) === NI.a.RECENT
                                    );
                                  }
                                  async getAIStickerList() {
                                    let e =
                                      await this.aiStickerRepository_.getAllAsync();
                                    if (
                                      (!e || 0 === e.length) &&
                                      this.aiStickerListVersion_.getAIStickerListVersion() ===
                                        iy.NOT_AI_STICKER_LIST_VERSION
                                    ) {
                                      e = (await this.syncAIStickerList_())
                                        ? await this.aiStickerRepository_.getAllAsync()
                                        : [];
                                    }
                                    return e.map((e) =>
                                      this.aiStickerMapper_.toAIStickerDTOFromDomain(
                                        e,
                                      ),
                                    );
                                  }
                                  getAIStickerListVersion() {
                                    return this.aiStickerListVersion_.getAIStickerListVersion();
                                  }
                                  async syncAIStickerList_() {
                                    return new Promise((e, t) => {
                                      const s = () => {
                                          e(!1);
                                        },
                                        i = new YI(async (t) => {
                                          try {
                                            if (t.errorCode === ZI.a.SUCCESS) {
                                              const s = t.data;
                                              if (
                                                s.version >
                                                this.aiStickerListVersion_.getAIStickerListVersion()
                                              ) {
                                                const t = s.stickers.map(
                                                  (e) =>
                                                    new kI(
                                                      e.id,
                                                      e.rootStickerCateId,
                                                      e.url,
                                                      e.width,
                                                      e.height,
                                                    ),
                                                );
                                                await this.aiStickerRepository_.insertMultiAsync(
                                                  t,
                                                ),
                                                  this.aiStickerListVersion_.setAIStickerListVersion(
                                                    s.version,
                                                  ),
                                                  s.expiredTime &&
                                                    (this.aiStickerListVersion_.setVersionExpiredTime(
                                                      s.expiredTime,
                                                    ),
                                                    this.internalEventBus_.dispatchEvent(
                                                      new QI(
                                                        s.expiredTime,
                                                        s.version,
                                                      ),
                                                    )),
                                                  e(!0);
                                              }
                                            }
                                            e(!1);
                                          } catch (i) {
                                            s();
                                          }
                                        }, s);
                                      this.internalEventBus_.dispatchEvent(i);
                                    });
                                  }
                                }),
                              ) || ny),
                          ) || ny),
                      ) || ny),
                  ) || ny),
              ) || ny),
          ) || ny;
        i.ModuleContainer.register(KI.a, ry);
        var oy = i.ModuleContainer.resolve(q.ZLoggerFactory).createZLogger(
          hs.ZLoggerNametags.common,
          [],
        );
        function dy(e) {
          return JSON.parse(e);
        }
        function ly(e, t) {
          if ("object" == typeof e) return e;
          try {
            e = dy(e);
          } catch (s) {
            oy.zsymb(
              18,
              16174,
              3e4,
              "Parse json failed",
              String(e).slice(0, 100),
            ),
              (e = t);
          }
          return e;
        }
        function cy(e) {
          return dy(e);
        }
        function hy(e) {
          var t;
          if (!e) return;
          let s = { message: "" };
          if ("string" == typeof e.msg) s.message = e.msg;
          else
            try {
              const t = e.msg;
              s = Object(f.a)(
                Object(f.a)({}, t),
                {},
                { message: t.title || "" },
              );
            } catch (n) {}
          const i = null !== (t = e.ownerId) && void 0 !== t ? t : e.fromUid;
          return Object(f.a)(
            Object(f.a)({}, e),
            {},
            {
              attachment: cy.deep(e.attach),
              rootClientMessageID: e.cliMsgId,
              rootClientMessageType: e.cliMsgType,
              rootContent: s,
              rootGlobalMessageID: e.globalMsgId,
              rootSentTime: +e.ts,
              rootSenderName: Ye.default.getDName(i),
              rootSenderID: i,
              ttl: e.ttl,
            },
          );
        }
        function uy(e) {
          if (e)
            return {
              fromID: e.fromId,
              icon: e.icon,
              isGroup: Boolean(e.isGroup),
              isMessageInfo: Boolean(e.isMsgInfo),
              senderAvatar: e.senderAvatar,
              senderDisplayName: e.senderDisplayName,
              threadID: e.threadId,
              timestamp: e.ts,
              ttl: e.ttl,
            };
        }
        (cy.noExceptions = function (e) {
          try {
            return cy(e);
          } catch (t) {
            return void Logger.zsymb(
              18,
              16174,
              30001,
              "Parse json failed",
              String(e).slice(0, 100),
            );
          }
        }),
          (cy.fallback = ly),
          (cy.fallbackSelf = function (e) {
            return ly(e, e);
          }),
          (cy.deep = function e(t) {
            const s = (e) => !isNaN(Number(e));
            if ("string" != typeof t)
              return Array.isArray(t)
                ? t.map((t) => e(t))
                : "object" == typeof t && null != t
                  ? Object.keys(t).reduce((i, n) => {
                      const a = t[n];
                      return (i[n] = s(a) ? a : e(a)), i;
                    }, {})
                  : t;
            if (s(t)) return t;
            try {
              return e(dy(t));
            } catch (i) {
              return t;
            }
          });
        function gy(e) {
          return e
            ? Object(f.a)(
                Object(f.a)({}, e),
                {},
                {
                  contentId: e.contentId,
                  pStickerType: e.pStickerType,
                  webp: {
                    width: e.webp.width,
                    height: e.webp.height,
                    url: e.webp.url,
                  },
                  height: e.height,
                  width: e.width,
                  thumbHeight: e.thumb_height,
                  thumbWidth: e.thumb_width,
                },
              )
            : {
                contentId: "",
                width: -1,
                height: -1,
                thumbWidth: -1,
                thumbHeight: -1,
                pStickerType: NI.c.AI_STICKER,
                webp: { width: -1, height: -1, url: "" },
              };
        }
        function my(e) {
          if (!e)
            return {
              title: "",
              description: "",
              oriUrl: "",
              thumbUrl: "",
              hdUrl: "",
              parsedParams: gy(null),
            };
          const t = e.params;
          let s = gy(null);
          if ("string" == typeof t)
            try {
              s = gy(JSON.parse(t));
            } catch (oC) {
              0;
            }
          else "object" == typeof t && (s = gy(t));
          return Object(f.a)(
            Object(f.a)({}, e),
            {},
            {
              title: e.title,
              description: e.description,
              hdUrl: e.hdUrl,
              oriUrl: e.oriUrl,
              thumbUrl: e.thumbUrl,
              parsedParams: s,
            },
          );
        }
        function py(e) {
          if (!e)
            return {
              color: -1,
              size: -1,
              subType: -1,
              type: -1,
              parsedExt: { sSrcStr: "", sSrcType: -1 },
            };
          const t = e.ext;
          let s = { sSrcStr: "", sSrcType: -1 };
          if ("string" == typeof t)
            try {
              s = JSON.parse(t);
            } catch (oC) {
              0;
            }
          else "object" == typeof t && (s = t);
          return Object(f.a)(
            Object(f.a)({}, e),
            {},
            {
              color: e.color,
              size: e.size,
              subType: e.subType,
              type: e.type,
              parsedExt: s,
            },
          );
        }
        function fy(e) {
          return Object(f.a)(
            Object(f.a)(
              {},
              (function (e) {
                if (e)
                  return Object(f.a)(
                    Object(f.a)({}, e),
                    {},
                    {
                      actionID: e.actionId,
                      clientMessageID: e.cliMsgId,
                      e2eeStatus: e.e2eeStatus,
                      eventInfo: uy(e.eventInfo),
                      extra: e.extra,
                      fromUID: String(e.fromUid),
                      messageID: e.msgId,
                      platformType: e.platformType,
                      quote: hy(e.quote),
                      sentSource: e.src,
                      sentTime: +e.sendDttm,
                      serverTime: +e.serverTime,
                      status: e.status,
                      syncFromMobile: e.syncFromMobile,
                      toUID: String(e.toUid),
                      ttl: e.ttl,
                      type: -1,
                    },
                  );
              })(e),
            ),
            {},
            {
              content: my(e.message),
              type: 9999,
              src: e.src,
              msgType: e.msgType,
              originMsgType: "chat.photo",
              properties: py(e.properties),
            },
          );
        }
        var vy,
          by = s("bKjh");
        let Iy =
          Object(i.injectable)()(
            (vy =
              (function (e, t) {
                return Object(i.inject)(AI)(e, void 0, 0);
              })(
                (vy =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (vy =
                      Reflect.metadata("design:paramtypes", [Object])(
                        (vy = class {
                          constructor(e) {
                            (this.internalEventBus_ = void 0),
                              (this.internalEventBus_ = e);
                          }
                          isAIStickerMessageObject(e) {
                            return Object(by.b)(e);
                          }
                          isAIStickerMessage(e) {
                            return Object(by.a)(e);
                          }
                          isOldAIStickerMessage(e) {
                            return Object(by.e)(e);
                          }
                          isNewAIStickerMessage(e) {
                            return Object(by.d)(e);
                          }
                          transformFromRawMessage(e) {
                            return fy(e);
                          }
                          transformAIStickerMessageObjectFromAISticker(e, t) {
                            return {
                              toId: e,
                              sendByUrl: !0,
                              title: "",
                              description: "",
                              file: {},
                              img: t.url,
                              oriUrl: t.url,
                              thumbUrl: t.thumb || t.url,
                              hdUrl: t.url,
                              width: t.intrinsicWidth,
                              height: t.intrinsicHeight,
                              params: {
                                contentId: t.id,
                                pStickerType: NI.c.AI_STICKER,
                                height: t.intrinsicHeight,
                                width: t.intrinsicWidth,
                                thumb_width: t.intrinsicWidth,
                                thumb_height: t.intrinsicHeight,
                                webp: {
                                  width: t.intrinsicWidth,
                                  height: t.intrinsicHeight,
                                  url: t.url,
                                },
                              },
                              properties: {
                                subType: 0,
                                color: -1,
                                size: -1,
                                type: R.MSG_BUBBLE_LAYOUT_TYPE_NO_BORDER,
                                ext: { sSrcStr: NI.d.AI, sSrcType: NI.e.AI },
                              },
                            };
                          }
                          forwardAIStickerMessage(e, t, s, i) {
                            return (
                              void 0 === i &&
                                (i = {
                                  retryTimeout: 0,
                                  lowPriority: !1,
                                  fwAdditional: {},
                                }),
                              new Promise((n, a) => {
                                const r =
                                  s.content.parsedParams.webp.url ||
                                  s.content.oriUrl;
                                if (!r) return a();
                                this.checkAlive_(r, {
                                  count:
                                    bt.default.retryConfig
                                      .max_normal_request_retry_count,
                                })
                                  .then(() => {
                                    var r, o, d, l, c, h;
                                    const u = {
                                        description: "",
                                        title: "",
                                        oriUrl: s.content.oriUrl,
                                        thumbUrl: s.content.thumbUrl,
                                        normalUrl: s.content.normalUrl,
                                        hdUrl:
                                          s.content.hdUrl ||
                                          s.content.normalUrl,
                                        contentId:
                                          s.content.parsedParams.contentId,
                                        thumb_width:
                                          null !==
                                            (r =
                                              s.content.parsedParams
                                                .thumbWidth) && void 0 !== r
                                            ? r
                                            : s.content.parsedParams.width,
                                        thumb_height:
                                          null !==
                                            (o =
                                              s.content.parsedParams
                                                .thumbHeight) && void 0 !== o
                                            ? o
                                            : s.content.parsedParams.height,
                                        webp: JSON.stringify(
                                          s.content.parsedParams.webp,
                                        ),
                                        width: s.content.parsedParams.width,
                                        height: s.content.parsedParams.height,
                                        properties: JSON.stringify({
                                          color: s.properties.color,
                                          size: s.properties.size,
                                          subType: s.properties.subType,
                                          type: s.properties.type,
                                          ext: JSON.stringify(
                                            s.properties.parsedExt,
                                          ),
                                        }),
                                        pStickerType:
                                          s.content.parsedParams.pStickerType,
                                        photoId:
                                          null !== (d = s.content.photoId) &&
                                          void 0 !== d
                                            ? d
                                            : 1,
                                      },
                                      g = s.e2eeStatus === R.MSG_E2EE;
                                    g && (u.isAISticker = !0);
                                    const m = new XI(
                                      {
                                        toUid: e,
                                        clientMsgId: t,
                                        lowPriority:
                                          null !== (l = i.lowPriority) &&
                                          void 0 !== l &&
                                          l,
                                        retryTimeout:
                                          null !== (c = i.retryTimeout) &&
                                          void 0 !== c
                                            ? c
                                            : 0,
                                        messageContent: u,
                                        additional:
                                          null !== (h = i.fwAdditional) &&
                                          void 0 !== h
                                            ? h
                                            : {},
                                      },
                                      async (e) => {
                                        if (g) n(e);
                                        else {
                                          const t = {
                                            msgId: e.msgId + "",
                                            thumbUrl: s.content.thumbUrl,
                                            hdUrl: s.content.hdUrl,
                                            oriUrl: s.content.oriUrl,
                                            width: s.content.parsedParams.width,
                                            height:
                                              s.content.parsedParams.height,
                                          };
                                          n(t);
                                        }
                                      },
                                      async (e) => {
                                        a(e);
                                      },
                                    );
                                    this.internalEventBus_.dispatchEvent(m);
                                  })
                                  .catch(a);
                              })
                            );
                          }
                          checkAlive_(e, t) {
                            return new Promise((s, n) => {
                              Ct.default
                                .checkAlive(e)
                                .then(s)
                                .catch((a) => {
                                  if (
                                    bt.default.retryConfig
                                      .enable_add_missing_retry &&
                                    a ===
                                      Rg.XMLHttpRequestErrorCode.NO_RESPONSE &&
                                    t.count
                                  ) {
                                    t.count = t.count - 1;
                                    const a = () =>
                                      this.checkAlive_(e, t).then(s).catch(n);
                                    i.ModuleContainer.resolve(
                                      Rg.ConnectionPendingController,
                                    ).pushToRetryQueue(a);
                                  } else n(a);
                                });
                            });
                          }
                        }),
                      ) || vy),
                  ) || vy),
              ) || vy),
          ) || vy;
        i.ModuleContainer.register(KI.b, Iy);
        var yy,
          _y = s("56jR"),
          Oy = s("397E"),
          Cy = s("RJlJ");
        Object(i.injectable)()(
          (yy =
            Object(V.e)()(
              (yy =
                Object($t.b)(Oy.b)(
                  (yy =
                    Object(i.singleton)(Oy.b)(
                      (yy =
                        (function (e, t) {
                          return Object(i.inject)(KI.a)(e, void 0, 0);
                        })(
                          (yy =
                            Reflect.metadata(
                              "design:type",
                              Function,
                            )(
                              (yy =
                                Reflect.metadata("design:paramtypes", [
                                  void 0 === _y.IAIStickerAppService
                                    ? Object
                                    : _y.IAIStickerAppService,
                                ])(
                                  (yy = class {
                                    constructor(e) {
                                      (this.aiStickerService_ = void 0),
                                        (this.state_ = {
                                          version: NI.b,
                                          aiStickers: [],
                                        }),
                                        (this.name = Oy.a),
                                        (this.key = Cy.a),
                                        (this.aiStickerService_ = e);
                                    }
                                    onAuthenticated(e) {
                                      Object(DI.a)().isEnable("AIStickerTab") &&
                                        this.aiStickerService_
                                          .getAIStickerList()
                                          .then((e) => {
                                            (this.state_.version =
                                              this.aiStickerService_.getAIStickerListVersion()),
                                              (this.state_.aiStickers = e),
                                              Object(nt.g)(this.name, this.key);
                                          });
                                    }
                                    getAIStickerList() {
                                      return this.state_.aiStickers;
                                    }
                                    init() {}
                                    getItem(e) {
                                      if (e.key === this.key)
                                        return this.state_;
                                    }
                                    getList(e, t) {
                                      return [];
                                    }
                                    onGetItemFailure(e, t) {
                                      0;
                                    }
                                    onGetListFailure(e, t) {
                                      0;
                                    }
                                  }),
                                ) || yy),
                            ) || yy),
                        ) || yy),
                    ) || yy),
                ) || yy),
            ) || yy),
        );
        var Ey = s("T6Qc"),
          My = s("RYTL");
        const Sy = Object(My.b)("socket-polling"),
          Ty = Object(My.b)("event-bus"),
          wy = Object(My.b)("z-storage"),
          Ry = Object(My.b)("z-search-v3"),
          Ly = Object(My.b)("actionlog-service"),
          Dy = Object(My.b)("important-message-manager"),
          Fy = Object(My.b)("sync-message-controller");
        class Ay extends te.a {
          constructor(e) {
            super("update"), (this.config = e);
          }
        }
        class jy extends te.b {
          constructor(e) {
            super(),
              (this.config = void 0),
              (this.options = void 0),
              (this.config = e.default),
              (this.options = e),
              (this.listener = this.listener.bind(this)),
              this.registerListener();
          }
          registerListener() {
            Mt.default.on("server-info-config", this.listener),
              Mt.default.on("authen-info-config", this.listener);
          }
          listener(e) {
            const t = this.selector(e);
            if (!t) return;
            const s = this.options.valiator.validateWithFallback(
                t,
                this.options.default,
                !0,
              ),
              i = this.merge(this.config, s);
            this.shouldConfigUpdate(this.config, i) &&
              ((this.config = i), this.dispatchEvent(new Ay(i)));
          }
          merge(e, t) {
            return Object(f.a)(
              Object(f.a)(Object(f.a)({}, this.options.default), e),
              t,
            );
          }
          shouldConfigUpdate(e, t) {
            return e === t;
          }
          get(e) {
            return b()(this.config, e);
          }
          set(e, t) {
            return y()(this.config, e, t), this;
          }
        }
        var Py,
          Ny = s("KBxP");
        const Uy = new mf.a({
          enable: mf.b.field().boolean(),
          batch_size: mf.b.field().number().min(0),
          enable_fetch_foreground: mf.b.field().boolean(),
          enable_segment_updater: mf.b.field().boolean(),
          enable_tracking_overflow: mf.b.field().boolean(),
          min_throttle: mf.b.field().number().min(100),
          throttle: mf.b.field().number().min(0),
          throttle_idle: mf.b.field().number(),
          queue_config: mf.b.field().array("string"),
          interval_check_insufficient_data: mf.b.field().number().min(0),
          max_time_check_insufficient_data: mf.b.field().number().min(0),
          max_retry_batch: mf.b.field().number().min(0),
          retry_strategy: mf.b.field().string().oneOf(["fibo", "linear"]),
          time_exclude: mf.b.field().array("number"),
          debugger: mf.b.field().schema({
            show_msg_src: mf.b.field().boolean(),
            logger: mf.b.field().schema({
              machine_transition: mf.b.field().boolean(),
              save_message: mf.b.field().boolean(),
              batch_request_info: mf.b.field().boolean(),
              interval_update_sufficient_ts: mf.b.field().boolean(),
            }),
            simulator: mf.b.field().schema({
              overflow_db_group_offline: mf.b.field().boolean(),
              slow_load_message: mf.b.field().boolean(),
            }),
          }),
        });
        let ky =
          Object(My.d)()(
            (Py =
              Object(My.e)(Ey.b)(
                (Py =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (Py =
                      Reflect.metadata(
                        "design:paramtypes",
                        [],
                      )(
                        (Py = class extends jy {
                          constructor() {
                            super({ default: Ny.b, valiator: Uy });
                          }
                          selector(e) {
                            return e.auto_fetch_msg_mini_cloud || {};
                          }
                          shouldConfigUpdate(e, t) {
                            return !new Ba.e.Comparer(e, t, !0)
                              .AND("enable")
                              .AND("batch_size")
                              .AND("min_throttle")
                              .AND("enable_fetch_foreground")
                              .AND("enable_segment_updater")
                              .AND("enable_tracking_overflow")
                              .AND("throttle")
                              .AND("throttle_idle")
                              .AND("queue_config")
                              .AND("interval_check_insufficient_data")
                              .AND("max_time_check_insufficient_data")
                              .AND("max_retry_batch")
                              .AND("retry_strategy")
                              .AND("time_exclude")
                              .AND("debugger", uf.a.isEqual)
                              .exec();
                          }
                        }),
                      ) || Py),
                  ) || Py),
              ) || Py),
          ) || Py;
        var By = s("7Yx4");
        let Gy, xy;
        !(function (e) {
          e.OVERFLOW_DB_GROUP_OFFLINE = "OVERFLOW_DB_GROUP_OFFLINE";
        })(Gy || (Gy = {})),
          (function (e) {
            (e.EMPTY = "EMPTY"), (e.RESET = "RESET"), (e.LOADED = "LOADED");
          })(xy || (xy = {}));
        var zy = s("j8Zv");
        let Vy, Hy;
        !(function (e) {
          (e[(e.ONLY_1_1 = 0)] = "ONLY_1_1"),
            (e[(e.ONLY_GROUP = 1)] = "ONLY_GROUP"),
            (e[(e.BOTH_1_1_AND_GROUP = 2)] = "BOTH_1_1_AND_GROUP"),
            (e[(e.NONE = 3)] = "NONE");
        })(Vy || (Vy = {})),
          (function (e) {
            e.SHOW_SYNC_MESSAGE_SUGGESTION = "SHOW_SYNC_MESSAGE_SUGGESTION";
          })(Hy || (Hy = {}));
        class $y extends te.a {
          constructor(e) {
            super(Hy.SHOW_SYNC_MESSAGE_SUGGESTION), (this.queueId = e);
          }
        }
        var Wy;
        let Ky,
          qy =
            Object(My.d)()(
              (Wy =
                Object(Ga.e)()(
                  (Wy =
                    Object(My.e)(Ey.c)(
                      (Wy =
                        (function (e, t) {
                          return i.ModuleContainer.inject(q.ZLoggerFactory)(
                            e,
                            void 0,
                            0,
                          );
                        })(
                          (Wy =
                            (function (e, t) {
                              return i.ModuleContainer.inject(yt)(e, void 0, 1);
                            })(
                              (Wy =
                                (function (e, t) {
                                  return Object(Ga.d)(Ey.b)(e, void 0, 2);
                                })(
                                  (Wy =
                                    (function (e, t) {
                                      return Object(Ga.d)(Ey.n)(e, void 0, 3);
                                    })(
                                      (Wy =
                                        (function (e, t) {
                                          return Object(Ga.d)(Ey.h)(
                                            e,
                                            void 0,
                                            4,
                                          );
                                        })(
                                          (Wy =
                                            (function (e, t) {
                                              return Object(Ga.d)(Ey.k)(
                                                e,
                                                void 0,
                                                5,
                                              );
                                            })(
                                              (Wy =
                                                (function (e, t) {
                                                  return Object(Ga.d)(Ey.o)(
                                                    e,
                                                    void 0,
                                                    6,
                                                  );
                                                })(
                                                  (Wy =
                                                    (function (e, t) {
                                                      return Object(Ga.d)(Ey.i)(
                                                        e,
                                                        void 0,
                                                        7,
                                                      );
                                                    })(
                                                      (Wy =
                                                        (function (e, t) {
                                                          return Object(Ga.d)(
                                                            Ey.r,
                                                          )(e, void 0, 8);
                                                        })(
                                                          (Wy =
                                                            (function (e, t) {
                                                              return Object(
                                                                Ga.d,
                                                              )(Ey.e)(
                                                                e,
                                                                void 0,
                                                                9,
                                                              );
                                                            })(
                                                              (Wy =
                                                                Reflect.metadata(
                                                                  "design:type",
                                                                  Function,
                                                                )(
                                                                  (Wy =
                                                                    Reflect.metadata(
                                                                      "design:paramtypes",
                                                                      [
                                                                        void 0 ===
                                                                        q.ZLoggerFactory
                                                                          ? Object
                                                                          : q.ZLoggerFactory,
                                                                        "undefined" ==
                                                                        typeof ISystemTime
                                                                          ? Object
                                                                          : ISystemTime,
                                                                        "undefined" ==
                                                                        typeof AFMC_IConfig
                                                                          ? Object
                                                                          : AFMC_IConfig,
                                                                        "undefined" ==
                                                                        typeof AFMC_IService
                                                                          ? Object
                                                                          : AFMC_IService,
                                                                        "undefined" ==
                                                                        typeof AFMC_ILedger
                                                                          ? Object
                                                                          : AFMC_ILedger,
                                                                        "undefined" ==
                                                                        typeof AFMC_IMetrics
                                                                          ? Object
                                                                          : AFMC_IMetrics,
                                                                        "undefined" ==
                                                                        typeof AFMC_IStorage
                                                                          ? Object
                                                                          : AFMC_IStorage,
                                                                        "undefined" ==
                                                                        typeof AFMC_IMachine
                                                                          ? Object
                                                                          : AFMC_IMachine,
                                                                        "undefined" ==
                                                                        typeof AFMC_ITrackingOverflowMessage
                                                                          ? Object
                                                                          : AFMC_ITrackingOverflowMessage,
                                                                        "undefined" ==
                                                                        typeof AFMC_IEventCollector
                                                                          ? Object
                                                                          : AFMC_IEventCollector,
                                                                      ],
                                                                    )(
                                                                      (Wy = class extends (
                                                                        te.b
                                                                      ) {
                                                                        constructor(
                                                                          e,
                                                                          t,
                                                                          s,
                                                                          i,
                                                                          n,
                                                                          a,
                                                                          r,
                                                                          o,
                                                                          d,
                                                                          l,
                                                                        ) {
                                                                          super(),
                                                                            (this.logger =
                                                                              void 0),
                                                                            (this.service =
                                                                              void 0),
                                                                            (this.ledger =
                                                                              void 0),
                                                                            (this.metrics =
                                                                              void 0),
                                                                            (this.storage =
                                                                              void 0),
                                                                            (this.systemTime =
                                                                              void 0),
                                                                            (this.fetcherMachine =
                                                                              void 0),
                                                                            (this.eventCollector =
                                                                              void 0),
                                                                            (this.trackingOverflow =
                                                                              void 0),
                                                                            (this.config =
                                                                              void 0),
                                                                            (this.isInsufficientMessage =
                                                                              void 0),
                                                                            (this.onOverflowDBGroupOffline =
                                                                              () => {
                                                                                this.logger.zsymb(
                                                                                  0,
                                                                                  16696,
                                                                                  30004,
                                                                                  "DB Group offline overflow, should suggest sync message",
                                                                                ),
                                                                                  this.dispatchEvent(
                                                                                    new $y(
                                                                                      zy.a.SOCKET_MESSAGE_GROUP,
                                                                                    ),
                                                                                  );
                                                                              }),
                                                                            (this.onConfigUpdate =
                                                                              (
                                                                                e,
                                                                              ) => {
                                                                                !0 ===
                                                                                e
                                                                                  .config
                                                                                  .enable
                                                                                  ? (this.logger.zsymb(
                                                                                      0,
                                                                                      16696,
                                                                                      30005,
                                                                                      "Receive config enabled, let start machine",
                                                                                    ),
                                                                                    this.registerMachineListener(),
                                                                                    this.fetcherMachine.start())
                                                                                  : (this.logger.zsymb(
                                                                                      0,
                                                                                      16696,
                                                                                      30006,
                                                                                      "Receive config disabled, let stop machine",
                                                                                    ),
                                                                                    this.fetcherMachine.stop(),
                                                                                    this.unregisterMachineListener());
                                                                              }),
                                                                            (this.onMachineTransition =
                                                                              (
                                                                                e,
                                                                              ) => {
                                                                                switch (
                                                                                  e
                                                                                    .event
                                                                                    .type
                                                                                ) {
                                                                                  case "START":
                                                                                    this.onMachineStartFetch();
                                                                                    break;
                                                                                  case "STOP":
                                                                                    this.onMachineStopFetch();
                                                                                }
                                                                                this.config.get(
                                                                                  "debugger.logger.machine_transition",
                                                                                ) &&
                                                                                  this.logger.zsymb(
                                                                                    12,
                                                                                    16696,
                                                                                    30007,
                                                                                    "machine transition",
                                                                                    JSON.stringify(
                                                                                      e.value,
                                                                                    ),
                                                                                  );
                                                                              }),
                                                                            (this.onMachineStop =
                                                                              () => {
                                                                                this.logger.zsymb(
                                                                                  0,
                                                                                  16696,
                                                                                  30008,
                                                                                  "Machine is stopped",
                                                                                );
                                                                              }),
                                                                            (this.onMachineStartFetch =
                                                                              async () => {
                                                                                const e =
                                                                                    (this.isInsufficientMessage =
                                                                                      await this.service.isInsufficientMessage()),
                                                                                  t =
                                                                                    this.trackingOverflow.getOverflowStatus(),
                                                                                  s =
                                                                                    this.fetcherMachine.hasRemainConvInPrevSession();
                                                                                if (
                                                                                  e
                                                                                )
                                                                                  this.dispatchEvent(
                                                                                    new $y(
                                                                                      zy.a.SOCKET_MESSAGE_GROUP,
                                                                                    ),
                                                                                  ),
                                                                                    this.logger.zsymb(
                                                                                      0,
                                                                                      16696,
                                                                                      30009,
                                                                                      "User messages may not be enough, should suggest sync message",
                                                                                    ),
                                                                                    this.metrics.logAutoShowBannerSuggestion(
                                                                                      s,
                                                                                    );
                                                                                else if (
                                                                                  (this.logger.zsymb(
                                                                                    0,
                                                                                    16696,
                                                                                    30010,
                                                                                    "Can cover overflow by fetch message from mini-cloud",
                                                                                  ),
                                                                                  t ===
                                                                                    Vy.ONLY_GROUP)
                                                                                )
                                                                                  this.metrics.logAutoHideBannerSuggestion();
                                                                                else
                                                                                  this.metrics.logAutoShowBannerSuggestion(
                                                                                    s,
                                                                                  );
                                                                                this.metrics.logStartFetch(
                                                                                  e,
                                                                                  t,
                                                                                );
                                                                              }),
                                                                            (this.onMachineStopFetch =
                                                                              async () => {
                                                                                const e =
                                                                                  0 ===
                                                                                  (await this.ledger.size());
                                                                                e
                                                                                  ? (this.logger.zsymb(
                                                                                      0,
                                                                                      16696,
                                                                                      30011,
                                                                                      "fetch done",
                                                                                    ),
                                                                                    this.storage.saveLastFetchSuccess(
                                                                                      this.systemTime.getTimeNow(),
                                                                                    ))
                                                                                  : this.logger.zsymb(
                                                                                      18,
                                                                                      16696,
                                                                                      30012,
                                                                                      "fetch stop",
                                                                                    ),
                                                                                  this.metrics.logStopFetch(
                                                                                    this
                                                                                      .isInsufficientMessage,
                                                                                    this.trackingOverflow.getOverflowStatus(),
                                                                                    e,
                                                                                  );
                                                                              }),
                                                                            (this.onOverflowMessageQueue =
                                                                              async (
                                                                                e,
                                                                              ) =>
                                                                                !1 ===
                                                                                this.config.get(
                                                                                  "enable",
                                                                                )
                                                                                  ? (this.logger.zsymb(
                                                                                      0,
                                                                                      16696,
                                                                                      30013,
                                                                                      "Module is disabled, should suggest sync message",
                                                                                    ),
                                                                                    void this.dispatchEvent(
                                                                                      new $y(
                                                                                        e.queueId,
                                                                                      ),
                                                                                    ))
                                                                                  : !1 ===
                                                                                      this.service.isQueueMessageGroup(
                                                                                        e.queueId,
                                                                                      )
                                                                                    ? (this.logger.zsymb(
                                                                                        0,
                                                                                        16696,
                                                                                        30014,
                                                                                        "Detected overflow other queue, forward event to suggest sync message",
                                                                                      ),
                                                                                      void this.dispatchEvent(
                                                                                        new $y(
                                                                                          e.queueId,
                                                                                        ),
                                                                                      ))
                                                                                    : void this.logger.zsymb(
                                                                                        0,
                                                                                        16696,
                                                                                        30015,
                                                                                        "Detected overflow queue message group, let wait done offline",
                                                                                      )),
                                                                            (this.logger =
                                                                              e.createZLogger(
                                                                                hs
                                                                                  .ZLoggerNametags
                                                                                  .autoFetchMsgCloud,
                                                                                [
                                                                                  hs
                                                                                    .ZLoggerNametags
                                                                                    .controller,
                                                                                ],
                                                                              )),
                                                                            (this.config =
                                                                              s),
                                                                            (this.ledger =
                                                                              n),
                                                                            (this.service =
                                                                              i),
                                                                            (this.metrics =
                                                                              a),
                                                                            (this.storage =
                                                                              r),
                                                                            (this.systemTime =
                                                                              t),
                                                                            (this.fetcherMachine =
                                                                              o),
                                                                            (this.eventCollector =
                                                                              l),
                                                                            (this.trackingOverflow =
                                                                              d),
                                                                            (this.isInsufficientMessage =
                                                                              !1);
                                                                        }
                                                                        start() {
                                                                          this.fetcherMachine.create(),
                                                                            this.registerListener(),
                                                                            this.config.get(
                                                                              "enable",
                                                                            )
                                                                              ? (this.logger.zsymb(
                                                                                  0,
                                                                                  16696,
                                                                                  3e4,
                                                                                  "Module is enabled on startup, let start machine",
                                                                                ),
                                                                                this.registerMachineListener(),
                                                                                this.fetcherMachine.start())
                                                                              : this.logger.zsymb(
                                                                                  0,
                                                                                  16696,
                                                                                  30001,
                                                                                  "Module is disabled on startup, let listen config from server",
                                                                                );
                                                                        }
                                                                        registerListener() {
                                                                          this.config.addEventListener(
                                                                            "update",
                                                                            this
                                                                              .onConfigUpdate,
                                                                          ),
                                                                            this.ledger.addEventListener(
                                                                              Gy.OVERFLOW_DB_GROUP_OFFLINE,
                                                                              this
                                                                                .onOverflowDBGroupOffline,
                                                                            ),
                                                                            this.eventCollector.addEventListener(
                                                                              By
                                                                                .a
                                                                                .OVERFLOW_MESSAGE_QUEUE,
                                                                              this
                                                                                .onOverflowMessageQueue,
                                                                            );
                                                                        }
                                                                        registerMachineListener() {
                                                                          this.logger.zsymb(
                                                                            0,
                                                                            16696,
                                                                            30002,
                                                                            "register machine listener",
                                                                          ),
                                                                            this.fetcherMachine.onStop(
                                                                              this
                                                                                .onMachineStop,
                                                                            ),
                                                                            this.fetcherMachine.onTransition(
                                                                              this
                                                                                .onMachineTransition,
                                                                            );
                                                                        }
                                                                        unregisterMachineListener() {
                                                                          this.logger.zsymb(
                                                                            0,
                                                                            16696,
                                                                            30003,
                                                                            "unregister machine listener",
                                                                          ),
                                                                            this.fetcherMachine.off(
                                                                              this
                                                                                .onMachineStop,
                                                                            ),
                                                                            this.fetcherMachine.off(
                                                                              this
                                                                                .onMachineTransition,
                                                                            );
                                                                        }
                                                                      }),
                                                                    ) || Wy),
                                                                ) || Wy),
                                                            ) || Wy),
                                                        ) || Wy),
                                                    ) || Wy),
                                                ) || Wy),
                                            ) || Wy),
                                        ) || Wy),
                                    ) || Wy),
                                ) || Wy),
                            ) || Wy),
                        ) || Wy),
                    ) || Wy),
                ) || Wy),
            ) || Wy;
        !(function (e) {
          (e.AUTO_FETCH_MSG_CLOUD_SETTING = "auto_fetch_msg_cloud"),
            (e.SYNC_MESSAGE_SETTING = "sync_cross_settings"),
            (e.IMPORT_MESSAGE_SETTING = "export_import_data"),
            (e.OVERFLOW_MSG_TS = "overflow_msg_ts"),
            (e.SUFFICIENT_MSG_TS = "sufficient_msg_ts"),
            (e.LAST_CLOSE_FIRST_LOGIN_TRANSFER_MODAL_TS =
              "last-time-close-first-login-transfer-modal");
        })(Ky || (Ky = {}));
        class Zy {
          constructor(e, t, s) {
            (this.key = void 0),
              (this.version = void 0),
              (this.storageAdapter = void 0),
              (this.data = null),
              (this.key = e),
              (this.version = t),
              (this.storageAdapter = s);
          }
          async get() {
            return this.data
              ? this.data
              : (this.data = await this.storageAdapter.readAsync(
                  this.key,
                  this.version,
                ));
          }
          async save(e) {
            (this.data = e),
              await this.storageAdapter.writeAsync(this.key, this.version, e);
          }
          async clear() {
            (this.data = null), await this.storageAdapter.removeAsync(this.key);
          }
        }
        class Jy extends Zy {
          constructor(e, t) {
            super([e, "conv_ids"].join("_"), 1, t);
          }
          async remove(e) {
            var t;
            const s = (
              null !== (t = await this.get()) && void 0 !== t ? t : []
            ).filter((t) => t !== e);
            await this.save(s);
          }
          async getRemainConv() {
            const e = await this.get();
            return (null == e ? void 0 : e.length) || 0;
          }
        }
        class Qy extends Zy {
          constructor(e, t) {
            super([e, "overflow"].join("_"), 1, t);
          }
        }
        class Yy extends Zy {
          constructor(e, t) {
            super([e, "last_fetch"].join("_"), 1, t);
          }
          async getLastTsSuccess() {
            var e, t;
            return null !==
              (t = (null !== (e = await this.get()) && void 0 !== e ? e : {})
                .lastTsSuccess) && void 0 !== t
              ? t
              : -1;
          }
          async getLastStartFetchInfo() {
            var e;
            const {
              lastTsStart: t,
              convIds: s,
              convErrorIds: i,
              totalMsgFetched: n,
            } = null !== (e = await this.get()) && void 0 !== e ? e : {};
            return {
              lastTsStart: t,
              convIds: s,
              convErrorIds: i,
              totalMsgFetched: n,
            };
          }
          async saveLastTsSuccess(e) {
            var t;
            const s = null !== (t = await this.get()) && void 0 !== t ? t : {};
            return this.save(
              Object(f.a)(Object(f.a)({}, s), {}, { lastTsSuccess: e }),
            );
          }
          async saveLastTsStart(e) {
            var t;
            const s = null !== (t = await this.get()) && void 0 !== t ? t : {};
            s.lastTsStart ||
              (await this.save(
                Object(f.a)(Object(f.a)({}, s), {}, { lastTsStart: e }),
              ));
          }
          async saveConvIds(e) {
            var t, s;
            const i = null !== (t = await this.get()) && void 0 !== t ? t : {},
              n =
                null !== (s = null == i ? void 0 : i.convIds) && void 0 !== s
                  ? s
                  : [],
              a = Ba.a.merge(n, e),
              r = Object(f.a)(Object(f.a)({}, i), {}, { convIds: a });
            0 === a.length && delete r.convIds, await this.save(r);
          }
          async saveConvErrorIds(e) {
            var t, s;
            const i = null !== (t = await this.get()) && void 0 !== t ? t : {},
              n =
                null !== (s = null == i ? void 0 : i.convErrorIds) &&
                void 0 !== s
                  ? s
                  : [],
              a = Ba.a.merge(n, e);
            await this.save(
              Object(f.a)(Object(f.a)({}, i), {}, { convErrorIds: a }),
            );
          }
          async saveTotalMessageFetched(e) {
            var t, s;
            const i = null !== (t = await this.get()) && void 0 !== t ? t : {},
              n =
                (null !== (s = i.totalMsgFetched) && void 0 !== s ? s : 0) + e;
            await this.save(
              Object(f.a)(Object(f.a)({}, i), {}, { totalMsgFetched: n }),
            );
          }
          async removeLastStartFetchInfo() {
            var e;
            const t = null !== (e = await this.get()) && void 0 !== e ? e : {};
            return (
              delete t.lastTsStart,
              delete t.convIds,
              delete t.convErrorIds,
              delete t.totalMsgFetched,
              this.save(t)
            );
          }
        }
        var Xy;
        let e_ =
          Object(My.d)()(
            (Xy =
              Object(Ga.e)()(
                (Xy =
                  Object(My.e)(Ey.o)(
                    (Xy =
                      (function (e, t) {
                        return Object(Ga.d)(Ey.a)(e, void 0, 0);
                      })(
                        (Xy =
                          Reflect.metadata(
                            "design:type",
                            Function,
                          )(
                            (Xy =
                              Reflect.metadata("design:paramtypes", [
                                "undefined" == typeof IAsyncStorageAdapter
                                  ? Object
                                  : IAsyncStorageAdapter,
                              ])(
                                (Xy = class {
                                  constructor(e) {
                                    (this.localStorage = void 0),
                                      (this.storageConvIds = void 0),
                                      (this.storageOverflow = void 0),
                                      (this.storageLastFetch = void 0),
                                      (this.localStorage =
                                        E.default.getInstance()),
                                      (this.storageConvIds = new Jy(
                                        Ky.AUTO_FETCH_MSG_CLOUD_SETTING,
                                        e,
                                      )),
                                      (this.storageOverflow = new Qy(
                                        Ky.AUTO_FETCH_MSG_CLOUD_SETTING,
                                        e,
                                      )),
                                      (this.storageLastFetch = new Yy(
                                        Ky.AUTO_FETCH_MSG_CLOUD_SETTING,
                                        e,
                                      ));
                                  }
                                  async getAllConvIds() {
                                    var e;
                                    return null !==
                                      (e = await this.storageConvIds.get()) &&
                                      void 0 !== e
                                      ? e
                                      : [];
                                  }
                                  async getLastTsSyncMessageSuccess() {
                                    var e;
                                    const t =
                                        this.localStorage.getItemForCurrentUser(
                                          Ky.SYNC_MESSAGE_SETTING,
                                        ),
                                      [, s] = Ba.e.safeParseJson(t);
                                    return null !==
                                      (e = null == s ? void 0 : s.lastSync) &&
                                      void 0 !== e
                                      ? e
                                      : -1;
                                  }
                                  async getLastTsCloseTransferSuggestion() {
                                    var e;
                                    const t =
                                        this.localStorage.getItemForCurrentUser(
                                          Ky.SYNC_MESSAGE_SETTING,
                                        ),
                                      [, s] = Ba.e.safeParseJson(t);
                                    return null !==
                                      (e =
                                        null == s
                                          ? void 0
                                          : s.lastCloseSuggest) && void 0 !== e
                                      ? e
                                      : -1;
                                  }
                                  async getLastTsCloseFirstLoginTransferSuggestion() {
                                    const e =
                                      await this.localStorage.getItemForCurrentUserAsync(
                                        Ky.LAST_CLOSE_FIRST_LOGIN_TRANSFER_MODAL_TS,
                                      );
                                    return e && !isNaN(Number(e))
                                      ? Number(e)
                                      : -1;
                                  }
                                  async getLastTsImportMessageSuccess() {
                                    var e;
                                    const t =
                                        this.localStorage.getItemForCurrentUser(
                                          Ky.IMPORT_MESSAGE_SETTING,
                                        ),
                                      [, s] = Ba.e.safeParseJson(t);
                                    return null !==
                                      (e =
                                        null == s
                                          ? void 0
                                          : s.lastTimeImportSuccess) &&
                                      void 0 !== e
                                      ? e
                                      : -1;
                                  }
                                  async getLastTsAutoFetchMessageSuccess() {
                                    return await this.storageLastFetch.getLastTsSuccess();
                                  }
                                  async getLastStartAutoFetchMessageInfo() {
                                    return await this.storageLastFetch.getLastStartFetchInfo();
                                  }
                                  async getLastTsOverflowMessage() {
                                    const e =
                                      this.localStorage.getItemForCurrentUser(
                                        Ky.OVERFLOW_MSG_TS,
                                      );
                                    return e && !isNaN(Number(e))
                                      ? Number(e)
                                      : -1;
                                  }
                                  async getLastTsSufficientMessage() {
                                    const e =
                                      this.localStorage.getItemForCurrentUser(
                                        Ky.SUFFICIENT_MSG_TS,
                                      );
                                    return e && !isNaN(Number(e))
                                      ? Number(e)
                                      : -1;
                                  }
                                  async getOverflowInfo() {
                                    return await this.storageOverflow.get();
                                  }
                                  async getRemainConv() {
                                    return await this.storageConvIds.getRemainConv();
                                  }
                                  async saveConvIds(e) {
                                    await this.storageConvIds.save(e),
                                      await this.storageLastFetch.saveConvIds(
                                        e,
                                      );
                                  }
                                  async saveLastFetchSuccess(e) {
                                    await this.storageLastFetch.saveLastTsSuccess(
                                      e,
                                    );
                                  }
                                  async saveLastOverflow(e) {
                                    this.localStorage.setItemForCurrentUser(
                                      Ky.OVERFLOW_MSG_TS,
                                      String(e),
                                    );
                                  }
                                  async saveLastSufficientMessage(e) {
                                    this.localStorage.setItemForCurrentUser(
                                      Ky.SUFFICIENT_MSG_TS,
                                      String(e),
                                    );
                                  }
                                  async saveOverflowInfo(e, t, s) {
                                    await this.storageOverflow.save({
                                      queueId: e,
                                      lastMsgId: t,
                                      lastActionId: s,
                                    });
                                  }
                                  async saveLastTsStartFetch(e) {
                                    await this.storageLastFetch.saveLastTsStart(
                                      e,
                                    );
                                  }
                                  async saveConvErrorId(e) {
                                    await this.storageLastFetch.saveConvErrorIds(
                                      [e],
                                    );
                                  }
                                  async saveTotalMessageFetched(e) {
                                    await this.storageLastFetch.saveTotalMessageFetched(
                                      e,
                                    );
                                  }
                                  async removeOverflowInfo() {
                                    await this.storageOverflow.clear();
                                  }
                                  async removeConvId(e) {
                                    await this.storageConvIds.remove(e);
                                  }
                                  async removeLastStartFetch() {
                                    await this.storageLastFetch.removeLastStartFetchInfo();
                                  }
                                }),
                              ) || Xy),
                          ) || Xy),
                      ) || Xy),
                  ) || Xy),
              ) || Xy),
          ) || Xy;
        var t_;
        let s_ =
          Object(My.d)()(
            (t_ =
              Object(My.e)(Ey.a)(
                (t_ =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (t_ =
                      Reflect.metadata(
                        "design:paramtypes",
                        [],
                      )(
                        (t_ = class {
                          constructor() {
                            (this.storage = void 0),
                              (this.storage = E.default.getInstance());
                          }
                          async readAsync(e, t) {
                            const s =
                                await this.storage.getItemForCurrentUserAsync(
                                  e,
                                ),
                              [i, n] = Ba.e.safeParseJson(s);
                            return i || null === n
                              ? null
                              : n.version === t
                                ? n.value
                                : (await this.storage.removeItemForCurrentUserAsync(
                                    e,
                                  ),
                                  null);
                          }
                          async writeAsync(e, t, s) {
                            const i = JSON.stringify({ version: t, value: s });
                            await this.storage.setItemForCurrentUserAsync(e, i);
                          }
                          async removeAsync(e) {
                            await this.storage.removeItemForCurrentUserAsync(e);
                          }
                        }),
                      ) || t_),
                  ) || t_),
              ) || t_),
          ) || t_;
        var i_ = s("9Gk3"),
          n_ = s("wd/R"),
          a_ = s.n(n_);
        let r_;
        !(function (e) {
          (e[(e.SAVE_MESSAE_ERROR = 0)] = "SAVE_MESSAE_ERROR"),
            (e[(e.GET_GROUP_INFO_ERROR = 1)] = "GET_GROUP_INFO_ERROR");
        })(r_ || (r_ = {}));
        class o_ extends xa {
          constructor(e) {
            super("SaveMessageError", r_.SAVE_MESSAE_ERROR, e);
          }
        }
        class d_ extends xa {
          constructor(e, t) {
            super(
              "GetGroupInfoError",
              r_.GET_GROUP_INFO_ERROR,
              "An error occured during get list groups info. Error: " +
                JSON.stringify(t) +
                ". GroupIds: " +
                e,
            );
          }
        }
        var l_,
          c_,
          h_,
          u_,
          g_,
          m_,
          p_,
          f_,
          v_,
          b_,
          I_,
          y_,
          __,
          O_,
          C_,
          E_,
          M_,
          S_,
          T_,
          w_,
          R_,
          L_;
        let D_ =
          ((l_ = Object(My.d)()),
          (c_ = Object(Ga.e)()),
          (h_ = Object(My.e)(Ey.n)),
          (u_ = function (e, t) {
            return Object(Ga.d)(Ey.b)(e, void 0, 0);
          }),
          (g_ = function (e, t) {
            return Object(Ga.d)(Ey.o)(e, void 0, 1);
          }),
          (m_ = function (e, t) {
            return Object(Ga.d)(Ey.j)(e, void 0, 2);
          }),
          (p_ = function (e, t) {
            return Object(Ga.d)(Ey.q)(e, void 0, 3);
          }),
          (f_ = function (e, t) {
            return i.ModuleContainer.inject(q.ZLoggerFactory)(e, void 0, 4);
          }),
          (v_ = function (e, t) {
            return i.ModuleContainer.inject(fi)(e, void 0, 5);
          }),
          (b_ = function (e, t) {
            return i.ModuleContainer.inject(hi.b)(e, void 0, 6);
          }),
          (I_ = function (e, t) {
            return i.ModuleContainer.inject(zt.d)(e, void 0, 7);
          }),
          (y_ = function (e, t) {
            return i.ModuleContainer.inject(yt)(e, void 0, 8);
          }),
          (__ = Reflect.metadata("design:type", Function)),
          (O_ = Reflect.metadata("design:paramtypes", [
            "undefined" == typeof AFMC_IConfig ? Object : AFMC_IConfig,
            "undefined" == typeof AFMC_IStorage ? Object : AFMC_IStorage,
            "undefined" == typeof AFMC_IMessageProcessor
              ? Object
              : AFMC_IMessageProcessor,
            "undefined" == typeof AFMC_ISufficientMessageController
              ? Object
              : AFMC_ISufficientMessageController,
            void 0 === q.ZLoggerFactory ? Object : q.ZLoggerFactory,
            "undefined" == typeof IMessageController
              ? Object
              : IMessageController,
            void 0 === hi.b ? Object : hi.b,
            void 0 === zt.d ? Object : zt.d,
            "undefined" == typeof ISystemTime ? Object : ISystemTime,
          ])),
          (C_ = _I((e) => {
            let [t] = e;
            return `${t.convId}::${t.requestMsgId}`;
          })),
          (E_ = Reflect.metadata("design:type", Function)),
          (M_ = Reflect.metadata("design:paramtypes", [
            "undefined" == typeof IBatchRequestInfo
              ? Object
              : IBatchRequestInfo,
          ])),
          (S_ = _I((e) => {
            let [t] = e;
            return `${t.convId}::${t.requestMsgId}`;
          })),
          (T_ = Reflect.metadata("design:type", Function)),
          (w_ = Reflect.metadata("design:paramtypes", [
            "undefined" == typeof IBatchRequestInfo
              ? Object
              : IBatchRequestInfo,
            Array,
          ])),
          l_(
            (R_ =
              c_(
                (R_ =
                  h_(
                    (R_ =
                      u_(
                        (R_ =
                          g_(
                            (R_ =
                              m_(
                                (R_ =
                                  p_(
                                    (R_ =
                                      f_(
                                        (R_ =
                                          v_(
                                            (R_ =
                                              b_(
                                                (R_ =
                                                  I_(
                                                    (R_ =
                                                      y_(
                                                        (R_ =
                                                          __(
                                                            (R_ =
                                                              O_(
                                                                ((L_ = class {
                                                                  constructor(
                                                                    e,
                                                                    t,
                                                                    s,
                                                                    i,
                                                                    n,
                                                                    a,
                                                                    r,
                                                                    o,
                                                                    d,
                                                                  ) {
                                                                    (this.logger =
                                                                      void 0),
                                                                      (this.config =
                                                                        void 0),
                                                                      (this.storage =
                                                                        void 0),
                                                                      (this.systemTime =
                                                                        void 0),
                                                                      (this.groupManager =
                                                                        void 0),
                                                                      (this.convManager =
                                                                        void 0),
                                                                      (this.messageProcessor =
                                                                        void 0),
                                                                      (this.messageController =
                                                                        void 0),
                                                                      (this.sufficientMessageController =
                                                                        void 0),
                                                                      (this.logger =
                                                                        n.createZLogger(
                                                                          hs
                                                                            .ZLoggerNametags
                                                                            .autoFetchMsgCloud,
                                                                          [
                                                                            hs
                                                                              .ZLoggerNametags
                                                                              .service,
                                                                          ],
                                                                        )),
                                                                      (this.config =
                                                                        e),
                                                                      (this.storage =
                                                                        t),
                                                                      (this.systemTime =
                                                                        d),
                                                                      (this.convManager =
                                                                        o),
                                                                      (this.groupManager =
                                                                        r),
                                                                      (this.messageProcessor =
                                                                        s),
                                                                      (this.messageController =
                                                                        a),
                                                                      (this.sufficientMessageController =
                                                                        i);
                                                                  }
                                                                  getThrottle(
                                                                    e,
                                                                  ) {
                                                                    return e
                                                                      ? Math.max(
                                                                          this.config.get(
                                                                            "min_throttle",
                                                                          ),
                                                                          this.config.get(
                                                                            "throttle",
                                                                          ) +
                                                                            this.config.get(
                                                                              "throttle_idle",
                                                                            ),
                                                                        )
                                                                      : Math.max(
                                                                          this.config.get(
                                                                            "min_throttle",
                                                                          ),
                                                                          this.config.get(
                                                                            "throttle",
                                                                          ),
                                                                        );
                                                                  }
                                                                  allowFetchForeground() {
                                                                    return this.config.get(
                                                                      "enable_fetch_foreground",
                                                                    );
                                                                  }
                                                                  async fetchMessages(
                                                                    e,
                                                                  ) {
                                                                    const {
                                                                        convId:
                                                                          t,
                                                                        requestMsgId:
                                                                          s,
                                                                      } = e,
                                                                      i =
                                                                        this.config.get(
                                                                          "batch_size",
                                                                        ),
                                                                      n =
                                                                        await this.messageController.fetchMessagesCloud(
                                                                          t,
                                                                          s,
                                                                          i,
                                                                          {
                                                                            isOA: 0,
                                                                            src: i_
                                                                              .c
                                                                              .AUTO_FETCH_MINI_CLOUD,
                                                                          },
                                                                        );
                                                                    return (
                                                                      n.groupMsgs.forEach(
                                                                        (e) =>
                                                                          e.setSrc(
                                                                            R
                                                                              .MSG_SRC
                                                                              .AUTO_LOADER,
                                                                          ),
                                                                      ),
                                                                      n
                                                                    );
                                                                  }
                                                                  async processMessages(
                                                                    e,
                                                                    t,
                                                                  ) {
                                                                    const [
                                                                      s,
                                                                      i,
                                                                    ] =
                                                                      await Ba.b.catchPromise(
                                                                        this.messageProcessor.process(
                                                                          e,
                                                                          t,
                                                                        ),
                                                                      );
                                                                    return (
                                                                      Bp(
                                                                        s,
                                                                        new o_(
                                                                          "Save messages error " +
                                                                            (null ==
                                                                            s
                                                                              ? void 0
                                                                              : s.toString()),
                                                                        ),
                                                                      ),
                                                                      i
                                                                    );
                                                                  }
                                                                  checkBusyHour() {
                                                                    const e =
                                                                        this.systemTime.getTimeNow(),
                                                                      t =
                                                                        a_()(
                                                                          e,
                                                                        ).get(
                                                                          "h",
                                                                        );
                                                                    if (
                                                                      !1 ===
                                                                      this.config
                                                                        .get(
                                                                          "time_exclude",
                                                                        )
                                                                        .includes(
                                                                          t,
                                                                        )
                                                                    )
                                                                      return [
                                                                        !1,
                                                                        0,
                                                                      ];
                                                                    const s =
                                                                        Math.random() *
                                                                        Math.max(
                                                                          this.config.get(
                                                                            "throttle",
                                                                          ),
                                                                          this.config.get(
                                                                            "min_throttle",
                                                                          ),
                                                                        ),
                                                                      i = a_()(
                                                                        e,
                                                                      )
                                                                        .add(
                                                                          1,
                                                                          "h",
                                                                        )
                                                                        .set(
                                                                          "m",
                                                                          0,
                                                                        )
                                                                        .set(
                                                                          "s",
                                                                          0,
                                                                        )
                                                                        .toDate()
                                                                        .getTime();
                                                                    return [
                                                                      !0,
                                                                      Math.abs(
                                                                        i - e,
                                                                      ) + s,
                                                                    ];
                                                                  }
                                                                  checkMaxRetryBatch(
                                                                    e,
                                                                    t,
                                                                  ) {
                                                                    if (
                                                                      e >=
                                                                      this.config.get(
                                                                        "max_retry_batch",
                                                                      )
                                                                    )
                                                                      return [
                                                                        !0,
                                                                        0,
                                                                      ];
                                                                    let s =
                                                                      this.getThrottle(
                                                                        t,
                                                                      ) +
                                                                      1e3 *
                                                                        Math.random();
                                                                    if (
                                                                      "fibo" ===
                                                                      this.config.get(
                                                                        "retry_strategy",
                                                                      )
                                                                    )
                                                                      s +=
                                                                        1e3 *
                                                                        Ba.d.get(
                                                                          e + 1,
                                                                        );
                                                                    return [
                                                                      !1,
                                                                      s,
                                                                    ];
                                                                  }
                                                                  async isInsufficientMessage() {
                                                                    const e =
                                                                      await this.sufficientMessageController.getLastTsSufficientMessage();
                                                                    return (
                                                                      this.systemTime.getTimeNow() -
                                                                        e >
                                                                      this.config.get(
                                                                        "max_time_check_insufficient_data",
                                                                      )
                                                                    );
                                                                  }
                                                                  isQueueMessageGroup(
                                                                    e,
                                                                  ) {
                                                                    return this.config
                                                                      .get(
                                                                        "queue_config",
                                                                      )
                                                                      .includes(
                                                                        e.toString(),
                                                                      );
                                                                  }
                                                                  async getGroupsHasMessageOffline() {
                                                                    let e = !1,
                                                                      t = [];
                                                                    const s =
                                                                      await this.storage.getOverflowInfo();
                                                                    if (s) {
                                                                      const i =
                                                                        await this.messageController.getGroupHasMessageOffline(
                                                                          s.queueId,
                                                                          s.lastMsgId,
                                                                          s.lastActionId,
                                                                        );
                                                                      (e =
                                                                        i.evict),
                                                                        (t =
                                                                          i.listConvIds),
                                                                        Ny.a &&
                                                                          this.config.get(
                                                                            "debugger.simulator.overflow_db_group_offline",
                                                                          ) &&
                                                                          (e =
                                                                            !0);
                                                                    }
                                                                    const i =
                                                                        await this.storage.getAllConvIds(),
                                                                      n =
                                                                        Ba.a.merge(
                                                                          t,
                                                                          i,
                                                                        ),
                                                                      [a, r] =
                                                                        await Ba.b.catchPromise(
                                                                          this.groupManager.getMulti(
                                                                            n,
                                                                          ),
                                                                        );
                                                                    Bp(
                                                                      a,
                                                                      new d_(
                                                                        n,
                                                                        a,
                                                                      ),
                                                                    );
                                                                    return {
                                                                      listGroups:
                                                                        await Ba.a.asyncMapParallel(
                                                                          r,
                                                                          async (
                                                                            e,
                                                                          ) => {
                                                                            const s =
                                                                                await this.convManager.get(
                                                                                  e.id,
                                                                                ),
                                                                              i =
                                                                                e.isAdmin() ||
                                                                                e.isOwner(),
                                                                              n =
                                                                                !(
                                                                                  null ==
                                                                                    s ||
                                                                                  !s.isPinned
                                                                                ),
                                                                              a =
                                                                                !(
                                                                                  null ==
                                                                                    s ||
                                                                                  !s.isMuted
                                                                                ),
                                                                              r =
                                                                                e.totalMembers;
                                                                            let o =
                                                                                -1,
                                                                              d =
                                                                                -1;
                                                                            const l =
                                                                              await (null ==
                                                                              s
                                                                                ? void 0
                                                                                : s.getLastMessage());
                                                                            return (
                                                                              null !=
                                                                                l &&
                                                                                l.sendDttm &&
                                                                                ((o =
                                                                                  Number(
                                                                                    l.sendDttm,
                                                                                  )),
                                                                                (d =
                                                                                  Ba.c.getNumberOfDays(
                                                                                    o,
                                                                                    this.systemTime.getTimeNow(),
                                                                                  ))),
                                                                              {
                                                                                convId:
                                                                                  e.id,
                                                                                groupInfo:
                                                                                  e,
                                                                                isNewGroupOffline:
                                                                                  t.includes(
                                                                                    e.id,
                                                                                  ),
                                                                                isPinned:
                                                                                  n,
                                                                                isOwnerOrAdmin:
                                                                                  i,
                                                                                isMuted:
                                                                                  a,
                                                                                lastActiveTime:
                                                                                  o,
                                                                                totalMembers:
                                                                                  r,
                                                                                lastActiveTimeInDays:
                                                                                  d,
                                                                              }
                                                                            );
                                                                          },
                                                                        ),
                                                                      evict: e,
                                                                    };
                                                                  }
                                                                  reloadMessageOfConv(
                                                                    e,
                                                                  ) {
                                                                    this.messageController.reloadMessage(
                                                                      e,
                                                                    );
                                                                  }
                                                                }),
                                                                Object(Sp.a)(
                                                                  L_.prototype,
                                                                  "fetchMessages",
                                                                  [C_, E_, M_],
                                                                  Object.getOwnPropertyDescriptor(
                                                                    L_.prototype,
                                                                    "fetchMessages",
                                                                  ),
                                                                  L_.prototype,
                                                                ),
                                                                Object(Sp.a)(
                                                                  L_.prototype,
                                                                  "processMessages",
                                                                  [S_, T_, w_],
                                                                  Object.getOwnPropertyDescriptor(
                                                                    L_.prototype,
                                                                    "processMessages",
                                                                  ),
                                                                  L_.prototype,
                                                                ),
                                                                (R_ = L_)),
                                                              ) || R_),
                                                          ) || R_),
                                                      ) || R_),
                                                  ) || R_),
                                              ) || R_),
                                          ) || R_),
                                      ) || R_),
                                  ) || R_),
                              ) || R_),
                          ) || R_),
                      ) || R_),
                  ) || R_),
              ) || R_),
          ) || R_);
        var F_,
          A_ = s("+Mel"),
          j_ = s("C3LF");
        let P_ =
          Object(My.d)()(
            (F_ =
              Object(Ga.e)()(
                (F_ =
                  Object(My.e)(Ey.e)(
                    (F_ =
                      (function (e, t) {
                        return Object(Ga.d)(Ty)(e, void 0, 0);
                      })(
                        (F_ =
                          (function (e, t) {
                            return Object(Ga.d)(Sy)(e, void 0, 1);
                          })(
                            (F_ =
                              (function (e, t) {
                                return Object(Ga.d)(Fy)(e, void 0, 2);
                              })(
                                (F_ =
                                  (function (e, t) {
                                    return i.ModuleContainer.inject(V.a)(
                                      e,
                                      void 0,
                                      3,
                                    );
                                  })(
                                    (F_ =
                                      Reflect.metadata(
                                        "design:type",
                                        Function,
                                      )(
                                        (F_ =
                                          Reflect.metadata(
                                            "design:paramtypes",
                                            [
                                              "undefined" == typeof IEventBus
                                                ? Object
                                                : IEventBus,
                                              "undefined" ==
                                              typeof ISocketPolling
                                                ? Object
                                                : ISocketPolling,
                                              "undefined" ==
                                              typeof SyncMessageController
                                                ? Object
                                                : SyncMessageController,
                                              "undefined" ==
                                              typeof BaseApplication
                                                ? Object
                                                : BaseApplication,
                                            ],
                                          )(
                                            (F_ = class extends te.b {
                                              constructor(e, t, s, i) {
                                                super(),
                                                  (this.onStartPullOffline =
                                                    () => {
                                                      this.dispatchEvent(
                                                        new j_.l(),
                                                      );
                                                    }),
                                                  (this.onDonePullOffline =
                                                    () => {
                                                      this.dispatchEvent(
                                                        new j_.n(),
                                                      );
                                                    }),
                                                  (this.onOverflowQueue = (
                                                    e,
                                                  ) => {
                                                    this.dispatchEvent(
                                                      new j_.j(e.queueId),
                                                    );
                                                  }),
                                                  (this.onStartSyncMessage =
                                                    () => {
                                                      this.dispatchEvent(
                                                        new j_.m("start"),
                                                      );
                                                    }),
                                                  (this.onResumeSyncMessage =
                                                    () => {
                                                      this.dispatchEvent(
                                                        new j_.m("resume"),
                                                      );
                                                    }),
                                                  (this.onSyncMessageSuccess =
                                                    () => {
                                                      this.dispatchEvent(
                                                        new j_.o("", !0),
                                                      );
                                                    }),
                                                  (this.onSyncMessageFailed =
                                                    () => {
                                                      this.dispatchEvent(
                                                        new j_.o("", !1),
                                                      );
                                                    }),
                                                  (this.onApplicationBackground =
                                                    () => {
                                                      this.dispatchEvent(
                                                        new j_.a(),
                                                      );
                                                    }),
                                                  (this.onApplicationForeground =
                                                    () => {
                                                      this.dispatchEvent(
                                                        new j_.c(),
                                                      );
                                                    }),
                                                  (this.onApplicationExit =
                                                    () => {
                                                      this.dispatchEvent(
                                                        new j_.b(),
                                                      );
                                                    }),
                                                  (this.onNetworkStatusChanged =
                                                    (e) => {
                                                      this.dispatchEvent(
                                                        new j_.i(e),
                                                      );
                                                    }),
                                                  (this.onLogout = () => {
                                                    this.dispatchEvent(
                                                      new j_.h(),
                                                    );
                                                  }),
                                                  (this.onServiceReady = () => {
                                                    this.dispatchEvent(
                                                      new j_.k(),
                                                    );
                                                  }),
                                                  (this.onBeforeUnload = () => {
                                                    this.dispatchEvent(
                                                      new j_.d(),
                                                    );
                                                  }),
                                                  this.registerListener(
                                                    e,
                                                    t,
                                                    i,
                                                    s,
                                                  );
                                              }
                                              registerListener(e, t, s, i) {
                                                var n, a, r, o, d;
                                                e.subscribe((e, t) => {
                                                  switch (e) {
                                                    case St.FetchActions
                                                      .CHECK_OVERFLOW_QUEUE_BY_FLAG:
                                                      return this.onOverflowQueue(
                                                        t,
                                                      );
                                                    case St.GeneralActions
                                                      .NETWORK_STATUS:
                                                      return this.onNetworkStatusChanged(
                                                        t,
                                                      );
                                                  }
                                                }),
                                                  t.addEventListener(
                                                    Mc.SOCKET_POLLING_EVENT
                                                      .CHAT_CONNECTED,
                                                    (e) => {
                                                      var t, s;
                                                      e.nextChatHandler.subcribe(
                                                        jg.b
                                                          .ON_START_PULL_OFFLINE,
                                                        this.onStartPullOffline,
                                                      ),
                                                        e.nextChatHandler.subcribe(
                                                          jg.b.ON_DONE_OFFLINE,
                                                          this
                                                            .onDonePullOffline,
                                                        ),
                                                        null ===
                                                          (t =
                                                            e.prevChatHandler) ||
                                                          void 0 === t ||
                                                          t.unsubcribe(
                                                            jg.b
                                                              .ON_START_PULL_OFFLINE,
                                                            this
                                                              .onStartPullOffline,
                                                          ),
                                                        null ===
                                                          (s =
                                                            e.prevChatHandler) ||
                                                          void 0 === s ||
                                                          s.unsubcribe(
                                                            jg.b
                                                              .ON_DONE_OFFLINE,
                                                            this
                                                              .onDonePullOffline,
                                                          );
                                                    },
                                                  ),
                                                  null == i ||
                                                    null ===
                                                      (n =
                                                        i.addEventListener) ||
                                                    void 0 === n ||
                                                    n.call(
                                                      i,
                                                      A_.a.ON_START,
                                                      this.onStartSyncMessage,
                                                    ),
                                                  null == i ||
                                                    null ===
                                                      (a =
                                                        i.addEventListener) ||
                                                    void 0 === a ||
                                                    a.call(
                                                      i,
                                                      A_.a.ON_RETRY,
                                                      this.onStartSyncMessage,
                                                    ),
                                                  null == i ||
                                                    null ===
                                                      (r =
                                                        i.addEventListener) ||
                                                    void 0 === r ||
                                                    r.call(
                                                      i,
                                                      A_.a.ON_RESUME,
                                                      this.onResumeSyncMessage,
                                                    ),
                                                  null == i ||
                                                    null ===
                                                      (o =
                                                        i.addEventListener) ||
                                                    void 0 === o ||
                                                    o.call(
                                                      i,
                                                      A_.a.ON_SUCCESS,
                                                      this.onSyncMessageSuccess,
                                                    ),
                                                  null == i ||
                                                    null ===
                                                      (d =
                                                        i.addEventListener) ||
                                                    void 0 === d ||
                                                    d.call(
                                                      i,
                                                      A_.a.ON_FAILED,
                                                      this.onSyncMessageFailed,
                                                    ),
                                                  s.addEventListener(
                                                    V.b.Idle,
                                                    this
                                                      .onApplicationBackground,
                                                  ),
                                                  s.addEventListener(
                                                    V.b.Active,
                                                    this
                                                      .onApplicationForeground,
                                                  ),
                                                  s.addEventListener(
                                                    V.b.Exit,
                                                    this.onApplicationExit,
                                                  ),
                                                  s.addEventListener(
                                                    V.b.ServicesReady,
                                                    this.onServiceReady,
                                                  ),
                                                  s.addEventListener(
                                                    V.b.BeforeUnload,
                                                    this.onBeforeUnload,
                                                  ),
                                                  s.addEventListener(
                                                    V.b.LogOut,
                                                    this.onLogout,
                                                  );
                                              }
                                              onLeaveGroup(e) {
                                                this.dispatchEvent(new j_.f(e));
                                              }
                                              onDeleteConv(e) {
                                                this.dispatchEvent(new j_.e(e));
                                              }
                                            }),
                                          ) || F_),
                                      ) || F_),
                                  ) || F_),
                              ) || F_),
                          ) || F_),
                      ) || F_),
                  ) || F_),
              ) || F_),
          ) || F_;
        class N_ {
          constructor(e) {
            (this.label = e),
              (this.data = new Map()),
              (this.id = 0),
              (this.locked = !1);
          }
          get nextId() {
            return ++this.id;
          }
          get info() {
            return `${this.label}: ${this.time}`;
          }
          get time() {
            let e = 0;
            return this.data.forEach((t) => (e += t.time)), e;
          }
          lock() {
            this.locked = !0;
          }
          unlock() {
            this.locked = !1;
          }
          getTracker() {
            var e = this;
            const t = this.nextId;
            return {
              start: () => this.start(t),
              end: () => this.end(t),
              do: function (s) {
                e.start(t);
                for (
                  var i = arguments.length,
                    n = new Array(i > 1 ? i - 1 : 0),
                    a = 1;
                  a < i;
                  a++
                )
                  n[a - 1] = arguments[a];
                const r = s(...n);
                return e.end(t), r;
              },
              doAsync: function (s) {
                e.start(t);
                for (
                  var i = arguments.length,
                    n = new Array(i > 1 ? i - 1 : 0),
                    a = 1;
                  a < i;
                  a++
                )
                  n[a - 1] = arguments[a];
                return s(...n).then((s) => (e.end(t), s));
              },
              reset: () => {
                this.data.delete(t);
              },
            };
          }
          start(e) {
            if (this.locked) return;
            const t = this.data.get(e);
            t
              ? this.data.set(
                  e,
                  Object(f.a)(Object(f.a)({}, t), {}, { start: Date.now() }),
                )
              : this.data.set(e, { time: 0, start: Date.now() });
          }
          end(e) {
            if (this.locked) return;
            const t = this.data.get(e);
            t &&
              this.data.set(
                e,
                Object(f.a)(
                  Object(f.a)({}, t),
                  {},
                  { time: t.time + Date.now() - t.start },
                ),
              );
          }
        }
        class U_ {
          constructor(e, t, s, n, a, r, o, d, l) {
            var c;
            (this.isNew = s),
              (this.isPinned = n),
              (this.isOwnerOrAdmin = a),
              (this.isMuted = r),
              (this.lastActiveTime = o),
              (this.totalMembers = d),
              (this.lastActiveTimeInDays = l),
              (this.segmentController = void 0),
              (this.hasMore = void 0),
              (this.tsCheck = void 0),
              (this.lastMsgId = void 0),
              (this.id = void 0),
              (this.convId = void 0),
              (this.metrics = void 0),
              (this.disabled = !1),
              (this.convId = this.id = t),
              (this.metrics = new k_(t)),
              (this.segmentController = e),
              (this.hasMore = !0),
              (this.tsCheck = i.ModuleContainer.resolve(yt).getTimeNow()),
              (this.lastMsgId =
                (null ===
                  (c = i.ModuleContainer.resolve(zt.b).getConvByIdSync(
                    this.convId,
                  )) || void 0 === c
                  ? void 0
                  : c.lastSmsLocalId) || "0");
          }
          getCursor() {
            return {
              value: () => this.getCurrentCursorValue(),
              next: (e) => this.update(e),
            };
          }
          async update(e) {
            const t = await this.segmentController.get(this.convId),
              s = await this.segmentController.updateSegment(t, e);
            this.hasMore = this.isHasMoreMessage(e, s);
          }
          disable() {
            this.disabled = !0;
          }
          async isDone() {
            return null === (await this.getCurrentCursorValue());
          }
          async getCurrentCursorValue() {
            var e;
            if (!this.hasMore) return null;
            if (this.disabled) return null;
            const t = await this.segmentController.get(this.convId),
              s = this.getRequestMsgId(t);
            return null === s
              ? null
              : {
                  convId: this.convId,
                  requestMsgId: s,
                  lastMsgId: this.lastMsgId,
                  lastDeleteMsgId:
                    (null === (e = t.lastDeletedMsgID) || void 0 === e
                      ? void 0
                      : e.toString()) || "0",
                };
          }
          getRequestMsgId(e) {
            var t, s, i;
            const n = null !== (t = e.lastDeletedMsgID) && void 0 !== t ? t : 0,
              a =
                null !== (s = e.lastCloudVerifiedDttm) && void 0 !== s ? s : 0,
              r =
                null !== (i = e.cloudSegmentCheckAutoFetch) && void 0 !== i
                  ? i
                  : [];
            if (parseInt(this.lastMsgId.replace(".", "")) <= n) return null;
            if (this.tsCheck > a) return "9999999999999999";
            for (let o = r.length - 1; o >= 0; o--) {
              const [e, t] = r[o];
              if (n >= t) return null;
              if (n < e) return String(e);
            }
            return null;
          }
          isHasMoreMessage(e, t) {
            return (
              !!e.hasMore &&
              0 !== e.messages.length &&
              this.getRequestMsgId(t) !== e.requestMsgId
            );
          }
        }
        class k_ {
          constructor(e) {
            (this.convId = e),
              (this.timeTracker = new B_()),
              (this.tsStart = 0),
              (this.tsStop = 0),
              (this.isDone = !1),
              (this.totalBatch = 0),
              (this.totalRetry = 0);
          }
          get metrics() {
            return i.ModuleContainer.resolve(Ey.l).get(Ey.k);
          }
          start() {
            this.tsStart = performance.now();
          }
          stop(e) {
            (this.tsStop = performance.now()), (this.isDone = e);
          }
          exportReport() {
            const e = this.tsStop || performance.now(),
              t = this.timeTracker.prepare.time,
              s = this.timeTracker.fetch.time,
              i = this.timeTracker.sync.time,
              n = e - this.tsStart,
              a = n - (t + s + i);
            return {
              convId: this.convId,
              meta: {
                isDone: this.isDone,
                total: this.totalBatch,
                retry: this.totalRetry,
              },
              duration: { total: n, prepare: t, fetch: s, save: i, idle: a },
            };
          }
          increaseBatch() {
            this.totalBatch++;
          }
          increaseRetry() {
            this.totalRetry++;
          }
          submit() {
            const e = this.exportReport();
            this.metrics.submitConvReport(e);
          }
        }
        class B_ {
          constructor() {
            (this.prepare = new N_("AFMC_prepare")),
              (this.fetch = new N_("AFMC_fetch")),
              (this.sync = new N_("AFMC_sync"));
          }
        }
        class G_ extends te.a {
          constructor() {
            super(Gy.OVERFLOW_DB_GROUP_OFFLINE);
          }
        }
        var x_, z_, V_, H_, $_, W_, K_, q_, Z_, J_, Q_, Y_, X_, eO;
        let tO =
          ((x_ = Object(Ga.e)()),
          (z_ = Object(My.d)()),
          (V_ = Object(My.e)(Ey.h)),
          (H_ = function (e, t) {
            return i.ModuleContainer.inject(q.ZLoggerFactory)(e, void 0, 0);
          }),
          ($_ = function (e, t) {
            return Object(Ga.d)(Ey.n)(e, void 0, 1);
          }),
          (W_ = function (e, t) {
            return Object(Ga.d)(Ey.o)(e, void 0, 2);
          }),
          (K_ = function (e, t) {
            return Object(Ga.d)(Ey.k)(e, void 0, 3);
          }),
          (q_ = Reflect.metadata("design:type", Function)),
          (Z_ = Reflect.metadata("design:paramtypes", [
            void 0 === q.ZLoggerFactory ? Object : q.ZLoggerFactory,
            "undefined" == typeof AFMC_IService ? Object : AFMC_IService,
            "undefined" == typeof AFMC_IStorage ? Object : AFMC_IStorage,
            "undefined" == typeof AFMC_IMetrics ? Object : AFMC_IMetrics,
          ])),
          void 0 === (sO = { maxRetry: 3, delay: 3e3 }) && (sO = yI),
          (J_ = (e, t, s) => {
            const i = s.value,
              n = "AsyncFunction" === i.constructor.name;
            s.value = n
              ? async function () {
                  for (
                    var e = arguments.length, t = new Array(e), s = 0;
                    s < e;
                    s++
                  )
                    t[s] = arguments[s];
                  let n = 0;
                  for (;;) {
                    var a, r;
                    const [e, s] = await Ba.b.catchAsyncFn(() =>
                      i.apply(this, t),
                    );
                    if (!e) return s;
                    if (
                      (null === (a = sO) ||
                        void 0 === a ||
                        null === (r = a.onRetry) ||
                        void 0 === r ||
                        r.call(a, e),
                      ++n >= sO.maxRetry)
                    )
                      throw e;
                    sO.delay &&
                      (await Ba.b.delay(sO.delay + 1e3 * Math.random()));
                  }
                }
              : function () {
                  for (
                    var e = arguments.length, t = new Array(e), s = 0;
                    s < e;
                    s++
                  )
                    t[s] = arguments[s];
                  let n = 0;
                  for (;;) {
                    var a, r;
                    const [e, s] = Ba.b.catchFn(() => i.apply(this, t));
                    if (!e) return s;
                    if (
                      (null === (a = sO) ||
                        void 0 === a ||
                        null === (r = a.onRetry) ||
                        void 0 === r ||
                        r.call(a, e),
                      ++n >= sO.maxRetry)
                    )
                      throw e;
                  }
                };
          }),
          (Q_ = Reflect.metadata("design:type", Function)),
          (Y_ = Reflect.metadata("design:paramtypes", [])),
          x_(
            (X_ =
              z_(
                (X_ =
                  V_(
                    (X_ =
                      H_(
                        (X_ =
                          $_(
                            (X_ =
                              W_(
                                (X_ =
                                  K_(
                                    (X_ =
                                      q_(
                                        (X_ =
                                          Z_(
                                            ((eO = class extends te.b {
                                              constructor(e, t, s, i) {
                                                super(),
                                                  (this.logger = void 0),
                                                  (this.service = void 0),
                                                  (this.storage = void 0),
                                                  (this.metrics = void 0),
                                                  (this.listCheckpoints =
                                                    void 0),
                                                  (this.currentCursorIndex =
                                                    void 0),
                                                  (this.logger =
                                                    e.createZLogger(
                                                      hs.ZLoggerNametags
                                                        .autoFetchMsgCloud,
                                                      [
                                                        hs.ZLoggerNametags
                                                          .stateMachine,
                                                      ],
                                                    )),
                                                  (this.service = t),
                                                  (this.storage = s),
                                                  (this.metrics = i),
                                                  (this.listCheckpoints = []),
                                                  (this.currentCursorIndex =
                                                    -1);
                                              }
                                              async init() {
                                                var e;
                                                const {
                                                  listGroups: t,
                                                  evict: s,
                                                } =
                                                  await this.service.getGroupsHasMessageOffline();
                                                s &&
                                                  this.dispatchEvent(new G_());
                                                const n = t.map(
                                                    (e) => e.convId,
                                                  ),
                                                  a =
                                                    i.ModuleContainer.resolve(
                                                      er,
                                                    );
                                                return (
                                                  (this.listCheckpoints = t.map(
                                                    (e) =>
                                                      new U_(
                                                        a,
                                                        e.convId,
                                                        e.isNewGroupOffline,
                                                        e.isPinned,
                                                        e.isOwnerOrAdmin,
                                                        e.isMuted,
                                                        e.lastActiveTime,
                                                        e.totalMembers,
                                                        e.lastActiveTimeInDays,
                                                      ),
                                                  )),
                                                  this.listCheckpoints.sort(
                                                    Ba.a.Sorter.create([
                                                      {
                                                        key: "lastActiveTime",
                                                        comparer:
                                                          Ba.a.Sorter.Comparer
                                                            .number,
                                                        order:
                                                          Ba.a.Sorter.Order.DES,
                                                      },
                                                      {
                                                        key: "isPinned",
                                                        comparer:
                                                          Ba.a.Sorter.Comparer
                                                            .bool,
                                                      },
                                                      {
                                                        key: "isOwnerOrAdmin",
                                                        comparer:
                                                          Ba.a.Sorter.Comparer
                                                            .bool,
                                                      },
                                                      {
                                                        key: "isMuted",
                                                        comparer:
                                                          Ba.a.Sorter.Comparer
                                                            .bool,
                                                        order:
                                                          Ba.a.Sorter.Order.DES,
                                                      },
                                                      {
                                                        key: "lastActiveTimeInDays",
                                                        comparer:
                                                          Ba.a.Sorter.Comparer
                                                            .number,
                                                      },
                                                      {
                                                        key: "totalMembers",
                                                        comparer:
                                                          Ba.a.Sorter.Comparer
                                                            .number,
                                                      },
                                                    ]),
                                                  ),
                                                  (this.currentCursorIndex =
                                                    0 -
                                                    Number(
                                                      this.listCheckpoints
                                                        .length <= 0,
                                                    )),
                                                  null ===
                                                    (e =
                                                      this.getCurrentCursorValue()) ||
                                                    void 0 === e ||
                                                    e.metrics.start(),
                                                  await this.storage.saveConvIds(
                                                    n,
                                                  ),
                                                  await this.storage.removeOverflowInfo(),
                                                  n.length &&
                                                    (this.logger.zsymb(
                                                      0,
                                                      16698,
                                                      3e4,
                                                      "init ledger success",
                                                      n,
                                                    ),
                                                    await this.submitMetricReport()),
                                                  this.listCheckpoints.some(
                                                    (e) => e.isNew,
                                                  )
                                                );
                                              }
                                              async size() {
                                                return await this.storage.getRemainConv();
                                              }
                                              async clear() {
                                                await Promise.all([
                                                  this.storage.saveConvIds([]),
                                                  this.storage.removeOverflowInfo(),
                                                ]),
                                                  (this.listCheckpoints = []);
                                              }
                                              getCursor() {
                                                return {
                                                  value: async () =>
                                                    this.getCurrentCursorValue(),
                                                  next: async () =>
                                                    this.handleNextCursor(),
                                                };
                                              }
                                              async remove(e) {
                                                await this.storage.removeConvId(
                                                  e,
                                                );
                                                const t =
                                                  this.listCheckpoints.find(
                                                    (t) => t.id === e,
                                                  );
                                                return !!t && (t.disable(), !0);
                                              }
                                              async submitMetricReport() {
                                                const e =
                                                    this.listCheckpoints.length,
                                                  t =
                                                    this.listCheckpoints.filter(
                                                      (e) => e.isNew,
                                                    ).length;
                                                this.metrics.submitLedgerReport(
                                                  {
                                                    totalConv: e,
                                                    totalNewConv: t,
                                                  },
                                                );
                                              }
                                              getCurrentCursorValue() {
                                                var e;
                                                return null !==
                                                  (e =
                                                    this.listCheckpoints[
                                                      this.currentCursorIndex
                                                    ]) && void 0 !== e
                                                  ? e
                                                  : null;
                                              }
                                              async handleNextCursor() {
                                                var e;
                                                const t =
                                                  this.getCurrentCursorValue();
                                                if (t) {
                                                  const e = await t.isDone();
                                                  e &&
                                                    (await this.storage.removeConvId(
                                                      t.convId,
                                                    )),
                                                    t.metrics.stop(e),
                                                    t.metrics.submit();
                                                }
                                                this.currentCursorIndex++,
                                                  null ===
                                                    (e =
                                                      this.getCurrentCursorValue()) ||
                                                    void 0 === e ||
                                                    e.metrics.start();
                                              }
                                            }),
                                            Object(Sp.a)(
                                              eO.prototype,
                                              "init",
                                              [J_, Q_, Y_],
                                              Object.getOwnPropertyDescriptor(
                                                eO.prototype,
                                                "init",
                                              ),
                                              eO.prototype,
                                            ),
                                            (X_ = eO)),
                                          ) || X_),
                                      ) || X_),
                                  ) || X_),
                              ) || X_),
                          ) || X_),
                      ) || X_),
                  ) || X_),
              ) || X_),
          ) || X_);
        var sO;
        let iO, nO, aO, rO, oO;
        !(function (e) {
          e[(e.SEGMENT_UPDATED = 0)] = "SEGMENT_UPDATED";
        })(iO || (iO = {})),
          (function (e) {
            (e.SUCCESS = "success"),
              (e.FAILED = "failed"),
              (e.FILLED_BY_SYNC = "filled_by_sync");
          })(nO || (nO = {})),
          (function (e) {
            (e.NONE = "none"), (e.CLOSE_APP = "close_app");
          })(aO || (aO = {})),
          (function (e) {
            (e[(e.AVG_EXECUTION_TIME_EACH_CONV = 151050)] =
              "AVG_EXECUTION_TIME_EACH_CONV"),
              (e[(e.AVG_BATCH = 151051)] = "AVG_BATCH"),
              (e[(e.AVG_BATCH_RETRY = 151052)] = "AVG_BATCH_RETRY"),
              (e[(e.AVG_CONV = 151053)] = "AVG_CONV"),
              (e[(e.AVG_NEW_CONV = 151054)] = "AVG_NEW_CONV"),
              (e[(e.ERROR_RUNNING = 151055)] = "ERROR_RUNNING");
          })(rO || (rO = {})),
          (function (e) {
            e[(e.SYNC_MESSAGE = 0)] = "SYNC_MESSAGE";
          })(oO || (oO = {}));
        var dO = s("Fbac");
        let lO, cO, hO;
        !(function (e) {
          (e.PREPARE_BATCH = "PREPARE_BATCH"),
            (e.FETCH_MESSAGE = "FETCH_MESSAGE"),
            (e.PROCESS_MESSAGE = "PROCESS_MESSAGE");
        })(lO || (lO = {})),
          (function (e) {
            (e[(e.PREPARE_BATCH = 0)] = "PREPARE_BATCH"),
              (e[(e.FETCH_MESSAGE = 1)] = "FETCH_MESSAGE"),
              (e[(e.PROCESS_MESSAGE = 2)] = "PROCESS_MESSAGE");
          })(cO || (cO = {}));
        class uO extends xa {
          constructor(e, t) {
            super(
              "ErrorTaskAborted",
              -1,
              `Task [type,id]=[${e},${t}] is aborted`,
            );
          }
        }
        !(function (e) {
          (e.ABORT = "ABORT"),
            (e.PAUSE = "PAUSE"),
            (e.RESUME = "RESUME"),
            (e.FULFILLED = "FULFILLED");
        })(hO || (hO = {}));
        class gO extends te.b {
          constructor() {
            super(),
              (this.id = void 0),
              (this.type = void 0),
              (this.promiseContainer = void 0),
              (this.abortee = void 0),
              (this.status = void 0),
              (this.isPaused = void 0),
              (this.result = void 0),
              (this.error = void 0),
              (this.onAbort = () => {
                (this.error = new uO(this.type, this.id)),
                  this.resolvePromise(),
                  this.dispatchEvent(new te.a(hO.ABORT));
              }),
              (this.status = "idle"),
              (this.isPaused = !1),
              (this.abortee = new AbortController()),
              (this.promiseContainer = new Ba.b.Container());
          }
          exec(e) {
            return (
              (this.status = "pending"),
              this.abortee.signal.addEventListener("abort", this.onAbort, {
                once: !0,
              }),
              Ba.b.catchPromise(e()).then((e) => {
                let [t, s] = e;
                (this.error = t),
                  (this.result = s),
                  (this.status = "fulfilled"),
                  this.isPaused || this.resolvePromise();
              }),
              this
            );
          }
          toPromise() {
            return this.promiseContainer.promise;
          }
          pause() {
            (this.isPaused = !0), this.dispatchEvent(new te.a(hO.PAUSE));
          }
          resume() {
            (this.isPaused = !1),
              this.dispatchEvent(new te.a(hO.RESUME)),
              this.abortee.signal.aborted ||
                ("fulfilled" === this.status && this.resolvePromise());
          }
          abort() {
            this.abortee.abort();
          }
          resolvePromise() {
            this.error
              ? this.promiseContainer.reject(this.error)
              : this.promiseContainer.resolve(this.result),
              this.dispatchEvent(new te.a(hO.FULFILLED)),
              this.abortee.signal.removeEventListener("abort", this.onAbort),
              this.removeAllEventListener();
          }
        }
        class mO extends gO {
          constructor() {
            super(),
              (this.id = void 0),
              (this.type = "prepare"),
              (this.id = ++mO.counter);
          }
        }
        mO.counter = 0;
        class pO extends gO {
          constructor() {
            super(),
              (this.id = void 0),
              (this.type = "fetch"),
              (this.id = ++pO.counter);
          }
        }
        pO.counter = 0;
        class fO extends gO {
          constructor() {
            super(),
              (this.id = void 0),
              (this.type = "process"),
              (this.id = ++fO.counter);
          }
        }
        fO.counter = 0;
        class vO extends gO {
          constructor() {
            super(),
              (this.id = void 0),
              (this.type = "sleep"),
              (this.id = ++vO.counter);
          }
        }
        vO.counter = 0;
        const bO = {
          isBackground: !1,
          pausedCounter: 0,
          error: null,
          totalMessageFetched: 0,
          totalMessageSaved: 0,
          task: null,
          currentStep: lO.PREPARE_BATCH,
          convCheckpoint: null,
          batchRequestInfo: null,
          batchResponseInfo: null,
          retryCounter: 0,
        };
        var IO;
        let yO =
          Object(My.d)()(
            (IO =
              Object(Ga.e)()(
                (IO =
                  Object(My.e)(Ey.i)(
                    (IO =
                      (function (e, t) {
                        return Object(Ga.d)(Ey.h)(e, void 0, 0);
                      })(
                        (IO =
                          (function (e, t) {
                            return Object(Ga.d)(Ey.b)(e, void 0, 1);
                          })(
                            (IO =
                              (function (e, t) {
                                return Object(Ga.d)(Ey.n)(e, void 0, 2);
                              })(
                                (IO =
                                  (function (e, t) {
                                    return Object(Ga.d)(Ey.o)(e, void 0, 3);
                                  })(
                                    (IO =
                                      (function (e, t) {
                                        return Object(Ga.d)(Ey.k)(e, void 0, 4);
                                      })(
                                        (IO =
                                          (function (e, t) {
                                            return i.ModuleContainer.inject(
                                              Ey.d,
                                            )(e, void 0, 5);
                                          })(
                                            (IO =
                                              (function (e, t) {
                                                return i.ModuleContainer.inject(
                                                  yt,
                                                )(e, void 0, 6);
                                              })(
                                                (IO =
                                                  (function (e, t) {
                                                    return Object(Ga.d)(Sy)(
                                                      e,
                                                      void 0,
                                                      7,
                                                    );
                                                  })(
                                                    (IO =
                                                      (function (e, t) {
                                                        return Object(Ga.d)(
                                                          Ey.e,
                                                        )(e, void 0, 8);
                                                      })(
                                                        (IO =
                                                          (function (e, t) {
                                                            return i.ModuleContainer.inject(
                                                              q.ZLoggerFactory,
                                                            )(e, void 0, 9);
                                                          })(
                                                            (IO =
                                                              Reflect.metadata(
                                                                "design:type",
                                                                Function,
                                                              )(
                                                                (IO =
                                                                  Reflect.metadata(
                                                                    "design:paramtypes",
                                                                    [
                                                                      "undefined" ==
                                                                      typeof AFMC_ILedger
                                                                        ? Object
                                                                        : AFMC_ILedger,
                                                                      "undefined" ==
                                                                      typeof AFMC_IConfig
                                                                        ? Object
                                                                        : AFMC_IConfig,
                                                                      "undefined" ==
                                                                      typeof AFMC_IService
                                                                        ? Object
                                                                        : AFMC_IService,
                                                                      "undefined" ==
                                                                      typeof AFMC_IStorage
                                                                        ? Object
                                                                        : AFMC_IStorage,
                                                                      "undefined" ==
                                                                      typeof AFMC_IMetrics
                                                                        ? Object
                                                                        : AFMC_IMetrics,
                                                                      "undefined" ==
                                                                      typeof AFMC_IDevtoolMonitor
                                                                        ? Object
                                                                        : AFMC_IDevtoolMonitor,
                                                                      "undefined" ==
                                                                      typeof ISystemTime
                                                                        ? Object
                                                                        : ISystemTime,
                                                                      "undefined" ==
                                                                      typeof ISocketPolling
                                                                        ? Object
                                                                        : ISocketPolling,
                                                                      "undefined" ==
                                                                      typeof AFMC_IEventCollector
                                                                        ? Object
                                                                        : AFMC_IEventCollector,
                                                                      void 0 ===
                                                                      q.ZLoggerFactory
                                                                        ? Object
                                                                        : q.ZLoggerFactory,
                                                                    ],
                                                                  )(
                                                                    (IO = class extends (
                                                                      uc
                                                                    ) {
                                                                      constructor(
                                                                        e,
                                                                        t,
                                                                        s,
                                                                        i,
                                                                        n,
                                                                        a,
                                                                        r,
                                                                        o,
                                                                        d,
                                                                        l,
                                                                      ) {
                                                                        super(),
                                                                          (this.logger =
                                                                            void 0),
                                                                          (this.config =
                                                                            void 0),
                                                                          (this.ledger =
                                                                            void 0),
                                                                          (this.service =
                                                                            void 0),
                                                                          (this.storage =
                                                                            void 0),
                                                                          (this.monitor =
                                                                            void 0),
                                                                          (this.metrics =
                                                                            void 0),
                                                                          (this.systemTime =
                                                                            void 0),
                                                                          (this.socketPolling =
                                                                            void 0),
                                                                          (this.eventCollector =
                                                                            void 0),
                                                                          (this.isSyncMessageSuccess =
                                                                            !1),
                                                                          (this.isHasRemainConvInPrevSessionFetch =
                                                                            !1),
                                                                          (this.registerSessionFetchListener =
                                                                            () => {
                                                                              this.logger.zsymb(
                                                                                0,
                                                                                16704,
                                                                                30002,
                                                                                "register session fetch listener",
                                                                              ),
                                                                                this.eventCollector.addEventListener(
                                                                                  By
                                                                                    .a
                                                                                    .LOAD_MESSAGE,
                                                                                  this
                                                                                    .onLoadMessage,
                                                                                ),
                                                                                this.eventCollector.addEventListener(
                                                                                  By
                                                                                    .a
                                                                                    .APPLICATION_BACKGROUND,
                                                                                  this
                                                                                    .onApplicationBackground,
                                                                                ),
                                                                                this.eventCollector.addEventListener(
                                                                                  By
                                                                                    .a
                                                                                    .APPLICATION_FOREGROUND,
                                                                                  this
                                                                                    .onApplicationForeground,
                                                                                );
                                                                            }),
                                                                          (this.unregisterSessionFetchListener =
                                                                            () => {
                                                                              this.logger.zsymb(
                                                                                0,
                                                                                16704,
                                                                                30003,
                                                                                "unregister session fetch listener",
                                                                              ),
                                                                                this.eventCollector.removeEventListener(
                                                                                  By
                                                                                    .a
                                                                                    .LOAD_MESSAGE,
                                                                                  this
                                                                                    .onLoadMessage,
                                                                                ),
                                                                                this.eventCollector.removeEventListener(
                                                                                  By
                                                                                    .a
                                                                                    .APPLICATION_BACKGROUND,
                                                                                  this
                                                                                    .onApplicationBackground,
                                                                                ),
                                                                                this.eventCollector.removeEventListener(
                                                                                  By
                                                                                    .a
                                                                                    .APPLICATION_FOREGROUND,
                                                                                  this
                                                                                    .onApplicationForeground,
                                                                                );
                                                                            }),
                                                                          (this.onEventChange =
                                                                            (
                                                                              e,
                                                                            ) => {
                                                                              switch (
                                                                                e.type
                                                                              ) {
                                                                                case "START":
                                                                                  this.registerSessionFetchListener();
                                                                                  break;
                                                                                case "STOP":
                                                                                  this.unregisterSessionFetchListener(),
                                                                                    this.submitFetchResult();
                                                                                  break;
                                                                                case "NEXT_TO_SLEEP_TO_NEXT_HOUR":
                                                                                  this.logger.zsymb(
                                                                                    0,
                                                                                    16704,
                                                                                    30004,
                                                                                    "Busy hour, let sleep to next hour",
                                                                                  );
                                                                                  break;
                                                                                case "TRY_MOVE_TO_NEXT_CONV":
                                                                                  this.onFetchConvError(
                                                                                    e
                                                                                      .data
                                                                                      .currConvId,
                                                                                  );
                                                                                  break;
                                                                                case "PROCESS_MESSAGE_SUCCESS":
                                                                                  this.storage.saveTotalMessageFetched(
                                                                                    e
                                                                                      .data
                                                                                      .totalMessageFetched,
                                                                                  );
                                                                                  break;
                                                                                case "FAILED":
                                                                                  const t =
                                                                                      this
                                                                                        .interpreter
                                                                                        .state
                                                                                        .context,
                                                                                    {
                                                                                      batchRequestInfo:
                                                                                        s,
                                                                                      currentStep:
                                                                                        i,
                                                                                    } =
                                                                                      t,
                                                                                    n = `${i}-${null == s ? void 0 : s.convId}-${null == s ? void 0 : s.requestMsgId}`;
                                                                                  this.logger.zsymb(
                                                                                    18,
                                                                                    16704,
                                                                                    30005,
                                                                                    `An error ocurred during fetch message ${n}`,
                                                                                  ),
                                                                                    this.logger.zsymb(
                                                                                      18,
                                                                                      16704,
                                                                                      30006,
                                                                                      e.error,
                                                                                    ),
                                                                                    this.metrics.submitErrorRunning(
                                                                                      i,
                                                                                      e.error,
                                                                                    );
                                                                              }
                                                                            }),
                                                                          (this.onEventChangeForDevtool =
                                                                            async (
                                                                              e,
                                                                            ) => {
                                                                              switch (
                                                                                e.type
                                                                              ) {
                                                                                case "PREPARE_BATCH_SUCCESS":
                                                                                  this.monitor.updateBatchRequestInfo(
                                                                                    e
                                                                                      .data
                                                                                      .batchRequestInfo,
                                                                                  ),
                                                                                    this.monitor.updateRemainConv(
                                                                                      await this.ledger.size(),
                                                                                    ),
                                                                                    this.config.get(
                                                                                      "debugger.logger.batch_request_info",
                                                                                    ) &&
                                                                                      this.logger.zsymb(
                                                                                        12,
                                                                                        16704,
                                                                                        30007,
                                                                                        "batch request info",
                                                                                        e
                                                                                          .data
                                                                                          .batchRequestInfo,
                                                                                      );
                                                                                  break;
                                                                                case "PROCESS_MESSAGE_SUCCESS":
                                                                                  var t,
                                                                                    s;
                                                                                  if (
                                                                                    (this.monitor.updateTotalMessageFetched(
                                                                                      e
                                                                                        .data
                                                                                        .totalMessageFetched,
                                                                                    ),
                                                                                    this.config.get(
                                                                                      "debugger.logger.save_message",
                                                                                    ))
                                                                                  )
                                                                                    this.logger.zsymb(
                                                                                      12,
                                                                                      16704,
                                                                                      30008,
                                                                                      "save message result",
                                                                                      null ===
                                                                                        (t =
                                                                                          e
                                                                                            .data
                                                                                            .result) ||
                                                                                        void 0 ===
                                                                                          t
                                                                                        ? void 0
                                                                                        : t.batchInfo,
                                                                                      null ===
                                                                                        (s =
                                                                                          e
                                                                                            .data
                                                                                            .result) ||
                                                                                        void 0 ===
                                                                                          s
                                                                                        ? void 0
                                                                                        : s.messages.map(
                                                                                            (
                                                                                              e,
                                                                                            ) =>
                                                                                              e.msgId,
                                                                                          ),
                                                                                    );
                                                                                  break;
                                                                                case "STOP":
                                                                                  this.monitor.updateBatchRequestInfo(
                                                                                    null,
                                                                                  ),
                                                                                    this.monitor.updateRemainConv(
                                                                                      await this.ledger.size(),
                                                                                    );
                                                                              }
                                                                            }),
                                                                          (this.onTransitionChangeForDevtool =
                                                                            (
                                                                              e,
                                                                            ) => {
                                                                              const t =
                                                                                [
                                                                                  "idle",
                                                                                  "running",
                                                                                  "paused",
                                                                                  "locked",
                                                                                ];
                                                                              for (const s of t)
                                                                                if (
                                                                                  e.matches(
                                                                                    s,
                                                                                  )
                                                                                )
                                                                                  return this.monitor.updateStatus(
                                                                                    s,
                                                                                  );
                                                                            }),
                                                                          (this.onFetchConvError =
                                                                            async (
                                                                              e,
                                                                            ) => {
                                                                              this.logger.zsymb(
                                                                                18,
                                                                                16704,
                                                                                30009,
                                                                                "Save conv fetch failed",
                                                                                e,
                                                                              ),
                                                                                await this.storage.saveConvErrorId(
                                                                                  e,
                                                                                );
                                                                            }),
                                                                          (this.onStartPullDataOffline =
                                                                            () => {
                                                                              this.pauseMachine();
                                                                            }),
                                                                          (this.onStopPullDataOffline =
                                                                            async () => {
                                                                              var e,
                                                                                t;
                                                                              let s =
                                                                                await this.ledger.size();
                                                                              s >
                                                                                0 &&
                                                                                ((this.isHasRemainConvInPrevSessionFetch =
                                                                                  !0),
                                                                                this.metrics.logResumeFetchAfterInterupt());
                                                                              const [
                                                                                i,
                                                                                n,
                                                                              ] =
                                                                                await Ba.b.catchPromise(
                                                                                  this.ledger.init(),
                                                                                );
                                                                              if (
                                                                                i
                                                                              )
                                                                                return (
                                                                                  this.logger.zsymb(
                                                                                    18,
                                                                                    16704,
                                                                                    30010,
                                                                                    "An error occured during init ledger",
                                                                                    i,
                                                                                  ),
                                                                                  void this.stopMachine()
                                                                                );
                                                                              n &&
                                                                                this.resetMachine(),
                                                                                (s =
                                                                                  await this.ledger.size()),
                                                                                (null !==
                                                                                  (e =
                                                                                    this
                                                                                      .interpreter) &&
                                                                                  void 0 !==
                                                                                    e &&
                                                                                  null !==
                                                                                    (t =
                                                                                      e
                                                                                        .state
                                                                                        .history) &&
                                                                                  void 0 !==
                                                                                    t &&
                                                                                  t.matches(
                                                                                    "running",
                                                                                  )) ||
                                                                                0 ===
                                                                                  s
                                                                                  ? (this.logger.zsymb(
                                                                                      0,
                                                                                      16704,
                                                                                      30011,
                                                                                      "resume machine",
                                                                                    ),
                                                                                    this.resumeMachine())
                                                                                  : (this.logger.zsymb(
                                                                                      0,
                                                                                      16704,
                                                                                      30012,
                                                                                      "start machine",
                                                                                    ),
                                                                                    this.startMachine(),
                                                                                    await this.storage.saveLastTsStartFetch(
                                                                                      this.systemTime.getTimeNow(),
                                                                                    ));
                                                                            }),
                                                                          (this.onStartTransferMessage =
                                                                            () => {
                                                                              var e;
                                                                              null !=
                                                                                this &&
                                                                                null !==
                                                                                  (e =
                                                                                    this
                                                                                      .interpreter) &&
                                                                                void 0 !==
                                                                                  e &&
                                                                                e.state.matches(
                                                                                  "running",
                                                                                ) &&
                                                                                this.metrics.logStartInteruptFetch(
                                                                                  oO.SYNC_MESSAGE,
                                                                                ),
                                                                                this.pauseMachine();
                                                                            }),
                                                                          (this.onStopTransferMessage =
                                                                            async (
                                                                              e,
                                                                            ) => {
                                                                              e.isSuccess
                                                                                ? ((this.isSyncMessageSuccess =
                                                                                    !0),
                                                                                  await this.ledger.clear(),
                                                                                  this.stopMachine())
                                                                                : ((this.isSyncMessageSuccess =
                                                                                    !1),
                                                                                  this.resumeMachine()),
                                                                                this.metrics.logStopInteruptFetch(
                                                                                  oO.SYNC_MESSAGE,
                                                                                  e.isSuccess,
                                                                                );
                                                                            }),
                                                                          (this.onDeleteConv =
                                                                            async (
                                                                              e,
                                                                            ) => {
                                                                              this.logger.zsymb(
                                                                                0,
                                                                                16704,
                                                                                30013,
                                                                                `Receive delete conversation ${e.convId} event`,
                                                                              ),
                                                                                this.handleRemoveConv(
                                                                                  e.convId,
                                                                                );
                                                                            }),
                                                                          (this.onLeaveGroup =
                                                                            async (
                                                                              e,
                                                                            ) => {
                                                                              this.logger.zsymb(
                                                                                0,
                                                                                16704,
                                                                                30014,
                                                                                `Receive leave group ${e.convId} event`,
                                                                              ),
                                                                                this.handleRemoveConv(
                                                                                  e.convId,
                                                                                );
                                                                            }),
                                                                          (this.onLoadMessage =
                                                                            (
                                                                              e,
                                                                            ) => {
                                                                              this.pauseMachine();
                                                                              const t =
                                                                                this.config.get(
                                                                                  "debugger.simulator.slow_load_message",
                                                                                );
                                                                              e.promiseContainer.promise
                                                                                .then(
                                                                                  () =>
                                                                                    t
                                                                                      ? Ba.b.delay(
                                                                                          5e3,
                                                                                        )
                                                                                      : void 0,
                                                                                )
                                                                                .finally(
                                                                                  () =>
                                                                                    this.resumeMachine(),
                                                                                );
                                                                            }),
                                                                          (this.onApplicationBackground =
                                                                            () => {
                                                                              this.backgroundMachine();
                                                                            }),
                                                                          (this.onApplicationForeground =
                                                                            () => {
                                                                              this.foregroundMachine();
                                                                            }),
                                                                          (this.submitFetchResult =
                                                                            async () => {
                                                                              var e;
                                                                              const t =
                                                                                  await this.storage.getLastStartAutoFetchMessageInfo(),
                                                                                s =
                                                                                  this.systemTime.getTimeNow();
                                                                              if (
                                                                                !!(
                                                                                  null !==
                                                                                    (e =
                                                                                      null ==
                                                                                      t
                                                                                        ? void 0
                                                                                        : t.convIds) &&
                                                                                  void 0 !==
                                                                                    e
                                                                                    ? e
                                                                                    : []
                                                                                )
                                                                                  .length
                                                                              ) {
                                                                                var i,
                                                                                  n,
                                                                                  a;
                                                                                const e =
                                                                                    async () =>
                                                                                      (await this.ledger.size()) >
                                                                                      0
                                                                                        ? nO.FAILED
                                                                                        : this
                                                                                              .isSyncMessageSuccess
                                                                                          ? nO.FILLED_BY_SYNC
                                                                                          : nO.SUCCESS,
                                                                                  r =
                                                                                    {
                                                                                      result:
                                                                                        await e(),
                                                                                      interupted:
                                                                                        this
                                                                                          .isHasRemainConvInPrevSessionFetch
                                                                                          ? aO.CLOSE_APP
                                                                                          : aO.NONE,
                                                                                      time:
                                                                                        s -
                                                                                        (null !==
                                                                                          (i =
                                                                                            t.lastTsStart) &&
                                                                                        void 0 !==
                                                                                          i
                                                                                          ? i
                                                                                          : 0),
                                                                                      totalConvFetched:
                                                                                        (null ===
                                                                                          (n =
                                                                                            t.convIds) ||
                                                                                        void 0 ===
                                                                                          n
                                                                                          ? void 0
                                                                                          : n.length) ||
                                                                                        0,
                                                                                      convFetchFailed:
                                                                                        (null ===
                                                                                          (a =
                                                                                            t.convErrorIds) ||
                                                                                        void 0 ===
                                                                                          a
                                                                                          ? void 0
                                                                                          : a.length) ||
                                                                                        0,
                                                                                      totalMsgFetched:
                                                                                        t.totalMsgFetched ||
                                                                                        0,
                                                                                    };
                                                                                this.logger.zsymb(
                                                                                  12,
                                                                                  16704,
                                                                                  30017,
                                                                                  "submit fetch result",
                                                                                  r,
                                                                                ),
                                                                                  this.metrics.submitResultReport(
                                                                                    r,
                                                                                  ),
                                                                                  await this.storage.removeLastStartFetch();
                                                                              }
                                                                              (this.isSyncMessageSuccess =
                                                                                !1),
                                                                                (this.isHasRemainConvInPrevSessionFetch =
                                                                                  !1);
                                                                            }),
                                                                          (this.autoStartMachine =
                                                                            () => {
                                                                              var e,
                                                                                t;
                                                                              null !==
                                                                                (e =
                                                                                  this
                                                                                    .socketPolling
                                                                                    .chatHandler) &&
                                                                                void 0 !==
                                                                                  e &&
                                                                                e.isDoneOffline &&
                                                                                null !==
                                                                                  (t =
                                                                                    this
                                                                                      .interpreter) &&
                                                                                void 0 !==
                                                                                  t &&
                                                                                t.state.matches(
                                                                                  "idle",
                                                                                ) &&
                                                                                (this.logger.zsymb(
                                                                                  0,
                                                                                  16704,
                                                                                  30018,
                                                                                  "Done offline detected, auto dispatch stop pull offline",
                                                                                ),
                                                                                this.onStopPullDataOffline());
                                                                            }),
                                                                          (this.startMachine =
                                                                            () =>
                                                                              this.send(
                                                                                {
                                                                                  type: "START",
                                                                                },
                                                                              )),
                                                                          (this.resetMachine =
                                                                            () =>
                                                                              this.send(
                                                                                {
                                                                                  type: "RESET",
                                                                                },
                                                                              )),
                                                                          (this.stopMachine =
                                                                            () =>
                                                                              this.send(
                                                                                {
                                                                                  type: "STOP",
                                                                                },
                                                                              )),
                                                                          (this.pauseMachine =
                                                                            () =>
                                                                              this.send(
                                                                                {
                                                                                  type: "PAUSED",
                                                                                },
                                                                              )),
                                                                          (this.resumeMachine =
                                                                            () =>
                                                                              this.send(
                                                                                {
                                                                                  type: "RESUME",
                                                                                },
                                                                              )),
                                                                          (this.foregroundMachine =
                                                                            () =>
                                                                              this.send(
                                                                                {
                                                                                  type: "FOREGROUND",
                                                                                },
                                                                              )),
                                                                          (this.backgroundMachine =
                                                                            () =>
                                                                              this.send(
                                                                                {
                                                                                  type: "BACKGROUND",
                                                                                },
                                                                              )),
                                                                          (this.logger =
                                                                            l.createZLogger(
                                                                              hs
                                                                                .ZLoggerNametags
                                                                                .autoFetchMsgCloud,
                                                                              [
                                                                                hs
                                                                                  .ZLoggerNametags
                                                                                  .stateMachine,
                                                                              ],
                                                                            )),
                                                                          (this.ledger =
                                                                            e),
                                                                          (this.config =
                                                                            t),
                                                                          (this.service =
                                                                            s),
                                                                          (this.storage =
                                                                            i),
                                                                          (this.metrics =
                                                                            n),
                                                                          (this.monitor =
                                                                            a),
                                                                          (this.systemTime =
                                                                            r),
                                                                          (this.socketPolling =
                                                                            o),
                                                                          (this.eventCollector =
                                                                            d);
                                                                      }
                                                                      createMachine() {
                                                                        return (
                                                                          (e =
                                                                            this
                                                                              .ledger),
                                                                          (t =
                                                                            this
                                                                              .service),
                                                                          Object(
                                                                            mc.a,
                                                                          )(
                                                                            {
                                                                              id: "afmc-machine-v2",
                                                                              initial:
                                                                                "idle",
                                                                              context:
                                                                                bO,
                                                                              states:
                                                                                {
                                                                                  idle: {
                                                                                    on: {
                                                                                      RESUME:
                                                                                        {
                                                                                          target:
                                                                                            "#afmc-machine-v2.resume",
                                                                                          actions:
                                                                                            [
                                                                                              "decreasePausedCounter",
                                                                                              "logPausedCounter",
                                                                                            ],
                                                                                        },
                                                                                    },
                                                                                  },
                                                                                  running:
                                                                                    {
                                                                                      id: "running",
                                                                                      type: "compound",
                                                                                      initial:
                                                                                        "checking",
                                                                                      states:
                                                                                        {
                                                                                          checking:
                                                                                            {
                                                                                              invoke:
                                                                                                {
                                                                                                  src:
                                                                                                    (
                                                                                                      s,
                                                                                                    ) =>
                                                                                                    async (
                                                                                                      i,
                                                                                                    ) => {
                                                                                                      var n;
                                                                                                      if (
                                                                                                        null ===
                                                                                                        (await e
                                                                                                          .getCursor()
                                                                                                          .value())
                                                                                                      )
                                                                                                        return void i(
                                                                                                          {
                                                                                                            type: "STOP",
                                                                                                          },
                                                                                                        );
                                                                                                      const [
                                                                                                        a,
                                                                                                        r,
                                                                                                      ] =
                                                                                                        t.checkBusyHour();
                                                                                                      if (
                                                                                                        a
                                                                                                      )
                                                                                                        i(
                                                                                                          {
                                                                                                            type: "NEXT_TO_SLEEP_TO_NEXT_HOUR",
                                                                                                            data: {
                                                                                                              time: r,
                                                                                                            },
                                                                                                          },
                                                                                                        );
                                                                                                      else if (
                                                                                                        "sleep" !==
                                                                                                        (null ===
                                                                                                          (n =
                                                                                                            s.task) ||
                                                                                                        void 0 ===
                                                                                                          n
                                                                                                          ? void 0
                                                                                                          : n.type)
                                                                                                      )
                                                                                                        if (
                                                                                                          s.isBackground ||
                                                                                                          t.allowFetchForeground()
                                                                                                        )
                                                                                                          switch (
                                                                                                            s.currentStep
                                                                                                          ) {
                                                                                                            case lO.PREPARE_BATCH:
                                                                                                              return void i(
                                                                                                                {
                                                                                                                  type: "NEXT_TO_PREPARE_BATCH",
                                                                                                                },
                                                                                                              );
                                                                                                            case lO.FETCH_MESSAGE:
                                                                                                              return void i(
                                                                                                                {
                                                                                                                  type: "NEXT_TO_FETCH_MESSAGE",
                                                                                                                },
                                                                                                              );
                                                                                                            case lO.PROCESS_MESSAGE:
                                                                                                              return void i(
                                                                                                                {
                                                                                                                  type: "NEXT_TO_PROCESS_MESSAGE",
                                                                                                                },
                                                                                                              );
                                                                                                            default:
                                                                                                              return void i(
                                                                                                                {
                                                                                                                  type: "NEXT_TO_SLEEP",
                                                                                                                },
                                                                                                              );
                                                                                                          }
                                                                                                        else
                                                                                                          i(
                                                                                                            {
                                                                                                              type: "NEXT_TO_SLEEP",
                                                                                                            },
                                                                                                          );
                                                                                                      else
                                                                                                        i(
                                                                                                          {
                                                                                                            type: "NEXT_TO_SLEEP",
                                                                                                          },
                                                                                                        );
                                                                                                    },
                                                                                                },
                                                                                              on: {
                                                                                                NEXT_TO_PREPARE_BATCH:
                                                                                                  {
                                                                                                    target:
                                                                                                      "#running.prepareBatch",
                                                                                                  },
                                                                                                NEXT_TO_FETCH_MESSAGE:
                                                                                                  {
                                                                                                    target:
                                                                                                      "#running.fetchMessage",
                                                                                                  },
                                                                                                NEXT_TO_PROCESS_MESSAGE:
                                                                                                  {
                                                                                                    target:
                                                                                                      "#running.processMessage",
                                                                                                  },
                                                                                                NEXT_TO_SLEEP:
                                                                                                  {
                                                                                                    target:
                                                                                                      "#running.sleep",
                                                                                                  },
                                                                                                NEXT_TO_SLEEP_TO_NEXT_HOUR:
                                                                                                  {
                                                                                                    target:
                                                                                                      "#running.sleep",
                                                                                                  },
                                                                                                STOP: {
                                                                                                  target:
                                                                                                    "#afmc-machine-v2.idle",
                                                                                                },
                                                                                              },
                                                                                            },
                                                                                          prepareBatch:
                                                                                            {
                                                                                              invoke:
                                                                                                {
                                                                                                  src:
                                                                                                    (
                                                                                                      t,
                                                                                                    ) =>
                                                                                                    async (
                                                                                                      s,
                                                                                                    ) => {
                                                                                                      var i;
                                                                                                      if (
                                                                                                        "prepare" ===
                                                                                                        (null ===
                                                                                                          (i =
                                                                                                            t.task) ||
                                                                                                        void 0 ===
                                                                                                          i
                                                                                                          ? void 0
                                                                                                          : i.type)
                                                                                                      )
                                                                                                        t.task.resume();
                                                                                                      else {
                                                                                                        const i =
                                                                                                            (t.task =
                                                                                                              new mO()),
                                                                                                          a =
                                                                                                            e.getCursor(),
                                                                                                          r =
                                                                                                            await a.value(),
                                                                                                          o =
                                                                                                            r.metrics.timeTracker.prepare.getTracker();
                                                                                                        try {
                                                                                                          o.start();
                                                                                                          const e =
                                                                                                              await i
                                                                                                                .exec(
                                                                                                                  async () => {
                                                                                                                    const e =
                                                                                                                      await r
                                                                                                                        .getCursor()
                                                                                                                        .value();
                                                                                                                    return null ===
                                                                                                                      e
                                                                                                                      ? (await a.next(),
                                                                                                                        null)
                                                                                                                      : (r.metrics.increaseBatch(),
                                                                                                                        {
                                                                                                                          convCheckpoint:
                                                                                                                            r,
                                                                                                                          batchRequestInfo:
                                                                                                                            e,
                                                                                                                        });
                                                                                                                  },
                                                                                                                )
                                                                                                                .toPromise(),
                                                                                                            {
                                                                                                              convCheckpoint:
                                                                                                                n = null,
                                                                                                              batchRequestInfo:
                                                                                                                d = null,
                                                                                                            } =
                                                                                                              e ||
                                                                                                              {};
                                                                                                          (t.convCheckpoint =
                                                                                                            r),
                                                                                                            (t.batchRequestInfo =
                                                                                                              d),
                                                                                                            n &&
                                                                                                            d
                                                                                                              ? ((t.currentStep =
                                                                                                                  lO.FETCH_MESSAGE),
                                                                                                                s(
                                                                                                                  {
                                                                                                                    type: "PREPARE_BATCH_SUCCESS",
                                                                                                                    data: {
                                                                                                                      batchRequestInfo:
                                                                                                                        d,
                                                                                                                      convCheckpoint:
                                                                                                                        n,
                                                                                                                    },
                                                                                                                  },
                                                                                                                ))
                                                                                                              : s(
                                                                                                                  {
                                                                                                                    type: "MOVE_TO_NEXT_CONV",
                                                                                                                  },
                                                                                                                );
                                                                                                        } catch (n) {
                                                                                                          if (
                                                                                                            n instanceof
                                                                                                            uO
                                                                                                          )
                                                                                                            return;
                                                                                                          s(
                                                                                                            {
                                                                                                              type: "FAILED",
                                                                                                              error:
                                                                                                                n,
                                                                                                            },
                                                                                                          );
                                                                                                        } finally {
                                                                                                          o.end();
                                                                                                        }
                                                                                                      }
                                                                                                    },
                                                                                                },
                                                                                              on: {
                                                                                                PREPARE_BATCH_SUCCESS:
                                                                                                  {
                                                                                                    target:
                                                                                                      "#running.checking",
                                                                                                    actions:
                                                                                                      "clearTask",
                                                                                                  },
                                                                                                MOVE_TO_NEXT_CONV:
                                                                                                  {
                                                                                                    target:
                                                                                                      "#running.checking",
                                                                                                    actions:
                                                                                                      "clearTask",
                                                                                                  },
                                                                                                FAILED:
                                                                                                  {
                                                                                                    target:
                                                                                                      "#running.checkRetry",
                                                                                                    actions:
                                                                                                      [
                                                                                                        "attachError",
                                                                                                        "clearTask",
                                                                                                      ],
                                                                                                  },
                                                                                              },
                                                                                            },
                                                                                          fetchMessage:
                                                                                            {
                                                                                              invoke:
                                                                                                {
                                                                                                  src:
                                                                                                    (
                                                                                                      e,
                                                                                                    ) =>
                                                                                                    async (
                                                                                                      s,
                                                                                                    ) => {
                                                                                                      var i;
                                                                                                      if (
                                                                                                        "fetch" ===
                                                                                                        (null ===
                                                                                                          (i =
                                                                                                            e.task) ||
                                                                                                        void 0 ===
                                                                                                          i
                                                                                                          ? void 0
                                                                                                          : i.type)
                                                                                                      )
                                                                                                        e.task.resume();
                                                                                                      else {
                                                                                                        const i =
                                                                                                            (e.task =
                                                                                                              new pO()),
                                                                                                          {
                                                                                                            batchRequestInfo:
                                                                                                              a,
                                                                                                            convCheckpoint:
                                                                                                              r,
                                                                                                          } =
                                                                                                            e,
                                                                                                          o =
                                                                                                            r.metrics.timeTracker.fetch.getTracker();
                                                                                                        try {
                                                                                                          o.start();
                                                                                                          const n =
                                                                                                            await i
                                                                                                              .exec(
                                                                                                                () =>
                                                                                                                  t.fetchMessages(
                                                                                                                    a,
                                                                                                                  ),
                                                                                                              )
                                                                                                              .toPromise();
                                                                                                          (e.batchResponseInfo =
                                                                                                            n),
                                                                                                            (e.currentStep =
                                                                                                              lO.PROCESS_MESSAGE),
                                                                                                            s(
                                                                                                              {
                                                                                                                type: "FETCH_MESSAGE_SUCCESS",
                                                                                                                data: {
                                                                                                                  batchResponseInfo:
                                                                                                                    n,
                                                                                                                },
                                                                                                              },
                                                                                                            );
                                                                                                        } catch (n) {
                                                                                                          if (
                                                                                                            n instanceof
                                                                                                            uO
                                                                                                          )
                                                                                                            return;
                                                                                                          s(
                                                                                                            {
                                                                                                              type: "FAILED",
                                                                                                              error:
                                                                                                                n,
                                                                                                            },
                                                                                                          );
                                                                                                        } finally {
                                                                                                          o.end();
                                                                                                        }
                                                                                                      }
                                                                                                    },
                                                                                                },
                                                                                              on: {
                                                                                                FETCH_MESSAGE_SUCCESS:
                                                                                                  {
                                                                                                    target:
                                                                                                      "#running.checking",
                                                                                                    actions:
                                                                                                      "clearTask",
                                                                                                  },
                                                                                                FAILED:
                                                                                                  {
                                                                                                    target:
                                                                                                      "#running.checkRetry",
                                                                                                    actions:
                                                                                                      [
                                                                                                        "attachError",
                                                                                                        "clearTask",
                                                                                                      ],
                                                                                                  },
                                                                                              },
                                                                                            },
                                                                                          processMessage:
                                                                                            {
                                                                                              invoke:
                                                                                                {
                                                                                                  src:
                                                                                                    (
                                                                                                      e,
                                                                                                    ) =>
                                                                                                    async (
                                                                                                      s,
                                                                                                    ) => {
                                                                                                      var i;
                                                                                                      if (
                                                                                                        "process" ===
                                                                                                        (null ===
                                                                                                          (i =
                                                                                                            e.task) ||
                                                                                                        void 0 ===
                                                                                                          i
                                                                                                          ? void 0
                                                                                                          : i.type)
                                                                                                      )
                                                                                                        e.task.resume();
                                                                                                      else {
                                                                                                        const i =
                                                                                                            (e.task =
                                                                                                              new fO()),
                                                                                                          {
                                                                                                            batchRequestInfo:
                                                                                                              r,
                                                                                                            batchResponseInfo:
                                                                                                              o,
                                                                                                            convCheckpoint:
                                                                                                              d,
                                                                                                          } = e,
                                                                                                          l =
                                                                                                            d.metrics.timeTracker.sync.getTracker();
                                                                                                        try {
                                                                                                          var n;
                                                                                                          l.start();
                                                                                                          const a =
                                                                                                              o.groupMsgs,
                                                                                                            c =
                                                                                                              await i
                                                                                                                .exec(
                                                                                                                  async () => {
                                                                                                                    const e =
                                                                                                                      await t.processMessages(
                                                                                                                        r,
                                                                                                                        a,
                                                                                                                      );
                                                                                                                    return (
                                                                                                                      await d
                                                                                                                        .getCursor()
                                                                                                                        .next(
                                                                                                                          {
                                                                                                                            messages:
                                                                                                                              a,
                                                                                                                            requestMsgId:
                                                                                                                              r.requestMsgId,
                                                                                                                            lastMsgId:
                                                                                                                              r.lastMsgId,
                                                                                                                            checkLoadTop:
                                                                                                                              !0,
                                                                                                                            hasMore:
                                                                                                                              o.hasMore,
                                                                                                                          },
                                                                                                                        ),
                                                                                                                      e
                                                                                                                    );
                                                                                                                  },
                                                                                                                )
                                                                                                                .toPromise();
                                                                                                          (e.totalMessageFetched +=
                                                                                                            a.length),
                                                                                                            (e.totalMessageSaved +=
                                                                                                              (null ==
                                                                                                                c ||
                                                                                                              null ===
                                                                                                                (n =
                                                                                                                  c.messages) ||
                                                                                                              void 0 ===
                                                                                                                n
                                                                                                                ? void 0
                                                                                                                : n.length) ||
                                                                                                              0),
                                                                                                            (e.error =
                                                                                                              null),
                                                                                                            (e.retryCounter = 0),
                                                                                                            (e.currentStep =
                                                                                                              lO.PREPARE_BATCH),
                                                                                                            s(
                                                                                                              {
                                                                                                                type: "PROCESS_MESSAGE_SUCCESS",
                                                                                                                data: {
                                                                                                                  result:
                                                                                                                    c,
                                                                                                                  totalMessageFetched:
                                                                                                                    a.length,
                                                                                                                },
                                                                                                              },
                                                                                                            );
                                                                                                        } catch (a) {
                                                                                                          if (
                                                                                                            a instanceof
                                                                                                            uO
                                                                                                          )
                                                                                                            return;
                                                                                                          s(
                                                                                                            {
                                                                                                              type: "FAILED",
                                                                                                              error:
                                                                                                                a,
                                                                                                            },
                                                                                                          );
                                                                                                        } finally {
                                                                                                          l.end();
                                                                                                        }
                                                                                                      }
                                                                                                    },
                                                                                                },
                                                                                              on: {
                                                                                                PROCESS_MESSAGE_SUCCESS:
                                                                                                  {
                                                                                                    target:
                                                                                                      "#running.sleep",
                                                                                                    actions:
                                                                                                      "clearTask",
                                                                                                  },
                                                                                                FAILED:
                                                                                                  {
                                                                                                    target:
                                                                                                      "#running.checkRetry",
                                                                                                    actions:
                                                                                                      [
                                                                                                        "attachError",
                                                                                                        "clearTask",
                                                                                                      ],
                                                                                                  },
                                                                                              },
                                                                                            },
                                                                                          sleep:
                                                                                            {
                                                                                              invoke:
                                                                                                {
                                                                                                  src:
                                                                                                    (
                                                                                                      e,
                                                                                                      s,
                                                                                                    ) =>
                                                                                                    async (
                                                                                                      i,
                                                                                                    ) => {
                                                                                                      var n;
                                                                                                      if (
                                                                                                        "sleep" ===
                                                                                                        (null ===
                                                                                                          (n =
                                                                                                            e.task) ||
                                                                                                        void 0 ===
                                                                                                          n
                                                                                                          ? void 0
                                                                                                          : n.type)
                                                                                                      )
                                                                                                        e.task.resume();
                                                                                                      else {
                                                                                                        const n =
                                                                                                          (e.task =
                                                                                                            new vO());
                                                                                                        try {
                                                                                                          let a = 0;
                                                                                                          switch (
                                                                                                            s.type
                                                                                                          ) {
                                                                                                            case "NEXT_TO_SLEEP_TO_NEXT_HOUR":
                                                                                                            case "RETRY":
                                                                                                              a =
                                                                                                                s
                                                                                                                  .data
                                                                                                                  .time;
                                                                                                              break;
                                                                                                            default:
                                                                                                              a =
                                                                                                                t.getThrottle(
                                                                                                                  e.isBackground,
                                                                                                                );
                                                                                                          }
                                                                                                          await n
                                                                                                            .exec(
                                                                                                              () =>
                                                                                                                Ba.b.delay(
                                                                                                                  a,
                                                                                                                ),
                                                                                                            )
                                                                                                            .toPromise(),
                                                                                                            i(
                                                                                                              {
                                                                                                                type: "WAKE_UP",
                                                                                                              },
                                                                                                            );
                                                                                                        } catch (a) {}
                                                                                                      }
                                                                                                    },
                                                                                                },
                                                                                              on: {
                                                                                                WAKE_UP:
                                                                                                  {
                                                                                                    target:
                                                                                                      "#running.checking",
                                                                                                    actions:
                                                                                                      "clearTask",
                                                                                                  },
                                                                                              },
                                                                                            },
                                                                                          checkRetry:
                                                                                            {
                                                                                              invoke:
                                                                                                {
                                                                                                  src:
                                                                                                    (
                                                                                                      s,
                                                                                                    ) =>
                                                                                                    async (
                                                                                                      i,
                                                                                                    ) => {
                                                                                                      var n;
                                                                                                      const [
                                                                                                        a,
                                                                                                        r,
                                                                                                      ] =
                                                                                                        t.checkMaxRetryBatch(
                                                                                                          s.retryCounter,
                                                                                                          s.isBackground,
                                                                                                        );
                                                                                                      if (
                                                                                                        a
                                                                                                      ) {
                                                                                                        var o;
                                                                                                        await e
                                                                                                          .getCursor()
                                                                                                          .next();
                                                                                                        const t =
                                                                                                          (null ===
                                                                                                            (o =
                                                                                                              s.batchRequestInfo) ||
                                                                                                          void 0 ===
                                                                                                            o
                                                                                                            ? void 0
                                                                                                            : o.convId) ||
                                                                                                          "";
                                                                                                        return (
                                                                                                          (s.error =
                                                                                                            null),
                                                                                                          (s.retryCounter = 0),
                                                                                                          (s.currentStep =
                                                                                                            lO.PREPARE_BATCH),
                                                                                                          i(
                                                                                                            {
                                                                                                              type: "TRY_MOVE_TO_NEXT_CONV",
                                                                                                              data: {
                                                                                                                currConvId:
                                                                                                                  t,
                                                                                                              },
                                                                                                            },
                                                                                                          )
                                                                                                        );
                                                                                                      }
                                                                                                      return (
                                                                                                        null ===
                                                                                                          (n =
                                                                                                            s.convCheckpoint) ||
                                                                                                          void 0 ===
                                                                                                            n ||
                                                                                                          n.metrics.increaseRetry(),
                                                                                                        s.retryCounter++,
                                                                                                        i(
                                                                                                          {
                                                                                                            type: "RETRY",
                                                                                                            data: {
                                                                                                              time: r,
                                                                                                            },
                                                                                                          },
                                                                                                        )
                                                                                                      );
                                                                                                    },
                                                                                                },
                                                                                              on: {
                                                                                                RETRY:
                                                                                                  {
                                                                                                    target:
                                                                                                      "#running.sleep",
                                                                                                  },
                                                                                                TRY_MOVE_TO_NEXT_CONV:
                                                                                                  {
                                                                                                    target:
                                                                                                      "#running.sleep",
                                                                                                  },
                                                                                              },
                                                                                            },
                                                                                        },
                                                                                    },
                                                                                  paused:
                                                                                    {
                                                                                      on: {
                                                                                        RESUME:
                                                                                          {
                                                                                            target:
                                                                                              "#afmc-machine-v2.resume",
                                                                                            actions:
                                                                                              [
                                                                                                "decreasePausedCounter",
                                                                                                "logPausedCounter",
                                                                                              ],
                                                                                          },
                                                                                      },
                                                                                    },
                                                                                  resume:
                                                                                    {
                                                                                      invoke:
                                                                                        {
                                                                                          src:
                                                                                            (
                                                                                              e,
                                                                                            ) =>
                                                                                            async (
                                                                                              t,
                                                                                            ) => {
                                                                                              e.pausedCounter
                                                                                                ? t(
                                                                                                    {
                                                                                                      type: "RESUME_PAUSED",
                                                                                                    },
                                                                                                  )
                                                                                                : t(
                                                                                                    {
                                                                                                      type: "RESUME_RUNNING",
                                                                                                    },
                                                                                                  );
                                                                                            },
                                                                                        },
                                                                                      on: {
                                                                                        RESUME_PAUSED:
                                                                                          {
                                                                                            target:
                                                                                              "#afmc-machine-v2.paused",
                                                                                          },
                                                                                        RESUME_RUNNING:
                                                                                          {
                                                                                            target:
                                                                                              "#afmc-machine-v2.running",
                                                                                          },
                                                                                      },
                                                                                    },
                                                                                },
                                                                              on: {
                                                                                PAUSED:
                                                                                  {
                                                                                    target:
                                                                                      "#afmc-machine-v2.paused",
                                                                                    actions:
                                                                                      [
                                                                                        "increasePausedCounter",
                                                                                        "pauseTask",
                                                                                        "logPausedCounter",
                                                                                      ],
                                                                                  },
                                                                                STOP: {
                                                                                  target:
                                                                                    "#afmc-machine-v2.idle",
                                                                                  actions:
                                                                                    [
                                                                                      "abortTask",
                                                                                      "resetAll",
                                                                                    ],
                                                                                },
                                                                                RESET:
                                                                                  {
                                                                                    actions:
                                                                                      "reset",
                                                                                  },
                                                                                START:
                                                                                  {
                                                                                    target:
                                                                                      "#afmc-machine-v2.resume",
                                                                                    actions:
                                                                                      "decreasePausedCounter",
                                                                                  },
                                                                                FOREGROUND:
                                                                                  {
                                                                                    actions:
                                                                                      "foreground",
                                                                                  },
                                                                                BACKGROUND:
                                                                                  {
                                                                                    actions:
                                                                                      "background",
                                                                                  },
                                                                              },
                                                                            },
                                                                            {
                                                                              actions:
                                                                                {
                                                                                  attachError:
                                                                                    dO.a.assign(
                                                                                      (
                                                                                        e,
                                                                                        t,
                                                                                      ) =>
                                                                                        Object(
                                                                                          f.a,
                                                                                        )(
                                                                                          Object(
                                                                                            f.a,
                                                                                          )(
                                                                                            {},
                                                                                            e,
                                                                                          ),
                                                                                          {},
                                                                                          {
                                                                                            error:
                                                                                              t.error,
                                                                                          },
                                                                                        ),
                                                                                    ),
                                                                                  abortTask:
                                                                                    (
                                                                                      e,
                                                                                    ) => {
                                                                                      var t;
                                                                                      return (
                                                                                        null !==
                                                                                          (t =
                                                                                            e.task) &&
                                                                                          void 0 !==
                                                                                            t &&
                                                                                          t.abort(),
                                                                                        (e.task =
                                                                                          null)
                                                                                      );
                                                                                    },
                                                                                  pauseTask:
                                                                                    (
                                                                                      e,
                                                                                    ) => {
                                                                                      var t;
                                                                                      return null ===
                                                                                        (t =
                                                                                          e.task) ||
                                                                                        void 0 ===
                                                                                          t
                                                                                        ? void 0
                                                                                        : t.pause();
                                                                                    },
                                                                                  clearTask:
                                                                                    dO.a.assign(
                                                                                      (
                                                                                        e,
                                                                                      ) =>
                                                                                        Object(
                                                                                          f.a,
                                                                                        )(
                                                                                          Object(
                                                                                            f.a,
                                                                                          )(
                                                                                            {},
                                                                                            e,
                                                                                          ),
                                                                                          {},
                                                                                          {
                                                                                            task: null,
                                                                                          },
                                                                                        ),
                                                                                    ),
                                                                                  increasePausedCounter:
                                                                                    dO.a.assign(
                                                                                      (
                                                                                        e,
                                                                                      ) =>
                                                                                        Object(
                                                                                          f.a,
                                                                                        )(
                                                                                          Object(
                                                                                            f.a,
                                                                                          )(
                                                                                            {},
                                                                                            e,
                                                                                          ),
                                                                                          {},
                                                                                          {
                                                                                            pausedCounter:
                                                                                              e.pausedCounter +
                                                                                              1,
                                                                                          },
                                                                                        ),
                                                                                    ),
                                                                                  decreasePausedCounter:
                                                                                    dO.a.assign(
                                                                                      (
                                                                                        e,
                                                                                      ) =>
                                                                                        Object(
                                                                                          f.a,
                                                                                        )(
                                                                                          Object(
                                                                                            f.a,
                                                                                          )(
                                                                                            {},
                                                                                            e,
                                                                                          ),
                                                                                          {},
                                                                                          {
                                                                                            pausedCounter:
                                                                                              Math.max(
                                                                                                e.pausedCounter -
                                                                                                  1,
                                                                                                0,
                                                                                              ),
                                                                                          },
                                                                                        ),
                                                                                    ),
                                                                                  logPausedCounter:
                                                                                    (
                                                                                      e,
                                                                                    ) => {
                                                                                      Ny.a;
                                                                                    },
                                                                                  foreground:
                                                                                    dO.a.assign(
                                                                                      (
                                                                                        e,
                                                                                      ) =>
                                                                                        Object(
                                                                                          f.a,
                                                                                        )(
                                                                                          Object(
                                                                                            f.a,
                                                                                          )(
                                                                                            {},
                                                                                            e,
                                                                                          ),
                                                                                          {},
                                                                                          {
                                                                                            isBackground:
                                                                                              !1,
                                                                                          },
                                                                                        ),
                                                                                    ),
                                                                                  background:
                                                                                    dO.a.assign(
                                                                                      (
                                                                                        e,
                                                                                      ) =>
                                                                                        Object(
                                                                                          f.a,
                                                                                        )(
                                                                                          Object(
                                                                                            f.a,
                                                                                          )(
                                                                                            {},
                                                                                            e,
                                                                                          ),
                                                                                          {},
                                                                                          {
                                                                                            isBackground:
                                                                                              !0,
                                                                                          },
                                                                                        ),
                                                                                    ),
                                                                                  reset:
                                                                                    dO.a.assign(
                                                                                      (
                                                                                        e,
                                                                                      ) => {
                                                                                        let {
                                                                                          isBackground:
                                                                                            t,
                                                                                          pausedCounter:
                                                                                            s,
                                                                                        } =
                                                                                          e;
                                                                                        return Object(
                                                                                          f.a,
                                                                                        )(
                                                                                          Object(
                                                                                            f.a,
                                                                                          )(
                                                                                            {},
                                                                                            bO,
                                                                                          ),
                                                                                          {},
                                                                                          {
                                                                                            isBackground:
                                                                                              t,
                                                                                            pausedCounter:
                                                                                              s,
                                                                                          },
                                                                                        );
                                                                                      },
                                                                                    ),
                                                                                  resetAll:
                                                                                    dO.a.assign(
                                                                                      () =>
                                                                                        Object(
                                                                                          f.a,
                                                                                        )(
                                                                                          {},
                                                                                          bO,
                                                                                        ),
                                                                                    ),
                                                                                },
                                                                            },
                                                                          )
                                                                        );
                                                                        var e,
                                                                          t;
                                                                      }
                                                                      start() {
                                                                        super.start(),
                                                                          this.registerListener(),
                                                                          this.autoStartMachine();
                                                                      }
                                                                      stop() {
                                                                        this.unregisterListener(),
                                                                          this.unregisterSessionFetchListener(),
                                                                          super.stop(),
                                                                          this.monitor.updateStatus(
                                                                            "disabled",
                                                                          );
                                                                      }
                                                                      hasRemainConvInPrevSession() {
                                                                        return this
                                                                          .isHasRemainConvInPrevSessionFetch;
                                                                      }
                                                                      registerListener() {
                                                                        var e,
                                                                          t,
                                                                          s;
                                                                        (this.logger.zsymb(
                                                                          0,
                                                                          16704,
                                                                          3e4,
                                                                          "register persit listener",
                                                                        ),
                                                                        this.eventCollector.addEventListener(
                                                                          By.a
                                                                            .START_PULL_OFFLINE_DATA,
                                                                          this
                                                                            .onStartPullDataOffline,
                                                                        ),
                                                                        this.eventCollector.addEventListener(
                                                                          By.a
                                                                            .STOP_PULL_OFFLINE_DATA,
                                                                          this
                                                                            .onStopPullDataOffline,
                                                                        ),
                                                                        this.eventCollector.addEventListener(
                                                                          By.a
                                                                            .DELETE_CONV,
                                                                          this
                                                                            .onDeleteConv,
                                                                        ),
                                                                        this.eventCollector.addEventListener(
                                                                          By.a
                                                                            .LEAVE_GROUP,
                                                                          this
                                                                            .onLeaveGroup,
                                                                        ),
                                                                        this.eventCollector.addEventListener(
                                                                          By.a
                                                                            .START_TRANSFER_MESSAGE,
                                                                          this
                                                                            .onStartTransferMessage,
                                                                        ),
                                                                        this.eventCollector.addEventListener(
                                                                          By.a
                                                                            .STOP_TRANSFER_MESSAGE,
                                                                          this
                                                                            .onStopTransferMessage,
                                                                        ),
                                                                        null ===
                                                                          (e =
                                                                            this
                                                                              .interpreter) ||
                                                                          void 0 ===
                                                                            e ||
                                                                          e.onEvent(
                                                                            this
                                                                              .onEventChange,
                                                                          ),
                                                                        Ny.a) &&
                                                                          (null ===
                                                                            (t =
                                                                              this
                                                                                .interpreter) ||
                                                                            void 0 ===
                                                                              t ||
                                                                            t.onEvent(
                                                                              this
                                                                                .onEventChangeForDevtool,
                                                                            ),
                                                                          null ===
                                                                            (s =
                                                                              this
                                                                                .interpreter) ||
                                                                            void 0 ===
                                                                              s ||
                                                                            s.onTransition(
                                                                              this
                                                                                .onTransitionChangeForDevtool,
                                                                            ));
                                                                      }
                                                                      unregisterListener() {
                                                                        var e,
                                                                          t,
                                                                          s;
                                                                        (this.logger.zsymb(
                                                                          0,
                                                                          16704,
                                                                          30001,
                                                                          "unregister persit listener",
                                                                        ),
                                                                        this.eventCollector.removeEventListener(
                                                                          By.a
                                                                            .START_PULL_OFFLINE_DATA,
                                                                          this
                                                                            .onStartPullDataOffline,
                                                                        ),
                                                                        this.eventCollector.removeEventListener(
                                                                          By.a
                                                                            .STOP_PULL_OFFLINE_DATA,
                                                                          this
                                                                            .onStopPullDataOffline,
                                                                        ),
                                                                        this.eventCollector.removeEventListener(
                                                                          By.a
                                                                            .DELETE_CONV,
                                                                          this
                                                                            .onDeleteConv,
                                                                        ),
                                                                        this.eventCollector.removeEventListener(
                                                                          By.a
                                                                            .LEAVE_GROUP,
                                                                          this
                                                                            .onLeaveGroup,
                                                                        ),
                                                                        this.eventCollector.removeEventListener(
                                                                          By.a
                                                                            .START_TRANSFER_MESSAGE,
                                                                          this
                                                                            .onStartTransferMessage,
                                                                        ),
                                                                        this.eventCollector.removeEventListener(
                                                                          By.a
                                                                            .STOP_TRANSFER_MESSAGE,
                                                                          this
                                                                            .onStopTransferMessage,
                                                                        ),
                                                                        null ===
                                                                          (e =
                                                                            this
                                                                              .interpreter) ||
                                                                          void 0 ===
                                                                            e ||
                                                                          e.off(
                                                                            this
                                                                              .onEventChange,
                                                                          ),
                                                                        Ny.a) &&
                                                                          (null ===
                                                                            (t =
                                                                              this
                                                                                .interpreter) ||
                                                                            void 0 ===
                                                                              t ||
                                                                            t.off(
                                                                              this
                                                                                .onEventChangeForDevtool,
                                                                            ),
                                                                          null ===
                                                                            (s =
                                                                              this
                                                                                .interpreter) ||
                                                                            void 0 ===
                                                                              s ||
                                                                            s.off(
                                                                              this
                                                                                .onTransitionChangeForDevtool,
                                                                            ));
                                                                      }
                                                                      async handleRemoveConv(
                                                                        e,
                                                                      ) {
                                                                        this.pauseMachine(),
                                                                          (await this.ledger.remove(
                                                                            e,
                                                                          ))
                                                                            ? (this.logger.zsymb(
                                                                                0,
                                                                                16704,
                                                                                30015,
                                                                                `Disabled checkpoint ${e} success`,
                                                                              ),
                                                                              this.resetMachine())
                                                                            : this.logger.zsymb(
                                                                                0,
                                                                                16704,
                                                                                30016,
                                                                                `Checkpoint ${e} does not exist`,
                                                                              ),
                                                                          this.resumeMachine();
                                                                      }
                                                                    }),
                                                                  ) || IO),
                                                              ) || IO),
                                                          ) || IO),
                                                      ) || IO),
                                                  ) || IO),
                                              ) || IO),
                                          ) || IO),
                                      ) || IO),
                                  ) || IO),
                              ) || IO),
                          ) || IO),
                      ) || IO),
                  ) || IO),
              ) || IO),
          ) || IO;
        var _O,
          OO = s("BYQe");
        let CO =
          Object(Ga.e)()(
            (_O =
              Object(My.d)()(
                (_O =
                  Object(My.e)(Ey.j)(
                    (_O =
                      (function (e, t) {
                        return Object(Ga.d)(Ey.f)(e, void 0, 0);
                      })(
                        (_O =
                          (function (e, t) {
                            return Object(Ga.d)(Ey.p)(e, void 0, 1);
                          })(
                            (_O =
                              (function (e, t) {
                                return Object(Ga.d)(Ey.g)(e, void 0, 2);
                              })(
                                (_O =
                                  Reflect.metadata(
                                    "design:type",
                                    Function,
                                  )(
                                    (_O =
                                      Reflect.metadata("design:paramtypes", [
                                        "undefined" == typeof IHandler
                                          ? Object
                                          : IHandler,
                                        "undefined" == typeof IHandler
                                          ? Object
                                          : IHandler,
                                        "undefined" == typeof IHandler
                                          ? Object
                                          : IHandler,
                                      ])(
                                        (_O = class {
                                          constructor(e, t, s) {
                                            (this.processor = void 0),
                                              (this.processor = new OO.Chain()
                                                .pipe(e)
                                                .pipe(t)
                                                .pipe(s));
                                          }
                                          async process(e, t) {
                                            return await this.processor.process(
                                              { batchInfo: e, messages: t },
                                            );
                                          }
                                        }),
                                      ) || _O),
                                  ) || _O),
                              ) || _O),
                          ) || _O),
                      ) || _O),
                  ) || _O),
              ) || _O),
          ) || _O;
        var EO;
        let MO =
          Object(My.d)()(
            (EO =
              Object(Ga.e)()(
                (EO =
                  Object(My.e)(Ey.k)(
                    (EO =
                      (function (e, t) {
                        return i.ModuleContainer.inject(J)(e, void 0, 0);
                      })(
                        (EO =
                          (function (e, t) {
                            return Object(Ga.d)(Ly)(e, void 0, 1);
                          })(
                            (EO =
                              (function (e, t) {
                                return i.ModuleContainer.inject(
                                  q.ZLoggerFactory,
                                )(e, void 0, 2);
                              })(
                                (EO =
                                  Reflect.metadata(
                                    "design:type",
                                    Function,
                                  )(
                                    (EO =
                                      Reflect.metadata("design:paramtypes", [
                                        "undefined" == typeof IQosService
                                          ? Object
                                          : IQosService,
                                        "undefined" == typeof IActionlogService
                                          ? Object
                                          : IActionlogService,
                                        void 0 === q.ZLoggerFactory
                                          ? Object
                                          : q.ZLoggerFactory,
                                      ])(
                                        (EO = class {
                                          constructor(e, t, s) {
                                            (this.logger = void 0),
                                              (this.actionlog = void 0),
                                              (this.qos = void 0),
                                              (this.qos = e),
                                              (this.actionlog = t),
                                              (this.logger = s.createZLogger(
                                                hs.ZLoggerNametags
                                                  .autoFetchMsgCloud,
                                                [hs.ZLoggerNametags.metricz],
                                              ));
                                          }
                                          logAutoHideBannerSuggestion() {
                                            this.actionlog.logAction(2460001);
                                          }
                                          logAutoShowBannerSuggestion(e) {
                                            this.actionlog.logAction(
                                              e ? 2460003 : 2460002,
                                            );
                                          }
                                          logStartFetch(e, t) {
                                            switch (
                                              (this.actionlog.logAction(
                                                2460101,
                                              ),
                                              t)
                                            ) {
                                              case Vy.ONLY_GROUP:
                                                e
                                                  ? this.actionlog.logAction(
                                                      2460104,
                                                    )
                                                  : this.actionlog.logAction(
                                                      2460102,
                                                    );
                                                break;
                                              case Vy.BOTH_1_1_AND_GROUP:
                                                e ||
                                                  this.actionlog.logAction(
                                                    2460103,
                                                  );
                                            }
                                          }
                                          logStopFetch(e, t, s) {
                                            if (!s)
                                              return this.actionlog.logAction(
                                                2460401,
                                              );
                                            switch (
                                              (this.actionlog.logAction(
                                                2460201,
                                              ),
                                              t)
                                            ) {
                                              case Vy.ONLY_GROUP:
                                                e
                                                  ? this.actionlog.logAction(
                                                      2460204,
                                                    )
                                                  : this.actionlog.logAction(
                                                      2460202,
                                                    );
                                                break;
                                              case Vy.BOTH_1_1_AND_GROUP:
                                                e ||
                                                  this.actionlog.logAction(
                                                    2460203,
                                                  );
                                            }
                                          }
                                          logStartInteruptFetch(e) {
                                            if (e === oO.SYNC_MESSAGE)
                                              this.actionlog.logAction(2460301);
                                          }
                                          logStopInteruptFetch(e, t) {
                                            if (e === oO.SYNC_MESSAGE)
                                              this.actionlog.logAction(
                                                t ? 2460302 : 2460303,
                                              );
                                          }
                                          logResumeFetchAfterInterupt() {
                                            this.actionlog.logAction(2460304);
                                          }
                                          submitResultReport(e) {
                                            const t = {
                                              result: e.result,
                                              interupted: e.interupted,
                                              time: e.time,
                                              total_conv_fetched:
                                                e.totalConvFetched,
                                              conv_fetch_failed:
                                                e.convFetchFailed,
                                              total_msg_fetched:
                                                e.totalMsgFetched,
                                            };
                                            this.actionlog.logActionInfoV2(
                                              Xe.b.AutoFetchMessageCloud,
                                              1,
                                              t,
                                            );
                                          }
                                          submitConvReport(e) {
                                            Ny.a &&
                                              this.logger.zsymb(
                                                12,
                                                16699,
                                                3e4,
                                                "submit metrics for conv",
                                                e.convId,
                                                JSON.stringify(e),
                                              ),
                                              this.qos.log({
                                                commandId:
                                                  rO.AVG_EXECUTION_TIME_EACH_CONV,
                                                success: !0,
                                                startTime: 0,
                                                duration: e.duration.total,
                                                params: [JSON.stringify(e)],
                                              }),
                                              this.qos.log({
                                                commandId: rO.AVG_BATCH,
                                                success: !0,
                                                startTime: 0,
                                                duration: e.meta.total,
                                              }),
                                              this.qos.log({
                                                commandId: rO.AVG_BATCH_RETRY,
                                                success: !0,
                                                startTime: 0,
                                                duration: e.meta.retry,
                                              });
                                          }
                                          submitLedgerReport(e) {
                                            Ny.a &&
                                              this.logger.zsymb(
                                                12,
                                                16699,
                                                30001,
                                                "submit ledger report",
                                                JSON.stringify(e),
                                              ),
                                              this.qos.log({
                                                commandId: rO.AVG_CONV,
                                                success: !0,
                                                startTime: 0,
                                                duration: e.totalConv,
                                              }),
                                              this.qos.log({
                                                commandId: rO.AVG_NEW_CONV,
                                                success: !0,
                                                startTime: 0,
                                                duration: e.totalNewConv,
                                              });
                                          }
                                          submitErrorRunning(e, t) {
                                            this.qos.log({
                                              commandId: rO.ERROR_RUNNING,
                                              success: !1,
                                              startTime: 0,
                                              errorCode: cO[e],
                                              params: [
                                                e,
                                                t.name,
                                                ...t.qosParams,
                                              ],
                                            });
                                          }
                                        }),
                                      ) || EO),
                                  ) || EO),
                              ) || EO),
                          ) || EO),
                      ) || EO),
                  ) || EO),
              ) || EO),
          ) || EO;
        var SO;
        let TO =
          Object(My.d)()(
            (SO =
              Object(My.e)(Ey.f)(
                (SO = class {
                  async process(e) {
                    const { batchInfo: t, messages: s } = e,
                      i = s.filter(
                        (e) => parseInt(e.msgId) > parseInt(t.lastDeleteMsgId),
                      );
                    return { batchInfo: t, messages: i };
                  }
                }),
              ) || SO),
          ) || SO;
        var wO;
        let RO =
          Object(Ga.e)()(
            (wO =
              Object(My.d)()(
                (wO =
                  Object(My.e)(Ey.g)(
                    (wO =
                      (function (e, t) {
                        return Object(Ga.d)(Ry)(e, void 0, 0);
                      })(
                        (wO =
                          Reflect.metadata(
                            "design:type",
                            Function,
                          )(
                            (wO =
                              Reflect.metadata("design:paramtypes", [
                                "undefined" == typeof IZSearchV3
                                  ? Object
                                  : IZSearchV3,
                              ])(
                                (wO = class {
                                  constructor(e) {
                                    this.zsearchV3 = e;
                                  }
                                  async process(e) {
                                    return (
                                      this.zsearchV3.executeData(
                                        this.filterMessageSearchable(
                                          e.messages,
                                        ),
                                      ),
                                      e
                                    );
                                  }
                                  filterMessageSearchable(e) {
                                    return e.filter((e) => {
                                      var t;
                                      return (
                                        "chat.delete" !== e.msgType &&
                                        "chat.undo" !== e.msgType &&
                                        "chat.list.action" !== e.msgType &&
                                        "msginfo.actionlist" !==
                                          (null === (t = e.content) ||
                                          void 0 === t
                                            ? void 0
                                            : t.action)
                                      );
                                    });
                                  }
                                }),
                              ) || wO),
                          ) || wO),
                      ) || wO),
                  ) || wO),
              ) || wO),
          ) || wO;
        var LO;
        let DO =
          Object(Ga.e)()(
            (LO =
              Object(My.d)()(
                (LO =
                  Object(My.e)(Ey.p)(
                    (LO =
                      (function (e, t) {
                        return Object(Ga.d)(wy)(e, void 0, 0);
                      })(
                        (LO =
                          (function (e, t) {
                            return Object(Ga.d)(Dy)(e, void 0, 1);
                          })(
                            (LO =
                              Reflect.metadata(
                                "design:type",
                                Function,
                              )(
                                (LO =
                                  Reflect.metadata("design:paramtypes", [
                                    "undefined" == typeof IZStorage
                                      ? Object
                                      : IZStorage,
                                    "undefined" == typeof IImportantMsgManager
                                      ? Object
                                      : IImportantMsgManager,
                                  ])(
                                    (LO = class {
                                      constructor(e, t) {
                                        (this.zstorage = e),
                                          (this.importantMsgManager = t);
                                      }
                                      async process(e) {
                                        var t;
                                        const { batchInfo: s, messages: i } = e,
                                          [n, a] = await Ba.b.catchPromise(
                                            this.zstorage.addMessages(
                                              s.convId,
                                              i,
                                              void 0,
                                            ),
                                          );
                                        ka(
                                          n,
                                          new o_(
                                            "Save messages error " +
                                              JSON.stringify(n),
                                          ),
                                        ),
                                          this.importantMsgManager.receiveImportantMessage(
                                            (null == a ? void 0 : a.messages) ||
                                              [],
                                          );
                                        const r = (
                                          null !==
                                            (t =
                                              null == a
                                                ? void 0
                                                : a.messages) && void 0 !== t
                                            ? t
                                            : []
                                        ).map((e) => e.msgId);
                                        return {
                                          batchInfo: s,
                                          messages: i.filter((e) =>
                                            r.includes(e.msgId),
                                          ),
                                        };
                                      }
                                    }),
                                  ) || LO),
                              ) || LO),
                          ) || LO),
                      ) || LO),
                  ) || LO),
              ) || LO),
          ) || LO;
        var FO;
        let AO =
          Object(Ga.e)()(
            (FO =
              Object(My.d)()(
                (FO =
                  Object(My.e)(Ey.m)(
                    (FO =
                      (function (e, t) {
                        return i.ModuleContainer.inject(er)(e, void 0, 0);
                      })(
                        (FO =
                          (function (e, t) {
                            return Object(Ga.d)(Ey.b)(e, void 0, 1);
                          })(
                            (FO =
                              Reflect.metadata(
                                "design:type",
                                Function,
                              )(
                                (FO =
                                  Reflect.metadata("design:paramtypes", [
                                    "undefined" ==
                                    typeof ICloudSegmentController
                                      ? Object
                                      : ICloudSegmentController,
                                    "undefined" == typeof AFMC_IConfig
                                      ? Object
                                      : AFMC_IConfig,
                                  ])(
                                    (FO = class {
                                      constructor(e, t) {
                                        (this.segmentController = e),
                                          (this.config = t),
                                          (this.mapCounter = {});
                                      }
                                      process(e) {
                                        const [t, s] = e;
                                        return (
                                          !s &&
                                            this.config.get(
                                              "enable_segment_updater",
                                            ) &&
                                            Ba.b.Macrotask.push(() =>
                                              this.updateSegment(t),
                                            ),
                                          e
                                        );
                                      }
                                      getGroupMessages(e) {
                                        return e.deliverProcessData.groupMsgs;
                                      }
                                      hasEvict(e) {
                                        var t, s;
                                        const i =
                                          null !==
                                            (t =
                                              null == e ||
                                              null ===
                                                (s = e.deliverProcessData) ||
                                              void 0 === s
                                                ? void 0
                                                : s.queueStatus) && void 0 !== t
                                            ? t
                                            : {};
                                        for (const a of this.config.get(
                                          "queue_config",
                                        )) {
                                          var n;
                                          if (
                                            null !== (n = i[a]) &&
                                            void 0 !== n &&
                                            n.evict
                                          )
                                            return !0;
                                        }
                                        return !1;
                                      }
                                      classifyMessagesByConv(e) {
                                        const t = {};
                                        for (const i of e) {
                                          var s;
                                          const e = i.isGroup
                                            ? i.msgKey
                                            : i.idTo;
                                          (t[e] =
                                            null !== (s = t[e]) && void 0 !== s
                                              ? s
                                              : []).push(i);
                                        }
                                        return t;
                                      }
                                      async updateSegment(e) {
                                        const t = this.getGroupMessages(e);
                                        if (0 === t.length) return;
                                        const s =
                                            this.classifyMessagesByConv(t),
                                          i = [];
                                        for (const n in s) {
                                          const t = s[n],
                                            a = this.getRange(t);
                                          i.push(
                                            this.update(
                                              n,
                                              a,
                                              this.getModeMerged(n, e),
                                            ),
                                          );
                                        }
                                        await Promise.all(i);
                                      }
                                      getModeMerged(e, t) {
                                        var s;
                                        let i = "merge";
                                        const n =
                                          null !== (s = this.mapCounter[e]) &&
                                          void 0 !== s
                                            ? s
                                            : 0;
                                        return (
                                          (this.hasEvict(t) || 0 === n) &&
                                            (i = "split"),
                                          (this.mapCounter[e] = n + 1),
                                          i
                                        );
                                      }
                                      getRange(e) {
                                        e.sort(
                                          Ba.a.Sorter.create([
                                            {
                                              key: "msgId",
                                              comparer:
                                                Ba.a.Sorter.Comparer.number,
                                              order: Ba.a.Sorter.Order.ASC,
                                            },
                                            {
                                              key: "ts",
                                              comparer:
                                                Ba.a.Sorter.Comparer.number,
                                              order: Ba.a.Sorter.Order.ASC,
                                            },
                                          ]),
                                        );
                                        const t = e.filter(
                                            (e) => !isNaN(Number(e.msgId)),
                                          ),
                                          s = t[0],
                                          i = t[t.length - 1];
                                        return [
                                          Number(s.msgId),
                                          Number(i.msgId),
                                        ];
                                      }
                                      async update(e, t, s) {
                                        const i =
                                            await this.segmentController.get(e),
                                          n =
                                            0 ===
                                            (null !==
                                              (a =
                                                i.cloudSegmentCheckAutoFetch) &&
                                            void 0 !== a
                                              ? a
                                              : []
                                            ).length
                                              ? ((s = "split"),
                                                null !==
                                                  (o = i.cloudSegmentCheck) &&
                                                void 0 !== o
                                                  ? o
                                                  : [])
                                              : null !==
                                                    (r =
                                                      i.cloudSegmentCheckAutoFetch) &&
                                                  void 0 !== r
                                                ? r
                                                : [];
                                        var a, r, o;
                                        const d = this.mergeSegment(t, n);
                                        switch (s) {
                                          case "split":
                                            i.cloudSegmentCheckAutoFetch = d;
                                            break;
                                          case "merge":
                                            i.cloudSegmentCheckAutoFetch =
                                              this.connectRange(t, d);
                                        }
                                        await this.segmentController.update(i);
                                      }
                                      connectRange(e, t) {
                                        const s = [];
                                        for (let i = 0; i < t.length; i++) {
                                          const n = t[i],
                                            a = t[i - 1];
                                          if (uf.a.isEqual(e, n) && a) {
                                            const e = a[0],
                                              t = n[1];
                                            s.pop(), s.push([e, t]);
                                          } else s.push(n);
                                        }
                                        return s;
                                      }
                                      mergeSegment(e, t) {
                                        if (!e || 2 !== e.length || e[0] > e[1])
                                          return t;
                                        if (0 == t.length) return [e];
                                        const s = [],
                                          [i, n] = e;
                                        let a = 0,
                                          r = 0;
                                        for (let o = 0; o < t.length; o++) {
                                          const e = t[o],
                                            d = e[0],
                                            l =
                                              e[1] ===
                                              parseInt(
                                                R.MessageConstants.MAX_MSG_ID,
                                              )
                                                ? e[0] + 1
                                                : e[1];
                                          if (r) {
                                            s.push(...t.slice(o));
                                            break;
                                          }
                                          i > l
                                            ? (s.push([d, l]),
                                              o === t.length - 1 &&
                                                s.push([i, n]))
                                            : (0 === a && (a = i < d ? i : d),
                                              n < d
                                                ? ((r = n),
                                                  s.push([a, r]),
                                                  s.push([d, l]))
                                                : n <= l && n >= d
                                                  ? ((r = l), s.push([a, l]))
                                                  : n > l &&
                                                    o === t.length - 1 &&
                                                    s.push([a, n]));
                                        }
                                        return s;
                                      }
                                    }),
                                  ) || FO),
                              ) || FO),
                          ) || FO),
                      ) || FO),
                  ) || FO),
              ) || FO),
          ) || FO;
        var jO;
        let PO =
          Object(My.d)()(
            (jO =
              Object(Ga.e)()(
                (jO =
                  Object(My.e)(Ey.q)(
                    (jO =
                      (function (e, t) {
                        return Object(Ga.d)(Ey.b)(e, void 0, 0);
                      })(
                        (jO =
                          (function (e, t) {
                            return Object(Ga.d)(Ey.o)(e, void 0, 1);
                          })(
                            (jO =
                              (function (e, t) {
                                return Object(Ga.d)(Ey.e)(e, void 0, 2);
                              })(
                                (jO =
                                  (function (e, t) {
                                    return i.ModuleContainer.inject(yt)(
                                      e,
                                      void 0,
                                      3,
                                    );
                                  })(
                                    (jO =
                                      (function (e, t) {
                                        return i.ModuleContainer.inject(
                                          q.ZLoggerFactory,
                                        )(e, void 0, 4);
                                      })(
                                        (jO =
                                          Reflect.metadata(
                                            "design:type",
                                            Function,
                                          )(
                                            (jO =
                                              Reflect.metadata(
                                                "design:paramtypes",
                                                [
                                                  "undefined" ==
                                                  typeof AFMC_IConfig
                                                    ? Object
                                                    : AFMC_IConfig,
                                                  "undefined" ==
                                                  typeof AFMC_IStorage
                                                    ? Object
                                                    : AFMC_IStorage,
                                                  "undefined" ==
                                                  typeof AFMC_IEventCollector
                                                    ? Object
                                                    : AFMC_IEventCollector,
                                                  "undefined" ==
                                                  typeof ISystemTime
                                                    ? Object
                                                    : ISystemTime,
                                                  void 0 === q.ZLoggerFactory
                                                    ? Object
                                                    : q.ZLoggerFactory,
                                                ],
                                              )(
                                                (jO = class {
                                                  constructor(e, t, s, i, n) {
                                                    (this.logger = void 0),
                                                      (this.config = void 0),
                                                      (this.storage = void 0),
                                                      (this.systemTime =
                                                        void 0),
                                                      (this.prevNetworkState =
                                                        void 0),
                                                      (this.intervalUpdate =
                                                        void 0),
                                                      (this.onApplicationExit =
                                                        () => {
                                                          this.updateLastSufficientTs(),
                                                            this.clearIntervalUpdate();
                                                        }),
                                                      (this.onLogout = () => {
                                                        this.updateLastSufficientTs(),
                                                          this.clearIntervalUpdate();
                                                      }),
                                                      (this.onBeforeUnload =
                                                        () => {
                                                          this.updateLastSufficientTs(),
                                                            this.clearIntervalUpdate();
                                                        }),
                                                      (this.onServiceReady =
                                                        () => {
                                                          this.startIntervalUpdate();
                                                        }),
                                                      (this.onNetworkStatusChanged =
                                                        (e) => {
                                                          e.status !==
                                                            this
                                                              .prevNetworkState &&
                                                            ((this.prevNetworkState =
                                                              e.status),
                                                            e.status ===
                                                            Dn.a.DISCONNECT
                                                              ? (this.updateLastSufficientTs(),
                                                                this.clearIntervalUpdate())
                                                              : this.startIntervalUpdate());
                                                        }),
                                                      (this.logger =
                                                        n.createZLogger(
                                                          hs.ZLoggerNametags
                                                            .autoFetchMsgCloud,
                                                          [],
                                                        )),
                                                      (this.config = e),
                                                      (this.storage = t),
                                                      (this.systemTime = i),
                                                      (this.prevNetworkState =
                                                        null),
                                                      (this.intervalUpdate =
                                                        null),
                                                      this.registerListener(s);
                                                  }
                                                  registerListener(e) {
                                                    e.addEventListener(
                                                      By.a.SERVICE_READY,
                                                      this.onServiceReady,
                                                    ),
                                                      e.addEventListener(
                                                        By.a.APPLICATION_EXIT,
                                                        this.onApplicationExit,
                                                      ),
                                                      e.addEventListener(
                                                        By.a
                                                          .NETWORK_STATUS_CHANGED,
                                                        this
                                                          .onNetworkStatusChanged,
                                                      ),
                                                      e.addEventListener(
                                                        By.a.BEFORE_UNLOAD,
                                                        this.onBeforeUnload,
                                                      ),
                                                      e.addEventListener(
                                                        By.a.LOG_OUT,
                                                        this.onLogout,
                                                      );
                                                  }
                                                  async updateLastSufficientTs() {
                                                    const e =
                                                        await this.getLastTsSufficientMessage(),
                                                      t =
                                                        this.systemTime.getTimeNow(),
                                                      s =
                                                        (await this.storage.getLastTsOverflowMessage()) >
                                                        e
                                                          ? e
                                                          : t;
                                                    await this.storage.saveLastSufficientMessage(
                                                      s,
                                                    ),
                                                      this.config.get(
                                                        "debugger.logger.interval_update_sufficient_ts",
                                                      ) &&
                                                        this.logger.zsymb(
                                                          12,
                                                          16702,
                                                          3e4,
                                                          "Update last sufficient ts",
                                                          s,
                                                        );
                                                  }
                                                  async getLastTsSufficientMessage() {
                                                    const e = await Promise.all(
                                                      [
                                                        this.storage.getLastTsSyncMessageSuccess(),
                                                        this.storage.getLastTsImportMessageSuccess(),
                                                        this.storage.getLastTsAutoFetchMessageSuccess(),
                                                        this.storage.getLastTsCloseTransferSuggestion(),
                                                        this.storage.getLastTsCloseFirstLoginTransferSuggestion(),
                                                        this.storage.getLastTsSufficientMessage(),
                                                      ],
                                                    );
                                                    return Math.max(...e);
                                                  }
                                                  startIntervalUpdate() {
                                                    this.clearIntervalUpdate(),
                                                      (this.intervalUpdate =
                                                        setInterval(() => {
                                                          this.updateLastSufficientTs();
                                                        }, this.config.get("interval_check_insufficient_data")));
                                                  }
                                                  clearIntervalUpdate() {
                                                    this.intervalUpdate &&
                                                      clearInterval(
                                                        this.intervalUpdate,
                                                      ),
                                                      (this.intervalUpdate =
                                                        null);
                                                  }
                                                }),
                                              ) || jO),
                                          ) || jO),
                                      ) || jO),
                                  ) || jO),
                              ) || jO),
                          ) || jO),
                      ) || jO),
                  ) || jO),
              ) || jO),
          ) || jO;
        var NO;
        let UO =
          Object(My.d)()(
            (NO =
              Object(Ga.e)()(
                (NO =
                  Object(My.e)(Ey.r)(
                    (NO =
                      (function (e, t) {
                        return Object(Ga.d)(Ey.b)(e, void 0, 0);
                      })(
                        (NO =
                          (function (e, t) {
                            return Object(Ga.d)(Ey.o)(e, void 0, 1);
                          })(
                            (NO =
                              (function (e, t) {
                                return i.ModuleContainer.inject(yt)(
                                  e,
                                  void 0,
                                  2,
                                );
                              })(
                                (NO =
                                  (function (e, t) {
                                    return i.ModuleContainer.inject(
                                      q.ZLoggerFactory,
                                    )(e, void 0, 3);
                                  })(
                                    (NO =
                                      (function (e, t) {
                                        return Object(Ga.d)(Ey.e)(e, void 0, 4);
                                      })(
                                        (NO =
                                          Reflect.metadata(
                                            "design:type",
                                            Function,
                                          )(
                                            (NO =
                                              Reflect.metadata(
                                                "design:paramtypes",
                                                [
                                                  "undefined" ==
                                                  typeof AFMC_IConfig
                                                    ? Object
                                                    : AFMC_IConfig,
                                                  "undefined" ==
                                                  typeof AFMC_IStorage
                                                    ? Object
                                                    : AFMC_IStorage,
                                                  "undefined" ==
                                                  typeof ISystemTime
                                                    ? Object
                                                    : ISystemTime,
                                                  void 0 === q.ZLoggerFactory
                                                    ? Object
                                                    : q.ZLoggerFactory,
                                                  "undefined" ==
                                                  typeof AFMC_IEventCollector
                                                    ? Object
                                                    : AFMC_IEventCollector,
                                                ],
                                              )(
                                                (NO = class {
                                                  constructor(e, t, s, i, n) {
                                                    (this.overflowQueueIds =
                                                      void 0),
                                                      (this.logger = void 0),
                                                      (this.config = void 0),
                                                      (this.storage = void 0),
                                                      (this.systemTime =
                                                        void 0),
                                                      (this.logger =
                                                        i.createZLogger(
                                                          hs.ZLoggerNametags
                                                            .autoFetchMsgCloud,
                                                          [],
                                                        )),
                                                      (this.config = e),
                                                      (this.storage = t),
                                                      (this.systemTime = s),
                                                      (this.overflowQueueIds =
                                                        []),
                                                      n.addEventListener(
                                                        By.a
                                                          .OVERFLOW_MESSAGE_QUEUE,
                                                        (e) => {
                                                          this.overflowQueueIds.push(
                                                            e.queueId.toString(),
                                                          ),
                                                            this.storage.saveLastOverflow(
                                                              this.systemTime.getTimeNow(),
                                                            );
                                                        },
                                                      );
                                                  }
                                                  process(e, t) {
                                                    if (
                                                      e &&
                                                      this.config.get(
                                                        "enable_tracking_overflow",
                                                      )
                                                    )
                                                      for (const s in e)
                                                        if (
                                                          this.config
                                                            .get("queue_config")
                                                            .includes(s)
                                                        ) {
                                                          if (e[s].evict) {
                                                            const e = "-1";
                                                            this.saveOverflowInfo(
                                                              s,
                                                              e,
                                                              t,
                                                            );
                                                          }
                                                        }
                                                  }
                                                  getOverflowStatus() {
                                                    const e =
                                                        !!this.overflowQueueIds.find(
                                                          (e) =>
                                                            [
                                                              zy.a
                                                                .SOCKET_MESSAGE_GROUP,
                                                              zy.a
                                                                .LP_MESSAGE_GROUP,
                                                            ].includes(e),
                                                        ),
                                                      t =
                                                        !!this.overflowQueueIds.find(
                                                          (e) =>
                                                            [
                                                              zy.a
                                                                .SOCKET_MESSAGE_1_1,
                                                              zy.a
                                                                .LP_MESSAGE_1_1,
                                                            ].includes(e),
                                                        );
                                                    return t || e
                                                      ? t && e
                                                        ? Vy.BOTH_1_1_AND_GROUP
                                                        : t
                                                          ? Vy.ONLY_1_1
                                                          : Vy.ONLY_GROUP
                                                      : Vy.NONE;
                                                  }
                                                  async saveOverflowInfo(
                                                    e,
                                                    t,
                                                    s,
                                                  ) {
                                                    const i =
                                                      await this.storage.getOverflowInfo();
                                                    (null == i
                                                      ? void 0
                                                      : i.queueId) !== e &&
                                                      (await this.storage.saveOverflowInfo(
                                                        e,
                                                        t,
                                                        s,
                                                      ),
                                                      this.logger.zsymb(
                                                        0,
                                                        16701,
                                                        3e4,
                                                        "Overflow detected, let save info",
                                                        {
                                                          queueId: e,
                                                          lastMsgId: t,
                                                          lastActionId: s,
                                                        },
                                                      ));
                                                  }
                                                }),
                                              ) || NO),
                                          ) || NO),
                                      ) || NO),
                                  ) || NO),
                              ) || NO),
                          ) || NO),
                      ) || NO),
                  ) || NO),
              ) || NO),
          ) || NO;
        var kO,
          BO = s("h5Sw");
        Object(i.singleton)(Ey.l)(
          (kO =
            Object(V.h)()(
              (kO =
                Object(V.f)()(
                  (kO =
                    Object(My.c)([
                      ky,
                      MO,
                      D_,
                      e_,
                      tO,
                      qy,
                      P_,
                      AO,
                      DO,
                      CO,
                      yO,
                      RO,
                      s_,
                      TO,
                      UO,
                      PO,
                      { token: wy, useFactory: () => Ee.default },
                      { token: Ty, useFactory: () => Mt.default },
                      { token: Ry, useFactory: () => bs.a },
                      { token: Sy, useFactory: () => Mc.default },
                      { token: Ly, useFactory: () => Xe.e },
                      { token: Dy, useFactory: () => BO.a },
                      {
                        token: Fy,
                        useFactory: () =>
                          i.ModuleContainer.resolveIfExist(jr.a),
                      },
                    ])(
                      (kO = class {
                        onAuthenticating() {
                          this.get(Ey.b);
                        }
                        onStart() {
                          this.get(Ey.c).start();
                        }
                        get(e) {
                          return My.a.resolve(e);
                        }
                      }),
                    ) || kO),
                ) || kO),
            ) || kO),
        );
        var GO;
        const xO = "z_afmc_devtool_";
        Object($t.b)(Ey.d)(
          (GO =
            (function (e, t) {
              return Object(i.inject)(fi)(e, void 0, 0);
            })(
              (GO =
                Reflect.metadata(
                  "design:type",
                  Function,
                )(
                  (GO =
                    Reflect.metadata("design:paramtypes", [
                      "undefined" == typeof IMessageController
                        ? Object
                        : IMessageController,
                    ])(
                      (GO = class {
                        constructor(e) {
                          var t;
                          (this.messageController = e),
                            (this.type = void 0),
                            (this.name = void 0),
                            (this.key = void 0),
                            (this.data = {
                              isShow: !0,
                              status: "disabled",
                              totalMessage: 0,
                              totalMessageFetched: 0,
                              remainConv: 0,
                              currentConv: "",
                              currentRequestMsgId: "",
                              totalMessageCurrentConv: 0,
                            }),
                            (this.promiseCountTotalMessage = null),
                            (this.promiseCountTotalMessageCurrConv = null),
                            (this.name =
                              "auto-fetch-message-cloud-devtool-monitor"),
                            (this.key =
                              "auto-fetch-message-cloud-devtool-monitor"),
                            (this.data.isShow =
                              Ny.a &&
                              Boolean(
                                Number(
                                  null !==
                                    (t = E.default.getInstance().getItem(xO)) &&
                                    void 0 !== t
                                    ? t
                                    : "0",
                                ),
                              )),
                            this.toggleUpdateTotalMessage();
                        }
                        toggleDevtool() {
                          !1 !== Ny.a &&
                            ((this.data.isShow = !this.data.isShow),
                            this.data.isShow
                              ? E.default
                                  .getInstance()
                                  .setItem(
                                    xO,
                                    Number(this.data.isShow).toString(),
                                  )
                              : E.default.getInstance().removeItem(xO),
                            Object(nt.g)(this.name, "all"));
                        }
                        updateStatus(e) {
                          !1 !== Ny.a &&
                            ((this.data.status = e),
                            Object(nt.g)(this.name, "all"));
                        }
                        async toggleUpdateTotalMessage() {
                          if (!1 === Ny.a) return;
                          this.promiseCountTotalMessage ||
                            (this.promiseCountTotalMessage = K.default
                              .getInstance()
                              .Core.Message.count());
                          const e = await this.promiseCountTotalMessage;
                          (this.data.totalMessage = e),
                            (this.promiseCountTotalMessage = null),
                            Object(nt.g)(this.name, "all");
                        }
                        async toggleUpdateTotalMessageCurrentConv() {
                          if (!1 === Ny.a) return;
                          this.promiseCountTotalMessageCurrConv ||
                            (this.promiseCountTotalMessageCurrConv =
                              this.messageController.countMessages(
                                this.data.currentConv,
                              ));
                          const e = await this.promiseCountTotalMessageCurrConv;
                          (this.promiseCountTotalMessageCurrConv = null),
                            (this.data.totalMessageCurrentConv = e),
                            Object(nt.g)(this.name, "all");
                        }
                        updateTotalMessageFetched(e) {
                          !1 !== Ny.a &&
                            ((this.data.totalMessageFetched += e),
                            Object(nt.g)(this.name, "all"),
                            this.toggleUpdateTotalMessage(),
                            this.toggleUpdateTotalMessageCurrentConv());
                        }
                        updateRemainConv(e) {
                          !1 !== Ny.a &&
                            ((this.data.remainConv = e),
                            Object(nt.g)(this.name, "all"));
                        }
                        updateBatchRequestInfo(e) {
                          !1 !== Ny.a &&
                            ((this.data.currentConv =
                              (null == e ? void 0 : e.convId) || ""),
                            (this.data.currentRequestMsgId =
                              (null == e ? void 0 : e.requestMsgId) || ""),
                            e || (this.data.totalMessageCurrentConv = 0),
                            Object(nt.g)(this.name, "all"));
                        }
                        getItem(e, t) {
                          return Object(f.a)({}, this.data);
                        }
                        init(e) {
                          throw new Error("Method not implemented.");
                        }
                        getList(e, t) {
                          throw new Error("Method not implemented.");
                        }
                        onGetItemFailure(e, t) {
                          throw new Error("Method not implemented.");
                        }
                        onGetListFailure(e, t) {
                          throw new Error("Method not implemented.");
                        }
                      }),
                    ) || GO),
                ) || GO),
            ) || GO),
        );
        const zO = Object(i.define)("pulloffline-reporter"),
          VO = () =>
            void 0 !== bt.default.socket.offline_monitor.enable &&
            bt.default.socket.offline_monitor.enable,
          HO = () =>
            void 0 !== bt.default.socket.offline_monitor.latency_time
              ? bt.default.socket.offline_monitor.latency_time
              : 3e4,
          $O = () =>
            void 0 !== bt.default.socket.offline_monitor.exclude_monitors_queues
              ? bt.default.socket.offline_monitor.exclude_monitors_queues
              : ["516", "517", "518", "519", "610", "611"];
        let WO;
        var KO;
        !(function (e) {
          function t(e, t, s) {
            const i = { lowestFPS: 60, dropTime: e[s].ts - e[t].ts };
            for (let n = t; n <= s; n++)
              e[n].fps < i.lowestFPS && (i.lowestFPS = e[n].fps);
            return i;
          }
          e.getDroppeds = function (e, s) {
            let i = 0,
              n = 0,
              a = s[0].fps <= e;
            const r = [];
            return (
              s.forEach((o, d) => {
                a
                  ? (o.fps > e && ((n = d), (a = !1), r.push(t(s, i, n))),
                    d == s.length - 1 &&
                      o.fps <= e &&
                      ((n = d), (a = !1), r.push(t(s, i, n))))
                  : o.fps > e
                    ? ((i = d), (a = !1))
                    : d == s.length - 1
                      ? ((n = d), (a = !1), r.push(t(s, i, n)))
                      : (a = !0);
              }),
              r
            );
          };
        })(WO || (WO = {}));
        const qO = { dropCount: 0, min: 60, dropTime: 0 };
        var ZO;
        function JO() {
          for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
            t[s] = arguments[s];
        }
        !(function (e) {
          (e.BeforePull = "beforePull"),
            (e.InPull = "inPull"),
            (e.InSaveDB = "inSaveDB"),
            (e.AfterSaveDB = "afterSaveDB");
        })(ZO || (ZO = {}));
        let QO =
          Object(i.singleton)(Ri.a)(
            (KO =
              Reflect.metadata(
                "design:type",
                Function,
              )(
                (KO =
                  Reflect.metadata("design:paramtypes", [
                    void 0 === zO ? Object : zO,
                  ])(
                    (KO = class {
                      constructor(e) {
                        (this.reporter = e),
                          (this.cpuUsage = void 0),
                          (this.fpsUsage = void 0),
                          (this.timeUsage = void 0),
                          (this.lastActionId = void 0),
                          (this.countData = {}),
                          (this.started = !1),
                          (this.isDoneMonitor = !1),
                          (this.doneOfflineCount = 0),
                          (this.donePullCount = 0),
                          (this.callStartPullCount = 0),
                          (this.actionIdSnapshot = {}),
                          (this.monitorQueues = new Set()),
                          (this.timeStartChat = {}),
                          (this.isFirstSnapshot = !0),
                          (this.fpsRecorder = {}),
                          (this.timeUsage = {
                            startTrackTime: 0,
                            beforePull: 0,
                            inPull: 0,
                            inSaveDB: 0,
                            afterSaveDB: 0,
                            openConv: 0,
                            waitSendOO: 0,
                            waitSendGr: 0,
                          }),
                          (this.cpuUsage = {
                            beforePull: 0,
                            inPull: 0,
                            inSaveDB: 0,
                            afterSaveDB: 0,
                          }),
                          (this.fpsUsage = {
                            beforePull: Object(f.a)({}, qO),
                            inPull: Object(f.a)({}, qO),
                            inSaveDB: Object(f.a)({}, qO),
                            afterSaveDB: Object(f.a)({}, qO),
                          }),
                          (this.lastActionId = {});
                      }
                      startMonitor() {
                        return (
                          JO("startMonitor ", VO()),
                          this.reporter.reportLastSession(),
                          VO()
                            ? (this.getCPU(),
                              this.trackFPS(ZO.BeforePull),
                              Promise.resolve())
                            : Promise.resolve()
                        );
                      }
                      async stopMonitor() {
                        this.timeStartChat.group &&
                          !this.timeUsage.waitSendGr &&
                          (this.timeUsage.waitSendGr =
                            vs.a.now() - this.timeStartChat.group),
                          this.timeStartChat.oneone &&
                            !this.timeUsage.waitSendOO &&
                            (this.timeUsage.waitSendOO =
                              vs.a.now() - this.timeStartChat.oneone),
                          await this.takeSnapshot(ZO.AfterSaveDB),
                          this.reporter.report({
                            isFirstSnapshot: this.isFirstSnapshot,
                            cpuUsage: this.cpuUsage,
                            fpsUsage: this.fpsUsage,
                            timeUsage: this.timeUsage,
                            countData: this.countData,
                          }),
                          (this.isFirstSnapshot = !1);
                      }
                      resetMonitor() {
                        this.monitorQueues.clear(),
                          (this.started = !1),
                          (this.isDoneMonitor = !1),
                          (this.doneOfflineCount = 0),
                          (this.donePullCount = 0),
                          (this.timeUsage = {
                            startTrackTime: 0,
                            beforePull: 0,
                            inPull: 0,
                            inSaveDB: 0,
                            afterSaveDB: 0,
                            openConv: 0,
                            waitSendOO: 0,
                            waitSendGr: 0,
                          }),
                          (this.cpuUsage = {
                            beforePull: 0,
                            inPull: 0,
                            inSaveDB: 0,
                            afterSaveDB: 0,
                          }),
                          (this.fpsUsage = {
                            beforePull: Object(f.a)({}, qO),
                            inPull: Object(f.a)({}, qO),
                            inSaveDB: Object(f.a)({}, qO),
                            afterSaveDB: Object(f.a)({}, qO),
                          }),
                          (this.lastActionId = {}),
                          (this.actionIdSnapshot = {}),
                          (this.countData = {}),
                          (this.timeStartChat = {});
                      }
                      addMonitorQueues(e) {
                        const t = $O();
                        e.forEach((e) => {
                          t.some((t) => e.startsWith(t)) ||
                            this.monitorQueues.add(e);
                        }),
                          JO("addMonitorQueues", e, this.monitorQueues);
                      }
                      async onStartPoll(e) {
                        this.callStartPullCount++,
                          VO() &&
                            (this.callStartPullCount % 2 == 1 &&
                              this.resetMonitor(),
                            this.addMonitorQueues(e),
                            JO(
                              "onStartPoll",
                              e,
                              this.started,
                              this.callStartPullCount,
                            ),
                            this.started ||
                              ((this.started = !0),
                              (this.timeUsage.startTrackTime = vs.a.now()),
                              await this.takeSnapshot(ZO.BeforePull),
                              this.trackFPS(ZO.InPull)));
                      }
                      async onEndPoll(e, t) {
                        VO() &&
                          this.monitorQueues.has(e) &&
                          (JO("onEndPoll", e, t, VO()),
                          (this.lastActionId[e] = t),
                          this.donePullCount++,
                          this.monitorQueues.size == this.donePullCount &&
                            (await this.takeSnapshot(ZO.InPull),
                            this.trackFPS(ZO.InSaveDB)));
                      }
                      onPollData(e, t) {
                        if (
                          VO() &&
                          !this.isDoneMonitor &&
                          this.monitorQueues.has(e)
                        )
                          switch (
                            (this.countData[e] || (this.countData[e] = 0),
                            JO("onPollData", e, t),
                            e)
                          ) {
                            case "510_0":
                            case "513_0":
                            case "515_0":
                            case "510_1":
                            case "513_1":
                            case "515_1":
                              (this.countData[e] += t.data.msgs.length),
                                (this.countData[e] += t.data.pageMsgs.length);
                              break;
                            case "511_0":
                            case "514_0":
                            case "513_0":
                            case "511_1":
                            case "514_1":
                            case "513_1":
                              this.countData[e] += t.data.groupMsgs.length;
                          }
                      }
                      onSavedData(e) {
                        if (!this.isDoneMonitor && VO()) {
                          JO("onSavedData", e, this.actionIdSnapshot);
                          for (const t in e)
                            this.monitorQueues.has(t) &&
                              this.lastActionId[t] &&
                              this.actionIdSnapshot[t] !== e[t] &&
                              (this.checkDoneDoOffline(t, e[t]),
                              (this.actionIdSnapshot[t] = e[t]));
                        }
                      }
                      onOpenConversation(e) {
                        "string" == typeof e &&
                          0 === this.timeUsage.openConv &&
                          (this.timeUsage.openConv =
                            vs.a.now() - this.timeUsage.startTrackTime);
                      }
                      onStartChat(e) {
                        "string" == typeof e &&
                          (e.startsWith("g") && !this.timeStartChat.group
                            ? (this.timeStartChat.group = vs.a.now())
                            : this.timeStartChat.oneone ||
                              (this.timeStartChat.oneone = vs.a.now()));
                      }
                      onEncryptChat(e) {
                        "string" == typeof e &&
                          (e.startsWith("g") && !this.timeUsage.waitSendGr
                            ? (this.timeUsage.waitSendGr =
                                vs.a.now() - this.timeStartChat.group)
                            : this.timeUsage.waitSendOO ||
                              (this.timeUsage.waitSendOO =
                                vs.a.now() - this.timeStartChat.oneone));
                      }
                      async checkDoneDoOffline(e, t) {
                        if (
                          (JO("checkDoneDoOffline", e, t, this.lastActionId[e]),
                          this.doneOfflineCount == this.monitorQueues.size)
                        )
                          return;
                        const s = this.lastActionId[e];
                        s &&
                          Number(t) == Number(s) &&
                          (this.doneOfflineCount++,
                          JO("DoneDoOffline", e, t),
                          this.doneOfflineCount == this.monitorQueues.size &&
                            ((this.isDoneMonitor = !0),
                            await this.takeSnapshot(ZO.InSaveDB),
                            this.trackFPS(ZO.AfterSaveDB),
                            this.reporter.saveDraft({
                              isFirstSnapshot: this.isFirstSnapshot,
                              cpuUsage: this.cpuUsage,
                              fpsUsage: this.fpsUsage,
                              timeUsage: this.timeUsage,
                              countData: this.countData,
                            }),
                            setTimeout(() => {
                              this.stopMonitor();
                            }, HO())));
                      }
                      async takeSnapshot(e) {
                        const t = await this.getCPU(),
                          s = this.getFPS(e);
                        (this.cpuUsage[e] = t),
                          (this.fpsUsage[e] = s),
                          (this.timeUsage[e] =
                            vs.a.now() - this.timeUsage.startTrackTime),
                          JO("takeSnapshot", t, s),
                          this.reporter.saveDraft({
                            isFirstSnapshot: this.isFirstSnapshot,
                            cpuUsage: this.cpuUsage,
                            fpsUsage: this.fpsUsage,
                            timeUsage: this.timeUsage,
                            countData: this.countData,
                          });
                      }
                      async getCPU() {
                        return 0;
                      }
                      trackFPS(e) {
                        (this.fpsRecorder[e] =
                          Ti.default.Fps.registerSectionRecorder(e)),
                          this.fpsRecorder[e].start();
                      }
                      getFPS(e) {
                        var t;
                        const s =
                          null === (t = this.fpsRecorder[e]) || void 0 === t
                            ? void 0
                            : t.end();
                        if (
                          (delete this.fpsRecorder[e],
                          JO("getFPS", s),
                          !s || 0 == s.fpsHistory.length)
                        )
                          return qO;
                        const i = WO.getDroppeds(50, s.fpsHistory);
                        if (0 == i.length) return qO;
                        const n = i.reduce((e, t) => (e += t.dropTime), 0),
                          a = Math.min(...i.map((e) => e.lowestFPS));
                        return { dropCount: i.length, dropTime: n, min: a };
                      }
                    }),
                  ) || KO),
              ) || KO),
          ) || KO;
        var YO;
        Object(i.injectable)()(
          (YO =
            Object(i.singleton)(Ri.a)(
              (YO =
                (function (e, t) {
                  return Object(i.inject)(zO)(e, void 0, 0);
                })(
                  (YO =
                    Reflect.metadata(
                      "design:type",
                      Function,
                    )(
                      (YO =
                        Reflect.metadata("design:paramtypes", [
                          void 0 === zO ? Object : zO,
                        ])(
                          (YO = class extends QO {
                            constructor(e) {
                              super(e);
                            }
                            async getCPU() {
                              return 0;
                            }
                          }),
                        ) || YO),
                    ) || YO),
                ) || YO),
            ) || YO),
        );
        var XO;
        const eC = "rp_ofl_p";
        Object(i.singleton)(zO)(
          (XO =
            Reflect.metadata(
              "design:type",
              Function,
            )(
              (XO =
                Reflect.metadata(
                  "design:paramtypes",
                  [],
                )(
                  (XO = class {
                    constructor() {
                      (this.logger = void 0),
                        (this.logger = i.ModuleContainer.resolve(
                          q.ZLoggerFactory,
                        ).createZLogger("offline-monitor", ["reporter"]));
                    }
                    reportLastSession() {
                      const e = E.default.getInstance().getObject(eC);
                      e &&
                        (this.logger.zsymb(
                          0,
                          16682,
                          3e4,
                          "detect last session",
                        ),
                        this.report(e));
                    }
                    report(e) {
                      this.logger.zsymb(
                        0,
                        16682,
                        30001,
                        "report: ",
                        JSON.stringify(e),
                      ),
                        Xe.e.logActionInfoV2(Xe.b.PullOffline, 1, e, [], !0);
                      E.default.getInstance().removeItem(eC);
                    }
                    saveDraft(e) {
                      E.default.getInstance().setObject(eC, e),
                        this.logger.zsymb(
                          0,
                          16682,
                          30002,
                          "draft saved: ",
                          JSON.stringify(e),
                        );
                    }
                  }),
                ) || XO),
            ) || XO),
        );
        var tC = s("+eUS");
        const sC =
          "render" !== __ZaBUNDLENAME__ &&
          "WEB" !== __ZaBUNDLENAME__ &&
          "shared-worker" !== __ZaBUNDLENAME__ &&
          "main" !== __ZaBUNDLENAME__;
        setTimeout(async function () {
          if (sC) return;
          const e = i.ModuleContainer.resolve(q.ZLoggerFactory).createZLogger(
            "bootstrap",
            ["shared"],
          );
          e.zsymb(3, 8152, 3e4, "running application bootstrap");
          try {
            const t = i.ModuleContainer.resolve(V.a);
            await t.start();
            let s = (() => {
              switch (__ZaBUNDLENAME__) {
                case "WEB":
                  return Aa.RunMode.Browser;
                case "render":
                  return Aa.RunMode.Host;
                case "shared-worker":
                  return Aa.RunMode.Client;
                case "main":
                  return Aa.RunMode.Background;
                default:
                  return Aa.RunMode.Unknown;
              }
            })();
            Object(tC.a)(s),
              s === Aa.RunMode.Browser &&
                (function () {
                  const e = Object(S.a)();
                  M.a.includes(e) ||
                    i.ModuleContainer.resolve(ve).setupWriters();
                })(),
              "shared-worker" === __ZaBUNDLENAME__ && (await t.init()),
              e.zsymb(3, 8152, 30001, "application bootstrap success");
          } catch (t) {
            e.zsymb(0, 8152, 30002, () => [
              "application bootstrap fail",
              { reason: t },
            ]);
          }
        }, 0);
        s("Lp8g");
        var iC = s("GFHO"),
          nC = s("ziJS"),
          aC = s("YZUF");
        s("zlHd");
        function rC() {
          nC.b.init(), Mi.b.init(), aC.b.init();
        }
        (function (e) {
          const t = new iC.a(e);
          if (t.remoteConfigs.key("enable").boolean) rC();
          else {
            const e = () => {
              t.remoteConfigs.key("enable").boolean &&
                (rC(), t.remoteConfigs.remove(e));
            };
            t.remoteConfigs.add(e);
          }
        })({ platform: "web" });
      },
      rhBN: function (e, t, s) {
        "use strict";
        var i,
          n = s("jDHv"),
          a = s("UK4g"),
          r = s("YEoC"),
          o = s("DI/x"),
          d = s("tHMN"),
          l = s("LzQZ");
        let c =
          n.ModuleContainer.injectable()(
            (i =
              (function (e, t) {
                return n.ModuleContainer.inject(d.b)(e, void 0, 0);
              })(
                (i =
                  Reflect.metadata(
                    "design:type",
                    Function,
                  )(
                    (i =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === d.b ? Object : d.b,
                      ])(
                        (i = class {
                          constructor(e) {
                            (this.engine = e),
                              (this.currentId = 1),
                              (this.transactions = void 0),
                              (this.transactions = new Map());
                          }
                          get(e) {
                            const t = this.transactions.get(e);
                            if (!t)
                              throw new o.h(
                                "The transaction has already committed!",
                              );
                            return t;
                          }
                          async beginTransaction(e, t, s) {
                            const i = this.currentId++,
                              n = new Error(),
                              o = await this.engine.do({
                                type: r.d.BeginTransaction,
                                database: e,
                                table: t[0],
                                transaction: i,
                                priority: r.c.BLOCKING,
                                retry: a.i,
                                timing: {},
                                meta: { step: -1, timeout: a.l, error: n },
                                params: { tables: t, mode: s },
                                trace: () => {},
                              });
                            return this.transactions.set(i, o), o;
                          }
                          commitTransaction(e) {
                            const t = this.transactions.get(e);
                            return !t || t.closed
                              ? (t && this.transactions.delete(e),
                                Promise.resolve())
                              : new Promise((s, i) => {
                                  t.onClose(() => {
                                    this.transactions.delete(e),
                                      t.error ? i(t.error) : s();
                                  });
                                });
                          }
                        }),
                      ) || i),
                  ) || i),
              ) || i),
          ) || i;
        n.ModuleContainer.registerSingleton(l.a, c);
      },
      taJj: function (e, t, s) {
        "use strict";
        t.a = class {
          constructor(e) {
            (this.chunkSize = void 0),
              (this.partialChunk = void 0),
              (this.offset = void 0),
              (this.chunkSize = e),
              (this.partialChunk = new Uint8Array(this.chunkSize)),
              (this.offset = 0);
          }
          send(e, t) {
            t.enqueue(e),
              (this.partialChunk = new Uint8Array(this.chunkSize)),
              (this.offset = 0);
          }
          transform(e, t) {
            let s = 0;
            if (this.offset > 0) {
              const i = Math.min(e.byteLength, this.chunkSize - this.offset);
              this.partialChunk.set(e.slice(0, i), this.offset),
                (this.offset += i),
                (s += i),
                this.offset === this.chunkSize &&
                  this.send(this.partialChunk, t);
            }
            for (; s < e.byteLength; ) {
              const i = e.byteLength - s;
              if (i >= this.chunkSize) {
                const i = e.slice(s, s + this.chunkSize);
                (s += this.chunkSize), this.send(i, t);
              } else {
                const t = e.slice(s, s + i);
                (s += t.byteLength),
                  this.partialChunk.set(t),
                  (this.offset = t.byteLength);
              }
            }
          }
          flush(e) {
            this.offset > 0 &&
              e.enqueue(this.partialChunk.slice(0, this.offset));
          }
        };
      },
      ycTR: function (e, t, s) {
        "use strict";
        s.d(t, "a", function () {
          return m;
        });
        var i = s("YEoC"),
          n = s("oRsZ"),
          a = s("IpiK"),
          r = s("d04y"),
          o = s("pRxM"),
          d = s("b3Jv"),
          l = s("4IGy"),
          c = s("xS/Y"),
          h = s("rdC+"),
          u = s("pP8i"),
          g = s("75G/");
        const m = (e, t) => {
          if (t === i.a.IDB)
            switch (e) {
              case "Core":
                return n.a.useIdb;
              case "MsgInfo":
                return a.a.useIdb;
              case "Qos":
                return r.a.useIdb;
              case "Reaction":
                return o.a.useIdb;
              case "Search":
                return d.a.useIdb;
              case "Storage":
                return l.a.useIdb;
              case "Res":
                return c.a.useIdb;
              case "SecureLocalstorage":
                return h.a.useIdb;
              case "ZLog":
                return u.a.useIdb;
              case "Media":
                return g.a.useIdb;
              default:
                return;
            }
          if (t === i.a.SQLite)
            switch (e) {
              case "Core":
                return n.a.useSqlite;
              case "MsgInfo":
                return a.a.useSqlite;
              case "Qos":
                return r.a.useSqlite;
              case "Reaction":
                return o.a.useSqlite;
              case "Search":
                return d.a.useSqlite;
              case "Storage":
                return l.a.useSqlite;
              case "Res":
                return c.a.useSqlite;
              case "SecureLocalstorage":
                return h.a.useSqlite;
              case "ZLog":
                return u.a.useSqlite;
              case "Media":
                return g.a.useSqlite;
              default:
                return;
            }
        };
      },
      zpw2: function (e, t, s) {
        "use strict";
        (function (e) {
          s.d(t, "a", function () {
            return h;
          });
          var i = s("jDHv"),
            n = s("Uzj0"),
            a = s("wH4e"),
            r = s("Mk04"),
            o = s("d951"),
            d = s("TTNl"),
            l = s("JMlY"),
            c = s("ipeT");
          class h {
            constructor(e, t, s) {
              (this.databaseName = e),
                (this.databaseSchema = t),
                (this.numOfActiveQueries = 0),
                (this.pendingQueries = []),
                (this.pending = !1),
                (this.idleListeners = []),
                (this._engine = null);
              const i = n.e.map(
                t,
                (t, i) =>
                  new c.a(
                    e,
                    i,
                    a.NO_TRANSACTION_ID,
                    this.doQuery.bind(this),
                    s,
                  ),
              );
              Object.entries(i).forEach((e) => {
                let [t, s] = e;
                Object.defineProperty(this, t, { value: s, writable: !1 });
              }),
                Object.defineProperty(this, "runTransaction", {
                  value: this.runTransaction.bind(
                    this,
                    this.databaseName,
                    this.databaseSchema,
                  ),
                }),
                (this.closeThisDatabase = Object(r.a)(
                  this.closeThisDatabase.bind(this),
                )),
                (this.deleteThisDatabase = Object(r.a)(
                  this.deleteThisDatabase.bind(this),
                ));
            }
            get engine() {
              return (
                this._engine || (this._engine = i.ModuleContainer.resolve(d.a)),
                this._engine
              );
            }
            get isIdle() {
              return 0 === this.numOfActiveQueries;
            }
            dispatchIdleEvent() {
              this.idleListeners.forEach((e) => e()), (this.idleListeners = []);
            }
            addIdleListenerOnce(e) {
              this.isIdle ? e() : this.idleListeners.push(e);
            }
            stop() {
              this.pending = !0;
            }
            resume() {
              this.pendingQueries.forEach((e) => {
                e.execute();
              }),
                (this.pendingQueries = []),
                (this.pending = !1);
            }
            waitUntilIdle() {
              return new Promise((e) => {
                this.addIdleListenerOnce(() => e());
              });
            }
            trapIdleTracking(e) {
              return (
                (this.numOfActiveQueries += 1),
                e.finally(() => {
                  (this.numOfActiveQueries -= 1),
                    this.isIdle && this.dispatchIdleEvent();
                })
              );
            }
            doQuery(e) {
              const t = () => this.trapIdleTracking(this.engine.do(e));
              if (this.pending) {
                const e = () => t(),
                  s = new o.a(e);
                return this.pendingQueries.push(s), s.getResult();
              }
              return t();
            }
            async closeThisDatabase() {
              this.stop(), await this.waitUntilIdle();
              const e = i.ModuleContainer.resolve(d.a);
              await e.closeDatabase(this.databaseName), this.resume();
            }
            async deleteThisDatabase() {
              this.stop(), await this.waitUntilIdle();
              const e = i.ModuleContainer.resolve(d.a);
              await e.deleteDatabase(this.databaseName), this.resume();
            }
            runTransaction(t, s, n, r, o) {
              void 0 === o && (o = a.TransactionMode.READWRITE);
              const d = i.ModuleContainer.resolve(l.a),
                h = this.doQuery.bind(this);
              return new Promise((i, l) => {
                try {
                  !(async function (i, l) {
                    const u = n.map((e) => ("string" == typeof e ? e : e.name)),
                      g = await d.beginTransaction(t, u, o),
                      m = u.map((e) => {
                        if (!s[e]) throw new a.MissingTableConfigError(e);
                        const i = s[e];
                        return new c.a(t, i, g.id, h);
                      });
                    await r(m),
                      e(() => {
                        d.commitTransaction(g.id).then(i).catch(l);
                      });
                  })(i, l);
                } catch (u) {
                  l(u);
                }
              });
            }
          }
        }).call(this, s("NWH6").setImmediate);
      },
    },
  ]);
//# sourceMappingURL=../sourcemaps/lazy/web-startup.780509e22ef0c5bb5889.js.map
